
.vsteensy/build/zeroTest_T41.elf:     file format elf32-littlearm

SYMBOL TABLE:
60000000 l    d  .text.progmem	00000000 .text.progmem
00000000 l    d  .text.itcm	00000000 .text.itcm
0000f4c0 l    d  .fini	00000000 .fini
0000f4c4 l    d  .ARM.exidx	00000000 .ARM.exidx
0000f4cc l    d  .text.itcm.padding	00000000 .text.itcm.padding
20000000 l    d  .data	00000000 .data
20001570 l    d  .bss	00000000 .bss
20200000 l    d  .bss.dma	00000000 .bss.dma
70000000 l    d  .bss.extram	00000000 .bss.extram
600125ec l    d  .text.csf	00000000 .text.csf
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 bootdata.c
00000000 l    df *ABS*	00000000 startup.c
00009234 l       .text.itcm	00000000 _MSP
00000000 l    df *ABS*	00000000 usb.c
000087cc l     F .text.itcm	00000070 schedule_transfer
0000883c l     F .text.itcm	00000036 run_callbacks
00008874 l     F .text.itcm	000000a0 endpoint0_transmit.constprop.1
00008914 l     F .text.itcm	00000670 isr
2000b104 l     O .bss	00000004 endpointN_notify_mask
2000b108 l     O .bss	00000001 sof_usage
2000b114 l     O .bss	00000004 endpoint0_notify_mask
2000b118 l     O .bss	00000001 usb_reboot_timer
2000b120 l     O .bss	00000008 endpoint0_setupdata
2000b128 l     O .bss	00000008 reply_buffer
2000b130 l     O .bss	00000008 endpoint0_buffer
00000000 l    df *ABS*	00000000 tempmon.c
2000b14c l     O .bss	00000004 s_hotTemp
2000b150 l     O .bss	00000004 s_hot_ROOM
2000b154 l     O .bss	00000004 s_roomC_hotC
2000b158 l     O .bss	00000004 s_hotCount
00000000 l    df *ABS*	00000000 analog.c
2000b2b9 l     O .bss	00000001 calibrating
00000000 l    df *ABS*	00000000 usb_desc.c
60001b40 l     O .text.progmem	0000000a qualifier_descriptor
20000b80 l     O .data	00000012 device_descriptor
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.13/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crti.o
00000000 l    df *ABS*	00000000 c:/users/zimme/documents/arduino-1.8.13/hardware/tools/arm/bin/../lib/gcc/arm-none-eabi/5.4.1/armv7e-m/fpu/crtn.o
00000000 l    df *ABS*	00000000 crtstuff.c
00000020 l     F .text.itcm	00000000 __do_global_dtors_aux
20001570 l       .bss	00000000 completed.8605
00000044 l     F .text.itcm	00000000 frame_dummy
20001574 l       .bss	00000000 object.8610
60001ba8 l     O .text.progmem	00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*	00000000 zeroTest.cpp
0000007c l     F .text.itcm	00000084 MTPD::write(char const*, int) [clone .part.8]
00006550 l     F .text.itcm	00000038 _GLOBAL__sub_I_zFS
20000000 l     O .data	00000016 supported_op
20000018 l     O .data	00000010 propertyList
00000000 l    df *ABS*	00000000 zeroFS.cpp
00000000 l    df *ABS*	00000000 sd_msc.cpp
00000000 l    df *ABS*	00000000 diskio.c
00000000 l    df *ABS*	00000000 sd_sdhc.c
00006ef8 l     F .text.itcm	000000b4 setSdclk
00006ffc l     F .text.itcm	0000005c sd_CMD
00007058 l     F .text.itcm	00000020 sd_ACMD
00007078 l     F .text.itcm	00000040 sd_CMD12_StopTransferWaitForBusy
2000af10 l     O .bss	00000004 dmaDone
2000af14 l     O .bss	00000010 sdCardDesc
00000000 l    df *ABS*	00000000 sd_spi.c
00007708 l     F .text.itcm	0000002c sd_chipSelect.part.0
00007734 l     F .text.itcm	00000058 spi_transfer.part.2
200002d8 l     O .data	00000200 crctab
00000000 l    df *ABS*	00000000 memcpy-armv7m.o
00000000 l    df *ABS*	00000000 usb_serial.c
0000808c l     F .text.itcm	0000006c rx_queue_transfer
000080f8 l     F .text.itcm	000000b4 rx_event
000081ac l     F .text.itcm	00000098 usb_serial_flush_callback
00008244 l     F .text.itcm	0000017c usb_serial_write.part.1
2000af24 l     O .bss	00000010 rx_index
2000af34 l     O .bss	00000002 tx_packet_size
2000af36 l     O .bss	00000001 tx_noautoflush
2000af37 l     O .bss	00000001 tx_head
2000af40 l     O .bss	00000100 rx_transfer
2000b040 l     O .bss	00000001 rx_tail
2000b044 l     O .bss	00000009 rx_list
2000b04e l     O .bss	00000002 rx_packet_size
20200000 l     O .bss.dma	00001000 rx_buffer
20201000 l     O .bss.dma	00002000 txbuffer
2000b050 l     O .bss	00000010 rx_count
2000b060 l     O .bss	00000004 rx_available
2000b064 l     O .bss	00000001 rx_head
2000b065 l     O .bss	00000001 transmit_previous_timeout
2000b066 l     O .bss	00000002 tx_available
2000b080 l     O .bss	00000080 tx_transfer
00000000 l    df *ABS*	00000000 delay.c
00000000 l    df *ABS*	00000000 rtc.c
00000000 l    df *ABS*	00000000 nonstd.c
00000000 l    df *ABS*	00000000 sm_pool.c
00000000 l    df *ABS*	00000000 digital.c
000097d4 l     F .text.itcm	0000004c digitalWrite.part.0
00000000 l    df *ABS*	00000000 pwm.c
00000000 l    df *ABS*	00000000 usb_mtp.c
00009b64 l     F .text.itcm	00000034 rx_event
00009b98 l     F .text.itcm	00000068 rx_queue_transfer
2000b15c l     O .bss	00000002 tx_packet_size
2000b15e l     O .bss	00000001 tx_head
2000b160 l     O .bss	00000080 rx_transfer
2000b1e0 l     O .bss	00000001 rx_tail
2000b1e4 l     O .bss	00000005 rx_list
2000b1ea l     O .bss	00000002 rx_packet_size
20203000 l     O .bss.dma	00000800 rx_buffer
20203800 l     O .bss.dma	00000800 txbuffer
2000b1ec l     O .bss	00000001 rx_head
2000b200 l     O .bss	00000080 tx_transfer
00000000 l    df *ABS*	00000000 yield.cpp
2000b280 l     O .bss	00000001 yield::running
00000000 l    df *ABS*	00000000 EventResponder.cpp
00000000 l    df *ABS*	00000000 usb_inst.cpp
00000000 l    df *ABS*	00000000 Print.cpp
00000000 l    df *ABS*	00000000 main.cpp
00000000 l    df *ABS*	00000000 Stream.cpp
00000000 l    df *ABS*	00000000 clockspeed.c
00000000 l    df *ABS*	00000000 _arm_addsubdf3.o
00000000 l    df *ABS*	00000000 _arm_muldivdf3.o
00000000 l    df *ABS*	00000000 _arm_cmpdf2.o
00000000 l    df *ABS*	00000000 _arm_unorddf2.o
00000000 l    df *ABS*	00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 _dvmd_tls.o
00000000 l    df *ABS*	00000000 efgcvt.c
00000000 l    df *ABS*	00000000 errno.c
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 mlock.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 lib_a-strcmp.o
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strlcat.c
00000000 l    df *ABS*	00000000 strlcpy.c
00000000 l    df *ABS*	00000000 lib_a-strlen.o
00000000 l    df *ABS*	00000000 vfprintf.c
20000900 l     O .data	00000010 zeroes.7258
20000950 l     O .data	00000010 blanks.7257
00000000 l    df *ABS*	00000000 vdprintf.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 dtoa.c
0000d8f0 l     F .text.itcm	00000128 quorem
00000000 l    df *ABS*	00000000 ecvtbuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 localeconv.c
00000000 l    df *ABS*	00000000 lib_a-memchr.o
00000000 l    df *ABS*	00000000 mprec.c
20000b68 l     O .data	0000000c p05.6087
00000000 l    df *ABS*	00000000 vfprintf.c
00000000 l    df *ABS*	00000000 vasnprintf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 _arm_fixdfsi.o
00000000 l    df *ABS*	00000000 locale.c
00000000 l    df *ABS*	00000000 ctype_.c
00000000 l    df *ABS*	00000000 impure.c
20000bc8 l     O .data	00000428 impure_data
00000000 l    df *ABS*	00000000 HardwareSerial.cpp
00000000 l    df *ABS*	00000000 reent.c
00000000 l    df *ABS*	00000000 
00000000 l       *UND*	00000000 __fini_array_end
00000000 l       *UND*	00000000 __bss_start__
00000000 l       *UND*	00000000 __bss_end__
00000000 l       *UND*	00000000 software_init_hook
00000000 l       *UND*	00000000 __fini_array_start
00000000 l       *UND*	00000000 hardware_init_hook
00000000 l       *UND*	00000000 __libc_fini
00000000 l       *UND*	00000000 __stack
60001b58 l     F .text.progmem	00000008 __startup_early_hook_veneer
60001b60 l     F .text.progmem	00000008 __pwm_init_veneer
60001b68 l     F .text.progmem	00000008 __startup_late_hook_veneer
60001b70 l     F .text.progmem	00000008 __memset_veneer
60001b78 l     F .text.progmem	00000008 __sm_set_pool_veneer
60001b80 l     F .text.progmem	00000008 ____libc_init_array_veneer
60001b88 l     F .text.progmem	00000008 __set_arm_clock_veneer
60001b90 l     F .text.progmem	00000008 __delay_veneer
60001b98 l     F .text.progmem	00000008 __main_veneer
60001ba0 l     F .text.progmem	00000008 __usb_init_serialnumber_veneer
0000f4b8 l     F .text.itcm	00000008 ___init_veneer
00007a28 g     F .text.itcm	000000a8 sd_writeData
0000ad14 g     F .text.itcm	0000002c .hidden __aeabi_dcmpun
000085fc g     F .text.itcm	0000000c usb_serial_available
000065d8 g     F .text.itcm	00000028 die(char const*, DRESULT)
0000acd8 g     F .text.itcm	00000012 .hidden __aeabi_dcmple
0000bf1c g     F .text.itcm	000000ba strcpy
0000ac14 g     F .text.itcm	0000007a .hidden __cmpdf2
00009240 g     F .text.itcm	00000002 startup_default_late_hook
00009ea4  w    F .text.itcm	000000c4 yield
2000b10c g     O .bss	00000004 usb_timer1_callback
0000ac14 g     F .text.itcm	0000007a .hidden __eqdf2
60001a4c g     O .text.progmem	00000018 usb_string_manufacturer_name_default
60001480 g     F .text.progmem	000003bc configure_external_ram
0000a784 g     F .text.itcm	0000005a .hidden __floatdidf
00009ff8 g     F .text.itcm	00000020 Print::println()
0000e84c g     F .text.itcm	00000100 fcvtbuf
00006dd8 g     F .text.itcm	00000034 zeroFS_class::GetSize(unsigned long)
000067b4 g     F .text.itcm	0000000c zeroFS_class::Open(HDR_TYPE)
0000b7dc g     F .text.itcm	00000002 __malloc_unlock
600019bc g     F .text.progmem	00000058 analog_init
0000d844 g     F .text.itcm	0000004a _vdprintf_r
20000bc0 g     O .data	00000004 F_CPU_ACTUAL
00006e38 g     F .text.itcm	00000004 MSC_disk_write
0000b674 g     F .text.itcm	000000c6 memmove
0000ec80 g     F .text.itcm	0000004c _Balloc
0000f4cc g       .ARM.exidx	00000000 __exidx_end
2000b294 g     O .bss	00000001 EventResponder::runningFromYield
0000ac04 g     F .text.itcm	0000008a .hidden __gtdf2
0000b07c g     F .text.itcm	0000000c __errno
60001000 g     O .text.progmem	00000020 ImageVectorTable
2000b284 g     O .bss	00000004 EventResponder::firstInterrupt
000090cc g     F .text.itcm	00000028 usb_transfer_status
00007f48 g     F .text.itcm	00000010 SPI_disk_initialize
00009720 g     F .text.itcm	00000090 sm_set_pool
000068f8 g     F .text.itcm	000000d0 zeroFS_class::ListAll()
000066f0 g     F .text.itcm	000000c4 zeroFS_class::Create(HDR_TYPE, int)
00009fe8  w    F .text.itcm	00000008 usb_serial_class::write(unsigned char const*, unsigned int)
200004dc g     O .data	00000370 digital_pin_to_info_PGM
2000dac0 g     O .bss	00000004 errno
0000f4c8 g       .text.itcm	00000000 _etext
20001570 g       .bss	00000000 _sbss
0000aca0 g     F .text.itcm	00000010 .hidden __aeabi_cdcmple
00007b3c g     F .text.itcm	0000005c sd_writeStart
60001bb0 g       *ABS*	00000000 _stextload
00005178 g     F .text.itcm	000013d8 loop
00008f84 g     F .text.itcm	00000064 usb_config_rx
00001780  w    F .text.itcm	00000648 MTPD::GetStorageInfo(unsigned long)
00006c14 g     F .text.itcm	00000080 zeroFS_class::Init(unsigned char, unsigned char, char const*)
0000a120 g     F .text.itcm	00000028 Stream::peekNextDigit()
2000b288 g     O .bss	00000004 EventResponder::lastInterrupt
00007f58 g     F .text.itcm	00000134 memcpy
0000ac90 g     F .text.itcm	00000020 .hidden __aeabi_cdrcmple
0000c160 g     F .text.itcm	000016e4 _svfprintf_r
0000a714 g     F .text.itcm	00000022 .hidden __floatsidf
2000b144 g     O .bss	00000004 systick_millis_count
0000ac0c g     F .text.itcm	00000082 .hidden __ltdf2
00009e1c g     F .text.itcm	00000030 usb_mtp_available
00006e3c g     F .text.itcm	00000034 disk_initialize
00007990 g     F .text.itcm	00000034 sd_readStart
0000ad40 g     F .text.itcm	00000000 .hidden __aeabi_uldivmod
00007474 g     F .text.itcm	00000004 SDHC_disk_initialize
2000b138 g     O .bss	00000001 usb_configuration
60000000 g     O .text.progmem	00000200 FlexSPI_NOR_Config
000096d0 g     F .text.itcm	00000050 sm_align_pool
00006e0c g     F .text.itcm	00000024 zeroFS_class::Read(unsigned long, char*, unsigned long)
60001a4c  w    O .text.progmem	00000018 usb_string_manufacturer_name
60001a14 g     O .text.progmem	00000008 usb_string_mtp
00007de0 g     F .text.itcm	0000005c spi_init
2000158c  w    O .bss	00000004 MTPD::write(char const*, int)::dst
20000a78 g     O .data	000000c8 __mprec_tens
6000129c g     F .text.progmem	000000ec usb_init
20001590 g     O .bss	00000004 sessionID_
2000b2c4 g     O .bss	00000004 __malloc_top_pad
2000d300 g     O .bss	00000004 systick_safe_read
20004054 g     O .bss	00002000 buff
aaaaaaaf g       *ABS*	00000000 _flexram_bank_config
0000a6f4 g     F .text.itcm	0000001e .hidden __aeabi_ui2d
0000ebb8 g     F .text.itcm	0000001c _localeconv_r
0000edfc g     F .text.itcm	00000012 __i2b
20000000 g       .data	00000000 _sdata
00009c00 g     F .text.itcm	000000a0 usb_mtp_configure
60001ad4 g     O .text.progmem	00000069 usb_config_descriptor_480
0000ad70 g     F .text.itcm	000002e2 .hidden __udivmoddi4
00004698  w    F .text.itcm	00000ae0 MTPD::getObjectPropValue(unsigned long, unsigned long)
0000a470 g     F .text.itcm	00000000 .hidden __aeabi_drsub
0000bbc0 g     F .text.itcm	00000024 _sbrk_r
0000923c g     F .text.itcm	00000002 startup_default_early_hook
6000102c g     F .text.progmem	00000270 ResetHandler
0000867c g     F .text.itcm	00000020 usb_serial_getchar
2000b2f8 g     O .bss	00000008 usb_cdc_line_coding
00006600 g     F .text.itcm	000000f0 zeroFS_class::Create(HDR_TYPE, char const*)
00009820 g     F .text.itcm	0000000a digitalWrite
2000b28c g     O .bss	00000004 EventResponder::lastYield
00006588  w    F .text.itcm	0000001c Print::write(char const*)
0000acc4 g     F .text.itcm	00000012 .hidden __aeabi_dcmplt
2000d400 g     O .bss	00000010 extmem_smalloc_pool
2000b2f0 g     O .bss	00000002 m_sd_status
2000b2c0 g     O .bss	00000004 __malloc_max_sbrked_mem
0000982c g     F .text.itcm	00000080 pinMode
0000a738 g     F .text.itcm	0000003a .hidden __extendsfdf2
0000aa34 g     F .text.itcm	000001d0 .hidden __aeabi_ddiv
0000a47c g     F .text.itcm	00000276 .hidden __adddf3
600125ec g     O .text.csf	00000c00 hab_csf
000004cc  w    F .text.itcm	00000250 MTPD::writestring(char const*)
20280000 g       .text.csf	00000000 _heap_end
2000b2f2 g     O .bss	00000002 m_sd_errorCode
0000f4c4 g       .ARM.exidx	00000000 __exidx_start
70000000 g       .bss.extram	00000000 _extram_end
0000a7e0 g     F .text.itcm	00000254 .hidden __aeabi_dmul
2000b290 g     O .bss	00000004 EventResponder::firstYield
0000b7e0 g     F .text.itcm	000003de _realloc_r
0000b088 g     F .text.itcm	00000050 __libc_init_array
00009380 g     F .text.itcm	00000350 dtostrf
20001594 g     O .bss	00002ac0 mFS
20000b40 g     O .data	00000028 __mprec_bigtens
00009244  w    F .text.itcm	0000008c HardFault_HandlerC
00009fd0  w    F .text.itcm	00000004 usb_serial_class::clear()
0000a6f4 g     F .text.itcm	0000001e .hidden __floatunsidf
000092d0 g     F .text.itcm	00000030 _sbrk
6001107c g       *ABS*	00000000 _sdataload
0000f090 g     F .text.itcm	00000042 __mcmp
20000b7c g     O .data	00000004 __brkval
2000b068 g     O .bss	00000001 usb_cdc_line_rtsdtr
60001b4c g     F .text.progmem	00000000 _init
00006850 g     F .text.itcm	00000058 zeroFS_class::Close(HDR_TYPE)
000083c0 g     F .text.itcm	00000002 usb_serial_reset
200084a0 g     O .bss	00002a70 zFS
60001a68 g     O .text.progmem	00000069 usb_config_descriptor_12
000065a4 g     F .text.itcm	00000034 printSector(char*)
2000db00 g       .bss	00000000 _ebss
0000071c  w    F .text.itcm	00001064 MTPD::WriteDescriptor()
20000b74 g     O .data	00000004 propertyListNum
00006d28 g     F .text.itcm	0000003c zeroFS_class::Next()
00006d64 g     F .text.itcm	00000074 zeroFS_class::Info(unsigned long, char*, unsigned long*, unsigned long*)
0000ed60 g     F .text.itcm	00000040 __hi0bits
0000f464 g     F .text.itcm	0000004e .hidden __fixdfsi
20204080 g       .bss.dma	00000000 _heap_start
00007478 g     F .text.itcm	00000114 sd_CardReadBlocks
20000b78 g     O .data	00000002 m_chipSelectPin
00000002 g       *ABS*	00000000 _itcm_block_count
2000c000 g     O .bss	00000020 endpoint0_transfer_data
000098ac g     F .text.itcm	000002b8 pwm_init
0000a47c g     F .text.itcm	00000276 .hidden __aeabi_dadd
0000ac0c g     F .text.itcm	00000082 .hidden __ledf2
00006b5c g     F .text.itcm	000000b8 zeroFS_class::fixEOF()
6000183c g     F .text.progmem	00000064 usb_pll_start
0000ef40 g     F .text.itcm	000000a0 __pow5mult
0000a774 g     F .text.itcm	0000006a .hidden __aeabi_ul2d
00000000  w      *UND*	00000000 __deregister_frame_info
2000c020 g     O .bss	00000020 endpoint0_transfer_ack
2000b300 g     O .bss	00000004 usb_cdc_line_rtsdtr_millis
00009080 g     F .text.itcm	00000028 usb_transmit
00009fb0 g     F .text.itcm	00000020 systick_isr
20000bac g     O .data	00000010 Serial
00009ff0  w    F .text.itcm	00000006 usb_serial_class::write(unsigned char)
0000923c  w    F .text.itcm	00000002 startup_early_hook
0000ad00 g     F .text.itcm	00000012 .hidden __aeabi_dcmpgt
000085b8 g     F .text.itcm	00000044 usb_serial_peekchar
0000ebe0 g     F .text.itcm	00000000 memchr
0000a1ac g     F .text.itcm	000002c4 set_arm_clock
2000b13c g     O .bss	00000004 systick_cycle_count
20000b94 g     O .data	00000016 usb_string_serial_number_default
0000e9e8 g     F .text.itcm	000001d0 _free_r
0000acec g     F .text.itcm	00000012 .hidden __aeabi_dcmpge
00009fe0  w    F .text.itcm	00000004 usb_serial_class::flush()
0000a478 g     F .text.itcm	0000027a .hidden __aeabi_dsub
2000156c g     O .data	00000004 __malloc_sbrk_base
00009fd8  w    F .text.itcm	00000004 usb_serial_class::read()
0000a774 g     F .text.itcm	0000006a .hidden __floatundidf
0000efe0 g     F .text.itcm	000000ae __lshift
00009050 g     F .text.itcm	0000002e usb_prepare_transfer
00009224 g     F .text.itcm	00000018 unused_interrupt_vector
0000f2a4 g     F .text.itcm	00000100 __ssprint_r
600018a0 g     F .text.progmem	0000011c tempmon_init
2000b100 g     O .bss	00000004 usb_timer0_callback
0000f3a4 g     F .text.itcm	0000005e _vasnprintf_r
00007c70 g     F .text.itcm	0000001c spi_receive
000079c4 g     F .text.itcm	00000028 sd_readStop
0000c02c g     F .text.itcm	0000002c strlcpy
00008608 g     F .text.itcm	00000074 usb_serial_flush_input
2000b2f4 g     O .bss	00000002 m_sd_type
0000ee10 g     F .text.itcm	00000130 __multiply
0000869c g     F .text.itcm	0000002c usb_serial_putchar
00000025 g       *ABS*	00000000 _teensy_model_identifier
2000b2c8 g     O .bss	00000028 __malloc_current_mallinfo
0000f1e8 g     F .text.itcm	000000ba __d2b
2000b298 g     O .bss	00000020 HardwareSerial::s_serials_with_serial_events
00006a74 g     F .text.itcm	000000e8 zeroFS_class::findEOF()
00009d50 g     F .text.itcm	000000cc usb_mtp_send
00007970 g     F .text.itcm	00000020 sd_readData2
0000758c g     F .text.itcm	0000000a SDHC_disk_read
0000a714 g     F .text.itcm	00000022 .hidden __aeabi_i2d
0000a1a4 g     F .text.itcm	00000006 Stream::parseInt()
200008c4  w    O .data	00000028 vtable for usb_serial_class
0000a0f0 g     F .text.itcm	00000030 Stream::timedPeek()
2000b140 g     O .bss	00000004 scale_cpu_cycles_to_microseconds
0000b054  w    F .text.itcm	00000002 .hidden __aeabi_ldiv0
00002948  w    F .text.itcm	00001d50 MTPD::getObjectPropDesc(unsigned long, unsigned long)
0000aa34 g     F .text.itcm	000001d0 .hidden __divdf3
20001160 g     O .data	00000408 __malloc_av_
0000a7e0 g     F .text.itcm	00000254 .hidden __muldf3
0000872c g     F .text.itcm	000000a0 usb_serial_flush_output
0000b7d8 g     F .text.itcm	00000002 __malloc_lock
2000d800 g     O .bss	000002c0 _VectorsRam
0000f404 g     F .text.itcm	0000005e _calloc_r
20000baa g     O .data	00000001 yield_active_check_flags
000068d0 g     F .text.itcm	00000028 zeroFS_class::Read(void*, unsigned long)
2000b110 g     O .bss	00000001 usb_high_speed
0000b73c g     F .text.itcm	0000009a memset
0000a0e0 g     F .text.itcm	00000010 main
2000b2bc g     O .bss	00000004 __malloc_max_total_mem
00006fac g     F .text.itcm	00000050 sd_isr
20204000 g     O .bss.dma	00000069 usb_descriptor_buffer
00006e34 g     F .text.itcm	00000004 MSC_disk_read
0000bfd8 g     F .text.itcm	00000052 strlcat
00007ad0 g     F .text.itcm	0000006c sd_writeData2
00009e4c g     F .text.itcm	00000058 usb_init_serialnumber
2000b2f6 g     O .bss	00000002 m_sckDivisor
60001bb0 g       .text.progmem	00000000 __init_array_end
0000da18 g     F .text.itcm	00000e34 _dtoa_r
0000b0d8 g     F .text.itcm	00000570 _malloc_r
2000b2b8 g     O .bss	00000001 HardwareSerial::s_count_serials_with_serial_events
0000d8a8 g     F .text.itcm	0000001a __ascii_wctomb
0000a784 g     F .text.itcm	0000005a .hidden __aeabi_l2d
000067c0 g     F .text.itcm	00000090 zeroFS_class::Open(HDR_TYPE, char const*)
00000031 g       *ABS*	00000000 __rtc_localtime
000091c0 g     F .text.itcm	00000064 micros
00007c30 g     F .text.itcm	00000040 SPI_disk_write
0000e94c g     F .text.itcm	0000009c _malloc_trim_r
60001a64 g     O .text.progmem	00000004 string0
000086c8 g     F .text.itcm	00000018 usb_serial_write
00009240  w    F .text.itcm	00000002 startup_late_hook
00009fdc  w    F .text.itcm	00000004 usb_serial_class::available()
0000bc48 g     F .text.itcm	000002dc strcmp
2000d000 g     O .bss	00000300 endpoint_queue_head
60001a1c  w    O .text.progmem	0000002e usb_string_product_name
000090f4 g     F .text.itcm	000000cc delay
0000ac14 g     F .text.itcm	0000007a .hidden __nedf2
0000f4c0 g     F .fini	00000000 _fini
60001020 g     O .text.progmem	0000000c BootData
0000bbe4 g     F .text.itcm	0000004c sprintf
0000a028 g     F .text.itcm	0000001e Print::printf(char const*, ...)
0000a0c8 g     F .text.itcm	00000016 Print::print(long)
000097b0 g     F .text.itcm	00000024 Panic_Temp_isr
0000d8c4 g     F .text.itcm	0000002c _write_r
00009ca0 g     F .text.itcm	000000b0 usb_mtp_recv
20000ff0 g     O .data	00000004 _impure_ptr
00007c8c g     F .text.itcm	00000154 sd_connect
60001ba8 g       .text.progmem	00000000 __preinit_array_end
0000b648 g     F .text.itcm	0000002a __ascii_mbtowc
000069c8 g     F .text.itcm	000000ac zeroFS_class::List()
00000100 g     F .text.itcm	000003cc setup
2000084c g     O .data	00000078 usb_descriptor_list
000070b8 g     F .text.itcm	000003bc sd_CardInit
00007ee4 g     F .text.itcm	00000064 sd_init
00006c94 g     F .text.itcm	00000094 zeroFS_class::Count(unsigned long)
20070000 g       .text.csf	00000000 _estack
000086e0 g     F .text.itcm	0000004c usb_serial_write_buffer_free
0000acb0 g     F .text.itcm	00000012 .hidden __aeabi_dcmpeq
000083c4 g     F .text.itcm	00000108 usb_serial_configure
0000a018  w    F .text.itcm	0000000e _write
20001570 g       .data	00000000 _edata
2000b148 g     O .bss	00000001 external_psram_size
00001dc8  w    F .text.itcm	00000b80 MTPD::GetObjectInfo(unsigned long)
00007e3c g     F .text.itcm	000000a8 spi_begin
00009fe4  w    F .text.itcm	00000004 usb_serial_class::availableForWrite()
00007b98 g     F .text.itcm	00000098 sd_writeStop
000076fc g     F .text.itcm	0000000a SDHC_disk_write
00009330 g     F .text.itcm	0000004e ultoa
0000778c g     F .text.itcm	000000ec sd_cardCommand
00009f68 g     F .text.itcm	00000044 EventResponder::runFromInterrupt()
20001568 g     O .data	00000004 __malloc_trim_threshold
00009fd4  w    F .text.itcm	00000004 usb_serial_class::peek()
0000b058 g     F .text.itcm	00000024 fcvtf
00006eb4 g     F .text.itcm	00000042 disk_write
20006060 g     O .bss	00002440 mtpd
0000f0d4 g     F .text.itcm	00000114 __mdiff
000068a8 g     F .text.itcm	00000028 zeroFS_class::Write(void*, unsigned long)
0000f464 g     F .text.itcm	0000004e .hidden __aeabi_d2iz
000079ec g     F .text.itcm	0000003c SPI_disk_read
20000960 g     O .data	00000101 _ctype_
60001ba8 g       .text.progmem	00000000 __init_array_start
0000b054  w    F .text.itcm	00000002 .hidden __aeabi_idiv0
0000ad14 g     F .text.itcm	0000002c .hidden __unorddf2
20000bbc g     O .data	00000004 F_BUS_ACTUAL
0000a148 g     F .text.itcm	0000005a Stream::parseInt(char)
00006e30 g     F .text.itcm	00000004 MSC_disk_initialize
00000000 g       .text.itcm	00000000 _stext
0000c080 g     F .text.itcm	000000dc strlen
00006e70 g     F .text.itcm	00000042 disk_read
0000aca0 g     F .text.itcm	00000010 .hidden __aeabi_cdcmpeq
0000ac04 g     F .text.itcm	0000008a .hidden __gedf2
60001a1c g     O .text.progmem	0000002e usb_string_product_name_default
00007598 g     F .text.itcm	00000164 sd_CardWriteBlocks
0000d890 g     F .text.itcm	00000018 vdprintf
0000a738 g     F .text.itcm	0000003a .hidden __aeabi_f2d
60001388 g     F .text.progmem	000000f8 configure_cache
00000000  w      *UND*	00000000 _Jv_RegisterClasses
0000a478 g     F .text.itcm	0000027a .hidden __subdf3
60001ba8 g       .text.progmem	00000000 __preinit_array_start
000090a8 g     F .text.itcm	00000024 usb_receive
0000eda0 g     F .text.itcm	0000005a __lo0bits
000131e8 g       *ABS*	00000000 _flashimagelen
00000000  w      *UND*	00000000 __register_frame_info
00009300 g     F .text.itcm	00000030 rtc_get
70000000 g       .bss.extram	00000000 _extram_start
00009fac g     F .text.itcm	00000004 pendablesrvreq_isr
20000ff4 g     O .data	0000016c __global_locale
00007878 g     F .text.itcm	000000f8 sd_readData
000084cc g     F .text.itcm	000000ec usb_serial_read
0000a048 g     F .text.itcm	0000007e Print::printNumber(unsigned long, unsigned char, unsigned char)
00008fe8 g     F .text.itcm	00000068 usb_config_tx
0000ece0 g     F .text.itcm	00000080 __multadd
0000eccc g     F .text.itcm	00000012 _Bfree
20000b94  w    O .data	00000016 usb_string_serial_number



Disassembly of section .text.progmem:

60000000 <FlexSPI_NOR_Config>:
60000000:	FCFB...V........
	...
60000044:	................
	...
60000080:	.....2.&........
60000090:	...$............
	...
600000b0:	................
	...
600000d0:	 ...............
	...
60000100:	................
60000110:	..... ..........
	...
60000130:	`...............
	...
600001c0:	................
600001d0:	................
	...
60000200:	................
60000210:	................
60000220:	................
60000230:	................
60000240:	................
60000250:	................
60000260:	................
60000270:	................
60000280:	................
60000290:	................
600002a0:	................
600002b0:	................
600002c0:	................
600002d0:	................
600002e0:	................
600002f0:	................
60000300:	................
60000310:	................
60000320:	................
60000330:	................
60000340:	................
60000350:	................
60000360:	................
60000370:	................
60000380:	................
60000390:	................
600003a0:	................
600003b0:	................
600003c0:	................
600003d0:	................
600003e0:	................
600003f0:	................
60000400:	................
60000410:	................
60000420:	................
60000430:	................
60000440:	................
60000450:	................
60000460:	................
60000470:	................
60000480:	................
60000490:	................
600004a0:	................
600004b0:	................
600004c0:	................
600004d0:	................
600004e0:	................
600004f0:	................
60000500:	................
60000510:	................
60000520:	................
60000530:	................
60000540:	................
60000550:	................
60000560:	................
60000570:	................
60000580:	................
60000590:	................
600005a0:	................
600005b0:	................
600005c0:	................
600005d0:	................
600005e0:	................
600005f0:	................
60000600:	................
60000610:	................
60000620:	................
60000630:	................
60000640:	................
60000650:	................
60000660:	................
60000670:	................
60000680:	................
60000690:	................
600006a0:	................
600006b0:	................
600006c0:	................
600006d0:	................
600006e0:	................
600006f0:	................
60000700:	................
60000710:	................
60000720:	................
60000730:	................
60000740:	................
60000750:	................
60000760:	................
60000770:	................
60000780:	................
60000790:	................
600007a0:	................
600007b0:	................
600007c0:	................
600007d0:	................
600007e0:	................
600007f0:	................
60000800:	................
60000810:	................
60000820:	................
60000830:	................
60000840:	................
60000850:	................
60000860:	................
60000870:	................
60000880:	................
60000890:	................
600008a0:	................
600008b0:	................
600008c0:	................
600008d0:	................
600008e0:	................
600008f0:	................
60000900:	................
60000910:	................
60000920:	................
60000930:	................
60000940:	................
60000950:	................
60000960:	................
60000970:	................
60000980:	................
60000990:	................
600009a0:	................
600009b0:	................
600009c0:	................
600009d0:	................
600009e0:	................
600009f0:	................
60000a00:	................
60000a10:	................
60000a20:	................
60000a30:	................
60000a40:	................
60000a50:	................
60000a60:	................
60000a70:	................
60000a80:	................
60000a90:	................
60000aa0:	................
60000ab0:	................
60000ac0:	................
60000ad0:	................
60000ae0:	................
60000af0:	................
60000b00:	................
60000b10:	................
60000b20:	................
60000b30:	................
60000b40:	................
60000b50:	................
60000b60:	................
60000b70:	................
60000b80:	................
60000b90:	................
60000ba0:	................
60000bb0:	................
60000bc0:	................
60000bd0:	................
60000be0:	................
60000bf0:	................
60000c00:	................
60000c10:	................
60000c20:	................
60000c30:	................
60000c40:	................
60000c50:	................
60000c60:	................
60000c70:	................
60000c80:	................
60000c90:	................
60000ca0:	................
60000cb0:	................
60000cc0:	................
60000cd0:	................
60000ce0:	................
60000cf0:	................
60000d00:	................
60000d10:	................
60000d20:	................
60000d30:	................
60000d40:	................
60000d50:	................
60000d60:	................
60000d70:	................
60000d80:	................
60000d90:	................
60000da0:	................
60000db0:	................
60000dc0:	................
60000dd0:	................
60000de0:	................
60000df0:	................
60000e00:	................
60000e10:	................
60000e20:	................
60000e30:	................
60000e40:	................
60000e50:	................
60000e60:	................
60000e70:	................
60000e80:	................
60000e90:	................
60000ea0:	................
60000eb0:	................
60000ec0:	................
60000ed0:	................
60000ee0:	................
60000ef0:	................
60000f00:	................
60000f10:	................
60000f20:	................
60000f30:	................
60000f40:	................
60000f50:	................
60000f60:	................
60000f70:	................
60000f80:	................
60000f90:	................
60000fa0:	................
60000fb0:	................
60000fc0:	................
60000fd0:	................
60000fe0:	................
60000ff0:	................

60001000 <ImageVectorTable>:
60001000:	.. C-..`........
60001010:	 ..`...`.%.`....

60001020 <BootData>:
60001020:	...`.1......

6000102c <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000102c:	ldr	r3, [pc, #472]	; (60001208 <ResetHandler+0x1dc>)
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000102e:	mov.w	r1, #11141120	; 0xaa0000
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001032:	ldr	r2, [pc, #472]	; (6000120c <ResetHandler+0x1e0>)
	IOMUXC_GPR_GPR16 = 0x00200007;
60001034:	ldr	r0, [pc, #472]	; (60001210 <ResetHandler+0x1e4>)
void startup_early_hook(void)		__attribute__ ((weak, alias("startup_default_early_hook")));
void startup_default_late_hook(void) {}
void startup_late_hook(void)		__attribute__ ((weak, alias("startup_default_late_hook")));
__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
void ResetHandler(void)
{
60001036:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
6000103a:	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
6000103c:	str	r0, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
6000103e:	ldr	r2, [pc, #468]	; (60001214 <ResetHandler+0x1e8>)
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001040:	str	r1, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001042:	mov	sp, r2
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001044:	ldr	r2, [pc, #464]	; (60001218 <ResetHandler+0x1ec>)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001046:	add.w	r3, r3, #180224	; 0x2c000
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
6000104a:	ldr	r1, [pc, #464]	; (6000121c <ResetHandler+0x1f0>)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000104c:	movs	r0, #8
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
6000104e:	cmp	r2, r1
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
	IOMUXC_GPR_GPR16 = 0x00200007;
	IOMUXC_GPR_GPR14 = 0x00AA0000;
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
60001050:	str.w	r0, [r3, #340]	; 0x154
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001054:	beq.n	60001076 <ResetHandler+0x4a>
	while (dest < dest_end) {
60001056:	ldr	r3, [pc, #456]	; (60001220 <ResetHandler+0x1f4>)
60001058:	cmp	r2, r3
6000105a:	bcs.n	60001076 <ResetHandler+0x4a>
6000105c:	mvns	r4, r2
6000105e:	mov	r0, r1
60001060:	add	r3, r4
60001062:	bic.w	r3, r3, #3
60001066:	adds	r3, #4
60001068:	add	r3, r1
		*dest++ = *src++;
6000106a:	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
6000106e:	cmp	r0, r3
		*dest++ = *src++;
60001070:	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001074:	bne.n	6000106a <ResetHandler+0x3e>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001076:	ldr	r2, [pc, #428]	; (60001224 <ResetHandler+0x1f8>)
60001078:	ldr	r1, [pc, #428]	; (60001228 <ResetHandler+0x1fc>)
6000107a:	cmp	r2, r1
6000107c:	beq.n	6000109e <ResetHandler+0x72>
	while (dest < dest_end) {
6000107e:	ldr	r3, [pc, #428]	; (6000122c <ResetHandler+0x200>)
60001080:	cmp	r2, r3
60001082:	bcs.n	6000109e <ResetHandler+0x72>
60001084:	mvns	r4, r2
60001086:	mov	r0, r1
60001088:	add	r3, r4
6000108a:	bic.w	r3, r3, #3
6000108e:	adds	r3, #4
60001090:	add	r3, r1
		*dest++ = *src++;
60001092:	ldr.w	r1, [r0], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001096:	cmp	r0, r3
		*dest++ = *src++;
60001098:	str.w	r1, [r2], #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
6000109c:	bne.n	60001092 <ResetHandler+0x66>
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
6000109e:	ldr	r2, [pc, #400]	; (60001230 <ResetHandler+0x204>)
600010a0:	ldr	r3, [pc, #400]	; (60001234 <ResetHandler+0x208>)
600010a2:	cmp	r2, r3
600010a4:	bcs.n	600010be <ResetHandler+0x92>
600010a6:	mvns	r0, r2
600010a8:	mov	r1, r2
		*dest++ = 0;
600010aa:	movs	r4, #0
600010ac:	add	r3, r0
600010ae:	bic.w	r3, r3, #3
600010b2:	adds	r3, #4
600010b4:	add	r3, r2
600010b6:	str.w	r4, [r1], #4
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
600010ba:	cmp	r3, r1
600010bc:	bne.n	600010b6 <ResetHandler+0x8a>
	memory_copy(&_stext, &_stextload, &_etext);
	memory_copy(&_sdata, &_sdataload, &_edata);
	memory_clear(&_sbss, &_ebss);

	// enable FPU
	SCB_CPACR = 0x00F00000;
600010be:	ldr	r2, [pc, #376]	; (60001238 <ResetHandler+0x20c>)
600010c0:	mov.w	r1, #15728640	; 0xf00000
600010c4:	ldr	r3, [pc, #372]	; (6000123c <ResetHandler+0x210>)
600010c6:	str	r1, [r2, #0]
600010c8:	add.w	r1, r3, #704	; 0x2c0
600010cc:	ldr	r2, [pc, #368]	; (60001240 <ResetHandler+0x214>)

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
600010ce:	str.w	r2, [r3, #4]!
600010d2:	cmp	r1, r3
600010d4:	bne.n	600010ce <ResetHandler+0xa2>
600010d6:	ldr	r3, [pc, #364]	; (60001244 <ResetHandler+0x218>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
600010d8:	movs	r1, #128	; 0x80
600010da:	ldr	r2, [pc, #364]	; (60001248 <ResetHandler+0x21c>)
600010dc:	strb.w	r1, [r3], #1
600010e0:	cmp	r3, r2
600010e2:	bne.n	600010dc <ResetHandler+0xb0>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600010e4:	ldr	r4, [pc, #356]	; (6000124c <ResetHandler+0x220>)
600010e6:	mov.w	r7, #2155905152	; 0x80808080
	reset_PFD();
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600010ea:	ldr	r6, [pc, #356]	; (60001250 <ResetHandler+0x224>)
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600010ec:	mov.w	r2, #4294967295
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600010f0:	ldr.w	sl, [pc, #412]	; 60001290 <ResetHandler+0x264>
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
600010f4:	movs	r5, #0
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
600010f6:	ldr	r3, [pc, #348]	; (60001254 <ResetHandler+0x228>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600010f8:	ldr.w	r9, [pc, #408]	; 60001294 <ResetHandler+0x268>
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600010fc:	ldr.w	r8, [pc, #408]	; 60001298 <ResetHandler+0x26c>
	SCB_CPACR = 0x00F00000;

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
	SCB_VTOR = (uint32_t)_VectorsRam;
60001100:	str.w	sl, [r3]
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001104:	str.w	r7, [r4, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001108:	str.w	r9, [r4, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000110c:	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001110:	str.w	r8, [r4, #240]	; 0xf0
	reset_PFD();
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
60001114:	ldr	r3, [r6, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
60001116:	ldr	r1, [pc, #240]	; (60001208 <ResetHandler+0x1dc>)
	reset_PFD();
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
60001118:	bic.w	r3, r3, #127	; 0x7f
6000111c:	orr.w	r3, r3, #64	; 0x40
60001120:	str	r3, [r6, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
60001122:	ldr	r3, [r6, #36]	; 0x24
60001124:	bic.w	r3, r3, #127	; 0x7f
60001128:	orr.w	r3, r3, #64	; 0x40
6000112c:	str	r3, [r6, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
6000112e:	str	r2, [r1, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
60001130:	str	r2, [r1, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
60001132:	str	r2, [r1, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
60001134:	str	r2, [r1, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
60001136:	bl	60001388 <configure_cache>
extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
6000113a:	ldr	r2, [pc, #284]	; (60001258 <ResetHandler+0x22c>)
6000113c:	movs	r0, #99	; 0x63
	SYST_CVR = 0;
6000113e:	ldr	r3, [pc, #284]	; (6000125c <ResetHandler+0x230>)
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
60001140:	ldr	r1, [pc, #284]	; (60001260 <ResetHandler+0x234>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001142:	str	r0, [r2, #0]
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001144:	movs	r2, #3
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
60001146:	str	r5, [r3, #0]
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
60001148:	str.w	r1, [sl, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
6000114c:	str.w	r2, [r3, #-8]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001150:	ldr	r1, [pc, #272]	; (60001264 <ResetHandler+0x238>)
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001152:	ldr	r2, [pc, #276]	; (60001268 <ResetHandler+0x23c>)

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
60001154:	ldr	r0, [pc, #276]	; (6000126c <ResetHandler+0x240>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
60001156:	str.w	r2, [r3, #3336]	; 0xd08
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000115a:	ldr	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000115c:	ldr	r2, [pc, #272]	; (60001270 <ResetHandler+0x244>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
6000115e:	orr.w	r3, r3, #16777216	; 0x1000000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
	_VectorsRam[15] = systick_isr;
60001162:	str.w	r0, [sl, #60]	; 0x3c
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001166:	ldr	r0, [pc, #268]	; (60001274 <ResetHandler+0x248>)
	_VectorsRam[15] = systick_isr;
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001168:	str	r3, [r1, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000116a:	ldr	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
6000116c:	ldr	r1, [pc, #264]	; (60001278 <ResetHandler+0x24c>)
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
	SYST_CVR = 0;
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000116e:	orr.w	r3, r3, #1
60001172:	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001174:	ldr	r3, [r0, #0]
60001176:	str	r3, [r1, #0]
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
	configure_systick();
	usb_pll_start();	
60001178:	bl	6000183c <usb_pll_start>
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
6000117c:	str.w	r7, [r4, #260]	; 0x104
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
60001180:	ldr	r0, [pc, #248]	; (6000127c <ResetHandler+0x250>)

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001182:	str.w	r9, [r4, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
60001186:	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000118a:	str.w	r8, [r4, #240]	; 0xf0
	configure_cache();
	configure_systick();
	usb_pll_start();	
	reset_PFD(); //TODO: is this really needed?
#ifdef F_CPU
	set_arm_clock(F_CPU);
6000118e:	bl	60001b88 <__set_arm_clock_veneer>
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001192:	ldr	r1, [r6, #108]	; 0x6c
	PIT_MCR = 0;
60001194:	ldr	r2, [pc, #232]	; (60001280 <ResetHandler+0x254>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001196:	orr.w	r1, r1, #12288	; 0x3000
	PIT_TCTRL1 = 0;
	PIT_TCTRL2 = 0;
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
6000119a:	ldr	r3, [pc, #232]	; (60001284 <ResetHandler+0x258>)
#ifdef F_CPU
	set_arm_clock(F_CPU);
#endif

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000119c:	str	r1, [r6, #108]	; 0x6c
	PIT_MCR = 0;
6000119e:	str	r5, [r2, #0]
	PIT_TCTRL0 = 0;
600011a0:	str.w	r5, [r2, #264]	; 0x108
	PIT_TCTRL1 = 0;
600011a4:	str.w	r5, [r2, #280]	; 0x118
	PIT_TCTRL2 = 0;
600011a8:	str.w	r5, [r2, #296]	; 0x128
	PIT_TCTRL3 = 0;
600011ac:	str.w	r5, [r2, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
600011b0:	ldr	r2, [r3, #56]	; 0x38
600011b2:	lsls	r2, r2, #31
600011b4:	bmi.n	600011c8 <ResetHandler+0x19c>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
		SNVS_LPSRTCMR = 1546300800u >> 17;
600011b6:	movw	r2, #11797	; 0x2e15
	PIT_TCTRL3 = 0;

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
600011ba:	ldr	r1, [pc, #204]	; (60001288 <ResetHandler+0x25c>)
600011bc:	str	r1, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
600011be:	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
600011c0:	ldr	r2, [r3, #56]	; 0x38
600011c2:	orr.w	r2, r2, #1
600011c6:	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
600011c8:	ldr	r2, [pc, #184]	; (60001284 <ResetHandler+0x258>)
600011ca:	ldr	r4, [pc, #192]	; (6000128c <ResetHandler+0x260>)
600011cc:	ldr	r3, [r2, #8]
600011ce:	orr.w	r3, r3, #65537	; 0x10001
600011d2:	str	r3, [r2, #8]

#ifdef ARDUINO_TEENSY41
	configure_external_ram();
600011d4:	bl	60001480 <configure_external_ram>
#endif
	startup_early_hook();
600011d8:	bl	60001b58 <__startup_early_hook_veneer>
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
600011dc:	ldr	r3, [r4, #0]
	while (millis() < 20) ; // wait at least 20ms before starting USB
600011de:	cmp	r3, #19
600011e0:	bls.n	600011dc <ResetHandler+0x1b0>
	usb_init();
600011e2:	bl	6000129c <usb_init>
	analog_init();
600011e6:	bl	600019bc <analog_init>
	pwm_init();
600011ea:	bl	60001b60 <__pwm_init_veneer>
	tempmon_init();
600011ee:	bl	600018a0 <tempmon_init>

	startup_late_hook();
600011f2:	bl	60001b68 <__startup_late_hook_veneer>
600011f6:	ldr	r3, [r4, #0]
	while (millis() < 300) ; // wait at least 300ms before calling user code
600011f8:	cmp.w	r3, #300	; 0x12c
600011fc:	bcc.n	600011f6 <ResetHandler+0x1ca>
	//printf("before C++ constructors\n");
	__libc_init_array();
600011fe:	bl	60001b80 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
60001202:	bl	60001b98 <__main_veneer>
60001206:	b.n	60001206 <ResetHandler+0x1da>
60001208:	.word	0x400ac000
6000120c:	.word	0xaaaaaaaf
60001210:	.word	0x00200007
60001214:	.word	0x20070000
60001218:	.word	0x00000000
6000121c:	.word	0x60001bb0
60001220:	.word	0x0000f4c8
60001224:	.word	0x20000000
60001228:	.word	0x6001107c
6000122c:	.word	0x20001570
60001230:	.word	0x20001570
60001234:	.word	0x2000db00
60001238:	.word	0xe000ed88
6000123c:	.word	0x2000d7fc
60001240:	.word	0x00009225
60001244:	.word	0xe000e400
60001248:	.word	0xe000e4a0
6000124c:	.word	0x400d8000
60001250:	.word	0x400fc000
60001254:	.word	0xe000ed08
60001258:	.word	0xe000e014
6000125c:	.word	0xe000e018
60001260:	.word	0x00009fad
60001264:	.word	0xe000edfc
60001268:	.word	0x20200000
6000126c:	.word	0x00009fb1
60001270:	.word	0xe0001000
60001274:	.word	0xe0001004
60001278:	.word	0x2000b13c
6000127c:	.word	0x179a7b00
60001280:	.word	0x40084000
60001284:	.word	0x400d4000
60001288:	.word	0x56c00000
6000128c:	.word	0x2000b144
60001290:	.word	0x2000d800
60001294:	.word	0x2018101b
60001298:	.word	0x13110d0c

6000129c <usb_init>:
FLASHMEM void usb_init(void)
{
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
6000129c:	ldr	r3, [pc, #192]	; (60001360 <usb_init+0xc4>)
6000129e:	movw	r2, #3937	; 0xf61

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
600012a2:	push	{r4, r5, r6, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600012a4:	str.w	r2, [r3, #288]	; 0x120

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600012a8:	movw	r5, #1028	; 0x404
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
600012ac:	bl	60001ba0 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600012b0:	ldr	r1, [pc, #176]	; (60001364 <usb_init+0xc8>)
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600012b2:	ldr	r0, [pc, #180]	; (60001368 <usb_init+0xcc>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600012b4:	ldr.w	r2, [r1, #128]	; 0x80
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
600012b8:	ldr	r4, [pc, #176]	; (6000136c <usb_init+0xd0>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600012ba:	orr.w	r2, r2, #3
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
600012be:	ldr	r3, [pc, #176]	; (60001370 <usb_init+0xd4>)

	usb_init_serialnumber();

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
600012c0:	str.w	r2, [r1, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
600012c4:	str.w	r5, [r0, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
600012c8:	ldr	r2, [r4, #0]
600012ca:	ands	r3, r2
600012cc:	cbnz	r3, 600012d6 <usb_init+0x3a>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
600012ce:	ldr.w	r3, [r0, #424]	; 0x1a8
600012d2:	lsls	r2, r3, #30
600012d4:	beq.n	6000130c <usb_init+0x70>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
600012d6:	ldr	r3, [pc, #144]	; (60001368 <usb_init+0xcc>)
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
600012d8:	mov.w	r1, #2147483648	; 0x80000000
600012dc:	ldr	r2, [pc, #140]	; (6000136c <usb_init+0xd0>)
600012de:	str	r1, [r2, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
600012e0:	mov	r2, r3
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
600012e2:	ldr.w	r1, [r3, #320]	; 0x140
600012e6:	orr.w	r1, r1, #2
600012ea:	str.w	r1, [r3, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
600012ee:	ldr.w	r3, [r2, #320]	; 0x140
600012f2:	lsls	r3, r3, #30
600012f4:	bmi.n	600012ee <usb_init+0x52>
		NVIC_CLEAR_PENDING(IRQ_USB1);
600012f6:	mov.w	r0, #131072	; 0x20000
600012fa:	ldr	r1, [pc, #120]	; (60001374 <usb_init+0xd8>)
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
600012fc:	ldr	r3, [pc, #108]	; (6000136c <usb_init+0xd0>)
600012fe:	mov.w	r2, #2147483648	; 0x80000000
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001302:	str	r0, [r1, #0]
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001304:	movs	r0, #25
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
		NVIC_CLEAR_PENDING(IRQ_USB1);
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001306:	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001308:	bl	60001b90 <__delay_veneer>
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
6000130c:	ldr	r5, [pc, #104]	; (60001378 <usb_init+0xdc>)
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
6000130e:	movs	r2, #0
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
60001310:	ldr	r3, [pc, #88]	; (6000136c <usb_init+0xd0>)
60001312:	mov.w	r1, #1073741824	; 0x40000000
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001316:	ldr	r4, [pc, #80]	; (60001368 <usb_init+0xcc>)
60001318:	movs	r6, #10
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
6000131a:	str	r1, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
6000131c:	mov	r0, r5
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
6000131e:	str	r2, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001320:	mov	r1, r2
	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
	USBPHY1_PWD = 0;
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
60001322:	str.w	r6, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001326:	mov.w	r2, #768	; 0x300
6000132a:	bl	60001b70 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
6000132e:	mov.w	r6, #4227072	; 0x408000
	endpoint_queue_head[1].config = (64 << 16);
60001332:	mov.w	r0, #4194304	; 0x400000
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
60001336:	movw	r3, #323	; 0x143
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
6000133a:	ldr	r2, [pc, #64]	; (6000137c <usb_init+0xe0>)
6000133c:	ldr	r1, [pc, #64]	; (60001380 <usb_init+0xe4>)
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
6000133e:	str	r6, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
60001340:	str	r0, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
60001342:	str.w	r5, [r4, #344]	; 0x158
60001346:	str.w	r1, [r2, #516]	; 0x204
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
6000134a:	str.w	r3, [r4, #328]	; 0x148
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &isr;
	attachInterruptVector(IRQ_USB1, &isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
6000134e:	ldr	r2, [pc, #52]	; (60001384 <usb_init+0xe8>)
60001350:	mov.w	r1, #131072	; 0x20000
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001354:	movs	r3, #1
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &isr;
	attachInterruptVector(IRQ_USB1, &isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
60001356:	str	r1, [r2, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
60001358:	str.w	r3, [r4, #320]	; 0x140
6000135c:	pop	{r4, r5, r6, pc}
6000135e:	nop
60001360:	.word	0x400d8000
60001364:	.word	0x400fc000
60001368:	.word	0x402e0000
6000136c:	.word	0x400d9000
60001370:	.word	0x001e1c00
60001374:	.word	0xe000e28c
60001378:	.word	0x2000d000
6000137c:	.word	0x2000d800
60001380:	.word	0x00008915
60001384:	.word	0xe000e10c

60001388 <configure_cache>:
#define SIZE_2G		(SCB_MPU_RASR_SIZE(30) | SCB_MPU_RASR_ENABLE)
#define SIZE_4G		(SCB_MPU_RASR_SIZE(31) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
60001388:	push	{r4, r5, r6, r7, lr}
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
6000138a:	ldr	r2, [pc, #160]	; (6000142c <configure_cache+0xa4>)
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
6000138c:	movs	r0, #0

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
6000138e:	ldr	r3, [pc, #160]	; (60001430 <configure_cache+0xa8>)
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
60001390:	mov.w	ip, #16
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
60001394:	ldr	r4, [pc, #156]	; (60001434 <configure_cache+0xac>)

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
60001396:	movs	r7, #17

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
60001398:	ldr.w	lr, [pc, #216]	; 60001474 <configure_cache+0xec>
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
6000139c:	movs	r6, #18
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
6000139e:	str	r0, [r4, #0]
	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600013a0:	movs	r5, #1
	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
600013a2:	str.w	ip, [r2]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
600013a6:	str.w	lr, [r3]
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
600013aa:	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600013ac:	ldr.w	lr, [pc, #200]	; 60001478 <configure_cache+0xf0>

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600013b0:	ldr	r7, [pc, #132]	; (60001438 <configure_cache+0xb0>)
	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
600013b2:	str.w	lr, [r3]

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
600013b6:	str	r6, [r2, #0]
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
600013b8:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600013ba:	ldr	r6, [pc, #128]	; (6000143c <configure_cache+0xb4>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600013bc:	ldr	r7, [pc, #128]	; (60001440 <configure_cache+0xb8>)
	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
600013be:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600013c0:	ldr	r1, [pc, #128]	; (60001444 <configure_cache+0xbc>)
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
600013c2:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600013c4:	ldr	r6, [pc, #128]	; (60001448 <configure_cache+0xc0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600013c6:	orr.w	r1, r1, #21

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600013ca:	ldr	r7, [pc, #128]	; (6000144c <configure_cache+0xc4>)
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600013cc:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600013ce:	str	r7, [r3, #0]
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600013d0:	add.w	r7, r7, #196608	; 0x30000

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600013d4:	ldr	r6, [pc, #120]	; (60001450 <configure_cache+0xc8>)
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600013d6:	str	r1, [r2, #0]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600013d8:	adds	r7, #2

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600013da:	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600013dc:	ldr.w	lr, [pc, #156]	; 6000147c <configure_cache+0xf4>
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600013e0:	ldr	r6, [pc, #112]	; (60001454 <configure_cache+0xcc>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600013e2:	ldr	r1, [pc, #116]	; (60001458 <configure_cache+0xd0>)
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600013e4:	str.w	lr, [r2]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600013e8:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600013ea:	str	r6, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600013ec:	ldr	r7, [pc, #108]	; (6000145c <configure_cache+0xd4>)

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600013ee:	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600013f0:	ldr	r6, [pc, #108]	; (60001460 <configure_cache+0xd8>)

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600013f2:	ldr	r1, [pc, #112]	; (60001464 <configure_cache+0xdc>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600013f4:	str	r7, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600013f6:	str	r6, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | NOEXEC | SIZE_256M;
600013f8:	ldr	r7, [pc, #108]	; (60001468 <configure_cache+0xe0>)
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600013fa:	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | NOEXEC | SIZE_256M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600013fc:	ldr	r6, [pc, #108]	; (6000146c <configure_cache+0xe4>)
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
600013fe:	ldr	r1, [pc, #112]	; (60001470 <configure_cache+0xe8>)

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | NOEXEC | SIZE_256M;
60001400:	str	r7, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
60001402:	str	r6, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
60001404:	str	r1, [r3, #0]

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
60001406:	str	r5, [r4, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
60001408:	dsb	sy
	asm("isb");
6000140c:	isb	sy
	SCB_CACHE_ICIALLU = 0;
60001410:	str.w	r0, [r3, #432]	; 0x1b0

	asm("dsb");
60001414:	dsb	sy
	asm("isb");
60001418:	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
6000141c:	ldr.w	r3, [r2, #-136]
60001420:	orr.w	r3, r3, #196608	; 0x30000
60001424:	str.w	r3, [r2, #-136]
60001428:	pop	{r4, r5, r6, r7, pc}
6000142a:	nop
6000142c:	.word	0xe000ed9c
60001430:	.word	0xe000eda0
60001434:	.word	0xe000ed94
60001438:	.word	0x00100009
6000143c:	.word	0x00200013
60001440:	.word	0x07020021
60001444:	.word	0x2000db00
60001448:	.word	0x20000014
6000144c:	.word	0x13080025
60001450:	.word	0x10000009
60001454:	.word	0x40000017
60001458:	.word	0x13100033
6000145c:	.word	0x60000018
60001460:	.word	0x070b002f
60001464:	.word	0x70000019
60001468:	.word	0x170b0037
6000146c:	.word	0x7000001a
60001470:	.word	0x130b002f
60001474:	.word	0x1000003f
60001478:	.word	0x03080025
6000147c:	.word	0x20200016

60001480 <configure_external_ram>:
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
60001480:	push	{r4, r5, r6, r7, lr}
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
60001482:	ldr	r3, [pc, #564]	; (600016b8 <configure_external_ram+0x238>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
60001484:	movs	r2, #24
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
60001486:	ldr	r6, [pc, #564]	; (600016bc <configure_external_ram+0x23c>)
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
60001488:	movs	r0, #1
}

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
6000148a:	ldr	r1, [pc, #564]	; (600016c0 <configure_external_ram+0x240>)
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
6000148c:	movw	lr, #34572	; 0x870c

FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
60001490:	ldr	r5, [pc, #560]	; (600016c4 <configure_external_ram+0x244>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
60001492:	mov.w	r7, #4294967295
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
60001496:	ldr	r4, [pc, #560]	; (600016c8 <configure_external_ram+0x248>)
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
	return id & 0xFFFF;
}

FLASHMEM void configure_external_ram()
{
60001498:	sub	sp, #12
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
6000149a:	str.w	r1, [r3, #604]	; 0x25c
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
6000149e:	str.w	r5, [r3, #608]	; 0x260
	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
600014a2:	movs	r5, #0
FLASHMEM void configure_external_ram()
{
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
600014a4:	str.w	r1, [r3, #612]	; 0x264
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
600014a8:	str.w	r4, [r3, #616]	; 0x268
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
600014ac:	mov.w	r4, #8192	; 0x2000
	// initialize pins
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600014b0:	str.w	r6, [r3, #620]	; 0x26c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600014b4:	ldr	r1, [pc, #532]	; (600016cc <configure_external_ram+0x24c>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_22 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_23 = 0x110F9; // keeper, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_24 = 0x1B0F9; // 100K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_25 = 0x100F9; // strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600014b6:	str.w	r6, [r3, #624]	; 0x270
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600014ba:	str.w	r6, [r3, #628]	; 0x274
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
600014be:	str.w	r6, [r3, #632]	; 0x278
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
600014c2:	ldr	r6, [pc, #524]	; (600016d0 <configure_external_ram+0x250>)
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_26 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_27 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_28 = 0x170F9; // 47K pullup, strong drive, max speed, hyst
	IOMUXC_SW_PAD_CTL_PAD_GPIO_EMC_29 = 0x170F9; // 47K pullup, strong drive, max speed, hyst

	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_22 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS1_B (Flash)
600014c4:	str	r2, [r3, #108]	; 0x6c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_23 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DQS
600014c6:	str	r2, [r3, #112]	; 0x70
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_24 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SS0_B (RAM)
600014c8:	str	r2, [r3, #116]	; 0x74
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_25 = 8 | 0x10; // ALT1 = FLEXSPI2_A_SCLK
600014ca:	str	r2, [r3, #120]	; 0x78
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
600014cc:	str	r2, [r3, #124]	; 0x7c
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
600014ce:	str.w	r2, [r3, #128]	; 0x80
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
600014d2:	str.w	r2, [r3, #132]	; 0x84
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3
600014d6:	str.w	r2, [r3, #136]	; 0x88

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
600014da:	movw	r2, #1541	; 0x605
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_26 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA0
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_27 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA1
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_28 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA2
	IOMUXC_SW_MUX_CTL_PAD_GPIO_EMC_29 = 8 | 0x10; // ALT1 = FLEXSPI2_A_DATA3

	IOMUXC_FLEXSPI2_IPP_IND_DQS_FA_SELECT_INPUT = 1; // GPIO_EMC_23 for Mode: ALT8, pg 986
600014de:	str.w	r0, [r1, #812]	; 0x32c
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT0_SELECT_INPUT = 1; // GPIO_EMC_26 for Mode: ALT8
600014e2:	str.w	r0, [r1, #816]	; 0x330
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT1_SELECT_INPUT = 1; // GPIO_EMC_27 for Mode: ALT8
600014e6:	str.w	r0, [r1, #820]	; 0x334
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
600014ea:	str.w	r0, [r1, #824]	; 0x338
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
600014ee:	str.w	r0, [r1, #828]	; 0x33c
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8
600014f2:	str.w	r0, [r1, #848]	; 0x350
	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600014f6:	mov	r1, r5
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
600014f8:	ldr	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
600014fa:	ldr	r0, [pc, #472]	; (600016d4 <configure_external_ram+0x254>)
600014fc:	ands	r0, r3
600014fe:	ldr	r3, [pc, #472]	; (600016d8 <configure_external_ram+0x258>)
60001500:	orrs	r3, r0
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
60001502:	ldr	r0, [pc, #472]	; (600016dc <configure_external_ram+0x25c>)
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT2_SELECT_INPUT = 1; // GPIO_EMC_28 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_IO_FA_BIT3_SELECT_INPUT = 1; // GPIO_EMC_29 for Mode: ALT8
	IOMUXC_FLEXSPI2_IPP_IND_SCK_FA_SELECT_INPUT = 1; // GPIO_EMC_25 for Mode: ALT8

	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
60001504:	str	r3, [r6, #24]
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);
60001506:	ldr.w	r3, [r6, #132]	; 0x84
6000150a:	orr.w	r3, r3, #12
6000150e:	str.w	r3, [r6, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
60001512:	movs	r6, #2
	// turn on clock  (TODO: increase clock speed later, slow & cautious for first release)
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
60001514:	ldr	r3, [r0, #0]
60001516:	orrs	r3, r6
60001518:	str	r3, [r0, #0]
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
6000151a:	ldr	r3, [r0, #0]
		 | FLEXSPI_MCR0_IPGRANTWAIT_MASK | FLEXSPI_MCR0_SCKFREERUNEN
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
6000151c:	and.w	lr, r3, lr
60001520:	ldr	r3, [pc, #444]	; (600016e0 <configure_external_ram+0x260>)
60001522:	orr.w	r3, lr, r3
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001526:	ldr.w	lr, [pc, #496]	; 60001718 <configure_external_ram+0x298>
	CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_FLEXSPI2_PODF_MASK | CCM_CBCMR_FLEXSPI2_CLK_SEL_MASK))
		| CCM_CBCMR_FLEXSPI2_PODF(5) | CCM_CBCMR_FLEXSPI2_CLK_SEL(3); // 88 MHz
	CCM_CCGR7 |= CCM_CCGR7_FLEXSPI2(CCM_CCGR_ON);

	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR0 = (FLEXSPI2_MCR0 & ~(FLEXSPI_MCR0_AHBGRANTWAIT_MASK
6000152a:	str	r3, [r0, #0]
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
6000152c:	ldr	r3, [pc, #436]	; (600016e4 <configure_external_ram+0x264>)
		 | FLEXSPI_MCR0_COMBINATIONEN | FLEXSPI_MCR0_DOZEEN
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
6000152e:	str	r7, [r0, #4]
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
60001530:	ldr.w	r7, [lr, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001534:	ands	r3, r7
	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001536:	ldr	r7, [pc, #432]	; (600016e8 <configure_external_ram+0x268>)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;
60001538:	orr.w	r3, r3, #536870912	; 0x20000000
		 | FLEXSPI_MCR0_HSEN | FLEXSPI_MCR0_ATDFEN | FLEXSPI_MCR0_ARDFEN
		 | FLEXSPI_MCR0_RXCLKSRC_MASK | FLEXSPI_MCR0_SWRESET))
		| FLEXSPI_MCR0_AHBGRANTWAIT(0xFF) | FLEXSPI_MCR0_IPGRANTWAIT(0xFF)
		| FLEXSPI_MCR0_RXCLKSRC(1) | FLEXSPI_MCR0_MDIS;
	FLEXSPI2_MCR1 = FLEXSPI_MCR1_SEQWAIT(0xFFFF) | FLEXSPI_MCR1_AHBBUSWAIT(0xFFFF);
	FLEXSPI2_MCR2 = (FLEXSPI_MCR2 & ~(FLEXSPI_MCR2_RESUMEWAIT_MASK
6000153c:	str	r3, [r0, #8]
		 | FLEXSPI_MCR2_SCKBDIFFOPT | FLEXSPI_MCR2_SAMEDEVICEEN
		 | FLEXSPI_MCR2_CLRLEARNPHASE | FLEXSPI_MCR2_CLRAHBBUFOPT))
		| FLEXSPI_MCR2_RESUMEWAIT(0x20) /*| FLEXSPI_MCR2_SAMEDEVICEEN*/;

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
6000153e:	ldr	r3, [r0, #12]
60001540:	bic.w	r3, r3, #120	; 0x78
60001544:	str	r3, [r0, #12]
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001546:	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001548:	ands	r7, r3
6000154a:	ldr	r3, [pc, #416]	; (600016ec <configure_external_ram+0x26c>)
6000154c:	orrs	r3, r7
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
6000154e:	ldr	r7, [pc, #408]	; (600016e8 <configure_external_ram+0x268>)

	FLEXSPI2_AHBCR = FLEXSPI2_AHBCR & ~(FLEXSPI_AHBCR_READADDROPT | FLEXSPI_AHBCR_PREFETCHEN
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001550:	str	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
60001552:	ldr	r3, [r0, #32]
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
60001554:	ands	r7, r3
60001556:	ldr	r3, [pc, #404]	; (600016ec <configure_external_ram+0x26c>)
60001558:	orrs	r3, r7
	FLEXSPI2_AHBRXBUF2CR0 = mask;
6000155a:	ldr	r7, [pc, #404]	; (600016f0 <configure_external_ram+0x270>)
		| FLEXSPI_AHBCR_BUFFERABLEEN | FLEXSPI_AHBCR_CACHABLEEN);
	uint32_t mask = (FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_PRIORITY_MASK
		| FLEXSPI_AHBRXBUFCR0_MSTRID_MASK | FLEXSPI_AHBRXBUFCR0_BUFSZ_MASK);
	FLEXSPI2_AHBRXBUF0CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF1CR0 = (FLEXSPI2_AHBRXBUF0CR0 & ~mask)
6000155c:	str	r3, [r0, #36]	; 0x24
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
6000155e:	str	r7, [r0, #40]	; 0x28
	FLEXSPI2_AHBRXBUF3CR0 = mask;
60001560:	str	r7, [r0, #44]	; 0x2c

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
60001562:	ldr.w	r3, [lr, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;

	FLEXSPI2_INTEN = 0;
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
60001566:	ldr	r7, [pc, #396]	; (600016f4 <configure_external_ram+0x274>)
		| FLEXSPI_AHBRXBUFCR0_PREFETCHEN | FLEXSPI_AHBRXBUFCR0_BUFSZ(64);
	FLEXSPI2_AHBRXBUF2CR0 = mask;
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
60001568:	bic.w	r3, r3, #63	; 0x3f
6000156c:	orr.w	r3, r3, #1
60001570:	str.w	r3, [r0, #184]	; 0xb8
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
60001574:	ldr.w	r3, [lr, #188]	; 0xbc
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
60001578:	ldr.w	lr, [pc, #388]	; 60001700 <configure_external_ram+0x280>
	FLEXSPI2_AHBRXBUF3CR0 = mask;

	// RX watermark = one 64 bit line
	FLEXSPI2_IPRXFCR = (FLEXSPI_IPRXFCR & 0xFFFFFFC0) | FLEXSPI_IPRXFCR_CLRIPRXF;
	// TX watermark = one 64 bit line
	FLEXSPI2_IPTXFCR = (FLEXSPI_IPTXFCR & 0xFFFFFFC0) | FLEXSPI_IPTXFCR_CLRIPTXF;
6000157c:	bic.w	r3, r3, #63	; 0x3f
60001580:	orr.w	r3, r3, #1
60001584:	str.w	r3, [r0, #188]	; 0xbc

	FLEXSPI2_INTEN = 0;
60001588:	str	r5, [r0, #16]
	FLEXSPI2_FLSHA1CR0 = 0x2000; // 8 MByte
6000158a:	str	r4, [r0, #96]	; 0x60
	FLEXSPI2_FLSHA1CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
6000158c:	str	r7, [r0, #112]	; 0x70
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA1CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
6000158e:	str.w	r2, [r0, #128]	; 0x80
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_FLSHA2CR0 = 0x2000; // 8 MByte
60001592:	str	r4, [r0, #100]	; 0x64
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
60001594:	str	r7, [r0, #116]	; 0x74
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
60001596:	str.w	r2, [r0, #132]	; 0x84
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
6000159a:	ldr	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
6000159c:	ldr	r3, [pc, #344]	; (600016f8 <configure_external_ram+0x278>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
6000159e:	bic.w	r4, r4, #2

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600015a2:	ldr	r2, [pc, #344]	; (600016fc <configure_external_ram+0x27c>)
	FLEXSPI2_FLSHA2CR1 = FLEXSPI_FLSHCR1_CSINTERVAL(2)
		| FLEXSPI_FLSHCR1_TCSH(3) | FLEXSPI_FLSHCR1_TCSS(3);
	FLEXSPI2_FLSHA2CR2 = FLEXSPI_FLSHCR2_AWRSEQID(6) | FLEXSPI_FLSHCR2_AWRSEQNUM(0)
		| FLEXSPI_FLSHCR2_ARDSEQID(5) | FLEXSPI_FLSHCR2_ARDSEQNUM(0);

	FLEXSPI2_MCR0 &= ~FLEXSPI_MCR0_MDIS;
600015a4:	str	r4, [r0, #0]

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600015a6:	str.w	lr, [r0, #24]
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600015aa:	str	r6, [r0, #28]
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
600015ac:	str.w	r1, [r3], #4
600015b0:	cmp	r3, r2
600015b2:	bne.n	600015ac <configure_external_ram+0x12c>
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600015b4:	ldr	r3, [pc, #292]	; (600016dc <configure_external_ram+0x25c>)
600015b6:	ldr	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600015b8:	mov	r1, r3

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
600015ba:	orr.w	r2, r2, #1
600015be:	str	r2, [r3, #0]
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait
600015c0:	ldr	r3, [r1, #0]
600015c2:	ldr	r2, [pc, #280]	; (600016dc <configure_external_ram+0x25c>)
600015c4:	ands.w	r3, r3, #1
600015c8:	bne.n	600015c0 <configure_external_ram+0x140>

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600015ca:	ldr	r6, [pc, #308]	; (60001700 <configure_external_ram+0x280>)
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600015cc:	movs	r5, #2

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
600015ce:	movw	r4, #1781	; 0x6f5
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
600015d2:	movw	r0, #1126	; 0x466
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
600015d6:	movw	r1, #1177	; 0x499
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
600015da:	ldr	r7, [pc, #296]	; (60001704 <configure_external_ram+0x284>)
	volatile uint32_t *luttable = &FLEXSPI2_LUT0;
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
600015dc:	str	r6, [r2, #24]
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
600015de:	movw	r6, #9217	; 0x2401
	for (int i=0; i < 64; i++) luttable[i] = 0;
	FLEXSPI2_MCR0 |= FLEXSPI_MCR0_SWRESET;
	while (FLEXSPI2_MCR0 & FLEXSPI_MCR0_SWRESET) ; // wait

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;
600015e2:	str	r5, [r2, #28]
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
600015e4:	movw	r5, #1077	; 0x435

	FLEXSPI2_LUTKEY = FLEXSPI_LUTKEY_VALUE;
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
600015e8:	str.w	r4, [r2, #512]	; 0x200
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
600015ec:	movw	r4, #8705	; 0x2201
	FLEXSPI2_LUTCR = FLEXSPI_LUTCR_UNLOCK;

	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
600015f0:	str.w	r0, [r2, #528]	; 0x210

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
600015f4:	movs	r0, #1
	// cmd index 0 = exit QPI mode
	FLEXSPI2_LUT0 = LUT0(CMD_SDR, PINS4, 0xF5);
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
600015f6:	str.w	r1, [r2, #544]	; 0x220
FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
600015fa:	mov	r1, r2
	// cmd index 1 = reset enable
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
600015fc:	str.w	r7, [r2, #560]	; 0x230
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001600:	add.w	r7, r7, #3657433088	; 0xda000000
	FLEXSPI2_LUT4 = LUT0(CMD_SDR, PINS1, 0x66);
	// cmd index 2 = reset
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
60001604:	str.w	r6, [r2, #564]	; 0x234
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001608:	add.w	r7, r7, #588	; 0x24c
	FLEXSPI2_LUT8 = LUT0(CMD_SDR, PINS1, 0x99);
	// cmd index 3 = read ID bytes
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
6000160c:	str.w	r5, [r2, #576]	; 0x240
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
60001610:	ldr	r6, [pc, #244]	; (60001708 <configure_external_ram+0x288>)
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
60001612:	ldr	r5, [pc, #248]	; (6000170c <configure_external_ram+0x28c>)
	FLEXSPI2_LUT12 = LUT0(CMD_SDR, PINS1, 0x9F) | LUT1(DUMMY_SDR, PINS1, 24);
	FLEXSPI2_LUT13 = LUT0(READ_SDR, PINS1, 1);
	// cmd index 4 = enter QPI mode
	FLEXSPI2_LUT16 = LUT0(CMD_SDR, PINS1, 0x35);
	// cmd index 5 = read QPI
	FLEXSPI2_LUT20 = LUT0(CMD_SDR, PINS4, 0xEB) | LUT1(ADDR_SDR, PINS4, 24);
60001614:	str.w	r7, [r2, #592]	; 0x250
	FLEXSPI2_LUT21 = LUT0(DUMMY_SDR, PINS4, 6) | LUT1(READ_SDR, PINS4, 1);
60001618:	str.w	r6, [r2, #596]	; 0x254
	// cmd index 6 = write QPI
	FLEXSPI2_LUT24 = LUT0(CMD_SDR, PINS4, 0x38) | LUT1(ADDR_SDR, PINS4, 24);
6000161c:	str.w	r5, [r2, #608]	; 0x260
	FLEXSPI2_LUT25 = LUT0(WRITE_SDR, PINS4, 1);
60001620:	str.w	r4, [r2, #612]	; 0x264
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001624:	str.w	r3, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001628:	str.w	r3, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
6000162c:	str.w	r0, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001630:	ldr	r3, [r1, #20]
60001632:	ldr	r2, [pc, #168]	; (600016dc <configure_external_ram+0x25c>)
60001634:	lsls	r5, r3, #31
60001636:	bpl.n	60001630 <configure_external_ram+0x1b0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001638:	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000163a:	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
6000163c:	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001640:	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001642:	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001644:	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001648:	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
6000164c:	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001650:	ldr	r3, [r1, #20]
60001652:	ldr	r2, [pc, #136]	; (600016dc <configure_external_ram+0x25c>)
60001654:	lsls	r4, r3, #31
60001656:	bpl.n	60001650 <configure_external_ram+0x1d0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001658:	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000165a:	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
6000165c:	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001660:	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001662:	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001664:	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001668:	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
6000166c:	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001670:	ldr	r3, [r1, #20]
60001672:	ldr	r2, [pc, #104]	; (600016dc <configure_external_ram+0x25c>)
60001674:	lsls	r0, r3, #31
60001676:	bpl.n	60001670 <configure_external_ram+0x1f0>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001678:	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000167a:	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
6000167c:	ldr	r0, [pc, #144]	; (60001710 <configure_external_ram+0x290>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000167e:	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001680:	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001682:	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
60001686:	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
6000168a:	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000168e:	ldr	r3, [r1, #20]
60001690:	ldr	r2, [pc, #72]	; (600016dc <configure_external_ram+0x25c>)
60001692:	lsls	r3, r3, #31
60001694:	bpl.n	6000168e <configure_external_ram+0x20e>
	uint32_t id = FLEXSPI2_RFDR0;
60001696:	ldr.w	r3, [r2, #256]	; 0x100

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
6000169a:	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
6000169e:	movs	r0, #33	; 0x21

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600016a0:	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600016a2:	str	r0, [r2, #20]

	// look for the first PSRAM chip
	flexspi2_command(0, 0); // exit quad mode
	flexspi2_command(1, 0); // reset enable
	flexspi2_command(2, 0); // reset (is this really necessary?)
	if (flexspi2_psram_id(0) == 0x5D0D) {
600016a4:	cmp	r3, r1
600016a6:	beq.n	6000171c <configure_external_ram+0x29c>
			external_psram_size * 0x100000 -
			((uint32_t)&_extram_end - (uint32_t)&_extram_start),
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
600016a8:	ldr	r3, [pc, #104]	; (60001714 <configure_external_ram+0x294>)
600016aa:	movs	r2, #0
600016ac:	str	r2, [r3, #0]
600016ae:	str	r2, [r3, #4]
600016b0:	str	r2, [r3, #8]
600016b2:	str	r2, [r3, #12]
	}
}
600016b4:	add	sp, #12
600016b6:	pop	{r4, r5, r6, r7, pc}
600016b8:	.word	0x401f8000
600016bc:	.word	0x000170f9
600016c0:	.word	0x0001b0f9
600016c4:	.word	0x000110f9
600016c8:	.word	0x000100f9
600016cc:	.word	0x401f8400
600016d0:	.word	0x400fc000
600016d4:	.word	0x1ffffcff
600016d8:	.word	0xa0000300
600016dc:	.word	0x402a4000
600016e0:	.word	0xffff0012
600016e4:	.word	0x00f737ff
600016e8:	.word	0x7cf0ff00
600016ec:	.word	0x80000040
600016f0:	.word	0x830f00ff
600016f4:	.word	0x00020063
600016f8:	.word	0x402a4200
600016fc:	.word	0x402a4300
60001700:	.word	0x5af05af0
60001704:	.word	0x3018049f
60001708:	.word	0x26013206
6000170c:	.word	0x0a180638
60001710:	.word	0x00030004
60001714:	.word	0x2000d400
60001718:	.word	0x402a8000
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000171c:	movs	r4, #0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
6000171e:	mov.w	r0, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001722:	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001724:	mov	r1, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001726:	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
6000172a:	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
6000172e:	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001732:	ldr	r3, [r1, #20]
60001734:	ldr	r2, [pc, #236]	; (60001824 <configure_external_ram+0x3a4>)
60001736:	lsls	r7, r3, #31
60001738:	bpl.n	60001732 <configure_external_ram+0x2b2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000173a:	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000173c:	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001740:	movs	r0, #0
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001742:	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001744:	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001746:	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
6000174a:	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
6000174e:	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001752:	ldr	r3, [r1, #20]
60001754:	ldr	r2, [pc, #204]	; (60001824 <configure_external_ram+0x3a4>)
60001756:	lsls	r6, r3, #31
60001758:	bpl.n	60001752 <configure_external_ram+0x2d2>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000175a:	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000175c:	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001760:	mov.w	r0, #65536	; 0x10000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001764:	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001766:	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
60001768:	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
6000176c:	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001770:	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001774:	ldr	r3, [r1, #20]
60001776:	ldr	r2, [pc, #172]	; (60001824 <configure_external_ram+0x3a4>)
60001778:	lsls	r5, r3, #31
6000177a:	bpl.n	60001774 <configure_external_ram+0x2f4>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000177c:	movs	r3, #1
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000177e:	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001782:	mov.w	r0, #131072	; 0x20000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001786:	mov	r1, r2
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001788:	str	r3, [r2, #20]
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
6000178a:	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
6000178e:	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001792:	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
60001796:	ldr	r3, [r1, #20]
60001798:	ldr	r2, [pc, #136]	; (60001824 <configure_external_ram+0x3a4>)
6000179a:	lsls	r4, r3, #31
6000179c:	bpl.n	60001796 <configure_external_ram+0x316>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000179e:	movs	r3, #1
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
600017a0:	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
600017a4:	ldr	r0, [pc, #128]	; (60001828 <configure_external_ram+0x3a8>)
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
600017a6:	mov	r1, r2
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
600017a8:	str	r3, [r2, #20]
}

FLASHMEM static uint32_t flexspi2_psram_id(uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
600017aa:	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
600017ae:	str.w	r0, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
600017b2:	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
600017b6:	ldr	r3, [r1, #20]
600017b8:	ldr	r2, [pc, #104]	; (60001824 <configure_external_ram+0x3a4>)
600017ba:	lsls	r0, r3, #31
600017bc:	bpl.n	600017b6 <configure_external_ram+0x336>
	uint32_t id = FLEXSPI2_RFDR0;
600017be:	ldr.w	r3, [r2, #256]	; 0x100
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
600017c2:	movw	r1, #23821	; 0x5d0d
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600017c6:	movs	r0, #33	; 0x21
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
600017c8:	uxth	r3, r3
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(3) | FLEXSPI_IPCR1_IDATSZ(4);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	uint32_t id = FLEXSPI2_RFDR0;
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE | FLEXSPI_INTR_IPRXWA;
600017ca:	str	r0, [r2, #20]
		// first PSRAM chip is present, look for a second PSRAM chip
		flexspi2_command(4, 0);
		flexspi2_command(0, 0x800000); // exit quad mode
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
600017cc:	cmp	r3, r1
600017ce:	beq.n	600017f2 <configure_external_ram+0x372>
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
		} else {
			// One PSRAM chip is present, 8 MByte
			external_psram_size = 8;
600017d0:	ldr	r3, [pc, #88]	; (6000182c <configure_external_ram+0x3ac>)
600017d2:	movs	r2, #8
600017d4:	mov.w	r4, #8388608	; 0x800000
600017d8:	strb	r2, [r3, #0]
		}
		// TODO: zero uninitialized EXTMEM variables
		// TODO: copy from flash to initialize EXTMEM variables
		sm_set_pool(&extmem_smalloc_pool, &_extram_end,
600017da:	ldr	r1, [pc, #84]	; (60001830 <configure_external_ram+0x3b0>)
600017dc:	movs	r0, #0
600017de:	ldr	r2, [pc, #84]	; (60001834 <configure_external_ram+0x3b4>)
600017e0:	movs	r3, #1
600017e2:	str	r0, [sp, #0]
600017e4:	subs	r2, r2, r1
600017e6:	ldr	r0, [pc, #80]	; (60001838 <configure_external_ram+0x3b8>)
600017e8:	add	r2, r4
600017ea:	bl	60001b78 <__sm_set_pool_veneer>
			1, NULL);
	} else {
		// No PSRAM
		memset(&extmem_smalloc_pool, 0, sizeof(extmem_smalloc_pool));
	}
}
600017ee:	add	sp, #12
600017f0:	pop	{r4, r5, r6, r7, pc}
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
600017f2:	mov.w	r4, #8388608	; 0x800000
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
600017f6:	mov.w	r1, #262144	; 0x40000
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
600017fa:	movs	r3, #1
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
600017fc:	mov	r0, r2
#define PINS1           FLEXSPI_LUT_NUM_PADS_1
#define PINS4           FLEXSPI_LUT_NUM_PADS_4

FLASHMEM static void flexspi2_command(uint32_t index, uint32_t addr)
{
	FLEXSPI2_IPCR0 = addr;
600017fe:	str.w	r4, [r2, #160]	; 0xa0
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
60001802:	str.w	r1, [r2, #164]	; 0xa4
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
60001806:	str.w	r3, [r2, #176]	; 0xb0
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
6000180a:	ldr	r3, [r0, #20]
6000180c:	ldr	r1, [pc, #20]	; (60001824 <configure_external_ram+0x3a4>)
6000180e:	lsls	r3, r3, #31
60001810:	bpl.n	6000180a <configure_external_ram+0x38a>
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
60001812:	movs	r0, #1
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
60001814:	ldr	r3, [pc, #20]	; (6000182c <configure_external_ram+0x3ac>)
60001816:	movs	r2, #16
60001818:	mov.w	r4, #16777216	; 0x1000000
{
	FLEXSPI2_IPCR0 = addr;
	FLEXSPI2_IPCR1 = FLEXSPI_IPCR1_ISEQID(index);
	FLEXSPI2_IPCMD = FLEXSPI_IPCMD_TRG;
	while (!(FLEXSPI2_INTR & FLEXSPI_INTR_IPCMDDONE)); // wait
	FLEXSPI2_INTR = FLEXSPI_INTR_IPCMDDONE;
6000181c:	str	r0, [r1, #20]
		flexspi2_command(1, 0x800000); // reset enable
		flexspi2_command(2, 0x800000); // reset (is this really necessary?)
		if (flexspi2_psram_id(0x800000) == 0x5D0D) {
			flexspi2_command(4, 0x800000);
			// Two PSRAM chips are present, 16 MByte
			external_psram_size = 16;
6000181e:	strb	r2, [r3, #0]
60001820:	b.n	600017da <configure_external_ram+0x35a>
60001822:	nop
60001824:	.word	0x402a4000
60001828:	.word	0x00030004
6000182c:	.word	0x2000b148
60001830:	.word	0x70000000
60001834:	.word	0x70000000
60001838:	.word	0x2000d400

6000183c <usb_pll_start>:

#endif // ARDUINO_TEENSY41


FLASHMEM void usb_pll_start()
{
6000183c:	push	{r4, r5, r6, r7}
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
6000183e:	ldr	r2, [pc, #92]	; (6000189c <usb_pll_start+0x60>)
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001840:	movs	r7, #64	; 0x40
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
60001842:	mov.w	r1, #65536	; 0x10000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
60001846:	mov.w	r6, #4096	; 0x1000
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
6000184a:	mov.w	r5, #8192	; 0x2000
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000184e:	mov.w	r4, #49152	; 0xc000
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001852:	movw	r0, #12354	; 0x3042


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001856:	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001858:	tst.w	r3, #2
6000185c:	beq.n	6000186c <usb_pll_start+0x30>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000185e:	str	r4, [r2, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001860:	str	r1, [r2, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
60001862:	str	r0, [r2, #24]


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001864:	ldr	r3, [r2, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001866:	tst.w	r3, #2
6000186a:	bne.n	6000185e <usb_pll_start+0x22>
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
6000186c:	tst.w	r3, #8192	; 0x2000
60001870:	bne.n	60001876 <usb_pll_start+0x3a>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
60001872:	str	r5, [r2, #20]
			continue;
60001874:	b.n	60001856 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001876:	tst.w	r3, #4096	; 0x1000
6000187a:	bne.n	60001880 <usb_pll_start+0x44>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
6000187c:	str	r6, [r2, #20]
			continue;
6000187e:	b.n	60001856 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
60001880:	cmp	r3, #0
60001882:	bge.n	60001856 <usb_pll_start+0x1a>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
60001884:	tst.w	r3, #65536	; 0x10000
60001888:	beq.n	6000188e <usb_pll_start+0x52>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
6000188a:	str	r1, [r2, #24]
			continue;
6000188c:	b.n	60001856 <usb_pll_start+0x1a>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
6000188e:	lsls	r3, r3, #25
60001890:	bmi.n	60001896 <usb_pll_start+0x5a>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
60001892:	str	r7, [r2, #20]
			continue;
60001894:	b.n	60001856 <usb_pll_start+0x1a>
		}
		return; // everything is as it should be  :-)
	}
}
60001896:	pop	{r4, r5, r6, r7}
60001898:	bx	lr
6000189a:	nop
6000189c:	.word	0x400d8000

600018a0 <tempmon_init>:
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600018a0:	ldr	r2, [pc, #236]	; (60001990 <tempmon_init+0xf0>)
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
600018a2:	vmov.f32	s13, #57	; 0x41c80000  25.0

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
600018a6:	ldr	r1, [pc, #236]	; (60001994 <tempmon_init+0xf4>)
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600018a8:	movs	r0, #0
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600018aa:	ldr	r3, [r2, #0]
  asm volatile ("dsb":::"memory");
  while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
600018ac:	push	{r4, r5, r6, r7, lr}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600018ae:	bic.w	r3, r3, #1

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600018b2:	movs	r4, #3
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600018b4:	ldr.w	lr, [pc, #256]	; 600019b8 <tempmon_init+0x118>
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600018b8:	str	r3, [r2, #0]

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600018ba:	str.w	r4, [r2, #144]	; 0x90
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
600018be:	ldr.w	r3, [r1, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
600018c2:	ldr	r7, [pc, #212]	; (60001998 <tempmon_init+0xf8>)
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600018c4:	uxtb	r5, r3
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
600018c6:	ubfx	r4, r3, #8, #12
600018ca:	ldr	r6, [pc, #208]	; (6000199c <tempmon_init+0xfc>)
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
600018cc:	rsb	r3, r4, r3, lsr #20
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
600018d0:	vmov	s15, r5
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600018d4:	sub.w	r1, r5, #85	; 0x55
  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600018d8:	str.w	r5, [lr]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
600018dc:	vcvt.f32.s32	s14, s15
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600018e0:	add.w	r5, r3, r3, lsl #2
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600018e4:	vmov	s15, r4
600018e8:	mul.w	r1, r3, r1
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;
600018ec:	str	r3, [r7, #0]
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
600018ee:	add.w	r3, r3, r3, lsl #6
    s_hot_ROOM = s_hotTemp - 25.0f;
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600018f2:	vcvt.f32.s32	s10, s15
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
600018f6:	vmov	s15, r1
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
600018fa:	subs	r1, r1, r5
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
600018fc:	vsub.f32	s13, s14, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001900:	vcvt.f32.u32	s14, s15
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
60001904:	ldr	r5, [pc, #152]	; (600019a0 <tempmon_init+0x100>)
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001906:	vmov	s15, r1
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000190a:	add	r3, r1
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
6000190c:	vstr	s13, [r5]
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001910:	vcvt.f32.u32	s15, s15
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
60001914:	str	r4, [r6, #0]
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001916:	vdiv.f32	s11, s14, s13
6000191a:	ldr	r6, [pc, #136]	; (600019a4 <tempmon_init+0x104>)
6000191c:	ldr	r5, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000191e:	ldr	r1, [pc, #136]	; (600019a8 <tempmon_init+0x108>)
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001920:	ldr	r4, [pc, #136]	; (600019ac <tempmon_init+0x10c>)
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001922:	vdiv.f32	s12, s15, s13
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001926:	vmov	s15, r3
6000192a:	ldr	r3, [pc, #132]	; (600019b0 <tempmon_init+0x110>)
6000192c:	str.w	r3, [r6, #320]	; 0x140
60001930:	vcvt.f32.u32	s15, s15
60001934:	vdiv.f32	s14, s15, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001938:	vadd.f32	s11, s11, s10
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000193c:	vadd.f32	s13, s12, s10
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001940:	vcvt.u32.f32	s11, s11
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001944:	vcvt.u32.f32	s13, s13
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001948:	vmov	r3, s11
6000194c:	orr.w	r3, r5, r3, lsl #20
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001950:	vmov	r5, s13
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001954:	vadd.f32	s15, s14, s10
    s_roomC_hotC = roomCount - s_hotCount;

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001958:	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000195a:	and.w	r1, r1, r5, lsl #16
6000195e:	ldr.w	r3, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001962:	vcvt.u32.f32	s15, s15
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
60001966:	orrs	r3, r1
60001968:	str.w	r3, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
6000196c:	vmov	r3, s15
60001970:	ldr.w	r1, [r2, #272]	; 0x110
60001974:	ubfx	r3, r3, #0, #12
60001978:	orrs	r3, r1
6000197a:	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
6000197e:	ldr	r3, [r2, #0]
60001980:	orr.w	r3, r3, #2
60001984:	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
60001986:	strb	r0, [r4, #0]
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
60001988:	ldr	r3, [pc, #40]	; (600019b4 <tempmon_init+0x114>)
6000198a:	movs	r2, #1
6000198c:	str	r2, [r3, #0]
6000198e:	pop	{r4, r5, r6, r7, pc}
60001990:	.word	0x400d8180
60001994:	.word	0x401f4400
60001998:	.word	0x2000b154
6000199c:	.word	0x2000b158
600019a0:	.word	0x2000b150
600019a4:	.word	0x2000d800
600019a8:	.word	0x0fff0000
600019ac:	.word	0xe000e440
600019b0:	.word	0x000097b1
600019b4:	.word	0xe000e108
600019b8:	.word	0x2000b14c

600019bc <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600019bc:	ldr	r3, [pc, #68]	; (60001a04 <analog_init+0x48>)
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
600019be:	ldr	r1, [pc, #72]	; (60001a08 <analog_init+0x4c>)
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600019c0:	ldr	r0, [r3, #108]	; 0x6c
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
600019c2:	mov	r2, r1
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600019c4:	orr.w	r0, r0, #196608	; 0x30000
}

#define MAX_ADC_CLOCK 20000000

FLASHMEM void analog_init(void)
{
600019c8:	push	{r4, r5}
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
600019ca:	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
600019cc:	movw	r5, #1591	; 0x637
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
600019d0:	ldr	r0, [r3, #108]	; 0x6c
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
600019d2:	movs	r4, #160	; 0xa0
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
600019d4:	orr.w	r0, r0, #768	; 0x300
600019d8:	str	r0, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
600019da:	str	r5, [r1, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
600019dc:	str	r4, [r1, #72]	; 0x48
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
600019de:	ldr	r3, [r2, #72]	; 0x48
600019e0:	lsls	r3, r3, #24
600019e2:	bmi.n	600019de <analog_init+0x22>
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
600019e4:	ldr	r3, [pc, #36]	; (60001a0c <analog_init+0x50>)
600019e6:	movw	r0, #1591	; 0x637
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
600019ea:	movs	r1, #160	; 0xa0
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) ;
600019ec:	mov	r2, r3
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
	calibrating = 1;
	while (ADC1_GC & ADC_GC_CAL) ;
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
600019ee:	str	r0, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
600019f0:	str	r1, [r3, #72]	; 0x48
	calibrating = 1;
	while (ADC2_GC & ADC_GC_CAL) ;
600019f2:	ldr	r3, [r2, #72]	; 0x48
600019f4:	ands.w	r3, r3, #128	; 0x80
600019f8:	bne.n	600019f2 <analog_init+0x36>
	calibrating = 0;
600019fa:	ldr	r2, [pc, #20]	; (60001a10 <analog_init+0x54>)
600019fc:	strb	r3, [r2, #0]
}
600019fe:	pop	{r4, r5}
60001a00:	bx	lr
60001a02:	nop
60001a04:	.word	0x400fc000
60001a08:	.word	0x400c4000
60001a0c:	.word	0x400c8000
60001a10:	.word	0x2000b2b9

60001a14 <usb_string_mtp>:
60001a14:	..M.T.P.

60001a1c <usb_string_product_name_default>:
60001a1c:	..T.e.e.n.s.y. .
60001a2c:	M.T.P. .D.i.s.k.
60001a3c:	/.S.e.r.i.a.l...

60001a4c <usb_string_manufacturer_name_default>:
60001a4c:	..T.e.e.n.s.y.d.
60001a5c:	u.i.n.o.

60001a64 <string0>:
60001a64:	....

60001a68 <usb_config_descriptor_12>:
60001a68:	..i.....2.......
60001a78:	...........$....
60001a88:	$....$...$......
60001a98:	................
60001aa8:	.@......@.......
60001ab8:	........@......@
60001ac8:	...... .....

60001ad4 <usb_config_descriptor_480>:
60001ad4:	..i.....2.......
60001ae4:	...........$....
60001af4:	$....$...$......
60001b04:	................
60001b14:	................
60001b24:	................
60001b34:	...... .....

60001b40 <qualifier_descriptor>:
60001b40:	.......@....

60001b4c <_init>:
60001b4c:	push	{r3, r4, r5, r6, r7, lr}
60001b4e:	nop
60001b50:	pop	{r3, r4, r5, r6, r7}
60001b52:	pop	{r3}
60001b54:	mov	lr, r3
60001b56:	bx	lr

60001b58 <__startup_early_hook_veneer>:
60001b58:	ldr.w	pc, [pc]	; 60001b5c <__startup_early_hook_veneer+0x4>
60001b5c:	.word	0x0000923d

60001b60 <__pwm_init_veneer>:
60001b60:	ldr.w	pc, [pc]	; 60001b64 <__pwm_init_veneer+0x4>
60001b64:	.word	0x000098ad

60001b68 <__startup_late_hook_veneer>:
60001b68:	ldr.w	pc, [pc]	; 60001b6c <__startup_late_hook_veneer+0x4>
60001b6c:	.word	0x00009241

60001b70 <__memset_veneer>:
60001b70:	ldr.w	pc, [pc]	; 60001b74 <__memset_veneer+0x4>
60001b74:	.word	0x0000b73d

60001b78 <__sm_set_pool_veneer>:
60001b78:	ldr.w	pc, [pc]	; 60001b7c <__sm_set_pool_veneer+0x4>
60001b7c:	.word	0x00009721

60001b80 <____libc_init_array_veneer>:
60001b80:	ldr.w	pc, [pc]	; 60001b84 <____libc_init_array_veneer+0x4>
60001b84:	.word	0x0000b089

60001b88 <__set_arm_clock_veneer>:
60001b88:	ldr.w	pc, [pc]	; 60001b8c <__set_arm_clock_veneer+0x4>
60001b8c:	.word	0x0000a1ad

60001b90 <__delay_veneer>:
60001b90:	ldr.w	pc, [pc]	; 60001b94 <__delay_veneer+0x4>
60001b94:	.word	0x000090f5

60001b98 <__main_veneer>:
60001b98:	ldr.w	pc, [pc]	; 60001b9c <__main_veneer+0x4>
60001b9c:	.word	0x0000a0e1

60001ba0 <__usb_init_serialnumber_veneer>:
60001ba0:	ldr.w	pc, [pc]	; 60001ba4 <__usb_init_serialnumber_veneer+0x4>
60001ba4:	.word	0x00009e4d

60001ba8 <__init_array_start>:
60001ba8:	.word	0x00000045
60001bac:	.word	0x00006551

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (float)((nmeas - s_hotCount) * s_hot_ROOM / s_roomC_hotC);

    return tmeas;
      20:	.word	0x4c05b510
      24:	ldrb	r3, [r4, #0]
    }

    /* ready to read temperature code value */
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (float)((nmeas - s_hotCount) * s_hot_ROOM / s_roomC_hotC);
      26:	cbnz	r3, 36 <__rtc_localtime+0x5>

    return tmeas;
      28:	ldr	r3, [pc, #16]	; (3c <__rtc_localtime+0xb>)
      2a:	cbz	r3, 32 <__rtc_localtime+0x1>
      2c:	ldr	r0, [pc, #16]	; (40 <__rtc_localtime+0xf>)
      2e:	nop.w
      32:	movs	r3, #1
      34:	strb	r3, [r4, #0]
      36:	pop	{r4, pc}
      38:	.word	0x20001570
      3c:	movs	r0, r0
      3e:	movs	r0, r0
}
      40:			; <UNDEFINED> instruction: 0xf4c40000

00000044 <frame_dummy>:
      44:	ldr	r3, [pc, #32]	; (68 <frame_dummy+0x24>)
      46:	push	{r4, lr}
      48:	cbz	r3, 52 <frame_dummy+0xe>
      4a:	ldr	r1, [pc, #32]	; (6c <frame_dummy+0x28>)
      4c:	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	nop.w
      52:	.short	0x4808
      54:	ldr	r3, [r0, #0]
      56:	.short	0xb903
      58:	pop	{r4, pc}
      5a:	.short	0x4b07
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      5c:	cmp	r3, #0
      5e:	.short	0xd0fb
      60:	ldmia.w	sp!, {r4, lr}
      64:	bx	r3
      66:	.short	0xbf00
      mode |= ADC_CFG_AVGS(2);
      mode1 |= ADC_CFG_AVGS(2);

    } else if (num >= 8) {
      mode |= ADC_CFG_AVGS(1);
      mode1 |= ADC_CFG_AVGS(1);
      68:	movs	r0, r0
    } else {
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
      6a:	.short	0x0000
  ADC2_CFG = mode1;
  
  if(num >= 4){
      6c:	asrs	r4, r6, #21
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
  ADC2_CFG = mode1;
      6e:	.short	0x2000
    } else {
      mode |= 0;
      mode1 |= 0;
    }

  ADC1_CFG = mode;
      70:			; <UNDEFINED> instruction: 0xf4c40000
  ADC2_CFG = mode1;
  
  if(num >= 4){
      74:	.word	0x20001570
      ADC1_GC |= ADC_GC_AVGE;// turns on averaging
      ADC2_GC |= ADC_GC_AVGE;// turns on averaging
  }
}
      78:	movs	r0, r0
	...

0000007c <MTPD::write(char const*, int) [clone .part.8]>:
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
      7c:	.word	0xe92d6843
    int fetch_packet(uint8_t *data_buffer)
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
      80:	blx	lr
      82:	mov	r6, r1
      84:	.word	0xb92b4690
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
      88:	ldr.w	sl, [pc, #112]	; fc <MTPD::write(char const*, int) [clone .part.8]+0x80>
      8c:	add.w	r2, r0, #544	; 0x220
      90:	.word	0x2000f8ca
        write_length_ += len;
      94:	add	r3, r8
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
      96:	cmp.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
      9a:	.short	0x6043
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
      9c:	ble.n	f6 <MTPD::write(char const*, int) [clone .part.8]+0x7a>
      9e:	.short	0xf500
      a0:	ldr	r4, [r0, #24]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
      a2:	.short	0xf500
      a4:	strb	r0, [r1, #28]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
      a6:	.short	0x2500
      a8:	ldr.w	sl, [pc, #80]	; fc <MTPD::write(char const*, int) [clone .part.8]+0x80>
      ac:	.word	0x45a8e001
      b0:	ble.n	f6 <MTPD::write(char const*, int) [clone .part.8]+0x7a>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
      b2:	.short	0xf8da
      b4:	movs	r0, r0
          int to_copy = min(len - pos, avail);
      b6:	.short	0xebc5
      b8:	lsls	r0, r1, #12
          memcpy(dst,src,to_copy);
      ba:	.short	0x4631
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
      bc:	rsb	r4, r0, r9
      c0:	cmp	r4, r3
      c2:	it	ge
      c4:	movge	r4, r3
          memcpy(dst,src,to_copy);
      c6:	mov	r2, r4
          pos += to_copy;
      c8:	add	r5, r4
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
      ca:	.short	0xf007
      cc:	vceq.i8	<illegal reg q15.5>, <illegal reg q10.5>, q5
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
      d0:	.word	0x44263000
      d4:	add	r4, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
      d6:	cmp	r4, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
      d8:	.word	0x4000f8ca
          if(dst == tx_data_buffer+MTP_TX_SIZE)
      dc:	bne.n	ae <MTPD::write(char const*, int) [clone .part.8]+0x32>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
      de:	movs	r2, #60	; 0x3c
      e0:	mov.w	r1, #512	; 0x200
      e4:	mov	r0, r7
      e6:	bl	9d50 <usb_mtp_send>
      ea:	cmp	r0, #0
      ec:	.word	0x45a8ddf7
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
      f0:	str.w	r7, [sl]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
      f4:	.word	0xe8bddcdd
      f8:	strh	r0, [r6, #62]	; 0x3e
      fa:	.short	0xbf00
      fc:	asrs	r4, r1, #22
      fe:	.short	0x2000

00000100 <setup>:

	// Maybe different pin configs if half duplex
	half_duplex_mode_ = (format & SERIAL_HALF_DUPLEX) != 0;
	if (!half_duplex_mode_)  {
		*(portControlRegister(hardware->rx_pins[rx_pin_index_].pin)) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		*(portConfigRegister(hardware->rx_pins[rx_pin_index_].pin)) = hardware->rx_pins[rx_pin_index_].mux_val;
     100:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     104:	ldr	r0, [pc, #748]	; (3f4 <setup+0x2f4>)
     106:	sub	sp, #100	; 0x64
     108:	ldr	r4, [pc, #748]	; (3f8 <setup+0x2f8>)
     10a:	ldr	r1, [pc, #752]	; (3fc <setup+0x2fc>)
     10c:	ldr	r2, [pc, #752]	; (400 <setup+0x300>)
     10e:	ldrb	r3, [r4, #0]
     110:	cmp	r3, #0
		if (hardware->rx_pins[rx_pin_index_].select_input_register) {
     112:	beq.n	10e <setup+0xe>
     114:	.word	0x07db7803
		 	*(hardware->rx_pins[rx_pin_index_].select_input_register) =  hardware->rx_pins[rx_pin_index_].select_val;		
     118:	bpl.n	10e <setup+0xe>
		}	

		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
     11a:	ldr	r3, [r1, #0]
     11c:	ldr	r5, [r2, #0]
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
	} else {
		// Half duplex maybe different pin pad config like PU...		
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
     11e:	subs	r3, r3, r5
     120:	.word	0xd9f42b0e
     124:	bl	85fc <usb_serial_available>
     128:	cmp	r0, #0
     12a:	beq.n	124 <setup+0x24>
				| IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3);
     12c:	ldr	r0, [pc, #724]	; (404 <setup+0x304>)
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
     12e:	bl	a1a4 <Stream::parseInt()>
     132:	movs	r1, #11
     134:	.word	0xf00848b4
     138:			; <UNDEFINED> instruction: 0xfac748b2
     13c:	bl	9ff8 <Print::println()>
     140:	movs	r1, #74	; 0x4a
     142:	ldr	r0, [pc, #712]	; (40c <setup+0x30c>)
     144:	bl	86c8 <usb_serial_write>
	}
	if (hardware->tx_pins[tx_pin_index_].select_input_register) {
     148:	ldr	r0, [pc, #696]	; (404 <setup+0x304>)
     14a:	bl	9ff8 <Print::println()>
	 	*(hardware->tx_pins[tx_pin_index_].select_input_register) =  hardware->tx_pins[tx_pin_index_].select_val;		
     14e:	bl	85fc <usb_serial_available>
#define DMA_NUM_CHANNELS        32

#ifdef __cplusplus
extern "C" void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
     152:	cmp	r0, #0
	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
	port->PINCFG = 0;

	// Enable the transmitter, receiver and enable receiver interrupt
	attachInterruptVector(hardware->irq, hardware->irq_handler);
     154:	.word	0x48abd0fb
	 	*(hardware->tx_pins[tx_pin_index_].select_input_register) =  hardware->tx_pins[tx_pin_index_].select_val;		
	}	
	//hardware->rx_mux_register = hardware->rx_mux_val;
	//hardware->tx_mux_register = hardware->tx_mux_val;

	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
     158:	movs	r7, #0
     15a:	bl	a1a4 <Stream::parseInt()>
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
	port->PINCFG = 0;
     15e:	.short	0x4605
	}	
	//hardware->rx_mux_register = hardware->rx_mux_val;
	//hardware->tx_mux_register = hardware->tx_mux_val;

	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
     160:	bl	872c <usb_serial_flush_output>
     164:	.word	0x220a4baa
     168:	movs	r1, #1
	 	*(hardware->tx_pins[tx_pin_index_].select_input_register) =  hardware->tx_pins[tx_pin_index_].select_val;		
	}	
	//hardware->rx_mux_register = hardware->rx_mux_val;
	//hardware->tx_mux_register = hardware->tx_mux_val;

	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
     16a:	.short	0x48aa
     16c:	mov	r4, r7
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
     16e:	.short	0xf006
     170:	ldc2l	1, cr2, [r1, #-44]	; 0xffffffd4
	 	*(hardware->tx_pins[tx_pin_index_].select_input_register) =  hardware->tx_pins[tx_pin_index_].select_val;		
	}	
	//hardware->rx_mux_register = hardware->rx_mux_val;
	//hardware->tx_mux_register = hardware->tx_mux_val;

	port->BAUD = LPUART_BAUD_OSR(bestosr - 1) | LPUART_BAUD_SBR(bestdiv)
     174:	.word	0xf00848a8
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
     178:			; <UNDEFINED> instruction: 0xfaa7f8df
     17c:	.word	0x48a182f0
     180:	bl	9ff8 <Print::println()>
	port->PINCFG = 0;

	// Enable the transmitter, receiver and enable receiver interrupt
	attachInterruptVector(hardware->irq, hardware->irq_handler);
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
     184:	.word	0x4639462a
     188:	ldr	r0, [pc, #648]	; (414 <setup+0x314>)
     18a:	.short	0xf006
     18c:			; <UNDEFINED> instruction: 0xfab14ba3
	NVIC_ENABLE_IRQ(hardware->irq);
     190:	.word	0xfba322b4
     194:	asrs	r7, r0, #12
	uint16_t tx_fifo_size = (((port->FIFO >> 4) & 0x7) << 2);
     196:	.short	0x091b
	port->PINCFG = 0;

	// Enable the transmitter, receiver and enable receiver interrupt
	attachInterruptVector(hardware->irq, hardware->irq_handler);
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
	NVIC_ENABLE_IRQ(hardware->irq);
     198:	add.w	r3, r3, r3, lsl #1
     19c:	.word	0x03c3eba7
     1a0:	mul.w	r3, r2, r3
     1a4:	cmp	r3, #0
	uint16_t tx_fifo_size = (((port->FIFO >> 4) & 0x7) << 2);
     1a6:	.short	0xf000
     1a8:	strh	r3, [r4, #10]
     1aa:	.short	0xfba8
     1ac:	adds	r2, #4
	uint8_t tx_water = (tx_fifo_size < 16) ? tx_fifo_size >> 1 : 7;
     1ae:	.short	0x23b4
     1b0:	lsrs	r2, r2, #2
     1b2:	.short	0xfb03
     1b4:	addw	r2, r2, #1175	; 0x497
     1b8:	.word	0x8107f000
	uint16_t rx_fifo_size = (((port->FIFO >> 0) & 0x7) << 2);
     1bc:	mov	r2, r7
     1be:	ldr	r1, [pc, #608]	; (420 <setup+0x320>)
     1c0:	.word	0x2400a804
	uint8_t rx_water = (rx_fifo_size < 16) ? rx_fifo_size >> 1 : 7;
     1c4:	bl	bbe4 <sprintf>
     1c8:	.word	0xf00ba804
	/*
	Serial.printf("SerialX::begin stat:%x ctrl:%x fifo:%x water:%x\n", port->STAT, port->CTRL, port->FIFO, port->WATER );
	Serial.printf("  FIFO sizes: tx:%d rx:%d\n",tx_fifo_size, rx_fifo_size);	
	Serial.printf("  Watermark tx:%d, rx: %d\n", tx_water, rx_water);
	*/
	port->WATER = LPUART_WATER_RXWATER(rx_water) | LPUART_WATER_TXWATER(tx_water);
     1cc:	vmax.u16	d20, d9, d1
	// lets configure up our CTRL register value
	uint32_t ctrl = CTRL_TX_INACTIVE;

	// Now process the bits in the Format value passed in
	// Bits 0-2 - Parity plus 9  bit. 
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
     1d0:	.word	0x4626a804
	Serial.printf("SerialX::begin stat:%x ctrl:%x fifo:%x water:%x\n", port->STAT, port->CTRL, port->FIFO, port->WATER );
	Serial.printf("  FIFO sizes: tx:%d rx:%d\n",tx_fifo_size, rx_fifo_size);	
	Serial.printf("  Watermark tx:%d, rx: %d\n", tx_water, rx_water);
	*/
	port->WATER = LPUART_WATER_RXWATER(rx_water) | LPUART_WATER_TXWATER(tx_water);
	port->FIFO |= LPUART_FIFO_TXFE | LPUART_FIFO_RXFE;
     1d4:	bl	86c8 <usb_serial_write>
     1d8:	mov.w	r5, #4294967295
	uint32_t ctrl = CTRL_TX_INACTIVE;

	// Now process the bits in the Format value passed in
	// Bits 0-2 - Parity plus 9  bit. 
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
     1dc:	bl	91c0 <micros>
	// lets configure up our CTRL register value
	uint32_t ctrl = CTRL_TX_INACTIVE;

	// Now process the bits in the Format value passed in
	// Bits 0-2 - Parity plus 9  bit. 
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
     1e0:	add	r2, sp, #16
     1e2:	.short	0x2103
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
	if ((format & 0x0F) == 0x04) ctrl |=  LPUART_CTRL_R9T8; // 8N2 is 9 bit with 9th bit always 1
     1e4:	mov	r9, r0
     1e6:	.short	0x488b
     1e8:	bl	6600 <zeroFS_class::Create(HDR_TYPE, char const*)>
     1ec:	.word	0xffe8f008
     1f0:	mov	fp, r0

	// Bit 5 TXINVERT
	if (format & 0x20) ctrl |= LPUART_CTRL_TXINV;		// tx invert
     1f2:	.short	0x4b8c
     1f4:	uxtb	r2, r4
     1f6:	.short	0xf503
     1f8:	str	r0, [r0, r0]

	// Now see if the user asked for Half duplex:
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);
     1fa:	strb.w	r2, [r3, #1]!
     1fe:	.short	0x1c51
	// write out computed CTRL
	port->CTRL = ctrl;

	// Bit 3 10 bit - Will assume that begin already cleared it.
	// process some other bits which change other registers.
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
     200:	cmp	r3, r0

	// Now see if the user asked for Half duplex:
	if (half_duplex_mode_) ctrl |= (LPUART_CTRL_LOOPS | LPUART_CTRL_RSRC);

	// write out computed CTRL
	port->CTRL = ctrl;
     202:	.short	0xb2ca

	// Bit 3 10 bit - Will assume that begin already cleared it.
	// process some other bits which change other registers.
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;
     204:	bne.n	1fa <setup+0xfa>
     206:	.short	0xf008
     208:	vrsubhn.i32	d20, <illegal reg q13.5>, q1
     20c:	.word	0x5200f44f

	// Bit 4 RXINVERT 
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
     210:	ldr	r1, [pc, #532]	; (428 <setup+0x328>)
	// Bit 3 10 bit - Will assume that begin already cleared it.
	// process some other bits which change other registers.
	if (format & 0x08) 	port->BAUD |= LPUART_BAUD_M10;

	// Bit 4 RXINVERT 
	uint32_t c = port->STAT & ~LPUART_STAT_RXINV;
     212:	.short	0x4880
     214:	adds	r4, #1
	if (format & 0x10) c |= LPUART_STAT_RXINV;		// rx invert
     216:	.short	0xf006
     218:	smusd	r0, r7, r8
	port->STAT = c;
     21c:			; <UNDEFINED> instruction: 0xffd1ebca

	// bit 8 can turn on 2 stop bit mote
	if ( format & 0x100) port->BAUD |= LPUART_BAUD_SBNS;	
     220:	.word	0x42860000
     224:	it	cc
     226:	.short	0x4606
     228:	cmp	r5, r0

	//Serial.printf("    stat:%x ctrl:%x fifo:%x water:%x\n", port->STAT, port->CTRL, port->FIFO, port->WATER );
	// Only if the user implemented their own...
	if (!(*hardware->serial_event_handler_default)) addToSerialEventsList(); 		// Enable the processing of serialEvent for this object
     22a:	.short	0xbf28
     22c:	movcs	r5, r0
     22e:	.short	0xf5b4
	//digitalWrite(4, LOW);
}


void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
     230:	ldrb	r2, [r7, #29]
     232:	.short	0xd1de
     234:	bl	91c0 <micros>
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
     238:	mov	sl, r0
     23a:	.short	0x2103
     23c:	ldr	r0, [pc, #468]	; (414 <setup+0x314>)
     23e:	.short	0x3701
     240:	bl	6850 <zeroFS_class::Close(HDR_TYPE)>
     244:	.word	0xffbcf008
     248:	rsb	r1, sl, r0
     24c:	.word	0x0000ebc9
     250:	lsrs	r4, r7, #2
	//digitalWrite(4, LOW);
}


void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
     252:	.short	0xebc9
     254:	lsls	r3, r1, #8
     256:	mov	r3, r5
     258:	.word	0x90029101
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
	}
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
     25c:	str	r6, [sp, #0]
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
     25e:	.short	0x4973

void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
		if (s_serials_with_serial_events[i] == this) return; // already in the list.
	}
	s_serials_with_serial_events[s_count_serials_with_serial_events++] = this;
     260:	ldr	r0, [pc, #416]	; (404 <setup+0x304>)
     262:	.short	0xf009
	yield_active_check_flags |= YIELD_CHECK_HARDWARE_SERIAL;
     264:	cdp2	11, 14, cr15, cr1, cr8, {5}
     268:	.word	0x22b42304
     26c:	lsrs	r3, r3, #2
     26e:	mls	r3, r2, r3, r7
     272:	cmp	r3, #0
     274:	.word	0x811df000
	uint32_t ctrl = CTRL_TX_INACTIVE;

	// Now process the bits in the Format value passed in
	// Bits 0-2 - Parity plus 9  bit. 
	ctrl |= (format & (LPUART_CTRL_PT | LPUART_CTRL_PE) );	// configure parity - turn off PT, PE, M and configure PT, PE
	if (format & 0x04) ctrl |= LPUART_CTRL_M;		// 9 bits (might include parity)
     278:	ldr	r3, [pc, #416]	; (41c <setup+0x31c>)
     27a:	.short	0x22b4
     27c:	umull	r1, r3, r3, r7
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
	} else {
		// Half duplex maybe different pin pad config like PU...		
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
				| IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3);
     280:	.word	0xeb03091b

		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3);
		*(portConfigRegister(hardware->tx_pins[tx_pin_index_].pin)) = hardware->tx_pins[tx_pin_index_].mux_val;
	} else {
		// Half duplex maybe different pin pad config like PU...		
		*(portControlRegister(hardware->tx_pins[tx_pin_index_].pin)) =  IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3) 
     284:	lsls	r3, r0, #13
     286:	.short	0xeba7
     288:	lsls	r3, r0, #15
     28a:	.short	0xfb02
     28c:	ssat	fp, #1, r3, lsl #8
	//digitalWrite(4, LOW);
}


void HardwareSerial::addToSerialEventsList() {
	for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
     290:	beq.w	4a8 <setup+0x3a8>
     294:	.word	0x429f4b66
     298:	bne.w	18e <setup+0x8e>
     29c:	.word	0x485d2100
     2a0:	bl	6850 <zeroFS_class::Close(HDR_TYPE)>
     2a4:	.word	0xf006485b
     2a8:	umlal	r2, r1, r5, r8
     2ac:	.word	0xf0084861
     2b0:			; <UNDEFINED> instruction: 0xfa0b4854
     2b4:	bl	9ff8 <Print::println()>
     2b8:	.word	0xf0064856
     2bc:	smlabb	r1, sp, fp, r2
     2c0:	.word	0xf008485d
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
     2c4:			; <UNDEFINED> instruction: 0xfa01484f
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     2c8:	.word	0xfe96f009

    Serial.println("List All");
    zFS.ListAll();

    Serial.println("List T_ROOT");
    zFS.Open(T_ROOT);
     2cc:	movs	r1, #0
     2ce:	.short	0x4851
     2d0:	bl	67b4 <zeroFS_class::Open(HDR_TYPE)>
    zFS.List();
     2d4:	.word	0xf006484f
     2d8:	usada8	r1, r7, sl, r2
     2dc:	.word	0xf0084857
     2e0:	ldr??.w	r4, [r3, #2120]	; 0x848
     2e4:	.word	0xfe88f009

    Serial.println("List T_DAY");
    zFS.Open(T_DAY);
     2e8:	movs	r1, #1
     2ea:	ldr	r0, [pc, #296]	; (414 <setup+0x314>)
     2ec:	.word	0xfa62f006
    zFS.List();
     2f0:	ldr	r0, [pc, #288]	; (414 <setup+0x314>)
     2f2:	bl	69c8 <zeroFS_class::List()>
     2f6:	.short	0x210b
     2f8:	ldr	r0, [pc, #324]	; (440 <setup+0x340>)
     2fa:	bl	86c8 <usb_serial_write>
     2fe:	.short	0x4841
     300:	bl	9ff8 <Print::println()>

    Serial.println("List T_HOUR");
    zFS.Open(T_HOUR);
     304:	.word	0x48432102
     308:	bl	67b4 <zeroFS_class::Open(HDR_TYPE)>
    zFS.List();
     30c:	.word	0xf0064841
     310:	smmlar	r1, fp, lr, r2
     314:	.word	0xf008484b
     318:	ldr??.w	r4, [r7, #2106]	; 0x83a
     31c:	.word	0xfe6cf009

    Serial.println("List T_HOUR; Day_01, Hour_0101");
    zFS.Open(T_ROOT);
     320:	movs	r1, #0
     322:	.short	0x483c
     324:	bl	67b4 <zeroFS_class::Open(HDR_TYPE)>
    zFS.Open(T_DAY,"Day_01");
     328:	.word	0x21014a47
     32c:	ldr	r0, [pc, #228]	; (414 <setup+0x314>)
     32e:	bl	67c0 <zeroFS_class::Open(HDR_TYPE, char const*)>
    zFS.Open(T_HOUR,"Hour_0101");
     332:	ldr	r2, [pc, #280]	; (44c <setup+0x34c>)
     334:	movs	r1, #2
     336:	ldr	r0, [pc, #220]	; (414 <setup+0x314>)
     338:	bl	67c0 <zeroFS_class::Open(HDR_TYPE, char const*)>
    zFS.List();
     33c:	ldr	r0, [pc, #212]	; (414 <setup+0x314>)
     33e:	.short	0xf006
     340:	smlsdx	r1, r3, lr, r2
     344:	.word	0xf0084842
     348:	ldrsh.w	r4, [pc, #2094]	; b7a <MTPD::WriteDescriptor()+0x45e>
     34c:	.word	0xfe54f009

    Serial.println("List T_HOUR; Day_03, Hour_0302");
    zFS.Open(T_ROOT);
     350:	movs	r1, #0
     352:	.short	0x4830
     354:	bl	67b4 <zeroFS_class::Open(HDR_TYPE)>
    zFS.Open(T_DAY,"Day_03");
     358:	.word	0x21014a3e
     35c:	ldr	r0, [pc, #180]	; (414 <setup+0x314>)
     35e:	.short	0xf006
     360:			; <UNDEFINED> instruction: 0xfa2f4a3d
    zFS.Open(T_HOUR,"Hour_0302");
     364:	.word	0x482b2102
     368:	bl	67c0 <zeroFS_class::Open(HDR_TYPE, char const*)>
    zFS.List();
     36c:	.word	0xf0064829
     370:			; <UNDEFINED> instruction: 0xfb2b212f
     374:	.word	0xf0084839
     378:	vld1.32			; <UNDEFINED> instruction: 0xf9a74822
     37c:	.word	0xfe3cf009

    Serial.println("Read T_FILE; Day_03, Hour_0302, File_030204.dat");
    zFS.Open(T_ROOT);
     380:	movs	r1, #0
     382:	.short	0x4824
     384:	bl	67b4 <zeroFS_class::Open(HDR_TYPE)>
    zFS.Open(T_DAY,"Day_03");
     388:	.word	0x21014a32
     38c:	ldr	r0, [pc, #132]	; (414 <setup+0x314>)
     38e:	.short	0xf006
     390:			; <UNDEFINED> instruction: 0xfa174a31
    zFS.Open(T_HOUR,"Hour_0302");
     394:	.word	0x481f2102
     398:	bl	67c0 <zeroFS_class::Open(HDR_TYPE, char const*)>
    zFS.Open(T_FILE,"File_030204.dat");
     39c:	ldr	r2, [pc, #192]	; (460 <setup+0x360>)
     39e:	.short	0x2103
     3a0:	ldr	r0, [pc, #112]	; (414 <setup+0x314>)
     3a2:	.short	0xf006
     3a4:			; <UNDEFINED> instruction: 0xfa0df44f
    zFS.Read((void *)buff,NBUF);
     3a8:	.word	0x491f5200
     3ac:	ldr	r0, [pc, #100]	; (414 <setup+0x314>)
     3ae:	.short	0xf006
     3b0:			; <UNDEFINED> instruction: 0xfa8f481d
    printSector(buff);
     3b4:	bl	65a4 <printSector(char*)>
    Serial.println();
     3b8:	.word	0xf0094812
     3bc:	cdp2	8, 1, cr4, cr13, cr9, {1}
    printSector(buff+512);
     3c0:	.word	0xf8f0f006
}
     3c4:	add	sp, #100	; 0x64
     3c6:	.short	0xe8bd
     3c8:	ldrh	r0, [r6, #62]	; 0x3e
        zFS.Create(T_DAY, dayName);
      }
      if(!(count % 180))
      { // new hour
        char hourName[80];
        sprintf(hourName,"Hour_%010ld",(count/180)*180);
     3ca:	.short	0x4927
     3cc:	add	r0, sp, #16
     3ce:	.short	0xf00b
     3d0:	stc2	8, cr10, [r9], {4}
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     3d4:	.word	0xfe54f00b
     3d8:	mov	r1, r0
     3da:	.short	0xa804
     3dc:	bl	86c8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     3e0:	.word	0xf0094808
     3e4:	vseleq.f32	s20, s18, s8
        Serial.println(hourName);
        zFS.Create(T_HOUR,hourName);
     3e8:	.word	0x480a2102
     3ec:	bl	6600 <zeroFS_class::Create(HDR_TYPE, char const*)>
     3f0:	.word	0xbf00e6e4
     3f4:	add	sp, #416	; 0x1a0
     3f6:	.short	0x2000
     3f8:	cbz	r0, 40a <setup+0x30a>
     3fa:	.short	0x2000
     3fc:	cbz	r4, 410 <setup+0x310>
     3fe:	.short	0x2000
     400:	cbz	r0, 444 <setup+0x344>
     402:	.short	0x2000
     404:	lsrs	r4, r5, #14
     406:	.short	0x2000
     408:	movs	r0, r5
     40a:	.short	0x2000
     40c:	movs	r4, r6
     40e:	.short	0x2000
     410:	lsls	r0, r0, #2
     412:	.short	0x2000
     414:	strh	r0, [r4, #36]	; 0x24
     416:	.short	0x2000
     418:	lsls	r0, r1, #2
     41a:	.short	0x2000
     41c:	add	r2, sp, #684	; 0x2ac
     41e:	.short	0xaaaa
     420:	lsls	r4, r5, #2
     422:	.short	0x2000
     424:	eors	r3, r2
     426:	.short	0x2000
     428:	eors	r4, r2
     42a:	.short	0x2000
     42c:	lsls	r4, r7, #2
     42e:	.short	0x2000
     430:	str	r7, [sp, #512]	; 0x200
     432:	.short	0x0006
     434:	lsls	r4, r2, #3
     436:	.short	0x2000
     438:	lsls	r0, r4, #3
     43a:	.short	0x2000
     43c:	lsls	r4, r5, #3
     43e:	.short	0x2000
     440:	lsls	r0, r7, #3
     442:	.short	0x2000
     444:	lsls	r4, r0, #4
     446:	.short	0x2000
     448:	.word	0x20000124
     44c:	.word	0x2000012c
     450:	.word	0x20000138
     454:	.word	0x20000158
     458:	.word	0x20000160
     45c:	.word	0x2000016c
     460:	.word	0x2000018c
     464:	.word	0x20004254
     468:	.word	0x200000a0
     46c:	.word	0x16c16c17
    uint32_t count=0;
    while(count < 24*180*100)
    { if(!(count % 24*180))
      { // new day
        char dayName[80];
        sprintf(dayName,"Day_%010ld",(count/(24*180))*24*180);
     470:	ldr	r3, [pc, #72]	; (4bc <setup+0x3bc>)
     472:	add	r0, sp, #16
     474:	ldr	r1, [pc, #72]	; (4c0 <setup+0x3c0>)
     476:	umull	r2, r3, r3, r7
     47a:	mov.w	r2, #4320	; 0x10e0
     47e:	lsrs	r3, r3, #12
     480:	mul.w	r2, r2, r3
     484:	bl	bbe4 <sprintf>
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     488:	add	r0, sp, #16
     48a:	bl	c080 <strlen>
     48e:	mov	r1, r0
     490:	add	r0, sp, #16
     492:	bl	86c8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     496:	ldr	r0, [pc, #44]	; (4c4 <setup+0x3c4>)
     498:	bl	9ff8 <Print::println()>
        Serial.println(dayName);
        zFS.Create(T_DAY, dayName);
     49c:	add	r2, sp, #16
     49e:	movs	r1, #1
     4a0:	ldr	r0, [pc, #36]	; (4c8 <setup+0x3c8>)
     4a2:	bl	6600 <zeroFS_class::Create(HDR_TYPE, char const*)>
     4a6:	b.n	1aa <setup+0xaa>
        Serial.printf(" %7d %7d %7d %7d %7d\n",(t1-t0),tmn,tmx,(t3-t2),(t3-t0));

        count++;
      }
      if(!(count % 180)) zFS.Close(T_HOUR);
      if(!(count % 24*180)) zFS.Close(T_DAY);
     4a8:	movs	r1, #1
     4aa:	ldr	r0, [pc, #28]	; (4c8 <setup+0x3c8>)
     4ac:	bl	6850 <zeroFS_class::Close(HDR_TYPE)>
     4b0:	b.n	294 <setup+0x194>
        uint32_t t3 = micros();
        Serial.printf(" %7d %7d %7d %7d %7d\n",(t1-t0),tmn,tmx,(t3-t2),(t3-t0));

        count++;
      }
      if(!(count % 180)) zFS.Close(T_HOUR);
     4b2:	movs	r1, #2
     4b4:	ldr	r0, [pc, #16]	; (4c8 <setup+0x3c8>)
     4b6:	bl	6850 <zeroFS_class::Close(HDR_TYPE)>
     4ba:	b.n	278 <setup+0x178>
     4bc:	.word	0xf2b9d649
     4c0:	.word	0x20000094
     4c4:	.word	0x20000bac
     4c8:	.word	0x200084a0

000004cc <MTPD::writestring(char const*)>:
  void write64(uint64_t x) { write((char*)&x, sizeof(x)); }

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
     4cc:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if (*str) 
     4d0:	ldrb	r3, [r1, #0]
  void write64(uint64_t x) { write((char*)&x, sizeof(x)); }

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
     4d2:	sub	sp, #12
     4d4:	mov	r9, r0
    if (*str) 
     4d6:	cmp	r3, #0
     4d8:	beq.n	5a2 <MTPD::writestring(char const*)+0xd6>
    { write8(strlen(str) + 1);
     4da:	mov	r0, r1
     4dc:	mov	sl, r1
     4de:	bl	c080 <strlen>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     4e2:	ldrb.w	r1, [r9]
     4e6:	adds	r0, #1
      {
        write_length_ += len;
     4e8:	ldr.w	r3, [r9, #4]
     4ec:	strb.w	r0, [sp, #2]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     4f0:	cmp	r1, #0
     4f2:	beq.w	620 <MTPD::writestring(char const*)+0x154>
      {
        write_length_ += len;
     4f6:	adds	r3, #1
     4f8:	str.w	r3, [r9, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     4fc:	ldrb.w	r2, [sl]
     500:	cmp	r2, #0
     502:	beq.n	596 <MTPD::writestring(char const*)+0xca>
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     504:	add.w	r8, r9, #544	; 0x220
     508:	b.n	518 <MTPD::writestring(char const*)+0x4c>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     50a:	adds	r3, #2
     50c:	str.w	r3, [r9, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     510:	ldrb.w	r2, [sl, #1]!
     514:	cmp	r2, #0
     516:	beq.n	58c <MTPD::writestring(char const*)+0xc0>
     518:	strh.w	r2, [sp, #6]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     51c:	cmp	r1, #0
     51e:	bne.n	50a <MTPD::writestring(char const*)+0x3e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     520:	ldr	r4, [pc, #500]	; (718 <MTPD::writestring(char const*)+0x24c>)
     522:	cmp	r3, #0
     524:	beq.n	5b6 <MTPD::writestring(char const*)+0xea>
     526:	ldr	r0, [r4, #0]
        write_length_ += len;
     528:	adds	r3, #2
     52a:	add.w	r7, r9, #1056	; 0x420
        
        const char * src=data;
     52e:	add.w	r6, sp, #6
        //
        int pos = 0; // into data
     532:	movs	r5, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     534:	str.w	r3, [r9, #4]
     538:	b.n	540 <MTPD::writestring(char const*)+0x74>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     53a:	cmp	r5, #1
     53c:	bgt.n	57c <MTPD::writestring(char const*)+0xb0>
     53e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     540:	subs	r2, r7, r0
     542:	rsb	r3, r5, #2
          memcpy(dst,src,to_copy);
     546:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     548:	cmp	r2, r3
     54a:	it	ge
     54c:	movge	r2, r3
     54e:	mov	fp, r2
          memcpy(dst,src,to_copy);
          pos += to_copy;
     550:	add	r5, r2
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     552:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     556:	ldr	r2, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     558:	add	r6, fp
          dst += to_copy;
     55a:	add.w	r3, r2, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     55e:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     560:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     562:	bne.n	53a <MTPD::writestring(char const*)+0x6e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     564:	movs	r2, #60	; 0x3c
     566:	mov.w	r1, #512	; 0x200
     56a:	mov	r0, r8
     56c:	bl	9d50 <usb_mtp_send>
     570:	cmp	r0, #0
     572:	ble.n	564 <MTPD::writestring(char const*)+0x98>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     574:	cmp	r5, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     576:	str.w	r8, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     57a:	ble.n	53e <MTPD::writestring(char const*)+0x72>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     57c:	ldrb.w	r2, [sl, #1]!
     580:	ldrb.w	r1, [r9]
     584:	ldr.w	r3, [r9, #4]
     588:	cmp	r2, #0
     58a:	bne.n	518 <MTPD::writestring(char const*)+0x4c>
     58c:	movs	r2, #0
     58e:	strh.w	r2, [sp, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     592:	cmp	r1, #0
     594:	beq.n	694 <MTPD::writestring(char const*)+0x1c8>
      {
        write_length_ += len;
     596:	adds	r3, #2
     598:	str.w	r3, [r9, #4]
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    } else 
    { write8(0);
    }
  }
     59c:	add	sp, #12
     59e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     5a2:	ldrb	r2, [r0, #0]
     5a4:	strb.w	r3, [sp, #3]
      {
        write_length_ += len;
     5a8:	ldr	r3, [r0, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     5aa:	cbz	r2, 5be <MTPD::writestring(char const*)+0xf2>
      {
        write_length_ += len;
     5ac:	adds	r3, #1
     5ae:	str	r3, [r0, #4]
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    } else 
    { write8(0);
    }
  }
     5b0:	add	sp, #12
     5b2:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     5b6:	mov	r0, r8
     5b8:	str.w	r8, [r4]
     5bc:	b.n	528 <MTPD::writestring(char const*)+0x5c>
     5be:	cmp	r3, #0
     5c0:	beq.w	6f2 <MTPD::writestring(char const*)+0x226>
     5c4:	ldr	r4, [pc, #336]	; (718 <MTPD::writestring(char const*)+0x24c>)
     5c6:	ldr	r0, [r4, #0]
        write_length_ += len;
     5c8:	adds	r3, #1
     5ca:	add.w	r7, r9, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     5ce:	add.w	r8, r9, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
     5d2:	add.w	r6, sp, #3
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     5d6:	str.w	r3, [r9, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
     5da:	mov.w	r9, #0
     5de:	b.n	5e8 <MTPD::writestring(char const*)+0x11c>
        while(pos<len)
     5e0:	cmp.w	r9, #0
     5e4:	bgt.n	5b0 <MTPD::writestring(char const*)+0xe4>
     5e6:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     5e8:	subs	r5, r7, r0
     5ea:	rsb	r3, r9, #1
          memcpy(dst,src,to_copy);
     5ee:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     5f0:	cmp	r5, r3
     5f2:	it	ge
     5f4:	movge	r5, r3
          memcpy(dst,src,to_copy);
     5f6:	mov	r2, r5
          pos += to_copy;
     5f8:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     5fa:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     5fe:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     600:	add	r6, r5
          dst += to_copy;
     602:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     604:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     606:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     608:	bne.n	5e0 <MTPD::writestring(char const*)+0x114>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     60a:	movs	r2, #60	; 0x3c
     60c:	mov.w	r1, #512	; 0x200
     610:	mov	r0, r8
     612:	bl	9d50 <usb_mtp_send>
     616:	cmp	r0, #0
     618:	ble.n	60a <MTPD::writestring(char const*)+0x13e>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     61a:	str.w	r8, [r4]
     61e:	b.n	5e0 <MTPD::writestring(char const*)+0x114>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     620:	cmp	r3, #0
     622:	beq.n	70a <MTPD::writestring(char const*)+0x23e>
     624:	ldr	r4, [pc, #240]	; (718 <MTPD::writestring(char const*)+0x24c>)
     626:	ldr	r0, [r4, #0]
        write_length_ += len;
     628:	adds	r3, #1
     62a:	add.w	r8, r9, #1056	; 0x420
        
        const char * src=data;
     62e:	add.w	r7, sp, #2
        //
        int pos = 0; // into data
     632:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     634:	str.w	r3, [r9, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     638:	add.w	fp, r9, #544	; 0x220
     63c:	b.n	644 <MTPD::writestring(char const*)+0x178>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     63e:	cmp	r6, #0
     640:	bgt.n	680 <MTPD::writestring(char const*)+0x1b4>
     642:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     644:	rsb	r5, r0, r8
     648:	rsb	r3, r6, #1
          memcpy(dst,src,to_copy);
     64c:	mov	r1, r7
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     64e:	cmp	r5, r3
     650:	it	ge
     652:	movge	r5, r3
          memcpy(dst,src,to_copy);
     654:	mov	r2, r5
          pos += to_copy;
     656:	add	r6, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     658:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     65c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     65e:	add	r7, r5
          dst += to_copy;
     660:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     662:	cmp	r5, r8
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     664:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     666:	bne.n	63e <MTPD::writestring(char const*)+0x172>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     668:	movs	r2, #60	; 0x3c
     66a:	mov.w	r1, #512	; 0x200
     66e:	mov	r0, fp
     670:	bl	9d50 <usb_mtp_send>
     674:	cmp	r0, #0
     676:	ble.n	668 <MTPD::writestring(char const*)+0x19c>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     678:	cmp	r6, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     67a:	str.w	fp, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     67e:	ble.n	642 <MTPD::writestring(char const*)+0x176>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     680:	ldrb.w	r2, [sl]
     684:	ldrb.w	r1, [r9]
     688:	ldr.w	r3, [r9, #4]
     68c:	cmp	r2, #0
     68e:	bne.w	504 <MTPD::writestring(char const*)+0x38>
     692:	b.n	58c <MTPD::writestring(char const*)+0xc0>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     694:	cbz	r3, 6fe <MTPD::writestring(char const*)+0x232>
     696:	ldr	r4, [pc, #128]	; (718 <MTPD::writestring(char const*)+0x24c>)
     698:	ldr	r0, [r4, #0]
        write_length_ += len;
     69a:	adds	r3, #2
     69c:	add.w	r7, r9, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     6a0:	add.w	r8, r9, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
     6a4:	add	r6, sp, #4
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     6a6:	str.w	r3, [r9, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
     6aa:	mov.w	r9, #0
     6ae:	b.n	6ba <MTPD::writestring(char const*)+0x1ee>
        while(pos<len)
     6b0:	cmp.w	r9, #1
     6b4:	bgt.w	5b0 <MTPD::writestring(char const*)+0xe4>
     6b8:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     6ba:	subs	r5, r7, r0
     6bc:	rsb	r3, r9, #2
          memcpy(dst,src,to_copy);
     6c0:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     6c2:	cmp	r5, r3
     6c4:	it	ge
     6c6:	movge	r5, r3
          memcpy(dst,src,to_copy);
     6c8:	mov	r2, r5
          pos += to_copy;
     6ca:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     6cc:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     6d0:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     6d2:	add	r6, r5
          dst += to_copy;
     6d4:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     6d6:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     6d8:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     6da:	bne.n	6b0 <MTPD::writestring(char const*)+0x1e4>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     6dc:	movs	r2, #60	; 0x3c
     6de:	mov.w	r1, #512	; 0x200
     6e2:	mov	r0, r8
     6e4:	bl	9d50 <usb_mtp_send>
     6e8:	cmp	r0, #0
     6ea:	ble.n	6dc <MTPD::writestring(char const*)+0x210>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     6ec:	str.w	r8, [r4]
     6f0:	b.n	6b0 <MTPD::writestring(char const*)+0x1e4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     6f2:	add.w	r2, r0, #544	; 0x220
     6f6:	ldr	r4, [pc, #32]	; (718 <MTPD::writestring(char const*)+0x24c>)
     6f8:	mov	r0, r2
     6fa:	str	r2, [r4, #0]
     6fc:	b.n	5c8 <MTPD::writestring(char const*)+0xfc>
     6fe:	add.w	r2, r9, #544	; 0x220
     702:	ldr	r4, [pc, #20]	; (718 <MTPD::writestring(char const*)+0x24c>)
     704:	mov	r0, r2
     706:	str	r2, [r4, #0]
     708:	b.n	69a <MTPD::writestring(char const*)+0x1ce>
     70a:	add.w	r2, r9, #544	; 0x220
     70e:	ldr	r4, [pc, #8]	; (718 <MTPD::writestring(char const*)+0x24c>)
     710:	mov	r0, r2
     712:	str	r2, [r4, #0]
     714:	b.n	628 <MTPD::writestring(char const*)+0x15c>
     716:	nop
     718:	.word	0x2000158c

0000071c <MTPD::WriteDescriptor()>:
    } else 
    { write8(0);
    }
  }

  void WriteDescriptor() {
     71c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     720:	movs	r2, #100	; 0x64
     722:	sub	sp, #92	; 0x5c
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     724:	ldrb	r3, [r0, #0]
    } else 
    { write8(0);
    }
  }

  void WriteDescriptor() {
     726:	mov	r5, r0
     728:	strh.w	r2, [sp, #14]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     72c:	cmp	r3, #0
     72e:	beq.w	fcc <MTPD::WriteDescriptor()+0x8b0>
      {
        write_length_ += len;
     732:	ldr	r3, [r0, #4]
     734:	movs	r2, #6
     736:	adds	r3, #2
     738:	str	r2, [sp, #48]	; 0x30
     73a:	movs	r2, #100	; 0x64
     73c:	adds	r3, #4
     73e:	strh.w	r2, [sp, #12]
     742:	movs	r2, #20
     744:	adds	r3, #2
     746:	strb.w	r2, [sp, #3]
     74a:	adds	r3, #1
     74c:	movs	r1, #1
     74e:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     750:	add.w	r9, r5, #544	; 0x220
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
     754:	movs	r2, #109	; 0x6d
     756:	ldr.w	sl, [pc, #824]	; a90 <MTPD::WriteDescriptor()+0x374>
     75a:	mov	r0, r9
     75c:	mov	r9, r5
     75e:	mov	r5, r0
     760:	b.n	770 <MTPD::WriteDescriptor()+0x54>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     762:	adds	r3, #2
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     764:	ldrb.w	r2, [sl, #1]!
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     768:	str.w	r3, [r9, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     76c:	cmp	r2, #0
     76e:	beq.n	7e4 <MTPD::WriteDescriptor()+0xc8>
     770:	strh.w	r2, [sp, #26]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     774:	cmp	r1, #0
     776:	bne.n	762 <MTPD::WriteDescriptor()+0x46>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     778:	ldr	r7, [pc, #772]	; (a80 <MTPD::WriteDescriptor()+0x364>)
     77a:	cmp	r3, #0
     77c:	beq.w	b34 <MTPD::WriteDescriptor()+0x418>
     780:	ldr	r0, [r7, #0]
        write_length_ += len;
     782:	adds	r3, #2
     784:	add.w	fp, r9, #1056	; 0x420
        
        const char * src=data;
     788:	add.w	r8, sp, #26
        //
        int pos = 0; // into data
     78c:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     78e:	str.w	r3, [r9, #4]
     792:	b.n	79a <MTPD::WriteDescriptor()+0x7e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     794:	cmp	r6, #1
     796:	bgt.n	7d4 <MTPD::WriteDescriptor()+0xb8>
     798:	ldr	r0, [r7, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     79a:	rsb	r4, r0, fp
     79e:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
     7a2:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     7a4:	cmp	r4, r3
     7a6:	it	ge
     7a8:	movge	r4, r3
          memcpy(dst,src,to_copy);
     7aa:	mov	r2, r4
          pos += to_copy;
     7ac:	add	r6, r4
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     7ae:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     7b2:	ldr	r3, [r7, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     7b4:	add	r8, r4
          dst += to_copy;
     7b6:	add	r4, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     7b8:	cmp	r4, fp
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     7ba:	str	r4, [r7, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     7bc:	bne.n	794 <MTPD::WriteDescriptor()+0x78>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     7be:	movs	r2, #60	; 0x3c
     7c0:	mov.w	r1, #512	; 0x200
     7c4:	mov	r0, r5
     7c6:	bl	9d50 <usb_mtp_send>
     7ca:	cmp	r0, #0
     7cc:	ble.n	7be <MTPD::WriteDescriptor()+0xa2>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     7ce:	cmp	r6, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     7d0:	str	r5, [r7, #0]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     7d2:	ble.n	798 <MTPD::WriteDescriptor()+0x7c>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     7d4:	ldrb.w	r2, [sl, #1]!
     7d8:	ldrb.w	r1, [r9]
     7dc:	ldr.w	r3, [r9, #4]
     7e0:	cmp	r2, #0
     7e2:	bne.n	770 <MTPD::WriteDescriptor()+0x54>
     7e4:	mov	r5, r9
     7e6:	strh.w	r2, [sp, #24]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     7ea:	cmp	r1, #0
     7ec:	beq.w	119a <MTPD::WriteDescriptor()+0xa7e>
      {
        write_length_ += len;
     7f0:	adds	r3, #2
     7f2:	strh.w	r2, [sp, #10]
     7f6:	movs	r2, #11
     7f8:	adds	r3, #2
     7fa:	str	r2, [sp, #44]	; 0x2c
     7fc:	adds	r3, #4
     7fe:	movs	r1, #1
     800:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     802:	add.w	r9, r5, #544	; 0x220
     806:	ldr.w	sl, [pc, #652]	; a94 <MTPD::WriteDescriptor()+0x378>
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
     80a:	movw	r2, #4097	; 0x1001
     80e:	mov	r0, r9
     810:	mov	r9, r5
     812:	mov	r5, r0
     814:	b.n	826 <MTPD::WriteDescriptor()+0x10a>
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
     816:	ldr	r2, [pc, #620]	; (a84 <MTPD::WriteDescriptor()+0x368>)
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     818:	adds	r3, #2
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
     81a:	cmp	r2, sl
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     81c:	str.w	r3, [r9, #4]
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
     820:	beq.n	898 <MTPD::WriteDescriptor()+0x17c>
     822:	ldrh.w	r2, [sl, #2]!
     826:	strh.w	r2, [sp, #16]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     82a:	cmp	r1, #0
     82c:	bne.n	816 <MTPD::WriteDescriptor()+0xfa>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     82e:	ldr	r7, [pc, #592]	; (a80 <MTPD::WriteDescriptor()+0x364>)
     830:	cmp	r3, #0
     832:	beq.w	b3a <MTPD::WriteDescriptor()+0x41e>
     836:	ldr	r0, [r7, #0]
        write_length_ += len;
     838:	adds	r3, #2
     83a:	add.w	fp, r9, #1056	; 0x420
        
        const char * src=data;
     83e:	add.w	r8, sp, #16
        //
        int pos = 0; // into data
     842:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     844:	str.w	r3, [r9, #4]
     848:	b.n	850 <MTPD::WriteDescriptor()+0x134>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     84a:	cmp	r6, #1
     84c:	bgt.n	88a <MTPD::WriteDescriptor()+0x16e>
     84e:	ldr	r0, [r7, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     850:	rsb	r4, r0, fp
     854:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
     858:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     85a:	cmp	r4, r3
     85c:	it	ge
     85e:	movge	r4, r3
          memcpy(dst,src,to_copy);
     860:	mov	r2, r4
          pos += to_copy;
     862:	add	r6, r4
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     864:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     868:	ldr	r3, [r7, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     86a:	add	r8, r4
          dst += to_copy;
     86c:	add	r4, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     86e:	cmp	r4, fp
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     870:	str	r4, [r7, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     872:	bne.n	84a <MTPD::WriteDescriptor()+0x12e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     874:	movs	r2, #60	; 0x3c
     876:	mov.w	r1, #512	; 0x200
     87a:	mov	r0, r5
     87c:	bl	9d50 <usb_mtp_send>
     880:	cmp	r0, #0
     882:	ble.n	874 <MTPD::WriteDescriptor()+0x158>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     884:	cmp	r6, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     886:	str	r5, [r7, #0]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     888:	ble.n	84e <MTPD::WriteDescriptor()+0x132>
    writestring("microsoft.com: 1.0;");
    write16(0);    // functional mode

    // Supported operations (array of uint16)
    write32(supported_op_num);
    for(int ii=0; ii<supported_op_num;ii++) write16(supported_op[ii]);
     88a:	ldr	r2, [pc, #504]	; (a84 <MTPD::WriteDescriptor()+0x368>)
     88c:	ldrb.w	r1, [r9]
     890:	cmp	r2, sl
     892:	ldr.w	r3, [r9, #4]
     896:	bne.n	822 <MTPD::WriteDescriptor()+0x106>
     898:	movs	r2, #0
     89a:	mov	r5, r9
     89c:	str	r2, [sp, #52]	; 0x34
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     89e:	cmp	r1, #0
     8a0:	beq.w	c58 <MTPD::WriteDescriptor()+0x53c>
     8a4:	movs	r2, #1
      {
        write_length_ += len;
     8a6:	adds	r3, #4
     8a8:	str	r2, [sp, #64]	; 0x40
     8aa:	movw	r2, #54274	; 0xd402
     8ae:	adds	r3, #4
     8b0:	strh.w	r2, [sp, #22]
     8b4:	movs	r2, #0
     8b6:	adds	r3, #2
     8b8:	str	r2, [sp, #60]	; 0x3c
     8ba:	movs	r2, #2
     8bc:	adds	r3, #4
     8be:	str	r2, [sp, #56]	; 0x38
     8c0:	mov.w	r2, #12288	; 0x3000
     8c4:	adds	r3, #4
     8c6:	strh.w	r2, [sp, #20]
     8ca:	movw	r2, #12289	; 0x3001
     8ce:	adds	r3, #2
     8d0:	strh.w	r2, [sp, #18]
     8d4:	movs	r2, #5
     8d6:	adds	r3, #2
     8d8:	strb.w	r2, [sp, #7]
     8dc:	adds	r3, #1
     8de:	movs	r1, #1
     8e0:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     8e2:	add.w	r9, r5, #544	; 0x220
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
     8e6:	movs	r2, #80	; 0x50
     8e8:	ldr.w	sl, [pc, #428]	; a98 <MTPD::WriteDescriptor()+0x37c>
     8ec:	mov	r0, r9
     8ee:	mov	r9, r5
     8f0:	mov	r5, r0
     8f2:	b.n	902 <MTPD::WriteDescriptor()+0x1e6>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     8f4:	adds	r3, #2
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     8f6:	ldrb.w	r2, [sl, #1]!
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     8fa:	str.w	r3, [r9, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     8fe:	cmp	r2, #0
     900:	beq.n	976 <MTPD::WriteDescriptor()+0x25a>
     902:	strh.w	r2, [sp, #30]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     906:	cmp	r1, #0
     908:	bne.n	8f4 <MTPD::WriteDescriptor()+0x1d8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     90a:	ldr	r7, [pc, #372]	; (a80 <MTPD::WriteDescriptor()+0x364>)
     90c:	cmp	r3, #0
     90e:	beq.w	b40 <MTPD::WriteDescriptor()+0x424>
     912:	ldr	r0, [r7, #0]
        write_length_ += len;
     914:	adds	r3, #2
     916:	add.w	fp, r9, #1056	; 0x420
        
        const char * src=data;
     91a:	add.w	r8, sp, #30
        //
        int pos = 0; // into data
     91e:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     920:	str.w	r3, [r9, #4]
     924:	b.n	92c <MTPD::WriteDescriptor()+0x210>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     926:	cmp	r6, #1
     928:	bgt.n	966 <MTPD::WriteDescriptor()+0x24a>
     92a:	ldr	r0, [r7, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     92c:	rsb	r4, r0, fp
     930:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
     934:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     936:	cmp	r4, r3
     938:	it	ge
     93a:	movge	r4, r3
          memcpy(dst,src,to_copy);
     93c:	mov	r2, r4
          pos += to_copy;
     93e:	add	r6, r4
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     940:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     944:	ldr	r3, [r7, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     946:	add	r8, r4
          dst += to_copy;
     948:	add	r4, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     94a:	cmp	r4, fp
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     94c:	str	r4, [r7, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     94e:	bne.n	926 <MTPD::WriteDescriptor()+0x20a>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     950:	movs	r2, #60	; 0x3c
     952:	mov.w	r1, #512	; 0x200
     956:	mov	r0, r5
     958:	bl	9d50 <usb_mtp_send>
     95c:	cmp	r0, #0
     95e:	ble.n	950 <MTPD::WriteDescriptor()+0x234>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     960:	cmp	r6, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     962:	str	r5, [r7, #0]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     964:	ble.n	92a <MTPD::WriteDescriptor()+0x20e>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     966:	ldrb.w	r2, [sl, #1]!
     96a:	ldrb.w	r1, [r9]
     96e:	ldr.w	r3, [r9, #4]
     972:	cmp	r2, #0
     974:	bne.n	902 <MTPD::WriteDescriptor()+0x1e6>
     976:	mov	r5, r9
     978:	strh.w	r2, [sp, #28]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     97c:	cmp	r1, #0
     97e:	beq.w	150e <MTPD::WriteDescriptor()+0xdf2>
     982:	movs	r2, #7
      {
        write_length_ += len;
     984:	adds	r3, #2
     986:	strb.w	r2, [sp, #6]
     98a:	adds	r3, #1
     98c:	movs	r1, #1
     98e:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     990:	add.w	r9, r5, #544	; 0x220
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
     994:	movs	r2, #84	; 0x54
     996:	ldr.w	sl, [pc, #260]	; a9c <MTPD::WriteDescriptor()+0x380>
     99a:	mov	r0, r9
     99c:	mov	r9, r5
     99e:	mov	r5, r0
     9a0:	b.n	9b0 <MTPD::WriteDescriptor()+0x294>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     9a2:	adds	r3, #2
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     9a4:	ldrb.w	r2, [sl, #1]!
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     9a8:	str.w	r3, [r9, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     9ac:	cmp	r2, #0
     9ae:	beq.n	a24 <MTPD::WriteDescriptor()+0x308>
     9b0:	strh.w	r2, [sp, #34]	; 0x22
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     9b4:	cmp	r1, #0
     9b6:	bne.n	9a2 <MTPD::WriteDescriptor()+0x286>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     9b8:	ldr	r7, [pc, #196]	; (a80 <MTPD::WriteDescriptor()+0x364>)
     9ba:	cmp	r3, #0
     9bc:	beq.w	b46 <MTPD::WriteDescriptor()+0x42a>
     9c0:	ldr	r0, [r7, #0]
        write_length_ += len;
     9c2:	adds	r3, #2
     9c4:	add.w	fp, r9, #1056	; 0x420
        
        const char * src=data;
     9c8:	add.w	r8, sp, #34	; 0x22
        //
        int pos = 0; // into data
     9cc:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     9ce:	str.w	r3, [r9, #4]
     9d2:	b.n	9da <MTPD::WriteDescriptor()+0x2be>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     9d4:	cmp	r6, #1
     9d6:	bgt.n	a14 <MTPD::WriteDescriptor()+0x2f8>
     9d8:	ldr	r0, [r7, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     9da:	rsb	r4, r0, fp
     9de:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
     9e2:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     9e4:	cmp	r4, r3
     9e6:	it	ge
     9e8:	movge	r4, r3
          memcpy(dst,src,to_copy);
     9ea:	mov	r2, r4
          pos += to_copy;
     9ec:	add	r6, r4
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     9ee:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     9f2:	ldr	r3, [r7, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     9f4:	add	r8, r4
          dst += to_copy;
     9f6:	add	r4, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     9f8:	cmp	r4, fp
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     9fa:	str	r4, [r7, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     9fc:	bne.n	9d4 <MTPD::WriteDescriptor()+0x2b8>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     9fe:	movs	r2, #60	; 0x3c
     a00:	mov.w	r1, #512	; 0x200
     a04:	mov	r0, r5
     a06:	bl	9d50 <usb_mtp_send>
     a0a:	cmp	r0, #0
     a0c:	ble.n	9fe <MTPD::WriteDescriptor()+0x2e2>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     a0e:	cmp	r6, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     a10:	str	r5, [r7, #0]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     a12:	ble.n	9d8 <MTPD::WriteDescriptor()+0x2bc>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     a14:	ldrb.w	r2, [sl, #1]!
     a18:	ldrb.w	r1, [r9]
     a1c:	ldr.w	r3, [r9, #4]
     a20:	cmp	r2, #0
     a22:	bne.n	9b0 <MTPD::WriteDescriptor()+0x294>
     a24:	mov	r5, r9
     a26:	strh.w	r2, [sp, #32]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     a2a:	cmp	r1, #0
     a2c:	beq.w	1660 <MTPD::WriteDescriptor()+0xf44>
      {
        write_length_ += len;
     a30:	adds	r3, #2
     a32:	str.w	r3, [r9, #4]
    writestring(MTP_MODEL);     // Model
    //writestring(MTP_VERS);      // version
    //writestring(MTP_SERNR);     // serial
    
    char buf[20];    
    dtostrf( (float)(TEENSYDUINO / 100.0f), 3, 2, buf);
     a36:	movs	r1, #2
     a38:	vldr	s0, [pc, #76]	; a88 <MTPD::WriteDescriptor()+0x36c>
     a3c:	add	r2, sp, #68	; 0x44
     a3e:	movs	r0, #3
     a40:	bl	9380 <dtostrf>
    strlcat(buf, " / MTP " MTP_VERS, sizeof(buf) );
     a44:	add	r0, sp, #68	; 0x44
     a46:	movs	r2, #20
     a48:	ldr	r1, [pc, #64]	; (a8c <MTPD::WriteDescriptor()+0x370>)
     a4a:	bl	bfd8 <strlcat>

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
     a4e:	ldrb.w	r6, [sp, #68]	; 0x44
     a52:	cmp	r6, #0
     a54:	beq.n	b52 <MTPD::WriteDescriptor()+0x436>
    { write8(strlen(str) + 1);
     a56:	add	r0, sp, #68	; 0x44
     a58:	bl	c080 <strlen>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     a5c:	ldrb	r4, [r5, #0]
     a5e:	adds	r0, #1
      {
        write_length_ += len;
     a60:	ldr	r3, [r5, #4]
     a62:	strb.w	r0, [sp, #5]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     a66:	cmp	r4, #0
     a68:	beq.w	15e8 <MTPD::WriteDescriptor()+0xecc>
      {
        write_length_ += len;
     a6c:	adds	r3, #1
     a6e:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     a70:	add.w	r9, r5, #544	; 0x220
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
     a74:	add.w	sl, sp, #68	; 0x44
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     a78:	mov	r2, r9
     a7a:	mov	r9, r5
     a7c:	mov	r5, r2
     a7e:	b.n	aae <MTPD::WriteDescriptor()+0x392>
     a80:	.word	0x2000158c
     a84:	.word	0x20000014
     a88:	.word	0x3fc51eb8
     a8c:	.word	0x200001c0
     a90:	.word	0x2000019c
     a94:	.word	0x20000000
     a98:	.word	0x200001b0
     a9c:	.word	0x200001b8
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     aa0:	adds	r3, #2
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     aa2:	ldrb.w	r6, [sl, #1]!
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     aa6:	str.w	r3, [r9, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     aaa:	cmp	r6, #0
     aac:	beq.n	b20 <MTPD::WriteDescriptor()+0x404>
     aae:	strh.w	r6, [sp, #38]	; 0x26
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     ab2:	cmp	r4, #0
     ab4:	bne.n	aa0 <MTPD::WriteDescriptor()+0x384>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     ab6:	ldr	r7, [pc, #776]	; (dc0 <MTPD::WriteDescriptor()+0x6a4>)
     ab8:	cmp	r3, #0
     aba:	beq.n	b4c <MTPD::WriteDescriptor()+0x430>
     abc:	ldr	r0, [r7, #0]
        write_length_ += len;
     abe:	adds	r3, #2
     ac0:	add.w	fp, r9, #1056	; 0x420
        
        const char * src=data;
     ac4:	add.w	r8, sp, #38	; 0x26
        //
        int pos = 0; // into data
     ac8:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     aca:	str.w	r3, [r9, #4]
     ace:	b.n	ad6 <MTPD::WriteDescriptor()+0x3ba>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     ad0:	cmp	r6, #1
     ad2:	bgt.n	b10 <MTPD::WriteDescriptor()+0x3f4>
     ad4:	ldr	r0, [r7, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     ad6:	rsb	r4, r0, fp
     ada:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
     ade:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     ae0:	cmp	r4, r3
     ae2:	it	ge
     ae4:	movge	r4, r3
          memcpy(dst,src,to_copy);
     ae6:	mov	r2, r4
          pos += to_copy;
     ae8:	add	r6, r4
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     aea:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     aee:	ldr	r3, [r7, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     af0:	add	r8, r4
          dst += to_copy;
     af2:	add	r4, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     af4:	cmp	r4, fp
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     af6:	str	r4, [r7, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     af8:	bne.n	ad0 <MTPD::WriteDescriptor()+0x3b4>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     afa:	movs	r2, #60	; 0x3c
     afc:	mov.w	r1, #512	; 0x200
     b00:	mov	r0, r5
     b02:	bl	9d50 <usb_mtp_send>
     b06:	cmp	r0, #0
     b08:	ble.n	afa <MTPD::WriteDescriptor()+0x3de>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     b0a:	cmp	r6, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     b0c:	str	r5, [r7, #0]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     b0e:	ble.n	ad4 <MTPD::WriteDescriptor()+0x3b8>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     b10:	ldrb.w	r6, [sl, #1]!
     b14:	ldrb.w	r4, [r9]
     b18:	ldr.w	r3, [r9, #4]
     b1c:	cmp	r6, #0
     b1e:	bne.n	aae <MTPD::WriteDescriptor()+0x392>
     b20:	mov	r5, r9
     b22:	movs	r2, #0
     b24:	strh.w	r2, [sp, #36]	; 0x24
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     b28:	cmp	r4, #0
     b2a:	beq.w	1450 <MTPD::WriteDescriptor()+0xd34>
      {
        write_length_ += len;
     b2e:	adds	r7, r3, #2
     b30:	str	r7, [r5, #4]
     b32:	b.n	b64 <MTPD::WriteDescriptor()+0x448>
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     b34:	mov	r0, r5
     b36:	str	r5, [r7, #0]
     b38:	b.n	782 <MTPD::WriteDescriptor()+0x66>
     b3a:	mov	r0, r5
     b3c:	str	r5, [r7, #0]
     b3e:	b.n	838 <MTPD::WriteDescriptor()+0x11c>
     b40:	mov	r0, r5
     b42:	str	r5, [r7, #0]
     b44:	b.n	914 <MTPD::WriteDescriptor()+0x1f8>
     b46:	mov	r0, r5
     b48:	str	r5, [r7, #0]
     b4a:	b.n	9c2 <MTPD::WriteDescriptor()+0x2a6>
     b4c:	mov	r0, r5
     b4e:	str	r5, [r7, #0]
     b50:	b.n	abe <MTPD::WriteDescriptor()+0x3a2>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     b52:	ldrb	r4, [r5, #0]
     b54:	strb.w	r6, [sp, #4]
      {
        write_length_ += len;
     b58:	ldr	r3, [r5, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     b5a:	cmp	r4, #0
     b5c:	beq.w	1344 <MTPD::WriteDescriptor()+0xc28>
      {
        write_length_ += len;
     b60:	adds	r7, r3, #1
     b62:	str	r7, [r5, #4]
     b64:	ldr	r2, [pc, #604]	; (dc4 <MTPD::WriteDescriptor()+0x6a8>)
     b66:	add	r3, sp, #68	; 0x44
     b68:	add.w	r0, sp, #78	; 0x4e
    dtostrf( (float)(TEENSYDUINO / 100.0f), 3, 2, buf);
    strlcat(buf, " / MTP " MTP_VERS, sizeof(buf) );
    writestring( buf );    
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
     b6c:	ldrh.w	r1, [r2, #2]!
     b70:	strb.w	r1, [r3], #1
     b74:	cmp	r0, r3
     b76:	bne.n	b6c <MTPD::WriteDescriptor()+0x450>

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
     b78:	ldrb.w	r6, [sp, #68]	; 0x44
     b7c:	cmp	r6, #0
     b7e:	beq.n	c44 <MTPD::WriteDescriptor()+0x528>
    { write8(strlen(str) + 1);
     b80:	add	r0, sp, #68	; 0x44
     b82:	bl	c080 <strlen>
     b86:	adds	r0, #1
     b88:	strb.w	r0, [sp, #9]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     b8c:	cmp	r4, #0
     b8e:	beq.w	13de <MTPD::WriteDescriptor()+0xcc2>
      {
        write_length_ += len;
     b92:	adds	r3, r7, #1
     b94:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     b96:	add.w	r9, r5, #544	; 0x220
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
     b9a:	add.w	sl, sp, #68	; 0x44
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     b9e:	mov	r2, r9
     ba0:	mov	r9, r5
     ba2:	mov	r5, r2
     ba4:	b.n	bb4 <MTPD::WriteDescriptor()+0x498>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     ba6:	adds	r3, #2
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     ba8:	ldrb.w	r6, [sl, #1]!
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
     bac:	str.w	r3, [r9, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     bb0:	cmp	r6, #0
     bb2:	beq.n	c26 <MTPD::WriteDescriptor()+0x50a>
     bb4:	strh.w	r6, [sp, #42]	; 0x2a
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     bb8:	cmp	r4, #0
     bba:	bne.n	ba6 <MTPD::WriteDescriptor()+0x48a>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     bbc:	ldr	r7, [pc, #512]	; (dc0 <MTPD::WriteDescriptor()+0x6a4>)
     bbe:	cmp	r3, #0
     bc0:	beq.n	c3e <MTPD::WriteDescriptor()+0x522>
     bc2:	ldr	r0, [r7, #0]
        write_length_ += len;
     bc4:	adds	r3, #2
     bc6:	add.w	fp, r9, #1056	; 0x420
        
        const char * src=data;
     bca:	add.w	r8, sp, #42	; 0x2a
        //
        int pos = 0; // into data
     bce:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     bd0:	str.w	r3, [r9, #4]
     bd4:	b.n	bdc <MTPD::WriteDescriptor()+0x4c0>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     bd6:	cmp	r6, #1
     bd8:	bgt.n	c16 <MTPD::WriteDescriptor()+0x4fa>
     bda:	ldr	r0, [r7, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     bdc:	rsb	r4, r0, fp
     be0:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
     be4:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     be6:	cmp	r4, r3
     be8:	it	ge
     bea:	movge	r4, r3
          memcpy(dst,src,to_copy);
     bec:	mov	r2, r4
          pos += to_copy;
     bee:	add	r6, r4
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     bf0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     bf4:	ldr	r3, [r7, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     bf6:	add	r8, r4
          dst += to_copy;
     bf8:	add	r4, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     bfa:	cmp	r4, fp
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     bfc:	str	r4, [r7, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     bfe:	bne.n	bd6 <MTPD::WriteDescriptor()+0x4ba>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     c00:	movs	r2, #60	; 0x3c
     c02:	mov.w	r1, #512	; 0x200
     c06:	mov	r0, r5
     c08:	bl	9d50 <usb_mtp_send>
     c0c:	cmp	r0, #0
     c0e:	ble.n	c00 <MTPD::WriteDescriptor()+0x4e4>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     c10:	cmp	r6, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     c12:	str	r5, [r7, #0]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     c14:	ble.n	bda <MTPD::WriteDescriptor()+0x4be>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
     c16:	ldrb.w	r6, [sl, #1]!
     c1a:	ldrb.w	r4, [r9]
     c1e:	ldr.w	r3, [r9, #4]
     c22:	cmp	r6, #0
     c24:	bne.n	bb4 <MTPD::WriteDescriptor()+0x498>
     c26:	mov	r5, r9
     c28:	movs	r2, #0
     c2a:	strh.w	r2, [sp, #40]	; 0x28
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     c2e:	cmp	r4, #0
     c30:	beq.w	14ae <MTPD::WriteDescriptor()+0xd92>
      {
        write_length_ += len;
     c34:	adds	r3, #2
     c36:	str	r3, [r5, #4]
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    #pragma GCC diagnostic pop
    writestring(buf);    
  }
     c38:	add	sp, #92	; 0x5c
     c3a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     c3e:	mov	r0, r5
     c40:	str	r5, [r7, #0]
     c42:	b.n	bc4 <MTPD::WriteDescriptor()+0x4a8>
     c44:	strb.w	r6, [sp, #8]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     c48:	cmp	r4, #0
     c4a:	beq.w	12e4 <MTPD::WriteDescriptor()+0xbc8>
      {
        write_length_ += len;
     c4e:	adds	r3, r7, #1
     c50:	str	r3, [r5, #4]
    #pragma GCC diagnostic push
    #pragma GCC diagnostic ignored "-Warray-bounds"
    for (size_t i=0; i<10; i++) buf[i] = usb_string_serial_number.wString[i];
    #pragma GCC diagnostic pop
    writestring(buf);    
  }
     c52:	add	sp, #92	; 0x5c
     c54:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     c58:	cmp	r3, #0
     c5a:	beq.w	118e <MTPD::WriteDescriptor()+0xa72>
     c5e:	ldr	r4, [pc, #352]	; (dc0 <MTPD::WriteDescriptor()+0x6a4>)
     c60:	ldr	r0, [r4, #0]
        write_length_ += len;
     c62:	adds	r3, #4
     c64:	add.w	r6, r5, #1056	; 0x420
        
        const char * src=data;
     c68:	add.w	r9, sp, #52	; 0x34
        //
        int pos = 0; // into data
     c6c:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     c70:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     c72:	add.w	sl, r5, #544	; 0x220
     c76:	b.n	c80 <MTPD::WriteDescriptor()+0x564>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     c78:	cmp.w	r8, #3
     c7c:	bgt.n	cbc <MTPD::WriteDescriptor()+0x5a0>
     c7e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     c80:	subs	r7, r6, r0
     c82:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
     c86:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     c88:	cmp	r7, r3
     c8a:	it	ge
     c8c:	movge	r7, r3
          memcpy(dst,src,to_copy);
     c8e:	mov	r2, r7
          pos += to_copy;
     c90:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     c92:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     c96:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     c98:	add	r9, r7
          dst += to_copy;
     c9a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     c9c:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     c9e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     ca0:	bne.n	c78 <MTPD::WriteDescriptor()+0x55c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     ca2:	movs	r2, #60	; 0x3c
     ca4:	mov.w	r1, #512	; 0x200
     ca8:	mov	r0, sl
     caa:	bl	9d50 <usb_mtp_send>
     cae:	cmp	r0, #0
     cb0:	ble.n	ca2 <MTPD::WriteDescriptor()+0x586>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     cb2:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     cb6:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     cba:	ble.n	c7e <MTPD::WriteDescriptor()+0x562>
     cbc:	movs	r1, #1
     cbe:	ldrb	r2, [r5, #0]
     cc0:	ldr	r3, [r5, #4]
     cc2:	str	r1, [sp, #64]	; 0x40
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     cc4:	cmp	r2, #0
     cc6:	bne.w	8aa <MTPD::WriteDescriptor()+0x18e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     cca:	cmp	r3, #0
     ccc:	beq.w	16d2 <MTPD::WriteDescriptor()+0xfb6>
     cd0:	ldr	r0, [r4, #0]
        write_length_ += len;
     cd2:	adds	r3, #4
        
        const char * src=data;
     cd4:	add.w	r9, sp, #64	; 0x40
        //
        int pos = 0; // into data
     cd8:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     cdc:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     ce0:	str	r3, [r5, #4]
     ce2:	b.n	cec <MTPD::WriteDescriptor()+0x5d0>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     ce4:	cmp.w	r8, #3
     ce8:	bgt.n	d28 <MTPD::WriteDescriptor()+0x60c>
     cea:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     cec:	subs	r7, r6, r0
     cee:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
     cf2:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     cf4:	cmp	r7, r3
     cf6:	it	ge
     cf8:	movge	r7, r3
          memcpy(dst,src,to_copy);
     cfa:	mov	r2, r7
          pos += to_copy;
     cfc:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     cfe:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     d02:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     d04:	add	r9, r7
          dst += to_copy;
     d06:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     d08:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     d0a:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     d0c:	bne.n	ce4 <MTPD::WriteDescriptor()+0x5c8>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     d0e:	movs	r2, #60	; 0x3c
     d10:	mov.w	r1, #512	; 0x200
     d14:	mov	r0, sl
     d16:	bl	9d50 <usb_mtp_send>
     d1a:	cmp	r0, #0
     d1c:	ble.n	d0e <MTPD::WriteDescriptor()+0x5f2>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     d1e:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     d22:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     d26:	ble.n	cea <MTPD::WriteDescriptor()+0x5ce>
     d28:	movw	r1, #54274	; 0xd402
     d2c:	ldrb	r2, [r5, #0]
     d2e:	ldr	r3, [r5, #4]
     d30:	strh.w	r1, [sp, #22]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     d34:	cmp	r2, #0
     d36:	bne.w	8b4 <MTPD::WriteDescriptor()+0x198>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     d3a:	cmp	r3, #0
     d3c:	beq.w	13d4 <MTPD::WriteDescriptor()+0xcb8>
     d40:	ldr	r0, [r4, #0]
        write_length_ += len;
     d42:	adds	r3, #2
        
        const char * src=data;
     d44:	add.w	r9, sp, #22
        //
        int pos = 0; // into data
     d48:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     d4c:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     d50:	str	r3, [r5, #4]
     d52:	b.n	d5c <MTPD::WriteDescriptor()+0x640>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     d54:	cmp.w	r8, #1
     d58:	bgt.n	d98 <MTPD::WriteDescriptor()+0x67c>
     d5a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     d5c:	subs	r7, r6, r0
     d5e:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
     d62:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     d64:	cmp	r7, r3
     d66:	it	ge
     d68:	movge	r7, r3
          memcpy(dst,src,to_copy);
     d6a:	mov	r2, r7
          pos += to_copy;
     d6c:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     d6e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     d72:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     d74:	add	r9, r7
          dst += to_copy;
     d76:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     d78:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     d7a:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     d7c:	bne.n	d54 <MTPD::WriteDescriptor()+0x638>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     d7e:	movs	r2, #60	; 0x3c
     d80:	mov.w	r1, #512	; 0x200
     d84:	mov	r0, sl
     d86:	bl	9d50 <usb_mtp_send>
     d8a:	cmp	r0, #0
     d8c:	ble.n	d7e <MTPD::WriteDescriptor()+0x662>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     d8e:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     d92:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     d96:	ble.n	d5a <MTPD::WriteDescriptor()+0x63e>
     d98:	movs	r1, #0
     d9a:	ldrb	r2, [r5, #0]
     d9c:	ldr	r3, [r5, #4]
     d9e:	str	r1, [sp, #60]	; 0x3c
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     da0:	cmp	r2, #0
     da2:	bne.w	8ba <MTPD::WriteDescriptor()+0x19e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     da6:	cmp	r3, #0
     da8:	beq.w	13ca <MTPD::WriteDescriptor()+0xcae>
     dac:	ldr	r0, [r4, #0]
        write_length_ += len;
     dae:	adds	r3, #4
        
        const char * src=data;
     db0:	add.w	r9, sp, #60	; 0x3c
        //
        int pos = 0; // into data
     db4:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     db8:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     dbc:	str	r3, [r5, #4]
     dbe:	b.n	dd0 <MTPD::WriteDescriptor()+0x6b4>
     dc0:	.word	0x2000158c
     dc4:	.word	0x20000b94
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     dc8:	cmp.w	r8, #3
     dcc:	bgt.n	e0c <MTPD::WriteDescriptor()+0x6f0>
     dce:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     dd0:	subs	r7, r6, r0
     dd2:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
     dd6:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     dd8:	cmp	r7, r3
     dda:	it	ge
     ddc:	movge	r7, r3
          memcpy(dst,src,to_copy);
     dde:	mov	r2, r7
          pos += to_copy;
     de0:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     de2:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     de6:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     de8:	add	r9, r7
          dst += to_copy;
     dea:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     dec:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     dee:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     df0:	bne.n	dc8 <MTPD::WriteDescriptor()+0x6ac>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     df2:	movs	r2, #60	; 0x3c
     df4:	mov.w	r1, #512	; 0x200
     df8:	mov	r0, sl
     dfa:	bl	9d50 <usb_mtp_send>
     dfe:	cmp	r0, #0
     e00:	ble.n	df2 <MTPD::WriteDescriptor()+0x6d6>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     e02:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     e06:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     e0a:	ble.n	dce <MTPD::WriteDescriptor()+0x6b2>
     e0c:	movs	r1, #2
     e0e:	ldrb	r2, [r5, #0]
     e10:	ldr	r3, [r5, #4]
     e12:	str	r1, [sp, #56]	; 0x38
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     e14:	cmp	r2, #0
     e16:	bne.w	8c0 <MTPD::WriteDescriptor()+0x1a4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     e1a:	cmp	r3, #0
     e1c:	beq.w	13c0 <MTPD::WriteDescriptor()+0xca4>
     e20:	ldr	r0, [r4, #0]
        write_length_ += len;
     e22:	adds	r3, #4
        
        const char * src=data;
     e24:	add.w	r9, sp, #56	; 0x38
        //
        int pos = 0; // into data
     e28:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     e2c:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     e30:	str	r3, [r5, #4]
     e32:	b.n	e3c <MTPD::WriteDescriptor()+0x720>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     e34:	cmp.w	r8, #3
     e38:	bgt.n	e78 <MTPD::WriteDescriptor()+0x75c>
     e3a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     e3c:	subs	r7, r6, r0
     e3e:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
     e42:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     e44:	cmp	r7, r3
     e46:	it	ge
     e48:	movge	r7, r3
          memcpy(dst,src,to_copy);
     e4a:	mov	r2, r7
          pos += to_copy;
     e4c:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     e4e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     e52:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     e54:	add	r9, r7
          dst += to_copy;
     e56:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     e58:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     e5a:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     e5c:	bne.n	e34 <MTPD::WriteDescriptor()+0x718>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     e5e:	movs	r2, #60	; 0x3c
     e60:	mov.w	r1, #512	; 0x200
     e64:	mov	r0, sl
     e66:	bl	9d50 <usb_mtp_send>
     e6a:	cmp	r0, #0
     e6c:	ble.n	e5e <MTPD::WriteDescriptor()+0x742>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     e6e:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     e72:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     e76:	ble.n	e3a <MTPD::WriteDescriptor()+0x71e>
     e78:	mov.w	r1, #12288	; 0x3000
     e7c:	ldrb	r2, [r5, #0]
     e7e:	ldr	r3, [r5, #4]
     e80:	strh.w	r1, [sp, #20]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     e84:	cmp	r2, #0
     e86:	bne.w	8ca <MTPD::WriteDescriptor()+0x1ae>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     e8a:	cmp	r3, #0
     e8c:	beq.w	13b6 <MTPD::WriteDescriptor()+0xc9a>
     e90:	ldr	r0, [r4, #0]
        write_length_ += len;
     e92:	adds	r3, #2
        
        const char * src=data;
     e94:	add.w	r9, sp, #20
        //
        int pos = 0; // into data
     e98:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     e9c:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     ea0:	str	r3, [r5, #4]
     ea2:	b.n	eac <MTPD::WriteDescriptor()+0x790>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     ea4:	cmp.w	r8, #1
     ea8:	bgt.n	ee8 <MTPD::WriteDescriptor()+0x7cc>
     eaa:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     eac:	subs	r7, r6, r0
     eae:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
     eb2:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     eb4:	cmp	r7, r3
     eb6:	it	ge
     eb8:	movge	r7, r3
          memcpy(dst,src,to_copy);
     eba:	mov	r2, r7
          pos += to_copy;
     ebc:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     ebe:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     ec2:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     ec4:	add	r9, r7
          dst += to_copy;
     ec6:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     ec8:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     eca:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     ecc:	bne.n	ea4 <MTPD::WriteDescriptor()+0x788>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     ece:	movs	r2, #60	; 0x3c
     ed0:	mov.w	r1, #512	; 0x200
     ed4:	mov	r0, sl
     ed6:	bl	9d50 <usb_mtp_send>
     eda:	cmp	r0, #0
     edc:	ble.n	ece <MTPD::WriteDescriptor()+0x7b2>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     ede:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     ee2:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     ee6:	ble.n	eaa <MTPD::WriteDescriptor()+0x78e>
     ee8:	movw	r1, #12289	; 0x3001
     eec:	ldrb	r2, [r5, #0]
     eee:	ldr	r3, [r5, #4]
     ef0:	strh.w	r1, [sp, #18]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     ef4:	cmp	r2, #0
     ef6:	bne.w	8d4 <MTPD::WriteDescriptor()+0x1b8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     efa:	cmp	r3, #0
     efc:	beq.w	13ac <MTPD::WriteDescriptor()+0xc90>
     f00:	ldr	r0, [r4, #0]
        write_length_ += len;
     f02:	adds	r3, #2
        
        const char * src=data;
     f04:	add.w	r9, sp, #18
        //
        int pos = 0; // into data
     f08:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     f0c:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     f10:	str	r3, [r5, #4]
     f12:	b.n	f1c <MTPD::WriteDescriptor()+0x800>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     f14:	cmp.w	r8, #1
     f18:	bgt.n	f58 <MTPD::WriteDescriptor()+0x83c>
     f1a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     f1c:	subs	r7, r6, r0
     f1e:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
     f22:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     f24:	cmp	r7, r3
     f26:	it	ge
     f28:	movge	r7, r3
          memcpy(dst,src,to_copy);
     f2a:	mov	r2, r7
          pos += to_copy;
     f2c:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     f2e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     f32:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     f34:	add	r9, r7
          dst += to_copy;
     f36:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     f38:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     f3a:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     f3c:	bne.n	f14 <MTPD::WriteDescriptor()+0x7f8>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     f3e:	movs	r2, #60	; 0x3c
     f40:	mov.w	r1, #512	; 0x200
     f44:	mov	r0, sl
     f46:	bl	9d50 <usb_mtp_send>
     f4a:	cmp	r0, #0
     f4c:	ble.n	f3e <MTPD::WriteDescriptor()+0x822>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     f4e:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     f52:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     f56:	ble.n	f1a <MTPD::WriteDescriptor()+0x7fe>
     f58:	movs	r1, #5
     f5a:	ldrb	r2, [r5, #0]
     f5c:	ldr	r3, [r5, #4]
     f5e:	strb.w	r1, [sp, #7]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
     f62:	cmp	r2, #0
     f64:	bne.w	8dc <MTPD::WriteDescriptor()+0x1c0>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     f68:	cmp	r3, #0
     f6a:	beq.w	1716 <MTPD::WriteDescriptor()+0xffa>
     f6e:	ldr	r0, [r4, #0]
        write_length_ += len;
     f70:	adds	r3, #1
        
        const char * src=data;
     f72:	add.w	r9, sp, #7
        //
        int pos = 0; // into data
     f76:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     f7a:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     f7e:	str	r3, [r5, #4]
     f80:	b.n	f8a <MTPD::WriteDescriptor()+0x86e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     f82:	cmp.w	r8, #0
     f86:	bgt.n	fc6 <MTPD::WriteDescriptor()+0x8aa>
     f88:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     f8a:	subs	r7, r6, r0
     f8c:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
     f90:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     f92:	cmp	r7, r3
     f94:	it	ge
     f96:	movge	r7, r3
          memcpy(dst,src,to_copy);
     f98:	mov	r2, r7
          pos += to_copy;
     f9a:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
     f9c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     fa0:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
     fa2:	add	r9, r7
          dst += to_copy;
     fa4:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     fa6:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
     fa8:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
     faa:	bne.n	f82 <MTPD::WriteDescriptor()+0x866>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
     fac:	movs	r2, #60	; 0x3c
     fae:	mov.w	r1, #512	; 0x200
     fb2:	mov	r0, sl
     fb4:	bl	9d50 <usb_mtp_send>
     fb8:	cmp	r0, #0
     fba:	ble.n	fac <MTPD::WriteDescriptor()+0x890>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     fbc:	cmp.w	r8, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
     fc0:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     fc4:	ble.n	f88 <MTPD::WriteDescriptor()+0x86c>
     fc6:	ldrb	r1, [r5, #0]
     fc8:	ldr	r3, [r5, #4]
     fca:	b.n	8e2 <MTPD::WriteDescriptor()+0x1c6>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
     fcc:	ldr	r3, [r0, #4]
     fce:	cmp	r3, #0
     fd0:	beq.w	1182 <MTPD::WriteDescriptor()+0xa66>
     fd4:	ldr	r4, [pc, #776]	; (12e0 <MTPD::WriteDescriptor()+0xbc4>)
     fd6:	ldr	r0, [r4, #0]
        write_length_ += len;
     fd8:	adds	r3, #2
     fda:	add.w	r6, r5, #1056	; 0x420
        
        const char * src=data;
     fde:	add.w	r9, sp, #14
        //
        int pos = 0; // into data
     fe2:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
     fe6:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
     fe8:	add.w	sl, r5, #544	; 0x220
     fec:	b.n	ff6 <MTPD::WriteDescriptor()+0x8da>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
     fee:	cmp.w	r8, #1
     ff2:	bgt.n	1032 <MTPD::WriteDescriptor()+0x916>
     ff4:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     ff6:	subs	r7, r6, r0
     ff8:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
     ffc:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
     ffe:	cmp	r7, r3
    1000:	it	ge
    1002:	movge	r7, r3
          memcpy(dst,src,to_copy);
    1004:	mov	r2, r7
          pos += to_copy;
    1006:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1008:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    100c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    100e:	add	r9, r7
          dst += to_copy;
    1010:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1012:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1014:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1016:	bne.n	fee <MTPD::WriteDescriptor()+0x8d2>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1018:	movs	r2, #60	; 0x3c
    101a:	mov.w	r1, #512	; 0x200
    101e:	mov	r0, sl
    1020:	bl	9d50 <usb_mtp_send>
    1024:	cmp	r0, #0
    1026:	ble.n	1018 <MTPD::WriteDescriptor()+0x8fc>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1028:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    102c:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1030:	ble.n	ff4 <MTPD::WriteDescriptor()+0x8d8>
    1032:	movs	r1, #6
    1034:	ldrb	r2, [r5, #0]
    1036:	ldr	r3, [r5, #4]
    1038:	str	r1, [sp, #48]	; 0x30
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    103a:	cmp	r2, #0
    103c:	bne.w	73a <MTPD::WriteDescriptor()+0x1e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1040:	cmp	r3, #0
    1042:	beq.w	16e8 <MTPD::WriteDescriptor()+0xfcc>
    1046:	ldr	r0, [r4, #0]
        write_length_ += len;
    1048:	adds	r3, #4
        
        const char * src=data;
    104a:	add.w	r9, sp, #48	; 0x30
        //
        int pos = 0; // into data
    104e:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1052:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1056:	str	r3, [r5, #4]
    1058:	b.n	1062 <MTPD::WriteDescriptor()+0x946>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    105a:	cmp.w	r8, #3
    105e:	bgt.n	109e <MTPD::WriteDescriptor()+0x982>
    1060:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1062:	subs	r7, r6, r0
    1064:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    1068:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    106a:	cmp	r7, r3
    106c:	it	ge
    106e:	movge	r7, r3
          memcpy(dst,src,to_copy);
    1070:	mov	r2, r7
          pos += to_copy;
    1072:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1074:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1078:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    107a:	add	r9, r7
          dst += to_copy;
    107c:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    107e:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1080:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1082:	bne.n	105a <MTPD::WriteDescriptor()+0x93e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1084:	movs	r2, #60	; 0x3c
    1086:	mov.w	r1, #512	; 0x200
    108a:	mov	r0, sl
    108c:	bl	9d50 <usb_mtp_send>
    1090:	cmp	r0, #0
    1092:	ble.n	1084 <MTPD::WriteDescriptor()+0x968>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1094:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1098:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    109c:	ble.n	1060 <MTPD::WriteDescriptor()+0x944>
    109e:	movs	r1, #100	; 0x64
    10a0:	ldrb	r2, [r5, #0]
    10a2:	ldr	r3, [r5, #4]
    10a4:	strh.w	r1, [sp, #12]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    10a8:	cmp	r2, #0
    10aa:	bne.w	742 <MTPD::WriteDescriptor()+0x26>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    10ae:	cmp	r3, #0
    10b0:	beq.w	16de <MTPD::WriteDescriptor()+0xfc2>
    10b4:	ldr	r0, [r4, #0]
        write_length_ += len;
    10b6:	adds	r3, #2
        
        const char * src=data;
    10b8:	add.w	r9, sp, #12
        //
        int pos = 0; // into data
    10bc:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    10c0:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    10c4:	str	r3, [r5, #4]
    10c6:	b.n	10d0 <MTPD::WriteDescriptor()+0x9b4>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    10c8:	cmp.w	r8, #1
    10cc:	bgt.n	110c <MTPD::WriteDescriptor()+0x9f0>
    10ce:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    10d0:	subs	r7, r6, r0
    10d2:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    10d6:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    10d8:	cmp	r7, r3
    10da:	it	ge
    10dc:	movge	r7, r3
          memcpy(dst,src,to_copy);
    10de:	mov	r2, r7
          pos += to_copy;
    10e0:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    10e2:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    10e6:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    10e8:	add	r9, r7
          dst += to_copy;
    10ea:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    10ec:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    10ee:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    10f0:	bne.n	10c8 <MTPD::WriteDescriptor()+0x9ac>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    10f2:	movs	r2, #60	; 0x3c
    10f4:	mov.w	r1, #512	; 0x200
    10f8:	mov	r0, sl
    10fa:	bl	9d50 <usb_mtp_send>
    10fe:	cmp	r0, #0
    1100:	ble.n	10f2 <MTPD::WriteDescriptor()+0x9d6>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1102:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1106:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    110a:	ble.n	10ce <MTPD::WriteDescriptor()+0x9b2>
    110c:	movs	r1, #20
    110e:	ldrb	r2, [r5, #0]
    1110:	ldr	r3, [r5, #4]
    1112:	strb.w	r1, [sp, #3]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1116:	cmp	r2, #0
    1118:	bne.w	74a <MTPD::WriteDescriptor()+0x2e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    111c:	cmp	r3, #0
    111e:	beq.w	1744 <MTPD::WriteDescriptor()+0x1028>
    1122:	ldr	r0, [r4, #0]
        write_length_ += len;
    1124:	adds	r3, #1
        
        const char * src=data;
    1126:	add.w	r9, sp, #3
        //
        int pos = 0; // into data
    112a:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    112e:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1132:	str	r3, [r5, #4]
    1134:	b.n	113e <MTPD::WriteDescriptor()+0xa22>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1136:	cmp.w	r8, #0
    113a:	bgt.n	117a <MTPD::WriteDescriptor()+0xa5e>
    113c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    113e:	subs	r7, r6, r0
    1140:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    1144:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1146:	cmp	r7, r3
    1148:	it	ge
    114a:	movge	r7, r3
          memcpy(dst,src,to_copy);
    114c:	mov	r2, r7
          pos += to_copy;
    114e:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1150:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1154:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1156:	add	r9, r7
          dst += to_copy;
    1158:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    115a:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    115c:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    115e:	bne.n	1136 <MTPD::WriteDescriptor()+0xa1a>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1160:	movs	r2, #60	; 0x3c
    1162:	mov.w	r1, #512	; 0x200
    1166:	mov	r0, sl
    1168:	bl	9d50 <usb_mtp_send>
    116c:	cmp	r0, #0
    116e:	ble.n	1160 <MTPD::WriteDescriptor()+0xa44>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1170:	cmp.w	r8, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1174:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1178:	ble.n	113c <MTPD::WriteDescriptor()+0xa20>
    117a:	ldrb	r1, [r5, #0]
    117c:	ldr	r3, [r5, #4]
    117e:	b.w	750 <MTPD::WriteDescriptor()+0x34>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1182:	add.w	r2, r0, #544	; 0x220
    1186:	ldr	r4, [pc, #344]	; (12e0 <MTPD::WriteDescriptor()+0xbc4>)
    1188:	mov	r0, r2
    118a:	str	r2, [r4, #0]
    118c:	b.n	fd8 <MTPD::WriteDescriptor()+0x8bc>
    118e:	add.w	r2, r9, #544	; 0x220
    1192:	ldr	r4, [pc, #332]	; (12e0 <MTPD::WriteDescriptor()+0xbc4>)
    1194:	mov	r0, r2
    1196:	str	r2, [r4, #0]
    1198:	b.n	c62 <MTPD::WriteDescriptor()+0x546>
    119a:	cmp	r3, #0
    119c:	beq.w	1738 <MTPD::WriteDescriptor()+0x101c>
    11a0:	ldr	r4, [pc, #316]	; (12e0 <MTPD::WriteDescriptor()+0xbc4>)
    11a2:	ldr	r0, [r4, #0]
        write_length_ += len;
    11a4:	adds	r3, #2
    11a6:	add.w	r6, r5, #1056	; 0x420
        
        const char * src=data;
    11aa:	add.w	r9, sp, #24
        //
        int pos = 0; // into data
    11ae:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    11b2:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    11b4:	add.w	sl, r5, #544	; 0x220
    11b8:	b.n	11c2 <MTPD::WriteDescriptor()+0xaa6>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    11ba:	cmp.w	r8, #1
    11be:	bgt.n	11fe <MTPD::WriteDescriptor()+0xae2>
    11c0:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    11c2:	subs	r7, r6, r0
    11c4:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    11c8:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    11ca:	cmp	r7, r3
    11cc:	it	ge
    11ce:	movge	r7, r3
          memcpy(dst,src,to_copy);
    11d0:	mov	r2, r7
          pos += to_copy;
    11d2:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    11d4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    11d8:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    11da:	add	r9, r7
          dst += to_copy;
    11dc:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    11de:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    11e0:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    11e2:	bne.n	11ba <MTPD::WriteDescriptor()+0xa9e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    11e4:	movs	r2, #60	; 0x3c
    11e6:	mov.w	r1, #512	; 0x200
    11ea:	mov	r0, sl
    11ec:	bl	9d50 <usb_mtp_send>
    11f0:	cmp	r0, #0
    11f2:	ble.n	11e4 <MTPD::WriteDescriptor()+0xac8>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    11f4:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    11f8:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    11fc:	ble.n	11c0 <MTPD::WriteDescriptor()+0xaa4>
    11fe:	movs	r1, #0
    1200:	ldrb	r2, [r5, #0]
    1202:	ldr	r3, [r5, #4]
    1204:	strh.w	r1, [sp, #10]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1208:	cmp	r2, #0
    120a:	bne.w	7f6 <MTPD::WriteDescriptor()+0xda>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    120e:	cmp	r3, #0
    1210:	beq.w	16c8 <MTPD::WriteDescriptor()+0xfac>
    1214:	ldr	r0, [r4, #0]
        write_length_ += len;
    1216:	adds	r3, #2
        
        const char * src=data;
    1218:	add.w	r9, sp, #10
        //
        int pos = 0; // into data
    121c:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1220:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1224:	str	r3, [r5, #4]
    1226:	b.n	1230 <MTPD::WriteDescriptor()+0xb14>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1228:	cmp.w	r8, #1
    122c:	bgt.n	126c <MTPD::WriteDescriptor()+0xb50>
    122e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1230:	subs	r7, r6, r0
    1232:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    1236:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1238:	cmp	r7, r3
    123a:	it	ge
    123c:	movge	r7, r3
          memcpy(dst,src,to_copy);
    123e:	mov	r2, r7
          pos += to_copy;
    1240:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1242:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1246:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1248:	add	r9, r7
          dst += to_copy;
    124a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    124c:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    124e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1250:	bne.n	1228 <MTPD::WriteDescriptor()+0xb0c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1252:	movs	r2, #60	; 0x3c
    1254:	mov.w	r1, #512	; 0x200
    1258:	mov	r0, sl
    125a:	bl	9d50 <usb_mtp_send>
    125e:	cmp	r0, #0
    1260:	ble.n	1252 <MTPD::WriteDescriptor()+0xb36>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1262:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1266:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    126a:	ble.n	122e <MTPD::WriteDescriptor()+0xb12>
    126c:	movs	r1, #11
    126e:	ldrb	r2, [r5, #0]
    1270:	ldr	r3, [r5, #4]
    1272:	str	r1, [sp, #44]	; 0x2c
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1274:	cmp	r2, #0
    1276:	bne.w	7fc <MTPD::WriteDescriptor()+0xe0>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    127a:	cmp	r3, #0
    127c:	beq.w	16be <MTPD::WriteDescriptor()+0xfa2>
    1280:	ldr	r0, [r4, #0]
        write_length_ += len;
    1282:	adds	r3, #4
        
        const char * src=data;
    1284:	add.w	r9, sp, #44	; 0x2c
        //
        int pos = 0; // into data
    1288:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    128c:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1290:	str	r3, [r5, #4]
    1292:	b.n	129c <MTPD::WriteDescriptor()+0xb80>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1294:	cmp.w	r8, #3
    1298:	bgt.n	12d8 <MTPD::WriteDescriptor()+0xbbc>
    129a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    129c:	subs	r7, r6, r0
    129e:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    12a2:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    12a4:	cmp	r7, r3
    12a6:	it	ge
    12a8:	movge	r7, r3
          memcpy(dst,src,to_copy);
    12aa:	mov	r2, r7
          pos += to_copy;
    12ac:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    12ae:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    12b2:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    12b4:	add	r9, r7
          dst += to_copy;
    12b6:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    12b8:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    12ba:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    12bc:	bne.n	1294 <MTPD::WriteDescriptor()+0xb78>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    12be:	movs	r2, #60	; 0x3c
    12c0:	mov.w	r1, #512	; 0x200
    12c4:	mov	r0, sl
    12c6:	bl	9d50 <usb_mtp_send>
    12ca:	cmp	r0, #0
    12cc:	ble.n	12be <MTPD::WriteDescriptor()+0xba2>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    12ce:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    12d2:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    12d6:	ble.n	129a <MTPD::WriteDescriptor()+0xb7e>
    12d8:	ldrb	r1, [r5, #0]
    12da:	ldr	r3, [r5, #4]
    12dc:	b.w	802 <MTPD::WriteDescriptor()+0xe6>
    12e0:	.word	0x2000158c
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    12e4:	cmp	r7, #0
    12e6:	beq.w	16fe <MTPD::WriteDescriptor()+0xfe2>
    12ea:	ldr	r4, [pc, #796]	; (1608 <MTPD::WriteDescriptor()+0xeec>)
    12ec:	ldr	r0, [r4, #0]
        write_length_ += len;
    12ee:	adds	r3, r7, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    12f0:	add.w	r8, r5, #544	; 0x220
    12f4:	add.w	r7, r5, #1056	; 0x420
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    12f8:	add	r6, sp, #8
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    12fa:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    12fc:	mov.w	r9, #0
    1300:	b.n	130c <MTPD::WriteDescriptor()+0xbf0>
        while(pos<len)
    1302:	cmp.w	r9, #0
    1306:	bgt.w	c52 <MTPD::WriteDescriptor()+0x536>
    130a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    130c:	subs	r5, r7, r0
    130e:	rsb	r3, r9, #1
          memcpy(dst,src,to_copy);
    1312:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1314:	cmp	r5, r3
    1316:	it	ge
    1318:	movge	r5, r3
          memcpy(dst,src,to_copy);
    131a:	mov	r2, r5
          pos += to_copy;
    131c:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    131e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1322:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1324:	add	r6, r5
          dst += to_copy;
    1326:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1328:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    132a:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    132c:	bne.n	1302 <MTPD::WriteDescriptor()+0xbe6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    132e:	movs	r2, #60	; 0x3c
    1330:	mov.w	r1, #512	; 0x200
    1334:	mov	r0, r8
    1336:	bl	9d50 <usb_mtp_send>
    133a:	cmp	r0, #0
    133c:	ble.n	132e <MTPD::WriteDescriptor()+0xc12>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    133e:	str.w	r8, [r4]
    1342:	b.n	1302 <MTPD::WriteDescriptor()+0xbe6>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1344:	cmp	r3, #0
    1346:	beq.w	16f2 <MTPD::WriteDescriptor()+0xfd6>
    134a:	ldr	r4, [pc, #700]	; (1608 <MTPD::WriteDescriptor()+0xeec>)
    134c:	ldr	r0, [r4, #0]
        write_length_ += len;
    134e:	adds	r3, #1
    1350:	add.w	r9, r5, #1056	; 0x420
        
        const char * src=data;
    1354:	add.w	r8, sp, #4
        //
        int pos = 0; // into data
    1358:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    135a:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    135c:	add.w	sl, r5, #544	; 0x220
    1360:	b.n	1368 <MTPD::WriteDescriptor()+0xc4c>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1362:	cmp	r7, #0
    1364:	bgt.n	13a4 <MTPD::WriteDescriptor()+0xc88>
    1366:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1368:	rsb	r6, r0, r9
    136c:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    1370:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1372:	cmp	r6, r3
    1374:	it	ge
    1376:	movge	r6, r3
          memcpy(dst,src,to_copy);
    1378:	mov	r2, r6
          pos += to_copy;
    137a:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    137c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1380:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1382:	add	r8, r6
          dst += to_copy;
    1384:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1386:	cmp	r6, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1388:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    138a:	bne.n	1362 <MTPD::WriteDescriptor()+0xc46>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    138c:	movs	r2, #60	; 0x3c
    138e:	mov.w	r1, #512	; 0x200
    1392:	mov	r0, sl
    1394:	bl	9d50 <usb_mtp_send>
    1398:	cmp	r0, #0
    139a:	ble.n	138c <MTPD::WriteDescriptor()+0xc70>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    139c:	cmp	r7, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    139e:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    13a2:	ble.n	1366 <MTPD::WriteDescriptor()+0xc4a>
    13a4:	ldrb	r4, [r5, #0]
    13a6:	ldr	r7, [r5, #4]
    13a8:	b.w	b64 <MTPD::WriteDescriptor()+0x448>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    13ac:	add.w	r2, r5, #544	; 0x220
    13b0:	mov	r0, r2
    13b2:	str	r2, [r4, #0]
    13b4:	b.n	f02 <MTPD::WriteDescriptor()+0x7e6>
    13b6:	add.w	r2, r5, #544	; 0x220
    13ba:	mov	r0, r2
    13bc:	str	r2, [r4, #0]
    13be:	b.n	e92 <MTPD::WriteDescriptor()+0x776>
    13c0:	add.w	r2, r5, #544	; 0x220
    13c4:	mov	r0, r2
    13c6:	str	r2, [r4, #0]
    13c8:	b.n	e22 <MTPD::WriteDescriptor()+0x706>
    13ca:	add.w	r2, r5, #544	; 0x220
    13ce:	mov	r0, r2
    13d0:	str	r2, [r4, #0]
    13d2:	b.n	dae <MTPD::WriteDescriptor()+0x692>
    13d4:	add.w	r2, r5, #544	; 0x220
    13d8:	mov	r0, r2
    13da:	str	r2, [r4, #0]
    13dc:	b.n	d42 <MTPD::WriteDescriptor()+0x626>
    13de:	cmp	r7, #0
    13e0:	beq.w	170a <MTPD::WriteDescriptor()+0xfee>
    13e4:	ldr	r4, [pc, #544]	; (1608 <MTPD::WriteDescriptor()+0xeec>)
    13e6:	ldr	r0, [r4, #0]
        write_length_ += len;
    13e8:	adds	r3, r7, #1
    13ea:	add.w	r9, r5, #1056	; 0x420
        
        const char * src=data;
    13ee:	add.w	r8, sp, #9
        //
        int pos = 0; // into data
    13f2:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    13f4:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    13f6:	add.w	sl, r5, #544	; 0x220
    13fa:	b.n	1402 <MTPD::WriteDescriptor()+0xce6>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    13fc:	cmp	r7, #0
    13fe:	bgt.n	143e <MTPD::WriteDescriptor()+0xd22>
    1400:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1402:	rsb	r6, r0, r9
    1406:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    140a:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    140c:	cmp	r6, r3
    140e:	it	ge
    1410:	movge	r6, r3
          memcpy(dst,src,to_copy);
    1412:	mov	r2, r6
          pos += to_copy;
    1414:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1416:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    141a:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    141c:	add	r8, r6
          dst += to_copy;
    141e:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1420:	cmp	r6, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1422:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1424:	bne.n	13fc <MTPD::WriteDescriptor()+0xce0>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1426:	movs	r2, #60	; 0x3c
    1428:	mov.w	r1, #512	; 0x200
    142c:	mov	r0, sl
    142e:	bl	9d50 <usb_mtp_send>
    1432:	cmp	r0, #0
    1434:	ble.n	1426 <MTPD::WriteDescriptor()+0xd0a>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1436:	cmp	r7, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1438:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    143c:	ble.n	1400 <MTPD::WriteDescriptor()+0xce4>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    143e:	ldrb.w	r6, [sp, #68]	; 0x44
    1442:	ldrb	r4, [r5, #0]
    1444:	ldr	r3, [r5, #4]
    1446:	cmp	r6, #0
    1448:	bne.w	b96 <MTPD::WriteDescriptor()+0x47a>
    144c:	b.w	c28 <MTPD::WriteDescriptor()+0x50c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1450:	cmp	r3, #0
    1452:	beq.w	1770 <MTPD::WriteDescriptor()+0x1054>
    1456:	ldr	r4, [pc, #432]	; (1608 <MTPD::WriteDescriptor()+0xeec>)
    1458:	ldr	r0, [r4, #0]
        write_length_ += len;
    145a:	adds	r3, #2
    145c:	add.w	r9, r5, #1056	; 0x420
        
        const char * src=data;
    1460:	add.w	r8, sp, #36	; 0x24
        //
        int pos = 0; // into data
    1464:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1466:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1468:	add.w	sl, r5, #544	; 0x220
    146c:	b.n	1474 <MTPD::WriteDescriptor()+0xd58>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    146e:	cmp	r7, #1
    1470:	bgt.n	13a4 <MTPD::WriteDescriptor()+0xc88>
    1472:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1474:	rsb	r6, r0, r9
    1478:	rsb	r3, r7, #2
          memcpy(dst,src,to_copy);
    147c:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    147e:	cmp	r6, r3
    1480:	it	ge
    1482:	movge	r6, r3
          memcpy(dst,src,to_copy);
    1484:	mov	r2, r6
          pos += to_copy;
    1486:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1488:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    148c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    148e:	add	r8, r6
          dst += to_copy;
    1490:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1492:	cmp	r6, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1494:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1496:	bne.n	146e <MTPD::WriteDescriptor()+0xd52>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1498:	movs	r2, #60	; 0x3c
    149a:	mov.w	r1, #512	; 0x200
    149e:	mov	r0, sl
    14a0:	bl	9d50 <usb_mtp_send>
    14a4:	cmp	r0, #0
    14a6:	ble.n	1498 <MTPD::WriteDescriptor()+0xd7c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    14a8:	str.w	sl, [r4]
    14ac:	b.n	146e <MTPD::WriteDescriptor()+0xd52>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    14ae:	cmp	r3, #0
    14b0:	beq.w	1764 <MTPD::WriteDescriptor()+0x1048>
    14b4:	ldr	r4, [pc, #336]	; (1608 <MTPD::WriteDescriptor()+0xeec>)
    14b6:	ldr	r0, [r4, #0]
        write_length_ += len;
    14b8:	adds	r3, #2
    14ba:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    14be:	add.w	r8, r5, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    14c2:	add	r6, sp, #40	; 0x28
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    14c4:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    14c6:	mov.w	r9, #0
    14ca:	b.n	14d6 <MTPD::WriteDescriptor()+0xdba>
        while(pos<len)
    14cc:	cmp.w	r9, #1
    14d0:	bgt.w	c52 <MTPD::WriteDescriptor()+0x536>
    14d4:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    14d6:	subs	r5, r7, r0
    14d8:	rsb	r3, r9, #2
          memcpy(dst,src,to_copy);
    14dc:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    14de:	cmp	r5, r3
    14e0:	it	ge
    14e2:	movge	r5, r3
          memcpy(dst,src,to_copy);
    14e4:	mov	r2, r5
          pos += to_copy;
    14e6:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    14e8:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    14ec:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    14ee:	add	r6, r5
          dst += to_copy;
    14f0:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    14f2:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    14f4:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    14f6:	bne.n	14cc <MTPD::WriteDescriptor()+0xdb0>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    14f8:	movs	r2, #60	; 0x3c
    14fa:	mov.w	r1, #512	; 0x200
    14fe:	mov	r0, r8
    1500:	bl	9d50 <usb_mtp_send>
    1504:	cmp	r0, #0
    1506:	ble.n	14f8 <MTPD::WriteDescriptor()+0xddc>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1508:	str.w	r8, [r4]
    150c:	b.n	14cc <MTPD::WriteDescriptor()+0xdb0>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    150e:	cmp	r3, #0
    1510:	beq.w	1758 <MTPD::WriteDescriptor()+0x103c>
    1514:	ldr	r4, [pc, #240]	; (1608 <MTPD::WriteDescriptor()+0xeec>)
    1516:	ldr	r0, [r4, #0]
        write_length_ += len;
    1518:	adds	r3, #2
    151a:	add.w	r6, r5, #1056	; 0x420
        
        const char * src=data;
    151e:	add.w	r9, sp, #28
        //
        int pos = 0; // into data
    1522:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1526:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1528:	add.w	sl, r5, #544	; 0x220
    152c:	b.n	1536 <MTPD::WriteDescriptor()+0xe1a>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    152e:	cmp.w	r8, #1
    1532:	bgt.n	1572 <MTPD::WriteDescriptor()+0xe56>
    1534:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1536:	subs	r7, r6, r0
    1538:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    153c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    153e:	cmp	r7, r3
    1540:	it	ge
    1542:	movge	r7, r3
          memcpy(dst,src,to_copy);
    1544:	mov	r2, r7
          pos += to_copy;
    1546:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1548:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    154c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    154e:	add	r9, r7
          dst += to_copy;
    1550:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1552:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1554:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1556:	bne.n	152e <MTPD::WriteDescriptor()+0xe12>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1558:	movs	r2, #60	; 0x3c
    155a:	mov.w	r1, #512	; 0x200
    155e:	mov	r0, sl
    1560:	bl	9d50 <usb_mtp_send>
    1564:	cmp	r0, #0
    1566:	ble.n	1558 <MTPD::WriteDescriptor()+0xe3c>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1568:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    156c:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1570:	ble.n	1534 <MTPD::WriteDescriptor()+0xe18>
    1572:	movs	r1, #7
    1574:	ldrb	r2, [r5, #0]
    1576:	ldr	r3, [r5, #4]
    1578:	strb.w	r1, [sp, #6]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    157c:	cmp	r2, #0
    157e:	bne.w	98a <MTPD::WriteDescriptor()+0x26e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1582:	cmp	r3, #0
    1584:	beq.w	174e <MTPD::WriteDescriptor()+0x1032>
    1588:	ldr	r0, [r4, #0]
        write_length_ += len;
    158a:	adds	r3, #1
        
        const char * src=data;
    158c:	add.w	r9, sp, #6
        //
        int pos = 0; // into data
    1590:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1594:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1598:	str	r3, [r5, #4]
    159a:	b.n	15a4 <MTPD::WriteDescriptor()+0xe88>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    159c:	cmp.w	r8, #0
    15a0:	bgt.n	15e0 <MTPD::WriteDescriptor()+0xec4>
    15a2:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    15a4:	subs	r7, r6, r0
    15a6:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    15aa:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    15ac:	cmp	r7, r3
    15ae:	it	ge
    15b0:	movge	r7, r3
          memcpy(dst,src,to_copy);
    15b2:	mov	r2, r7
          pos += to_copy;
    15b4:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    15b6:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    15ba:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    15bc:	add	r9, r7
          dst += to_copy;
    15be:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    15c0:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    15c2:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    15c4:	bne.n	159c <MTPD::WriteDescriptor()+0xe80>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    15c6:	movs	r2, #60	; 0x3c
    15c8:	mov.w	r1, #512	; 0x200
    15cc:	mov	r0, sl
    15ce:	bl	9d50 <usb_mtp_send>
    15d2:	cmp	r0, #0
    15d4:	ble.n	15c6 <MTPD::WriteDescriptor()+0xeaa>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    15d6:	cmp.w	r8, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    15da:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    15de:	ble.n	15a2 <MTPD::WriteDescriptor()+0xe86>
    15e0:	ldrb	r1, [r5, #0]
    15e2:	ldr	r3, [r5, #4]
    15e4:	b.w	990 <MTPD::WriteDescriptor()+0x274>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    15e8:	cmp	r3, #0
    15ea:	beq.w	172c <MTPD::WriteDescriptor()+0x1010>
    15ee:	ldr	r4, [pc, #24]	; (1608 <MTPD::WriteDescriptor()+0xeec>)
    15f0:	ldr	r0, [r4, #0]
        write_length_ += len;
    15f2:	adds	r3, #1
    15f4:	add.w	r9, r5, #1056	; 0x420
        
        const char * src=data;
    15f8:	add.w	r8, sp, #5
        //
        int pos = 0; // into data
    15fc:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    15fe:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1600:	add.w	sl, r5, #544	; 0x220
    1604:	b.n	1612 <MTPD::WriteDescriptor()+0xef6>
    1606:	nop
    1608:	.word	0x2000158c
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    160c:	cmp	r7, #0
    160e:	bgt.n	164e <MTPD::WriteDescriptor()+0xf32>
    1610:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1612:	rsb	r6, r0, r9
    1616:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    161a:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    161c:	cmp	r6, r3
    161e:	it	ge
    1620:	movge	r6, r3
          memcpy(dst,src,to_copy);
    1622:	mov	r2, r6
          pos += to_copy;
    1624:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1626:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    162a:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    162c:	add	r8, r6
          dst += to_copy;
    162e:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1630:	cmp	r6, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1632:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1634:	bne.n	160c <MTPD::WriteDescriptor()+0xef0>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1636:	movs	r2, #60	; 0x3c
    1638:	mov.w	r1, #512	; 0x200
    163c:	mov	r0, sl
    163e:	bl	9d50 <usb_mtp_send>
    1642:	cmp	r0, #0
    1644:	ble.n	1636 <MTPD::WriteDescriptor()+0xf1a>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1646:	cmp	r7, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1648:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    164c:	ble.n	1610 <MTPD::WriteDescriptor()+0xef4>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    164e:	ldrb.w	r6, [sp, #68]	; 0x44
    1652:	ldrb	r4, [r5, #0]
    1654:	ldr	r3, [r5, #4]
    1656:	cmp	r6, #0
    1658:	bne.w	a70 <MTPD::WriteDescriptor()+0x354>
    165c:	b.w	b22 <MTPD::WriteDescriptor()+0x406>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1660:	cmp	r3, #0
    1662:	beq.n	1720 <MTPD::WriteDescriptor()+0x1004>
    1664:	ldr	r4, [pc, #276]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    1666:	ldr	r0, [r4, #0]
        write_length_ += len;
    1668:	adds	r3, #2
    166a:	add.w	r9, r5, #1056	; 0x420
        
        const char * src=data;
    166e:	add.w	r8, sp, #32
        //
        int pos = 0; // into data
    1672:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1674:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1676:	add.w	sl, r5, #544	; 0x220
    167a:	b.n	1684 <MTPD::WriteDescriptor()+0xf68>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    167c:	cmp	r7, #1
    167e:	bgt.w	a36 <MTPD::WriteDescriptor()+0x31a>
    1682:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1684:	rsb	r6, r0, r9
    1688:	rsb	r3, r7, #2
          memcpy(dst,src,to_copy);
    168c:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    168e:	cmp	r6, r3
    1690:	it	ge
    1692:	movge	r6, r3
          memcpy(dst,src,to_copy);
    1694:	mov	r2, r6
          pos += to_copy;
    1696:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1698:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    169c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    169e:	add	r8, r6
          dst += to_copy;
    16a0:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    16a2:	cmp	r6, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    16a4:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    16a6:	bne.n	167c <MTPD::WriteDescriptor()+0xf60>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    16a8:	movs	r2, #60	; 0x3c
    16aa:	mov.w	r1, #512	; 0x200
    16ae:	mov	r0, sl
    16b0:	bl	9d50 <usb_mtp_send>
    16b4:	cmp	r0, #0
    16b6:	ble.n	16a8 <MTPD::WriteDescriptor()+0xf8c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    16b8:	str.w	sl, [r4]
    16bc:	b.n	167c <MTPD::WriteDescriptor()+0xf60>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    16be:	add.w	r2, r5, #544	; 0x220
    16c2:	mov	r0, r2
    16c4:	str	r2, [r4, #0]
    16c6:	b.n	1282 <MTPD::WriteDescriptor()+0xb66>
    16c8:	add.w	r2, r5, #544	; 0x220
    16cc:	mov	r0, r2
    16ce:	str	r2, [r4, #0]
    16d0:	b.n	1216 <MTPD::WriteDescriptor()+0xafa>
    16d2:	add.w	r2, r5, #544	; 0x220
    16d6:	mov	r0, r2
    16d8:	str	r2, [r4, #0]
    16da:	b.w	cd2 <MTPD::WriteDescriptor()+0x5b6>
    16de:	add.w	r2, r5, #544	; 0x220
    16e2:	mov	r0, r2
    16e4:	str	r2, [r4, #0]
    16e6:	b.n	10b6 <MTPD::WriteDescriptor()+0x99a>
    16e8:	add.w	r2, r5, #544	; 0x220
    16ec:	mov	r0, r2
    16ee:	str	r2, [r4, #0]
    16f0:	b.n	1048 <MTPD::WriteDescriptor()+0x92c>
    16f2:	add.w	r2, r5, #544	; 0x220
    16f6:	ldr	r4, [pc, #132]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    16f8:	mov	r0, r2
    16fa:	str	r2, [r4, #0]
    16fc:	b.n	134e <MTPD::WriteDescriptor()+0xc32>
    16fe:	add.w	r3, r5, #544	; 0x220
    1702:	ldr	r4, [pc, #120]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    1704:	mov	r0, r3
    1706:	str	r3, [r4, #0]
    1708:	b.n	12ee <MTPD::WriteDescriptor()+0xbd2>
    170a:	add.w	r3, r5, #544	; 0x220
    170e:	ldr	r4, [pc, #108]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    1710:	mov	r0, r3
    1712:	str	r3, [r4, #0]
    1714:	b.n	13e8 <MTPD::WriteDescriptor()+0xccc>
    1716:	add.w	r2, r5, #544	; 0x220
    171a:	mov	r0, r2
    171c:	str	r2, [r4, #0]
    171e:	b.n	f70 <MTPD::WriteDescriptor()+0x854>
    1720:	add.w	r2, r9, #544	; 0x220
    1724:	ldr	r4, [pc, #84]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    1726:	mov	r0, r2
    1728:	str	r2, [r4, #0]
    172a:	b.n	1668 <MTPD::WriteDescriptor()+0xf4c>
    172c:	add.w	r2, r5, #544	; 0x220
    1730:	ldr	r4, [pc, #72]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    1732:	mov	r0, r2
    1734:	str	r2, [r4, #0]
    1736:	b.n	15f2 <MTPD::WriteDescriptor()+0xed6>
    1738:	add.w	r2, r9, #544	; 0x220
    173c:	ldr	r4, [pc, #60]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    173e:	mov	r0, r2
    1740:	str	r2, [r4, #0]
    1742:	b.n	11a4 <MTPD::WriteDescriptor()+0xa88>
    1744:	add.w	r2, r5, #544	; 0x220
    1748:	mov	r0, r2
    174a:	str	r2, [r4, #0]
    174c:	b.n	1124 <MTPD::WriteDescriptor()+0xa08>
    174e:	add.w	r2, r5, #544	; 0x220
    1752:	mov	r0, r2
    1754:	str	r2, [r4, #0]
    1756:	b.n	158a <MTPD::WriteDescriptor()+0xe6e>
    1758:	add.w	r2, r9, #544	; 0x220
    175c:	ldr	r4, [pc, #28]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    175e:	mov	r0, r2
    1760:	str	r2, [r4, #0]
    1762:	b.n	1518 <MTPD::WriteDescriptor()+0xdfc>
    1764:	add.w	r2, r5, #544	; 0x220
    1768:	ldr	r4, [pc, #16]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    176a:	mov	r0, r2
    176c:	str	r2, [r4, #0]
    176e:	b.n	14b8 <MTPD::WriteDescriptor()+0xd9c>
    1770:	add.w	r2, r5, #544	; 0x220
    1774:	ldr	r4, [pc, #4]	; (177c <MTPD::WriteDescriptor()+0x1060>)
    1776:	mov	r0, r2
    1778:	str	r2, [r4, #0]
    177a:	b.n	145a <MTPD::WriteDescriptor()+0xd3e>
    177c:	.word	0x2000158c

00001780 <MTPD::GetStorageInfo(unsigned long)>:
    uint32_t num=1;//mFS_get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void GetStorageInfo(uint32_t storage) {
    1780:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32_t store = Storage2Store(storage);
    1784:	subs	r3, r1, #1
    uint32_t num=1;//mFS_get_FSCount();
    write32(num); // number of storages (disks)
    for(uint32_t ii=0;ii<num;ii++)  write32(Store2Storage(ii)); // storage id
  }

  void GetStorageInfo(uint32_t storage) {
    1786:	sub	sp, #60	; 0x3c
    1788:	movs	r2, #1
    178a:	mov	r6, r0
    uint32_t store = Storage2Store(storage);
    178c:	str	r3, [sp, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    178e:	ldrb	r3, [r0, #0]
    1790:	strh.w	r2, [sp, #30]
    1794:	cmp	r3, #0
    1796:	beq.w	18d6 <MTPD::GetStorageInfo(unsigned long)+0x156>
    179a:	movs	r2, #2
      {
        write_length_ += len;
    179c:	ldr	r3, [r0, #4]
    179e:	add	r3, r2
    17a0:	strh.w	r2, [sp, #28]
    17a4:	movs	r2, #0
    17a6:	adds	r3, #2
    17a8:	strh.w	r2, [sp, #26]
public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    uint32_t Next(uint32_t store) {return zFs[store].Next();}

    uint64_t size(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].rootSector()); }
    17ac:	ldr	r1, [sp, #4]
    17ae:	movw	r2, #10864	; 0x2a70
    17b2:	ldr.w	fp, [pc, #912]	; 1b44 <MTPD::GetStorageInfo(unsigned long)+0x3c4>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    17b6:	adds	r3, #2
public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    uint32_t Next(uint32_t store) {return zFs[store].Next();}

    uint64_t size(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].rootSector()); }
    17b8:	mul.w	r2, r2, r1
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    17bc:	str	r3, [r6, #4]
public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    uint32_t Next(uint32_t store) {return zFs[store].Next();}

    uint64_t size(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].rootSector()); }
    17be:	adds	r2, #80	; 0x50
    17c0:	add.w	r0, fp, r2
    17c4:	ldr.w	r2, [fp, r2]
    17c8:	ldr	r1, [r0, #24]
    uint64_t free(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].eofSector()); }
    17ca:	ldr	r0, [r0, #16]
public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    uint32_t Next(uint32_t store) {return zFs[store].Next();}

    uint64_t size(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].rootSector()); }
    17cc:	subs	r2, r1, r2
    uint64_t free(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].eofSector()); }
    17ce:	subs	r1, r1, r0
    17d0:	lsrs	r0, r2, #23
    17d2:	lsls	r2, r2, #9
    17d4:	str	r0, [sp, #52]	; 0x34
    17d6:	lsrs	r0, r1, #23
    17d8:	str	r2, [sp, #48]	; 0x30
    17da:	lsls	r2, r1, #9
    17dc:	str	r0, [sp, #12]
    17de:	str	r2, [sp, #8]
    17e0:	ldr	r2, [sp, #8]
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    17e2:	adds	r3, #8
    17e4:	str	r2, [sp, #40]	; 0x28
    17e6:	ldr	r2, [sp, #12]
    17e8:	str	r2, [sp, #44]	; 0x2c
    17ea:	mov.w	r2, #4294967295
    17ee:	adds	r3, #8
    17f0:	str	r2, [sp, #36]	; 0x24
    17f2:	adds	r7, r3, #4
    uint32_t Read(uint32_t handle, char* out, uint32_t count) ;

    uint64_t size()  {  return (uint64_t)512 *(uint64_t)(total_sectors - root_sector); }
    uint64_t free()  {  return (uint64_t)512 *(uint64_t)(total_sectors - eof_sector); }

    char * getName() {return name;}
    17f4:	movw	r9, #10864	; 0x2a70
    17f8:	ldr	r3, [sp, #4]
    17fa:	str	r7, [r6, #4]
    17fc:	mla	r9, r9, r3, fp

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    1800:	ldrb.w	r3, [r9, #110]	; 0x6e
    1804:	add.w	r9, r9, #110	; 0x6e
    1808:	cmp	r3, #0
    180a:	beq.n	18c4 <MTPD::GetStorageInfo(unsigned long)+0x144>
    { write8(strlen(str) + 1);
    180c:	mov	r0, r9
    180e:	bl	c080 <strlen>
    1812:	adds	r0, #1
    1814:	strb.w	r0, [sp, #25]
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    1818:	adds	r3, r7, #1
    181a:	str	r3, [r6, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    181c:	ldrb.w	r2, [r9]
    1820:	cmp	r2, #0
    1822:	beq.n	18c0 <MTPD::GetStorageInfo(unsigned long)+0x140>
    1824:	movs	r1, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1826:	add.w	sl, r6, #544	; 0x220
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    182a:	mov	r0, sl
    182c:	mov	sl, r6
    182e:	mov	r6, r0
    1830:	b.n	1840 <MTPD::GetStorageInfo(unsigned long)+0xc0>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    1832:	adds	r3, #2
    1834:	str.w	r3, [sl, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    1838:	ldrb.w	r2, [r9, #1]!
    183c:	cmp	r2, #0
    183e:	beq.n	18b2 <MTPD::GetStorageInfo(unsigned long)+0x132>
    1840:	strh.w	r2, [sp, #34]	; 0x22
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1844:	cmp	r1, #0
    1846:	bne.n	1832 <MTPD::GetStorageInfo(unsigned long)+0xb2>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1848:	ldr	r7, [pc, #756]	; (1b40 <MTPD::GetStorageInfo(unsigned long)+0x3c0>)
    184a:	cmp	r3, #0
    184c:	beq.n	18d0 <MTPD::GetStorageInfo(unsigned long)+0x150>
    184e:	ldr	r0, [r7, #0]
        write_length_ += len;
    1850:	adds	r3, #2
    1852:	add.w	fp, sl, #1056	; 0x420
        
        const char * src=data;
    1856:	add.w	r8, sp, #34	; 0x22
        //
        int pos = 0; // into data
    185a:	movs	r5, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    185c:	str.w	r3, [sl, #4]
    1860:	b.n	1868 <MTPD::GetStorageInfo(unsigned long)+0xe8>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1862:	cmp	r5, #1
    1864:	bgt.n	18a2 <MTPD::GetStorageInfo(unsigned long)+0x122>
    1866:	ldr	r0, [r7, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1868:	rsb	r4, r0, fp
    186c:	rsb	r3, r5, #2
          memcpy(dst,src,to_copy);
    1870:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1872:	cmp	r4, r3
    1874:	it	ge
    1876:	movge	r4, r3
          memcpy(dst,src,to_copy);
    1878:	mov	r2, r4
          pos += to_copy;
    187a:	add	r5, r4
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    187c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1880:	ldr	r3, [r7, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1882:	add	r8, r4
          dst += to_copy;
    1884:	add	r4, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1886:	cmp	r4, fp
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1888:	str	r4, [r7, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    188a:	bne.n	1862 <MTPD::GetStorageInfo(unsigned long)+0xe2>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    188c:	movs	r2, #60	; 0x3c
    188e:	mov.w	r1, #512	; 0x200
    1892:	mov	r0, r6
    1894:	bl	9d50 <usb_mtp_send>
    1898:	cmp	r0, #0
    189a:	ble.n	188c <MTPD::GetStorageInfo(unsigned long)+0x10c>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    189c:	cmp	r5, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    189e:	str	r6, [r7, #0]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    18a0:	ble.n	1866 <MTPD::GetStorageInfo(unsigned long)+0xe6>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    18a2:	ldrb.w	r2, [r9, #1]!
    18a6:	ldrb.w	r1, [sl]
    18aa:	ldr.w	r3, [sl, #4]
    18ae:	cmp	r2, #0
    18b0:	bne.n	1840 <MTPD::GetStorageInfo(unsigned long)+0xc0>
    18b2:	mov	r6, sl
    18b4:	movs	r2, #0
    18b6:	strh.w	r2, [sp, #32]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    18ba:	cmp	r1, #0
    18bc:	beq.w	1d3c <MTPD::GetStorageInfo(unsigned long)+0x5bc>
      {
        write_length_ += len;
    18c0:	adds	r3, #2
    18c2:	b.n	18c6 <MTPD::GetStorageInfo(unsigned long)+0x146>
    18c4:	adds	r3, r7, #1
    18c6:	adds	r3, #1
    18c8:	str	r3, [r6, #4]
    const char *name = mFS.getName(store);
    writestring(name);  // storage descriptor
    writestring("");  // volume identifier

    //printf("%d %d ",storage,store); Serial.println(name); Serial.flush();
  }
    18ca:	add	sp, #60	; 0x3c
    18cc:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    18d0:	mov	r0, r6
    18d2:	str	r6, [r7, #0]
    18d4:	b.n	1850 <MTPD::GetStorageInfo(unsigned long)+0xd0>
    18d6:	ldr	r3, [r0, #4]
    18d8:	cmp	r3, #0
    18da:	beq.w	1c2e <MTPD::GetStorageInfo(unsigned long)+0x4ae>
    18de:	ldr	r4, [pc, #608]	; (1b40 <MTPD::GetStorageInfo(unsigned long)+0x3c0>)
    18e0:	ldr	r0, [r4, #0]
        write_length_ += len;
    18e2:	adds	r3, #2
    18e4:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    18e8:	add.w	r9, sp, #30
        //
        int pos = 0; // into data
    18ec:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    18f0:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    18f2:	add.w	fp, r6, #544	; 0x220
    18f6:	b.n	1900 <MTPD::GetStorageInfo(unsigned long)+0x180>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    18f8:	cmp.w	r8, #1
    18fc:	bgt.n	193c <MTPD::GetStorageInfo(unsigned long)+0x1bc>
    18fe:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1900:	subs	r7, r5, r0
    1902:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    1906:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1908:	cmp	r7, r3
    190a:	it	ge
    190c:	movge	r7, r3
          memcpy(dst,src,to_copy);
    190e:	mov	r2, r7
          pos += to_copy;
    1910:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1912:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1916:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1918:	add	r9, r7
          dst += to_copy;
    191a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    191c:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    191e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1920:	bne.n	18f8 <MTPD::GetStorageInfo(unsigned long)+0x178>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1922:	movs	r2, #60	; 0x3c
    1924:	mov.w	r1, #512	; 0x200
    1928:	mov	r0, fp
    192a:	bl	9d50 <usb_mtp_send>
    192e:	cmp	r0, #0
    1930:	ble.n	1922 <MTPD::GetStorageInfo(unsigned long)+0x1a2>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1932:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1936:	str.w	fp, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    193a:	ble.n	18fe <MTPD::GetStorageInfo(unsigned long)+0x17e>
    193c:	movs	r1, #2
    193e:	ldrb	r2, [r6, #0]
    1940:	ldr	r3, [r6, #4]
    1942:	strh.w	r1, [sp, #28]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1946:	cmp	r2, #0
    1948:	bne.w	17a4 <MTPD::GetStorageInfo(unsigned long)+0x24>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    194c:	cmp	r3, #0
    194e:	beq.w	1d32 <MTPD::GetStorageInfo(unsigned long)+0x5b2>
    1952:	ldr	r0, [r4, #0]
        write_length_ += len;
    1954:	adds	r3, #2
        
        const char * src=data;
    1956:	add.w	r9, sp, #28
        //
        int pos = 0; // into data
    195a:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    195e:	add.w	fp, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1962:	str	r3, [r6, #4]
    1964:	b.n	196e <MTPD::GetStorageInfo(unsigned long)+0x1ee>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1966:	cmp.w	r8, #1
    196a:	bgt.n	19aa <MTPD::GetStorageInfo(unsigned long)+0x22a>
    196c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    196e:	subs	r7, r5, r0
    1970:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    1974:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1976:	cmp	r7, r3
    1978:	it	ge
    197a:	movge	r7, r3
          memcpy(dst,src,to_copy);
    197c:	mov	r2, r7
          pos += to_copy;
    197e:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1980:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1984:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1986:	add	r9, r7
          dst += to_copy;
    1988:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    198a:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    198c:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    198e:	bne.n	1966 <MTPD::GetStorageInfo(unsigned long)+0x1e6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1990:	movs	r2, #60	; 0x3c
    1992:	mov.w	r1, #512	; 0x200
    1996:	mov	r0, fp
    1998:	bl	9d50 <usb_mtp_send>
    199c:	cmp	r0, #0
    199e:	ble.n	1990 <MTPD::GetStorageInfo(unsigned long)+0x210>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    19a0:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    19a4:	str.w	fp, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    19a8:	ble.n	196c <MTPD::GetStorageInfo(unsigned long)+0x1ec>
    19aa:	movs	r1, #0
    19ac:	ldrb	r2, [r6, #0]
    19ae:	ldr	r3, [r6, #4]
    19b0:	strh.w	r1, [sp, #26]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    19b4:	cmp	r2, #0
    19b6:	bne.w	17ac <MTPD::GetStorageInfo(unsigned long)+0x2c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    19ba:	cmp	r3, #0
    19bc:	beq.w	1d28 <MTPD::GetStorageInfo(unsigned long)+0x5a8>
    19c0:	ldr	r0, [r4, #0]
        write_length_ += len;
    19c2:	adds	r3, #2
        
        const char * src=data;
    19c4:	add.w	r9, sp, #26
        //
        int pos = 0; // into data
    19c8:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    19cc:	add.w	fp, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    19d0:	str	r3, [r6, #4]
    19d2:	b.n	19dc <MTPD::GetStorageInfo(unsigned long)+0x25c>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    19d4:	cmp.w	r8, #1
    19d8:	bgt.n	1a18 <MTPD::GetStorageInfo(unsigned long)+0x298>
    19da:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    19dc:	subs	r7, r5, r0
    19de:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    19e2:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    19e4:	cmp	r7, r3
    19e6:	it	ge
    19e8:	movge	r7, r3
          memcpy(dst,src,to_copy);
    19ea:	mov	r2, r7
          pos += to_copy;
    19ec:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    19ee:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    19f2:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    19f4:	add	r9, r7
          dst += to_copy;
    19f6:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    19f8:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    19fa:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    19fc:	bne.n	19d4 <MTPD::GetStorageInfo(unsigned long)+0x254>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    19fe:	movs	r2, #60	; 0x3c
    1a00:	mov.w	r1, #512	; 0x200
    1a04:	mov	r0, fp
    1a06:	bl	9d50 <usb_mtp_send>
    1a0a:	cmp	r0, #0
    1a0c:	ble.n	19fe <MTPD::GetStorageInfo(unsigned long)+0x27e>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1a0e:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1a12:	str.w	fp, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1a16:	ble.n	19da <MTPD::GetStorageInfo(unsigned long)+0x25a>
public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    uint32_t Next(uint32_t store) {return zFs[store].Next();}

    uint64_t size(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].rootSector()); }
    1a18:	ldr	r3, [sp, #4]
    1a1a:	movw	r2, #10864	; 0x2a70
    1a1e:	ldr.w	fp, [pc, #292]	; 1b44 <MTPD::GetStorageInfo(unsigned long)+0x3c4>
    1a22:	mul.w	r2, r2, r3
    1a26:	ldrb	r1, [r6, #0]
    1a28:	ldr	r3, [r6, #4]
    1a2a:	adds	r2, #80	; 0x50
    1a2c:	add.w	r7, fp, r2
    1a30:	ldr.w	r2, [fp, r2]
    1a34:	ldr	r0, [r7, #24]
    uint64_t free(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].eofSector()); }
    1a36:	ldr	r7, [r7, #16]
public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    uint32_t Next(uint32_t store) {return zFs[store].Next();}

    uint64_t size(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].rootSector()); }
    1a38:	subs	r2, r0, r2
    uint64_t free(uint32_t store)  
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].eofSector()); }
    1a3a:	subs	r0, r0, r7
    1a3c:	lsrs	r7, r2, #23
    1a3e:	lsls	r2, r2, #9
    1a40:	str	r7, [sp, #52]	; 0x34
    1a42:	lsrs	r7, r0, #23
    1a44:	str	r2, [sp, #48]	; 0x30
    1a46:	lsls	r2, r0, #9
    1a48:	str	r7, [sp, #12]
    1a4a:	str	r2, [sp, #8]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1a4c:	cmp	r1, #0
    1a4e:	bne.w	17e0 <MTPD::GetStorageInfo(unsigned long)+0x60>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1a52:	cmp	r3, #0
    1a54:	beq.w	1d1e <MTPD::GetStorageInfo(unsigned long)+0x59e>
    1a58:	ldr	r0, [r4, #0]
        write_length_ += len;
    1a5a:	adds	r3, #8
        
        const char * src=data;
    1a5c:	add.w	r8, sp, #48	; 0x30
        //
        int pos = 0; // into data
    1a60:	movs	r7, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1a62:	add.w	r9, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1a66:	str	r3, [r6, #4]
    1a68:	b.n	1a70 <MTPD::GetStorageInfo(unsigned long)+0x2f0>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1a6a:	cmp	r7, #7
    1a6c:	bgt.n	1aac <MTPD::GetStorageInfo(unsigned long)+0x32c>
    1a6e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1a70:	rsb	sl, r0, r5
    1a74:	rsb	r3, r7, #8
          memcpy(dst,src,to_copy);
    1a78:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1a7a:	cmp	sl, r3
    1a7c:	it	ge
    1a7e:	movge	sl, r3
          memcpy(dst,src,to_copy);
    1a80:	mov	r2, sl
          pos += to_copy;
    1a82:	add	r7, sl
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1a84:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1a88:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1a8a:	add	r8, sl
          dst += to_copy;
    1a8c:	add	r3, sl
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1a8e:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1a90:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1a92:	bne.n	1a6a <MTPD::GetStorageInfo(unsigned long)+0x2ea>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1a94:	movs	r2, #60	; 0x3c
    1a96:	mov.w	r1, #512	; 0x200
    1a9a:	mov	r0, r9
    1a9c:	bl	9d50 <usb_mtp_send>
    1aa0:	cmp	r0, #0
    1aa2:	ble.n	1a94 <MTPD::GetStorageInfo(unsigned long)+0x314>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1aa4:	cmp	r7, #7
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1aa6:	str.w	r9, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1aaa:	ble.n	1a6e <MTPD::GetStorageInfo(unsigned long)+0x2ee>
    1aac:	ldr	r3, [sp, #8]
    1aae:	ldrb	r2, [r6, #0]
    1ab0:	str	r3, [sp, #40]	; 0x28
    1ab2:	ldr	r3, [sp, #12]
    1ab4:	str	r3, [sp, #44]	; 0x2c
    1ab6:	ldr	r3, [r6, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1ab8:	cmp	r2, #0
    1aba:	bne.w	17ea <MTPD::GetStorageInfo(unsigned long)+0x6a>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1abe:	cmp	r3, #0
    1ac0:	beq.w	1d14 <MTPD::GetStorageInfo(unsigned long)+0x594>
    1ac4:	ldr	r0, [r4, #0]
        write_length_ += len;
    1ac6:	adds	r3, #8
        
        const char * src=data;
    1ac8:	add.w	r8, sp, #40	; 0x28
        //
        int pos = 0; // into data
    1acc:	movs	r7, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1ace:	add.w	r9, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1ad2:	str	r3, [r6, #4]
    1ad4:	b.n	1adc <MTPD::GetStorageInfo(unsigned long)+0x35c>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1ad6:	cmp	r7, #7
    1ad8:	bgt.n	1b18 <MTPD::GetStorageInfo(unsigned long)+0x398>
    1ada:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1adc:	rsb	sl, r0, r5
    1ae0:	rsb	r3, r7, #8
          memcpy(dst,src,to_copy);
    1ae4:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1ae6:	cmp	sl, r3
    1ae8:	it	ge
    1aea:	movge	sl, r3
          memcpy(dst,src,to_copy);
    1aec:	mov	r2, sl
          pos += to_copy;
    1aee:	add	r7, sl
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1af0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1af4:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1af6:	add	r8, sl
          dst += to_copy;
    1af8:	add	r3, sl
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1afa:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1afc:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1afe:	bne.n	1ad6 <MTPD::GetStorageInfo(unsigned long)+0x356>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1b00:	movs	r2, #60	; 0x3c
    1b02:	mov.w	r1, #512	; 0x200
    1b06:	mov	r0, r9
    1b08:	bl	9d50 <usb_mtp_send>
    1b0c:	cmp	r0, #0
    1b0e:	ble.n	1b00 <MTPD::GetStorageInfo(unsigned long)+0x380>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1b10:	cmp	r7, #7
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1b12:	str.w	r9, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1b16:	ble.n	1ada <MTPD::GetStorageInfo(unsigned long)+0x35a>
    1b18:	mov.w	r1, #4294967295
    1b1c:	ldrb	r2, [r6, #0]
    1b1e:	ldr	r3, [r6, #4]
    1b20:	str	r1, [sp, #36]	; 0x24
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1b22:	cmp	r2, #0
    1b24:	bne.w	17f2 <MTPD::GetStorageInfo(unsigned long)+0x72>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1b28:	cmp	r3, #0
    1b2a:	beq.w	1c3a <MTPD::GetStorageInfo(unsigned long)+0x4ba>
    1b2e:	ldr	r0, [r4, #0]
        write_length_ += len;
    1b30:	adds	r3, #4
        
        const char * src=data;
    1b32:	add.w	r8, sp, #36	; 0x24
        //
        int pos = 0; // into data
    1b36:	movs	r7, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1b38:	add.w	r9, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1b3c:	str	r3, [r6, #4]
    1b3e:	b.n	1b4e <MTPD::GetStorageInfo(unsigned long)+0x3ce>
    1b40:	.word	0x2000158c
    1b44:	.word	0x20001594
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1b48:	cmp	r7, #3
    1b4a:	bgt.n	1b8a <MTPD::GetStorageInfo(unsigned long)+0x40a>
    1b4c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1b4e:	rsb	sl, r0, r5
    1b52:	rsb	r3, r7, #4
          memcpy(dst,src,to_copy);
    1b56:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1b58:	cmp	sl, r3
    1b5a:	it	ge
    1b5c:	movge	sl, r3
          memcpy(dst,src,to_copy);
    1b5e:	mov	r2, sl
          pos += to_copy;
    1b60:	add	r7, sl
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1b62:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1b66:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1b68:	add	r8, sl
          dst += to_copy;
    1b6a:	add	r3, sl
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1b6c:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1b6e:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1b70:	bne.n	1b48 <MTPD::GetStorageInfo(unsigned long)+0x3c8>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1b72:	movs	r2, #60	; 0x3c
    1b74:	mov.w	r1, #512	; 0x200
    1b78:	mov	r0, r9
    1b7a:	bl	9d50 <usb_mtp_send>
    1b7e:	cmp	r0, #0
    1b80:	ble.n	1b72 <MTPD::GetStorageInfo(unsigned long)+0x3f2>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1b82:	cmp	r7, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1b84:	str.w	r9, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1b88:	ble.n	1b4c <MTPD::GetStorageInfo(unsigned long)+0x3cc>
    1b8a:	movw	r3, #10864	; 0x2a70
    1b8e:	ldr	r2, [sp, #4]
    1b90:	ldrb.w	r8, [r6]
    1b94:	mla	sl, r3, r2, fp
    1b98:	ldr	r7, [r6, #4]
    1b9a:	add.w	r3, sl, #104	; 0x68
    1b9e:	mov	r1, r3
    1ba0:	str	r3, [sp, #4]

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    1ba2:	ldrb	r3, [r3, #6]
    1ba4:	add.w	r9, r1, #6
    1ba8:	cmp	r3, #0
    1baa:	beq.n	1c44 <MTPD::GetStorageInfo(unsigned long)+0x4c4>
    { write8(strlen(str) + 1);
    1bac:	mov	r0, r9
    1bae:	bl	c080 <strlen>
    1bb2:	adds	r0, #1
    1bb4:	strb.w	r0, [sp, #25]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1bb8:	cmp.w	r8, #0
    1bbc:	bne.w	1818 <MTPD::GetStorageInfo(unsigned long)+0x98>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1bc0:	cmp	r7, #0
    1bc2:	beq.w	1db8 <MTPD::GetStorageInfo(unsigned long)+0x638>
    1bc6:	ldr	r0, [r4, #0]
        write_length_ += len;
    1bc8:	adds	r3, r7, #1
        
        const char * src=data;
    1bca:	add.w	fp, sp, #25
        //
        int pos = 0; // into data
    1bce:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1bd2:	add.w	r7, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1bd6:	str	r3, [r6, #4]
    1bd8:	b.n	1be2 <MTPD::GetStorageInfo(unsigned long)+0x462>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1bda:	cmp.w	r8, #0
    1bde:	bgt.n	1c1e <MTPD::GetStorageInfo(unsigned long)+0x49e>
    1be0:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1be2:	rsb	sl, r0, r5
    1be6:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    1bea:	mov	r1, fp
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1bec:	cmp	sl, r3
    1bee:	it	ge
    1bf0:	movge	sl, r3
          memcpy(dst,src,to_copy);
    1bf2:	mov	r2, sl
          pos += to_copy;
    1bf4:	add	r8, sl
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1bf6:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1bfa:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1bfc:	add	fp, sl
          dst += to_copy;
    1bfe:	add	r3, sl
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1c00:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1c02:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1c04:	bne.n	1bda <MTPD::GetStorageInfo(unsigned long)+0x45a>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1c06:	movs	r2, #60	; 0x3c
    1c08:	mov.w	r1, #512	; 0x200
    1c0c:	mov	r0, r7
    1c0e:	bl	9d50 <usb_mtp_send>
    1c12:	cmp	r0, #0
    1c14:	ble.n	1c06 <MTPD::GetStorageInfo(unsigned long)+0x486>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1c16:	cmp.w	r8, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1c1a:	str	r7, [r4, #0]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1c1c:	ble.n	1be0 <MTPD::GetStorageInfo(unsigned long)+0x460>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    1c1e:	ldr	r3, [sp, #4]
    1c20:	ldrb	r1, [r6, #0]
    1c22:	ldrb	r2, [r3, #6]
    1c24:	ldr	r3, [r6, #4]
    1c26:	cmp	r2, #0
    1c28:	bne.w	1826 <MTPD::GetStorageInfo(unsigned long)+0xa6>
    1c2c:	b.n	18b4 <MTPD::GetStorageInfo(unsigned long)+0x134>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1c2e:	add.w	r2, r0, #544	; 0x220
    1c32:	ldr	r4, [pc, #400]	; (1dc4 <MTPD::GetStorageInfo(unsigned long)+0x644>)
    1c34:	mov	r0, r2
    1c36:	str	r2, [r4, #0]
    1c38:	b.n	18e2 <MTPD::GetStorageInfo(unsigned long)+0x162>
    1c3a:	add.w	r2, r6, #544	; 0x220
    1c3e:	mov	r0, r2
    1c40:	str	r2, [r4, #0]
    1c42:	b.n	1b30 <MTPD::GetStorageInfo(unsigned long)+0x3b0>
    1c44:	strb.w	r3, [sp, #24]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1c48:	cmp.w	r8, #0
    1c4c:	bne.w	18c4 <MTPD::GetStorageInfo(unsigned long)+0x144>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1c50:	cmp	r7, #0
    1c52:	beq.w	1da2 <MTPD::GetStorageInfo(unsigned long)+0x622>
    1c56:	ldr	r0, [r4, #0]
        write_length_ += len;
    1c58:	adds	r3, r7, #1
        
        const char * src=data;
    1c5a:	add.w	r9, sp, #24
        //
        int pos = 0; // into data
    1c5e:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1c62:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1c66:	str	r3, [r6, #4]
    1c68:	b.n	1c72 <MTPD::GetStorageInfo(unsigned long)+0x4f2>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1c6a:	cmp.w	r8, #0
    1c6e:	bgt.n	1cae <MTPD::GetStorageInfo(unsigned long)+0x52e>
    1c70:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1c72:	subs	r7, r5, r0
    1c74:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    1c78:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1c7a:	cmp	r7, r3
    1c7c:	it	ge
    1c7e:	movge	r7, r3
          memcpy(dst,src,to_copy);
    1c80:	mov	r2, r7
          pos += to_copy;
    1c82:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1c84:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1c88:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1c8a:	add	r9, r7
          dst += to_copy;
    1c8c:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1c8e:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1c90:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1c92:	bne.n	1c6a <MTPD::GetStorageInfo(unsigned long)+0x4ea>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1c94:	movs	r2, #60	; 0x3c
    1c96:	mov.w	r1, #512	; 0x200
    1c9a:	mov	r0, sl
    1c9c:	bl	9d50 <usb_mtp_send>
    1ca0:	cmp	r0, #0
    1ca2:	ble.n	1c94 <MTPD::GetStorageInfo(unsigned long)+0x514>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1ca4:	cmp.w	r8, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1ca8:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1cac:	ble.n	1c70 <MTPD::GetStorageInfo(unsigned long)+0x4f0>
    1cae:	movs	r2, #0
    1cb0:	ldrb	r1, [r6, #0]
    1cb2:	ldr	r3, [r6, #4]
    1cb4:	strb.w	r2, [sp, #23]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1cb8:	cmp	r1, #0
    1cba:	bne.w	18c6 <MTPD::GetStorageInfo(unsigned long)+0x146>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1cbe:	cmp	r3, #0
    1cc0:	beq.n	1d98 <MTPD::GetStorageInfo(unsigned long)+0x618>
    1cc2:	ldr	r0, [r4, #0]
        write_length_ += len;
    1cc4:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1cc6:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    1cca:	add.w	r8, sp, #23
        //
        int pos = 0; // into data
    1cce:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1cd0:	str	r3, [r6, #4]
    1cd2:	b.n	1cdc <MTPD::GetStorageInfo(unsigned long)+0x55c>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1cd4:	cmp	r7, #0
    1cd6:	bgt.w	18ca <MTPD::GetStorageInfo(unsigned long)+0x14a>
    1cda:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1cdc:	subs	r6, r5, r0
    1cde:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    1ce2:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1ce4:	cmp	r6, r3
    1ce6:	it	ge
    1ce8:	movge	r6, r3
          memcpy(dst,src,to_copy);
    1cea:	mov	r2, r6
          pos += to_copy;
    1cec:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1cee:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1cf2:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1cf4:	add	r8, r6
          dst += to_copy;
    1cf6:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1cf8:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1cfa:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1cfc:	bne.n	1cd4 <MTPD::GetStorageInfo(unsigned long)+0x554>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1cfe:	movs	r2, #60	; 0x3c
    1d00:	mov.w	r1, #512	; 0x200
    1d04:	mov	r0, r9
    1d06:	bl	9d50 <usb_mtp_send>
    1d0a:	cmp	r0, #0
    1d0c:	ble.n	1cfe <MTPD::GetStorageInfo(unsigned long)+0x57e>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1d0e:	str.w	r9, [r4]
    1d12:	b.n	1cd4 <MTPD::GetStorageInfo(unsigned long)+0x554>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1d14:	add.w	r2, r6, #544	; 0x220
    1d18:	mov	r0, r2
    1d1a:	str	r2, [r4, #0]
    1d1c:	b.n	1ac6 <MTPD::GetStorageInfo(unsigned long)+0x346>
    1d1e:	add.w	r2, r6, #544	; 0x220
    1d22:	mov	r0, r2
    1d24:	str	r2, [r4, #0]
    1d26:	b.n	1a5a <MTPD::GetStorageInfo(unsigned long)+0x2da>
    1d28:	add.w	r2, r6, #544	; 0x220
    1d2c:	mov	r0, r2
    1d2e:	str	r2, [r4, #0]
    1d30:	b.n	19c2 <MTPD::GetStorageInfo(unsigned long)+0x242>
    1d32:	add.w	r2, r6, #544	; 0x220
    1d36:	mov	r0, r2
    1d38:	str	r2, [r4, #0]
    1d3a:	b.n	1954 <MTPD::GetStorageInfo(unsigned long)+0x1d4>
    1d3c:	cbz	r3, 1dac <MTPD::GetStorageInfo(unsigned long)+0x62c>
    1d3e:	ldr	r4, [pc, #132]	; (1dc4 <MTPD::GetStorageInfo(unsigned long)+0x644>)
    1d40:	ldr	r0, [r4, #0]
        write_length_ += len;
    1d42:	adds	r3, #2
    1d44:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    1d48:	add.w	r9, sp, #32
        //
        int pos = 0; // into data
    1d4c:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1d50:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1d52:	add.w	sl, r6, #544	; 0x220
    1d56:	b.n	1d60 <MTPD::GetStorageInfo(unsigned long)+0x5e0>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1d58:	cmp.w	r8, #1
    1d5c:	bgt.n	1cae <MTPD::GetStorageInfo(unsigned long)+0x52e>
    1d5e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1d60:	subs	r7, r5, r0
    1d62:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    1d66:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1d68:	cmp	r7, r3
    1d6a:	it	ge
    1d6c:	movge	r7, r3
          memcpy(dst,src,to_copy);
    1d6e:	mov	r2, r7
          pos += to_copy;
    1d70:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1d72:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1d76:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1d78:	add	r9, r7
          dst += to_copy;
    1d7a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1d7c:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1d7e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1d80:	bne.n	1d58 <MTPD::GetStorageInfo(unsigned long)+0x5d8>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1d82:	movs	r2, #60	; 0x3c
    1d84:	mov.w	r1, #512	; 0x200
    1d88:	mov	r0, sl
    1d8a:	bl	9d50 <usb_mtp_send>
    1d8e:	cmp	r0, #0
    1d90:	ble.n	1d82 <MTPD::GetStorageInfo(unsigned long)+0x602>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1d92:	str.w	sl, [r4]
    1d96:	b.n	1d58 <MTPD::GetStorageInfo(unsigned long)+0x5d8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1d98:	add.w	r2, r6, #544	; 0x220
    1d9c:	mov	r0, r2
    1d9e:	str	r2, [r4, #0]
    1da0:	b.n	1cc4 <MTPD::GetStorageInfo(unsigned long)+0x544>
    1da2:	add.w	r3, r6, #544	; 0x220
    1da6:	mov	r0, r3
    1da8:	str	r3, [r4, #0]
    1daa:	b.n	1c58 <MTPD::GetStorageInfo(unsigned long)+0x4d8>
    1dac:	add.w	r2, r6, #544	; 0x220
    1db0:	ldr	r4, [pc, #16]	; (1dc4 <MTPD::GetStorageInfo(unsigned long)+0x644>)
    1db2:	mov	r0, r2
    1db4:	str	r2, [r4, #0]
    1db6:	b.n	1d42 <MTPD::GetStorageInfo(unsigned long)+0x5c2>
    1db8:	add.w	r3, r6, #544	; 0x220
    1dbc:	mov	r0, r3
    1dbe:	str	r3, [r4, #0]
    1dc0:	b.n	1bc8 <MTPD::GetStorageInfo(unsigned long)+0x448>
    1dc2:	nop
    1dc4:	.word	0x2000158c

00001dc8 <MTPD::GetObjectInfo(unsigned long)>:
      uint32_t handle;
      while((handle=mFS.Next(store))) write32(handle);
    }
    return;
  }
  void GetObjectInfo(uint32_t handle) 
    1dc8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1dcc:	sub	sp, #348	; 0x15c
    1dce:	mov	r7, r0
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].eofSector()); }

    char * getName(uint32_t store) {return zFs[store].getName();}

    uint32_t Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
    { return zFs[0].Info(handle, filename, size, parent);}
    1dd0:	ldr	r0, [pc, #724]	; (20a8 <MTPD::GetObjectInfo(unsigned long)+0x2e0>)
    1dd2:	add	r6, sp, #40	; 0x28
    1dd4:	add	r3, sp, #36	; 0x24
    1dd6:	add	r2, sp, #88	; 0x58
    1dd8:	str	r6, [sp, #0]
    1dda:	bl	6d64 <zeroFS_class::Info(unsigned long, char*, unsigned long*, unsigned long*)>
    1dde:	movs	r2, #1
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1de0:	ldrb	r3, [r7, #0]
    1de2:	str	r2, [sp, #44]	; 0x2c
    1de4:	cmp	r3, #0
    1de6:	beq.w	1f2c <MTPD::GetObjectInfo(unsigned long)+0x164>
      {
        write_length_ += len;
    1dea:	ldr	r3, [r7, #4]
    Serial.println(parent,HEX);
    #endif

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    1dec:	ldr	r2, [sp, #36]	; 0x24
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    1dee:	adds	r3, #4
    Serial.println(parent,HEX);
    #endif

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    1df0:	adds	r2, #1
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    1df2:	str	r3, [r7, #4]
    Serial.println(parent,HEX);
    #endif

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    1df4:	beq.w	2656 <MTPD::GetObjectInfo(unsigned long)+0x88e>
    1df8:	movs	r2, #0
    1dfa:	strh.w	r2, [sp, #28]
    1dfe:	movs	r2, #0
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    1e00:	adds	r3, #2
    1e02:	strh.w	r2, [sp, #26]
    1e06:	ldr	r2, [sp, #36]	; 0x24
    1e08:	adds	r3, #2
    1e0a:	str	r2, [sp, #76]	; 0x4c
    1e0c:	movs	r2, #0
    1e0e:	adds	r3, #4
    1e10:	strh.w	r2, [sp, #24]
    1e14:	movs	r2, #0
    1e16:	adds	r3, #2
    1e18:	str	r2, [sp, #72]	; 0x48
    1e1a:	movs	r2, #0
    1e1c:	adds	r3, #4
    1e1e:	str	r2, [sp, #68]	; 0x44
    1e20:	movs	r2, #0
    1e22:	adds	r3, #4
    1e24:	str	r2, [sp, #64]	; 0x40
    1e26:	movs	r2, #0
    1e28:	adds	r3, #4
    1e2a:	str	r2, [sp, #60]	; 0x3c
    1e2c:	movs	r2, #0
    1e2e:	adds	r3, #4
    1e30:	str	r2, [sp, #56]	; 0x38
    1e32:	movs	r2, #0
    1e34:	adds	r3, #4
    1e36:	str	r2, [sp, #52]	; 0x34
    1e38:	ldr	r2, [r6, #0]
    1e3a:	adds	r3, #4
    1e3c:	str	r2, [sp, #48]	; 0x30
    1e3e:	ldr	r2, [sp, #36]	; 0x24
    1e40:	adds	r3, #4
    1e42:	sub.w	r2, r2, #4294967295
    1e46:	clz	r2, r2
    1e4a:	lsrs	r2, r2, #5
    1e4c:	strh.w	r2, [sp, #30]
    1e50:	movs	r2, #0
    1e52:	adds	r3, #2
    1e54:	str	r2, [sp, #84]	; 0x54
    1e56:	movs	r2, #0
    1e58:	adds	r3, #4
    1e5a:	str	r2, [sp, #80]	; 0x50
    1e5c:	adds	r6, r3, #4

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    1e5e:	ldrb.w	r2, [sp, #88]	; 0x58
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    1e62:	str	r6, [r7, #4]

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    1e64:	cmp	r2, #0
    1e66:	beq.n	1f14 <MTPD::GetObjectInfo(unsigned long)+0x14c>
    { write8(strlen(str) + 1);
    1e68:	add	r0, sp, #88	; 0x58
    1e6a:	str	r2, [sp, #12]
    1e6c:	bl	c080 <strlen>
    1e70:	ldr	r2, [sp, #12]
    1e72:	adds	r0, #1
    1e74:	strb.w	r0, [sp, #23]
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    1e78:	adds	r3, r6, #1
    1e7a:	movs	r1, #1
    1e7c:	str	r3, [r7, #4]
    1e7e:	add.w	sl, sp, #88	; 0x58
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1e82:	add.w	r9, r7, #544	; 0x220
    1e86:	b.n	1e94 <MTPD::GetObjectInfo(unsigned long)+0xcc>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    1e88:	adds	r3, #2
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    1e8a:	ldrb.w	r2, [sl, #1]!
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    1e8e:	str	r3, [r7, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    1e90:	cmp	r2, #0
    1e92:	beq.n	1f04 <MTPD::GetObjectInfo(unsigned long)+0x13c>
    1e94:	strh.w	r2, [sp, #34]	; 0x22
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1e98:	cmp	r1, #0
    1e9a:	bne.n	1e88 <MTPD::GetObjectInfo(unsigned long)+0xc0>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1e9c:	ldr	r4, [pc, #524]	; (20ac <MTPD::GetObjectInfo(unsigned long)+0x2e4>)
    1e9e:	cmp	r3, #0
    1ea0:	beq.n	1f24 <MTPD::GetObjectInfo(unsigned long)+0x15c>
    1ea2:	ldr	r0, [r4, #0]
        write_length_ += len;
    1ea4:	adds	r3, #2
    1ea6:	add.w	r8, r7, #1056	; 0x420
        
        const char * src=data;
    1eaa:	add.w	r6, sp, #34	; 0x22
        //
        int pos = 0; // into data
    1eae:	movs	r5, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1eb0:	str	r3, [r7, #4]
    1eb2:	b.n	1eba <MTPD::GetObjectInfo(unsigned long)+0xf2>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1eb4:	cmp	r5, #1
    1eb6:	bgt.n	1ef8 <MTPD::GetObjectInfo(unsigned long)+0x130>
    1eb8:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1eba:	rsb	r2, r0, r8
    1ebe:	rsb	r3, r5, #2
          memcpy(dst,src,to_copy);
    1ec2:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1ec4:	cmp	r2, r3
    1ec6:	it	ge
    1ec8:	movge	r2, r3
    1eca:	mov	fp, r2
          memcpy(dst,src,to_copy);
          pos += to_copy;
    1ecc:	add	r5, r2
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1ece:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1ed2:	ldr	r2, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1ed4:	add	r6, fp
          dst += to_copy;
    1ed6:	add.w	r3, r2, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1eda:	cmp	r3, r8
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1edc:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1ede:	bne.n	1eb4 <MTPD::GetObjectInfo(unsigned long)+0xec>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1ee0:	movs	r2, #60	; 0x3c
    1ee2:	mov.w	r1, #512	; 0x200
    1ee6:	mov	r0, r9
    1ee8:	bl	9d50 <usb_mtp_send>
    1eec:	cmp	r0, #0
    1eee:	ble.n	1ee0 <MTPD::GetObjectInfo(unsigned long)+0x118>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1ef0:	cmp	r5, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1ef2:	str.w	r9, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1ef6:	ble.n	1eb8 <MTPD::GetObjectInfo(unsigned long)+0xf0>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    1ef8:	ldrb.w	r2, [sl, #1]!
    1efc:	ldrb	r1, [r7, #0]
    1efe:	ldr	r3, [r7, #4]
    1f00:	cmp	r2, #0
    1f02:	bne.n	1e94 <MTPD::GetObjectInfo(unsigned long)+0xcc>
    1f04:	movs	r2, #0
    1f06:	strh.w	r2, [sp, #32]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1f0a:	cmp	r1, #0
    1f0c:	beq.w	2864 <MTPD::GetObjectInfo(unsigned long)+0xa9c>
      {
        write_length_ += len;
    1f10:	adds	r3, #2
    1f12:	b.n	1f16 <MTPD::GetObjectInfo(unsigned long)+0x14e>
    1f14:	adds	r3, r6, #1
    1f16:	adds	r3, #1
    1f18:	adds	r3, #1
    1f1a:	adds	r3, #1
    1f1c:	str	r3, [r7, #4]
    write32(0);  // sequence number
    writestring(filename);
    writestring("");  // date created
    writestring("");  // date modified
    writestring("");  // keywords
  }
    1f1e:	add	sp, #348	; 0x15c
    1f20:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1f24:	mov	r0, r9
    1f26:	str.w	r9, [r4]
    1f2a:	b.n	1ea4 <MTPD::GetObjectInfo(unsigned long)+0xdc>
    1f2c:	ldr	r3, [r7, #4]
    1f2e:	cmp	r3, #0
    1f30:	beq.w	264a <MTPD::GetObjectInfo(unsigned long)+0x882>
    1f34:	ldr	r4, [pc, #372]	; (20ac <MTPD::GetObjectInfo(unsigned long)+0x2e4>)
    1f36:	ldr	r0, [r4, #0]
        write_length_ += len;
    1f38:	adds	r3, #4
        
        const char * src=data;
    1f3a:	add.w	sl, sp, #44	; 0x2c
    1f3e:	add.w	r5, r7, #1056	; 0x420
        //
        int pos = 0; // into data
    1f42:	mov.w	r9, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1f46:	str	r3, [r7, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1f48:	add.w	fp, r7, #544	; 0x220
    1f4c:	b.n	1f56 <MTPD::GetObjectInfo(unsigned long)+0x18e>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1f4e:	cmp.w	r9, #3
    1f52:	bgt.n	1f94 <MTPD::GetObjectInfo(unsigned long)+0x1cc>
    1f54:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1f56:	rsb	r8, r0, r5
    1f5a:	rsb	r3, r9, #4
          memcpy(dst,src,to_copy);
    1f5e:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1f60:	cmp	r8, r3
    1f62:	it	ge
    1f64:	movge	r8, r3
          memcpy(dst,src,to_copy);
    1f66:	mov	r2, r8
          pos += to_copy;
    1f68:	add	r9, r8
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1f6a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1f6e:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1f70:	add	sl, r8
          dst += to_copy;
    1f72:	add	r3, r8
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1f74:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1f76:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1f78:	bne.n	1f4e <MTPD::GetObjectInfo(unsigned long)+0x186>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1f7a:	movs	r2, #60	; 0x3c
    1f7c:	mov.w	r1, #512	; 0x200
    1f80:	mov	r0, fp
    1f82:	bl	9d50 <usb_mtp_send>
    1f86:	cmp	r0, #0
    1f88:	ble.n	1f7a <MTPD::GetObjectInfo(unsigned long)+0x1b2>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1f8a:	cmp.w	r9, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    1f8e:	str.w	fp, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1f92:	ble.n	1f54 <MTPD::GetObjectInfo(unsigned long)+0x18c>
    Serial.println(parent,HEX);
    #endif

    uint32_t storage = Store2Storage(store);
    write32(storage); // storage
    write16(size == 0xFFFFFFFFUL ? 0x3001 : 0x0000); // format
    1f94:	ldr	r3, [sp, #36]	; 0x24
    1f96:	movw	r2, #12289	; 0x3001
    1f9a:	ldrb	r1, [r7, #0]
    1f9c:	adds	r3, #1
    1f9e:	ldr	r3, [r7, #4]
    1fa0:	it	ne
    1fa2:	movne	r2, #0
    1fa4:	strh.w	r2, [sp, #28]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    1fa8:	cmp	r1, #0
    1faa:	bne.w	1dfe <MTPD::GetObjectInfo(unsigned long)+0x36>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    1fae:	cmp	r3, #0
    1fb0:	beq.w	28d0 <MTPD::GetObjectInfo(unsigned long)+0xb08>
    1fb4:	ldr	r0, [r4, #0]
        write_length_ += len;
    1fb6:	adds	r3, #2
        
        const char * src=data;
    1fb8:	add.w	r9, sp, #28
        //
        int pos = 0; // into data
    1fbc:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    1fc0:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    1fc4:	str	r3, [r7, #4]
    1fc6:	b.n	1fd0 <MTPD::GetObjectInfo(unsigned long)+0x208>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    1fc8:	cmp.w	r8, #1
    1fcc:	bgt.n	200e <MTPD::GetObjectInfo(unsigned long)+0x246>
    1fce:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1fd0:	rsb	fp, r0, r5
    1fd4:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    1fd8:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    1fda:	cmp	fp, r3
    1fdc:	it	ge
    1fde:	movge	fp, r3
          memcpy(dst,src,to_copy);
    1fe0:	mov	r2, fp
          pos += to_copy;
    1fe2:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    1fe4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1fe8:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    1fea:	add	r9, fp
          dst += to_copy;
    1fec:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1fee:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    1ff0:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    1ff2:	bne.n	1fc8 <MTPD::GetObjectInfo(unsigned long)+0x200>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    1ff4:	movs	r2, #60	; 0x3c
    1ff6:	mov.w	r1, #512	; 0x200
    1ffa:	mov	r0, sl
    1ffc:	bl	9d50 <usb_mtp_send>
    2000:	cmp	r0, #0
    2002:	ble.n	1ff4 <MTPD::GetObjectInfo(unsigned long)+0x22c>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2004:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2008:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    200c:	ble.n	1fce <MTPD::GetObjectInfo(unsigned long)+0x206>
    200e:	movs	r3, #0
    2010:	ldrb	r2, [r7, #0]
    2012:	strh.w	r3, [sp, #26]
    2016:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2018:	cmp	r2, #0
    201a:	bne.w	1e06 <MTPD::GetObjectInfo(unsigned long)+0x3e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    201e:	cmp	r3, #0
    2020:	beq.w	28c4 <MTPD::GetObjectInfo(unsigned long)+0xafc>
    2024:	ldr	r0, [r4, #0]
        write_length_ += len;
    2026:	adds	r3, #2
        
        const char * src=data;
    2028:	add.w	r9, sp, #26
        //
        int pos = 0; // into data
    202c:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2030:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2034:	str	r3, [r7, #4]
    2036:	b.n	2040 <MTPD::GetObjectInfo(unsigned long)+0x278>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2038:	cmp.w	r8, #1
    203c:	bgt.n	207e <MTPD::GetObjectInfo(unsigned long)+0x2b6>
    203e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2040:	rsb	fp, r0, r5
    2044:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2048:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    204a:	cmp	fp, r3
    204c:	it	ge
    204e:	movge	fp, r3
          memcpy(dst,src,to_copy);
    2050:	mov	r2, fp
          pos += to_copy;
    2052:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2054:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2058:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    205a:	add	r9, fp
          dst += to_copy;
    205c:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    205e:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2060:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2062:	bne.n	2038 <MTPD::GetObjectInfo(unsigned long)+0x270>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2064:	movs	r2, #60	; 0x3c
    2066:	mov.w	r1, #512	; 0x200
    206a:	mov	r0, sl
    206c:	bl	9d50 <usb_mtp_send>
    2070:	cmp	r0, #0
    2072:	ble.n	2064 <MTPD::GetObjectInfo(unsigned long)+0x29c>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2074:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2078:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    207c:	ble.n	203e <MTPD::GetObjectInfo(unsigned long)+0x276>
    207e:	ldr	r3, [sp, #36]	; 0x24
    2080:	ldrb	r2, [r7, #0]
    2082:	str	r3, [sp, #76]	; 0x4c
    2084:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2086:	cmp	r2, #0
    2088:	bne.w	1e0c <MTPD::GetObjectInfo(unsigned long)+0x44>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    208c:	cmp	r3, #0
    208e:	beq.w	28fa <MTPD::GetObjectInfo(unsigned long)+0xb32>
    2092:	ldr	r0, [r4, #0]
        write_length_ += len;
    2094:	adds	r3, #4
        
        const char * src=data;
    2096:	add.w	r9, sp, #76	; 0x4c
        //
        int pos = 0; // into data
    209a:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    209e:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    20a2:	str	r3, [r7, #4]
    20a4:	b.n	20b8 <MTPD::GetObjectInfo(unsigned long)+0x2f0>
    20a6:	nop
    20a8:	.word	0x200015e4
    20ac:	.word	0x2000158c
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    20b0:	cmp.w	r8, #3
    20b4:	bgt.n	20f6 <MTPD::GetObjectInfo(unsigned long)+0x32e>
    20b6:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    20b8:	rsb	fp, r0, r5
    20bc:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    20c0:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    20c2:	cmp	fp, r3
    20c4:	it	ge
    20c6:	movge	fp, r3
          memcpy(dst,src,to_copy);
    20c8:	mov	r2, fp
          pos += to_copy;
    20ca:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    20cc:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    20d0:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    20d2:	add	r9, fp
          dst += to_copy;
    20d4:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    20d6:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    20d8:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    20da:	bne.n	20b0 <MTPD::GetObjectInfo(unsigned long)+0x2e8>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    20dc:	movs	r2, #60	; 0x3c
    20de:	mov.w	r1, #512	; 0x200
    20e2:	mov	r0, sl
    20e4:	bl	9d50 <usb_mtp_send>
    20e8:	cmp	r0, #0
    20ea:	ble.n	20dc <MTPD::GetObjectInfo(unsigned long)+0x314>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    20ec:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    20f0:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    20f4:	ble.n	20b6 <MTPD::GetObjectInfo(unsigned long)+0x2ee>
    20f6:	movs	r3, #0
    20f8:	ldrb	r2, [r7, #0]
    20fa:	strh.w	r3, [sp, #24]
    20fe:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2100:	cmp	r2, #0
    2102:	bne.w	1e14 <MTPD::GetObjectInfo(unsigned long)+0x4c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2106:	cmp	r3, #0
    2108:	beq.w	28f0 <MTPD::GetObjectInfo(unsigned long)+0xb28>
    210c:	ldr	r0, [r4, #0]
        write_length_ += len;
    210e:	adds	r3, #2
        
        const char * src=data;
    2110:	add.w	r9, sp, #24
        //
        int pos = 0; // into data
    2114:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2118:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    211c:	str	r3, [r7, #4]
    211e:	b.n	2128 <MTPD::GetObjectInfo(unsigned long)+0x360>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2120:	cmp.w	r8, #1
    2124:	bgt.n	2166 <MTPD::GetObjectInfo(unsigned long)+0x39e>
    2126:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2128:	rsb	fp, r0, r5
    212c:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2130:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2132:	cmp	fp, r3
    2134:	it	ge
    2136:	movge	fp, r3
          memcpy(dst,src,to_copy);
    2138:	mov	r2, fp
          pos += to_copy;
    213a:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    213c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2140:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2142:	add	r9, fp
          dst += to_copy;
    2144:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2146:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2148:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    214a:	bne.n	2120 <MTPD::GetObjectInfo(unsigned long)+0x358>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    214c:	movs	r2, #60	; 0x3c
    214e:	mov.w	r1, #512	; 0x200
    2152:	mov	r0, sl
    2154:	bl	9d50 <usb_mtp_send>
    2158:	cmp	r0, #0
    215a:	ble.n	214c <MTPD::GetObjectInfo(unsigned long)+0x384>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    215c:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2160:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2164:	ble.n	2126 <MTPD::GetObjectInfo(unsigned long)+0x35e>
    2166:	movs	r3, #0
    2168:	ldrb	r2, [r7, #0]
    216a:	str	r3, [sp, #72]	; 0x48
    216c:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    216e:	cmp	r2, #0
    2170:	bne.w	1e1a <MTPD::GetObjectInfo(unsigned long)+0x52>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2174:	cmp	r3, #0
    2176:	beq.w	28e6 <MTPD::GetObjectInfo(unsigned long)+0xb1e>
    217a:	ldr	r0, [r4, #0]
        write_length_ += len;
    217c:	adds	r3, #4
        
        const char * src=data;
    217e:	add.w	r9, sp, #72	; 0x48
        //
        int pos = 0; // into data
    2182:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2186:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    218a:	str	r3, [r7, #4]
    218c:	b.n	2196 <MTPD::GetObjectInfo(unsigned long)+0x3ce>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    218e:	cmp.w	r8, #3
    2192:	bgt.n	21d4 <MTPD::GetObjectInfo(unsigned long)+0x40c>
    2194:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2196:	rsb	fp, r0, r5
    219a:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    219e:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    21a0:	cmp	fp, r3
    21a2:	it	ge
    21a4:	movge	fp, r3
          memcpy(dst,src,to_copy);
    21a6:	mov	r2, fp
          pos += to_copy;
    21a8:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    21aa:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    21ae:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    21b0:	add	r9, fp
          dst += to_copy;
    21b2:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    21b4:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    21b6:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    21b8:	bne.n	218e <MTPD::GetObjectInfo(unsigned long)+0x3c6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    21ba:	movs	r2, #60	; 0x3c
    21bc:	mov.w	r1, #512	; 0x200
    21c0:	mov	r0, sl
    21c2:	bl	9d50 <usb_mtp_send>
    21c6:	cmp	r0, #0
    21c8:	ble.n	21ba <MTPD::GetObjectInfo(unsigned long)+0x3f2>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    21ca:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    21ce:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    21d2:	ble.n	2194 <MTPD::GetObjectInfo(unsigned long)+0x3cc>
    21d4:	movs	r3, #0
    21d6:	ldrb	r2, [r7, #0]
    21d8:	str	r3, [sp, #68]	; 0x44
    21da:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    21dc:	cmp	r2, #0
    21de:	bne.w	1e20 <MTPD::GetObjectInfo(unsigned long)+0x58>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    21e2:	cmp	r3, #0
    21e4:	beq.w	28dc <MTPD::GetObjectInfo(unsigned long)+0xb14>
    21e8:	ldr	r0, [r4, #0]
        write_length_ += len;
    21ea:	adds	r3, #4
        
        const char * src=data;
    21ec:	add.w	r9, sp, #68	; 0x44
        //
        int pos = 0; // into data
    21f0:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    21f4:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    21f8:	str	r3, [r7, #4]
    21fa:	b.n	2204 <MTPD::GetObjectInfo(unsigned long)+0x43c>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    21fc:	cmp.w	r8, #3
    2200:	bgt.n	2242 <MTPD::GetObjectInfo(unsigned long)+0x47a>
    2202:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2204:	rsb	fp, r0, r5
    2208:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    220c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    220e:	cmp	fp, r3
    2210:	it	ge
    2212:	movge	fp, r3
          memcpy(dst,src,to_copy);
    2214:	mov	r2, fp
          pos += to_copy;
    2216:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2218:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    221c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    221e:	add	r9, fp
          dst += to_copy;
    2220:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2222:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2224:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2226:	bne.n	21fc <MTPD::GetObjectInfo(unsigned long)+0x434>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2228:	movs	r2, #60	; 0x3c
    222a:	mov.w	r1, #512	; 0x200
    222e:	mov	r0, sl
    2230:	bl	9d50 <usb_mtp_send>
    2234:	cmp	r0, #0
    2236:	ble.n	2228 <MTPD::GetObjectInfo(unsigned long)+0x460>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2238:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    223c:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2240:	ble.n	2202 <MTPD::GetObjectInfo(unsigned long)+0x43a>
    2242:	movs	r3, #0
    2244:	ldrb	r2, [r7, #0]
    2246:	str	r3, [sp, #64]	; 0x40
    2248:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    224a:	cmp	r2, #0
    224c:	bne.w	1e26 <MTPD::GetObjectInfo(unsigned long)+0x5e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2250:	cmp	r3, #0
    2252:	beq.w	285a <MTPD::GetObjectInfo(unsigned long)+0xa92>
    2256:	ldr	r0, [r4, #0]
        write_length_ += len;
    2258:	adds	r3, #4
        
        const char * src=data;
    225a:	add.w	r9, sp, #64	; 0x40
        //
        int pos = 0; // into data
    225e:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2262:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2266:	str	r3, [r7, #4]
    2268:	b.n	2272 <MTPD::GetObjectInfo(unsigned long)+0x4aa>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    226a:	cmp.w	r8, #3
    226e:	bgt.n	22b0 <MTPD::GetObjectInfo(unsigned long)+0x4e8>
    2270:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2272:	rsb	fp, r0, r5
    2276:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    227a:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    227c:	cmp	fp, r3
    227e:	it	ge
    2280:	movge	fp, r3
          memcpy(dst,src,to_copy);
    2282:	mov	r2, fp
          pos += to_copy;
    2284:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2286:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    228a:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    228c:	add	r9, fp
          dst += to_copy;
    228e:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2290:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2292:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2294:	bne.n	226a <MTPD::GetObjectInfo(unsigned long)+0x4a2>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2296:	movs	r2, #60	; 0x3c
    2298:	mov.w	r1, #512	; 0x200
    229c:	mov	r0, sl
    229e:	bl	9d50 <usb_mtp_send>
    22a2:	cmp	r0, #0
    22a4:	ble.n	2296 <MTPD::GetObjectInfo(unsigned long)+0x4ce>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    22a6:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    22aa:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    22ae:	ble.n	2270 <MTPD::GetObjectInfo(unsigned long)+0x4a8>
    22b0:	movs	r3, #0
    22b2:	ldrb	r2, [r7, #0]
    22b4:	str	r3, [sp, #60]	; 0x3c
    22b6:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    22b8:	cmp	r2, #0
    22ba:	bne.w	1e2c <MTPD::GetObjectInfo(unsigned long)+0x64>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    22be:	cmp	r3, #0
    22c0:	beq.w	2850 <MTPD::GetObjectInfo(unsigned long)+0xa88>
    22c4:	ldr	r0, [r4, #0]
        write_length_ += len;
    22c6:	adds	r3, #4
        
        const char * src=data;
    22c8:	add.w	r9, sp, #60	; 0x3c
        //
        int pos = 0; // into data
    22cc:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    22d0:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    22d4:	str	r3, [r7, #4]
    22d6:	b.n	22e0 <MTPD::GetObjectInfo(unsigned long)+0x518>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    22d8:	cmp.w	r8, #3
    22dc:	bgt.n	231e <MTPD::GetObjectInfo(unsigned long)+0x556>
    22de:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    22e0:	rsb	fp, r0, r5
    22e4:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    22e8:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    22ea:	cmp	fp, r3
    22ec:	it	ge
    22ee:	movge	fp, r3
          memcpy(dst,src,to_copy);
    22f0:	mov	r2, fp
          pos += to_copy;
    22f2:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    22f4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    22f8:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    22fa:	add	r9, fp
          dst += to_copy;
    22fc:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    22fe:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2300:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2302:	bne.n	22d8 <MTPD::GetObjectInfo(unsigned long)+0x510>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2304:	movs	r2, #60	; 0x3c
    2306:	mov.w	r1, #512	; 0x200
    230a:	mov	r0, sl
    230c:	bl	9d50 <usb_mtp_send>
    2310:	cmp	r0, #0
    2312:	ble.n	2304 <MTPD::GetObjectInfo(unsigned long)+0x53c>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2314:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2318:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    231c:	ble.n	22de <MTPD::GetObjectInfo(unsigned long)+0x516>
    231e:	movs	r3, #0
    2320:	ldrb	r2, [r7, #0]
    2322:	str	r3, [sp, #56]	; 0x38
    2324:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2326:	cmp	r2, #0
    2328:	bne.w	1e32 <MTPD::GetObjectInfo(unsigned long)+0x6a>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    232c:	cmp	r3, #0
    232e:	beq.w	2846 <MTPD::GetObjectInfo(unsigned long)+0xa7e>
    2332:	ldr	r0, [r4, #0]
        write_length_ += len;
    2334:	adds	r3, #4
        
        const char * src=data;
    2336:	add.w	r9, sp, #56	; 0x38
        //
        int pos = 0; // into data
    233a:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    233e:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2342:	str	r3, [r7, #4]
    2344:	b.n	234e <MTPD::GetObjectInfo(unsigned long)+0x586>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2346:	cmp.w	r8, #3
    234a:	bgt.n	238c <MTPD::GetObjectInfo(unsigned long)+0x5c4>
    234c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    234e:	rsb	fp, r0, r5
    2352:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    2356:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2358:	cmp	fp, r3
    235a:	it	ge
    235c:	movge	fp, r3
          memcpy(dst,src,to_copy);
    235e:	mov	r2, fp
          pos += to_copy;
    2360:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2362:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2366:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2368:	add	r9, fp
          dst += to_copy;
    236a:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    236c:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    236e:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2370:	bne.n	2346 <MTPD::GetObjectInfo(unsigned long)+0x57e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2372:	movs	r2, #60	; 0x3c
    2374:	mov.w	r1, #512	; 0x200
    2378:	mov	r0, sl
    237a:	bl	9d50 <usb_mtp_send>
    237e:	cmp	r0, #0
    2380:	ble.n	2372 <MTPD::GetObjectInfo(unsigned long)+0x5aa>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2382:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2386:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    238a:	ble.n	234c <MTPD::GetObjectInfo(unsigned long)+0x584>
    238c:	movs	r3, #0
    238e:	ldrb	r2, [r7, #0]
    2390:	str	r3, [sp, #52]	; 0x34
    2392:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2394:	cmp	r2, #0
    2396:	bne.w	1e38 <MTPD::GetObjectInfo(unsigned long)+0x70>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    239a:	cmp	r3, #0
    239c:	beq.w	283c <MTPD::GetObjectInfo(unsigned long)+0xa74>
    23a0:	ldr	r0, [r4, #0]
        write_length_ += len;
    23a2:	adds	r3, #4
        
        const char * src=data;
    23a4:	add.w	r9, sp, #52	; 0x34
        //
        int pos = 0; // into data
    23a8:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    23ac:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    23b0:	str	r3, [r7, #4]
    23b2:	b.n	23bc <MTPD::GetObjectInfo(unsigned long)+0x5f4>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    23b4:	cmp.w	r8, #3
    23b8:	bgt.n	23fa <MTPD::GetObjectInfo(unsigned long)+0x632>
    23ba:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    23bc:	rsb	fp, r0, r5
    23c0:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    23c4:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    23c6:	cmp	fp, r3
    23c8:	it	ge
    23ca:	movge	fp, r3
          memcpy(dst,src,to_copy);
    23cc:	mov	r2, fp
          pos += to_copy;
    23ce:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    23d0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    23d4:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    23d6:	add	r9, fp
          dst += to_copy;
    23d8:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    23da:	cmp	r3, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    23dc:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    23de:	bne.n	23b4 <MTPD::GetObjectInfo(unsigned long)+0x5ec>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    23e0:	movs	r2, #60	; 0x3c
    23e2:	mov.w	r1, #512	; 0x200
    23e6:	mov	r0, sl
    23e8:	bl	9d50 <usb_mtp_send>
    23ec:	cmp	r0, #0
    23ee:	ble.n	23e0 <MTPD::GetObjectInfo(unsigned long)+0x618>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    23f0:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    23f4:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    23f8:	ble.n	23ba <MTPD::GetObjectInfo(unsigned long)+0x5f2>
    23fa:	ldr	r3, [r6, #0]
    23fc:	ldrb	r2, [r7, #0]
    23fe:	str	r3, [sp, #48]	; 0x30
    2400:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2402:	cmp	r2, #0
    2404:	bne.w	1e3e <MTPD::GetObjectInfo(unsigned long)+0x76>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2408:	cmp	r3, #0
    240a:	beq.w	2832 <MTPD::GetObjectInfo(unsigned long)+0xa6a>
    240e:	ldr	r0, [r4, #0]
        write_length_ += len;
    2410:	adds	r3, #4
        
        const char * src=data;
    2412:	add.w	r9, sp, #48	; 0x30
        //
        int pos = 0; // into data
    2416:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    241a:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    241e:	str	r3, [r7, #4]
    2420:	b.n	242a <MTPD::GetObjectInfo(unsigned long)+0x662>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2422:	cmp.w	r8, #3
    2426:	bgt.n	2466 <MTPD::GetObjectInfo(unsigned long)+0x69e>
    2428:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    242a:	subs	r6, r5, r0
    242c:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    2430:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2432:	cmp	r6, r3
    2434:	it	ge
    2436:	movge	r6, r3
          memcpy(dst,src,to_copy);
    2438:	mov	r2, r6
          pos += to_copy;
    243a:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    243c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2440:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2442:	add	r9, r6
          dst += to_copy;
    2444:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2446:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2448:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    244a:	bne.n	2422 <MTPD::GetObjectInfo(unsigned long)+0x65a>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    244c:	movs	r2, #60	; 0x3c
    244e:	mov.w	r1, #512	; 0x200
    2452:	mov	r0, sl
    2454:	bl	9d50 <usb_mtp_send>
    2458:	cmp	r0, #0
    245a:	ble.n	244c <MTPD::GetObjectInfo(unsigned long)+0x684>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    245c:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2460:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2464:	ble.n	2428 <MTPD::GetObjectInfo(unsigned long)+0x660>
    2466:	ldr	r2, [sp, #36]	; 0x24
    2468:	ldrb	r1, [r7, #0]
    246a:	sub.w	r2, r2, #4294967295
    246e:	ldr	r3, [r7, #4]
    2470:	clz	r2, r2
    2474:	lsrs	r2, r2, #5
    2476:	strh.w	r2, [sp, #30]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    247a:	cmp	r1, #0
    247c:	bne.w	1e50 <MTPD::GetObjectInfo(unsigned long)+0x88>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2480:	cmp	r3, #0
    2482:	beq.w	2828 <MTPD::GetObjectInfo(unsigned long)+0xa60>
    2486:	ldr	r0, [r4, #0]
        write_length_ += len;
    2488:	adds	r3, #2
        
        const char * src=data;
    248a:	add.w	r9, sp, #30
        //
        int pos = 0; // into data
    248e:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2492:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2496:	str	r3, [r7, #4]
    2498:	b.n	24a2 <MTPD::GetObjectInfo(unsigned long)+0x6da>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    249a:	cmp.w	r8, #1
    249e:	bgt.n	24de <MTPD::GetObjectInfo(unsigned long)+0x716>
    24a0:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    24a2:	subs	r6, r5, r0
    24a4:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    24a8:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    24aa:	cmp	r6, r3
    24ac:	it	ge
    24ae:	movge	r6, r3
          memcpy(dst,src,to_copy);
    24b0:	mov	r2, r6
          pos += to_copy;
    24b2:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    24b4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    24b8:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    24ba:	add	r9, r6
          dst += to_copy;
    24bc:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    24be:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    24c0:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    24c2:	bne.n	249a <MTPD::GetObjectInfo(unsigned long)+0x6d2>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    24c4:	movs	r2, #60	; 0x3c
    24c6:	mov.w	r1, #512	; 0x200
    24ca:	mov	r0, sl
    24cc:	bl	9d50 <usb_mtp_send>
    24d0:	cmp	r0, #0
    24d2:	ble.n	24c4 <MTPD::GetObjectInfo(unsigned long)+0x6fc>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    24d4:	cmp.w	r8, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    24d8:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    24dc:	ble.n	24a0 <MTPD::GetObjectInfo(unsigned long)+0x6d8>
    24de:	movs	r3, #0
    24e0:	ldrb	r2, [r7, #0]
    24e2:	str	r3, [sp, #84]	; 0x54
    24e4:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    24e6:	cmp	r2, #0
    24e8:	bne.w	1e56 <MTPD::GetObjectInfo(unsigned long)+0x8e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    24ec:	cmp	r3, #0
    24ee:	beq.w	281e <MTPD::GetObjectInfo(unsigned long)+0xa56>
    24f2:	ldr	r0, [r4, #0]
        write_length_ += len;
    24f4:	adds	r3, #4
        
        const char * src=data;
    24f6:	add.w	r9, sp, #84	; 0x54
        //
        int pos = 0; // into data
    24fa:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    24fe:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2502:	str	r3, [r7, #4]
    2504:	b.n	250e <MTPD::GetObjectInfo(unsigned long)+0x746>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2506:	cmp.w	r8, #3
    250a:	bgt.n	254a <MTPD::GetObjectInfo(unsigned long)+0x782>
    250c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    250e:	subs	r6, r5, r0
    2510:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    2514:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2516:	cmp	r6, r3
    2518:	it	ge
    251a:	movge	r6, r3
          memcpy(dst,src,to_copy);
    251c:	mov	r2, r6
          pos += to_copy;
    251e:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2520:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2524:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2526:	add	r9, r6
          dst += to_copy;
    2528:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    252a:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    252c:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    252e:	bne.n	2506 <MTPD::GetObjectInfo(unsigned long)+0x73e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2530:	movs	r2, #60	; 0x3c
    2532:	mov.w	r1, #512	; 0x200
    2536:	mov	r0, sl
    2538:	bl	9d50 <usb_mtp_send>
    253c:	cmp	r0, #0
    253e:	ble.n	2530 <MTPD::GetObjectInfo(unsigned long)+0x768>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2540:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2544:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2548:	ble.n	250c <MTPD::GetObjectInfo(unsigned long)+0x744>
    254a:	movs	r3, #0
    254c:	ldrb	r2, [r7, #0]
    254e:	str	r3, [sp, #80]	; 0x50
    2550:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2552:	cmp	r2, #0
    2554:	bne.w	1e5c <MTPD::GetObjectInfo(unsigned long)+0x94>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2558:	cmp	r3, #0
    255a:	beq.w	2662 <MTPD::GetObjectInfo(unsigned long)+0x89a>
    255e:	ldr	r0, [r4, #0]
        write_length_ += len;
    2560:	adds	r3, #4
        
        const char * src=data;
    2562:	add.w	r9, sp, #80	; 0x50
        //
        int pos = 0; // into data
    2566:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    256a:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    256e:	str	r3, [r7, #4]
    2570:	b.n	257a <MTPD::GetObjectInfo(unsigned long)+0x7b2>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2572:	cmp.w	r8, #3
    2576:	bgt.n	25b6 <MTPD::GetObjectInfo(unsigned long)+0x7ee>
    2578:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    257a:	subs	r6, r5, r0
    257c:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    2580:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2582:	cmp	r6, r3
    2584:	it	ge
    2586:	movge	r6, r3
          memcpy(dst,src,to_copy);
    2588:	mov	r2, r6
          pos += to_copy;
    258a:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    258c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2590:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2592:	add	r9, r6
          dst += to_copy;
    2594:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2596:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2598:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    259a:	bne.n	2572 <MTPD::GetObjectInfo(unsigned long)+0x7aa>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    259c:	movs	r2, #60	; 0x3c
    259e:	mov.w	r1, #512	; 0x200
    25a2:	mov	r0, sl
    25a4:	bl	9d50 <usb_mtp_send>
    25a8:	cmp	r0, #0
    25aa:	ble.n	259c <MTPD::GetObjectInfo(unsigned long)+0x7d4>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    25ac:	cmp.w	r8, #3
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    25b0:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    25b4:	ble.n	2578 <MTPD::GetObjectInfo(unsigned long)+0x7b0>

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    25b6:	ldrb.w	r2, [sp, #88]	; 0x58
    25ba:	ldrb.w	r8, [r7]
    25be:	ldr	r6, [r7, #4]
    25c0:	cmp	r2, #0
    25c2:	beq.n	266c <MTPD::GetObjectInfo(unsigned long)+0x8a4>
    { write8(strlen(str) + 1);
    25c4:	add	r0, sp, #88	; 0x58
    25c6:	str	r2, [sp, #12]
    25c8:	bl	c080 <strlen>
    25cc:	adds	r0, #1
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    25ce:	ldr	r2, [sp, #12]
    25d0:	strb.w	r0, [sp, #23]
    25d4:	cmp.w	r8, #0
    25d8:	bne.w	1e78 <MTPD::GetObjectInfo(unsigned long)+0xb0>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    25dc:	cmp	r6, #0
    25de:	beq.w	293a <MTPD::GetObjectInfo(unsigned long)+0xb72>
    25e2:	ldr	r0, [r4, #0]
        write_length_ += len;
    25e4:	adds	r3, r6, #1
        
        const char * src=data;
    25e6:	add.w	r9, sp, #23
        //
        int pos = 0; // into data
    25ea:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    25ee:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    25f2:	str	r3, [r7, #4]
    25f4:	b.n	25fe <MTPD::GetObjectInfo(unsigned long)+0x836>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    25f6:	cmp.w	r8, #0
    25fa:	bgt.n	263a <MTPD::GetObjectInfo(unsigned long)+0x872>
    25fc:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    25fe:	subs	r6, r5, r0
    2600:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    2604:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2606:	cmp	r6, r3
    2608:	it	ge
    260a:	movge	r6, r3
          memcpy(dst,src,to_copy);
    260c:	mov	r2, r6
          pos += to_copy;
    260e:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2610:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2614:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2616:	add	r9, r6
          dst += to_copy;
    2618:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    261a:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    261c:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    261e:	bne.n	25f6 <MTPD::GetObjectInfo(unsigned long)+0x82e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2620:	movs	r2, #60	; 0x3c
    2622:	mov.w	r1, #512	; 0x200
    2626:	mov	r0, sl
    2628:	bl	9d50 <usb_mtp_send>
    262c:	cmp	r0, #0
    262e:	ble.n	2620 <MTPD::GetObjectInfo(unsigned long)+0x858>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2630:	cmp.w	r8, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2634:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2638:	ble.n	25fc <MTPD::GetObjectInfo(unsigned long)+0x834>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    263a:	ldrb.w	r2, [sp, #88]	; 0x58
    263e:	ldrb	r1, [r7, #0]
    2640:	ldr	r3, [r7, #4]
    2642:	cmp	r2, #0
    2644:	bne.w	1e7e <MTPD::GetObjectInfo(unsigned long)+0xb6>
    2648:	b.n	1f04 <MTPD::GetObjectInfo(unsigned long)+0x13c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    264a:	add.w	r2, r7, #544	; 0x220
    264e:	ldr	r4, [pc, #756]	; (2944 <MTPD::GetObjectInfo(unsigned long)+0xb7c>)
    2650:	mov	r0, r2
    2652:	str	r2, [r4, #0]
    2654:	b.n	1f38 <MTPD::GetObjectInfo(unsigned long)+0x170>
    2656:	movw	r2, #12289	; 0x3001
    265a:	strh.w	r2, [sp, #28]
    265e:	b.w	1dfe <MTPD::GetObjectInfo(unsigned long)+0x36>
    2662:	add.w	r2, r7, #544	; 0x220
    2666:	mov	r0, r2
    2668:	str	r2, [r4, #0]
    266a:	b.n	2560 <MTPD::GetObjectInfo(unsigned long)+0x798>
    266c:	strb.w	r2, [sp, #22]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2670:	cmp.w	r8, #0
    2674:	bne.w	1f14 <MTPD::GetObjectInfo(unsigned long)+0x14c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2678:	cmp	r6, #0
    267a:	beq.w	2924 <MTPD::GetObjectInfo(unsigned long)+0xb5c>
    267e:	ldr	r0, [r4, #0]
        write_length_ += len;
    2680:	adds	r3, r6, #1
        
        const char * src=data;
    2682:	add.w	r9, sp, #22
        //
        int pos = 0; // into data
    2686:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    268a:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    268e:	str	r3, [r7, #4]
    2690:	b.n	269a <MTPD::GetObjectInfo(unsigned long)+0x8d2>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2692:	cmp.w	r8, #0
    2696:	bgt.n	26d6 <MTPD::GetObjectInfo(unsigned long)+0x90e>
    2698:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    269a:	subs	r6, r5, r0
    269c:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    26a0:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    26a2:	cmp	r6, r3
    26a4:	it	ge
    26a6:	movge	r6, r3
          memcpy(dst,src,to_copy);
    26a8:	mov	r2, r6
          pos += to_copy;
    26aa:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    26ac:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    26b0:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    26b2:	add	r9, r6
          dst += to_copy;
    26b4:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    26b6:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    26b8:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    26ba:	bne.n	2692 <MTPD::GetObjectInfo(unsigned long)+0x8ca>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    26bc:	movs	r2, #60	; 0x3c
    26be:	mov.w	r1, #512	; 0x200
    26c2:	mov	r0, sl
    26c4:	bl	9d50 <usb_mtp_send>
    26c8:	cmp	r0, #0
    26ca:	ble.n	26bc <MTPD::GetObjectInfo(unsigned long)+0x8f4>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    26cc:	cmp.w	r8, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    26d0:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    26d4:	ble.n	2698 <MTPD::GetObjectInfo(unsigned long)+0x8d0>
    26d6:	movs	r2, #0
    26d8:	ldrb	r1, [r7, #0]
    26da:	ldr	r3, [r7, #4]
    26dc:	strb.w	r2, [sp, #21]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    26e0:	cmp	r1, #0
    26e2:	bne.w	1f16 <MTPD::GetObjectInfo(unsigned long)+0x14e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    26e6:	cmp	r3, #0
    26e8:	beq.w	291a <MTPD::GetObjectInfo(unsigned long)+0xb52>
    26ec:	ldr	r0, [r4, #0]
        write_length_ += len;
    26ee:	adds	r3, #1
        
        const char * src=data;
    26f0:	add.w	r9, sp, #21
        //
        int pos = 0; // into data
    26f4:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    26f8:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    26fc:	str	r3, [r7, #4]
    26fe:	b.n	2708 <MTPD::GetObjectInfo(unsigned long)+0x940>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2700:	cmp.w	r8, #0
    2704:	bgt.n	2744 <MTPD::GetObjectInfo(unsigned long)+0x97c>
    2706:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2708:	subs	r6, r5, r0
    270a:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    270e:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2710:	cmp	r6, r3
    2712:	it	ge
    2714:	movge	r6, r3
          memcpy(dst,src,to_copy);
    2716:	mov	r2, r6
          pos += to_copy;
    2718:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    271a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    271e:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2720:	add	r9, r6
          dst += to_copy;
    2722:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2724:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2726:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2728:	bne.n	2700 <MTPD::GetObjectInfo(unsigned long)+0x938>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    272a:	movs	r2, #60	; 0x3c
    272c:	mov.w	r1, #512	; 0x200
    2730:	mov	r0, sl
    2732:	bl	9d50 <usb_mtp_send>
    2736:	cmp	r0, #0
    2738:	ble.n	272a <MTPD::GetObjectInfo(unsigned long)+0x962>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    273a:	cmp.w	r8, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    273e:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2742:	ble.n	2706 <MTPD::GetObjectInfo(unsigned long)+0x93e>
    2744:	movs	r3, #0
    2746:	ldrb	r2, [r7, #0]
    2748:	strb.w	r3, [sp, #20]
    274c:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    274e:	cmp	r2, #0
    2750:	bne.w	1f18 <MTPD::GetObjectInfo(unsigned long)+0x150>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2754:	cmp	r3, #0
    2756:	beq.w	2910 <MTPD::GetObjectInfo(unsigned long)+0xb48>
    275a:	ldr	r0, [r4, #0]
        write_length_ += len;
    275c:	adds	r3, #1
        
        const char * src=data;
    275e:	add.w	r9, sp, #20
        //
        int pos = 0; // into data
    2762:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2766:	add.w	sl, r7, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    276a:	str	r3, [r7, #4]
    276c:	b.n	2776 <MTPD::GetObjectInfo(unsigned long)+0x9ae>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    276e:	cmp.w	r8, #0
    2772:	bgt.n	27b2 <MTPD::GetObjectInfo(unsigned long)+0x9ea>
    2774:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2776:	subs	r6, r5, r0
    2778:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    277c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    277e:	cmp	r6, r3
    2780:	it	ge
    2782:	movge	r6, r3
          memcpy(dst,src,to_copy);
    2784:	mov	r2, r6
          pos += to_copy;
    2786:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2788:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    278c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    278e:	add	r9, r6
          dst += to_copy;
    2790:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2792:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2794:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2796:	bne.n	276e <MTPD::GetObjectInfo(unsigned long)+0x9a6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2798:	movs	r2, #60	; 0x3c
    279a:	mov.w	r1, #512	; 0x200
    279e:	mov	r0, sl
    27a0:	bl	9d50 <usb_mtp_send>
    27a4:	cmp	r0, #0
    27a6:	ble.n	2798 <MTPD::GetObjectInfo(unsigned long)+0x9d0>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    27a8:	cmp.w	r8, #0
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    27ac:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    27b0:	ble.n	2774 <MTPD::GetObjectInfo(unsigned long)+0x9ac>
    27b2:	movs	r3, #0
    27b4:	ldrb	r2, [r7, #0]
    27b6:	strb.w	r3, [sp, #19]
    27ba:	ldr	r3, [r7, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    27bc:	cmp	r2, #0
    27be:	bne.w	1f1a <MTPD::GetObjectInfo(unsigned long)+0x152>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    27c2:	cmp	r3, #0
    27c4:	beq.w	2906 <MTPD::GetObjectInfo(unsigned long)+0xb3e>
    27c8:	ldr	r0, [r4, #0]
        write_length_ += len;
    27ca:	adds	r3, #1
        
        const char * src=data;
    27cc:	add.w	r9, sp, #19
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    27d0:	add.w	sl, r7, #544	; 0x220
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    27d4:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    27d8:	str	r3, [r7, #4]
    27da:	b.n	27e6 <MTPD::GetObjectInfo(unsigned long)+0xa1e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    27dc:	cmp.w	r8, #0
    27e0:	bgt.w	1f1e <MTPD::GetObjectInfo(unsigned long)+0x156>
    27e4:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    27e6:	subs	r6, r5, r0
    27e8:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    27ec:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    27ee:	cmp	r6, r3
    27f0:	it	ge
    27f2:	movge	r6, r3
          memcpy(dst,src,to_copy);
    27f4:	mov	r2, r6
          pos += to_copy;
    27f6:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    27f8:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    27fc:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    27fe:	add	r9, r6
          dst += to_copy;
    2800:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2802:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2804:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2806:	bne.n	27dc <MTPD::GetObjectInfo(unsigned long)+0xa14>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2808:	movs	r2, #60	; 0x3c
    280a:	mov.w	r1, #512	; 0x200
    280e:	mov	r0, sl
    2810:	bl	9d50 <usb_mtp_send>
    2814:	cmp	r0, #0
    2816:	ble.n	2808 <MTPD::GetObjectInfo(unsigned long)+0xa40>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2818:	str.w	sl, [r4]
    281c:	b.n	27dc <MTPD::GetObjectInfo(unsigned long)+0xa14>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    281e:	add.w	r2, r7, #544	; 0x220
    2822:	mov	r0, r2
    2824:	str	r2, [r4, #0]
    2826:	b.n	24f4 <MTPD::GetObjectInfo(unsigned long)+0x72c>
    2828:	add.w	r2, r7, #544	; 0x220
    282c:	mov	r0, r2
    282e:	str	r2, [r4, #0]
    2830:	b.n	2488 <MTPD::GetObjectInfo(unsigned long)+0x6c0>
    2832:	add.w	r2, r7, #544	; 0x220
    2836:	mov	r0, r2
    2838:	str	r2, [r4, #0]
    283a:	b.n	2410 <MTPD::GetObjectInfo(unsigned long)+0x648>
    283c:	add.w	r2, r7, #544	; 0x220
    2840:	mov	r0, r2
    2842:	str	r2, [r4, #0]
    2844:	b.n	23a2 <MTPD::GetObjectInfo(unsigned long)+0x5da>
    2846:	add.w	r2, r7, #544	; 0x220
    284a:	mov	r0, r2
    284c:	str	r2, [r4, #0]
    284e:	b.n	2334 <MTPD::GetObjectInfo(unsigned long)+0x56c>
    2850:	add.w	r2, r7, #544	; 0x220
    2854:	mov	r0, r2
    2856:	str	r2, [r4, #0]
    2858:	b.n	22c6 <MTPD::GetObjectInfo(unsigned long)+0x4fe>
    285a:	add.w	r2, r7, #544	; 0x220
    285e:	mov	r0, r2
    2860:	str	r2, [r4, #0]
    2862:	b.n	2258 <MTPD::GetObjectInfo(unsigned long)+0x490>
    2864:	cmp	r3, #0
    2866:	beq.n	292e <MTPD::GetObjectInfo(unsigned long)+0xb66>
    2868:	ldr	r4, [pc, #216]	; (2944 <MTPD::GetObjectInfo(unsigned long)+0xb7c>)
    286a:	ldr	r0, [r4, #0]
        write_length_ += len;
    286c:	adds	r3, #2
        
        const char * src=data;
    286e:	add.w	r9, sp, #32
    2872:	add.w	r5, r7, #1056	; 0x420
        //
        int pos = 0; // into data
    2876:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    287a:	str	r3, [r7, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    287c:	add.w	sl, r7, #544	; 0x220
    2880:	b.n	288c <MTPD::GetObjectInfo(unsigned long)+0xac4>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2882:	cmp.w	r8, #1
    2886:	bgt.w	26d6 <MTPD::GetObjectInfo(unsigned long)+0x90e>
    288a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    288c:	subs	r6, r5, r0
    288e:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2892:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2894:	cmp	r6, r3
    2896:	it	ge
    2898:	movge	r6, r3
          memcpy(dst,src,to_copy);
    289a:	mov	r2, r6
          pos += to_copy;
    289c:	add	r8, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    289e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    28a2:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    28a4:	add	r9, r6
          dst += to_copy;
    28a6:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    28a8:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    28aa:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    28ac:	bne.n	2882 <MTPD::GetObjectInfo(unsigned long)+0xaba>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    28ae:	movs	r2, #60	; 0x3c
    28b0:	mov.w	r1, #512	; 0x200
    28b4:	mov	r0, sl
    28b6:	bl	9d50 <usb_mtp_send>
    28ba:	cmp	r0, #0
    28bc:	ble.n	28ae <MTPD::GetObjectInfo(unsigned long)+0xae6>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    28be:	str.w	sl, [r4]
    28c2:	b.n	2882 <MTPD::GetObjectInfo(unsigned long)+0xaba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    28c4:	add.w	r2, r7, #544	; 0x220
    28c8:	mov	r0, r2
    28ca:	str	r2, [r4, #0]
    28cc:	b.w	2026 <MTPD::GetObjectInfo(unsigned long)+0x25e>
    28d0:	add.w	r2, r7, #544	; 0x220
    28d4:	mov	r0, r2
    28d6:	str	r2, [r4, #0]
    28d8:	b.w	1fb6 <MTPD::GetObjectInfo(unsigned long)+0x1ee>
    28dc:	add.w	r2, r7, #544	; 0x220
    28e0:	mov	r0, r2
    28e2:	str	r2, [r4, #0]
    28e4:	b.n	21ea <MTPD::GetObjectInfo(unsigned long)+0x422>
    28e6:	add.w	r2, r7, #544	; 0x220
    28ea:	mov	r0, r2
    28ec:	str	r2, [r4, #0]
    28ee:	b.n	217c <MTPD::GetObjectInfo(unsigned long)+0x3b4>
    28f0:	add.w	r2, r7, #544	; 0x220
    28f4:	mov	r0, r2
    28f6:	str	r2, [r4, #0]
    28f8:	b.n	210e <MTPD::GetObjectInfo(unsigned long)+0x346>
    28fa:	add.w	r2, r7, #544	; 0x220
    28fe:	mov	r0, r2
    2900:	str	r2, [r4, #0]
    2902:	b.w	2094 <MTPD::GetObjectInfo(unsigned long)+0x2cc>
    2906:	add.w	r2, r7, #544	; 0x220
    290a:	mov	r0, r2
    290c:	str	r2, [r4, #0]
    290e:	b.n	27ca <MTPD::GetObjectInfo(unsigned long)+0xa02>
    2910:	add.w	r2, r7, #544	; 0x220
    2914:	mov	r0, r2
    2916:	str	r2, [r4, #0]
    2918:	b.n	275c <MTPD::GetObjectInfo(unsigned long)+0x994>
    291a:	add.w	r2, r7, #544	; 0x220
    291e:	mov	r0, r2
    2920:	str	r2, [r4, #0]
    2922:	b.n	26ee <MTPD::GetObjectInfo(unsigned long)+0x926>
    2924:	add.w	r3, r7, #544	; 0x220
    2928:	mov	r0, r3
    292a:	str	r3, [r4, #0]
    292c:	b.n	2680 <MTPD::GetObjectInfo(unsigned long)+0x8b8>
    292e:	add.w	r2, r7, #544	; 0x220
    2932:	ldr	r4, [pc, #16]	; (2944 <MTPD::GetObjectInfo(unsigned long)+0xb7c>)
    2934:	mov	r0, r2
    2936:	str	r2, [r4, #0]
    2938:	b.n	286c <MTPD::GetObjectInfo(unsigned long)+0xaa4>
    293a:	add.w	r3, r7, #544	; 0x220
    293e:	mov	r0, r3
    2940:	str	r3, [r4, #0]
    2942:	b.n	25e4 <MTPD::GetObjectInfo(unsigned long)+0x81c>
    2944:	.word	0x2000158c

00002948 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>:
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void getObjectPropDesc(uint32_t p1, uint32_t p2)
    {
      switch(p1)
    2948:	mvn.w	r3, #56320	; 0xdc00
    294c:	add	r3, r1
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    }

    void getObjectPropDesc(uint32_t p1, uint32_t p2)
    294e:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    2952:	mov	r6, r0
    2954:	sub	sp, #144	; 0x90
    {
      switch(p1)
    2956:	cmp	r3, #67	; 0x43
    2958:	bhi.n	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    295a:	tbh	[pc, r3, lsl #1]
    295e:	.short	0x0057
    2960:	.word	0x00730065
    2964:	.word	0x005400ac
    2968:	.word	0x00ba0054
    296c:	.word	0x012d00f3
    2970:	.word	0x01670054
    2974:	.word	0x00540054
    2978:	.word	0x00540054
    297c:	.word	0x00540054
    2980:	.word	0x00540054
    2984:	.word	0x00540054
    2988:	.word	0x00540054
    298c:	.word	0x00540054
    2990:	.word	0x00540054
    2994:	.word	0x00540054
    2998:	.word	0x00540054
    299c:	.word	0x00540054
    29a0:	.word	0x00540054
    29a4:	.word	0x00540054
    29a8:	.word	0x00540054
    29ac:	.word	0x00540054
    29b0:	.word	0x00540054
    29b4:	.word	0x00540054
    29b8:	.word	0x00540054
    29bc:	.word	0x00540054
    29c0:	.word	0x00540054
    29c4:	.word	0x00540054
    29c8:	.word	0x00540054
    29cc:	.word	0x00540054
    29d0:	.word	0x00540054
    29d4:	.word	0x00540054
    29d8:	.word	0x00540054
    29dc:	.word	0x01a10054
    29e0:	.word	0x00540054
    29e4:	.short	0x0044
    29e6:	movw	r2, #56388	; 0xdc44
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    29ea:	ldrb	r3, [r0, #0]
    29ec:	strh.w	r2, [sp, #70]	; 0x46
    29f0:	cmp	r3, #0
    29f2:	beq.w	3564 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc1c>
      {
        write_length_ += len;
    29f6:	ldr	r3, [r6, #4]
    29f8:	adds	r3, #2
    29fa:	adds	r3, #2
    29fc:	adds	r3, #1
    29fe:	adds	r3, #1
    2a00:	adds	r3, #4
    2a02:	adds	r3, #1
    2a04:	str	r3, [r6, #4]
          write8(0);
          break;
        default:
          break;
      }
    }
    2a06:	add	sp, #144	; 0x90
    2a08:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    2a0c:	movw	r2, #56321	; 0xdc01
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2a10:	ldrb	r3, [r0, #0]
    2a12:	strh.w	r2, [sp, #30]
    2a16:	cmp	r3, #0
    2a18:	beq.w	3426 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xade>
      {
        write_length_ += len;
    2a1c:	ldr	r3, [r6, #4]
    2a1e:	adds	r3, #2
    2a20:	adds	r3, #2
    2a22:	adds	r3, #1
    2a24:	adds	r3, #4
    2a26:	b.n	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
    2a28:	movw	r2, #56322	; 0xdc02
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2a2c:	ldrb	r3, [r0, #0]
    2a2e:	strh.w	r2, [sp, #36]	; 0x24
    2a32:	cmp	r3, #0
    2a34:	beq.w	31b6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x86e>
      {
        write_length_ += len;
    2a38:	ldr	r3, [r6, #4]
    2a3a:	adds	r3, #2
    2a3c:	adds	r3, #2
    2a3e:	adds	r3, #1
    2a40:	adds	r3, #2
    2a42:	b.n	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
    2a44:	movw	r2, #56323	; 0xdc03
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2a48:	ldrb	r3, [r0, #0]
    2a4a:	strh.w	r2, [sp, #42]	; 0x2a
    2a4e:	cmp	r3, #0
    2a50:	bne.n	2a38 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf0>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2a52:	ldr	r3, [r0, #4]
    2a54:	cmp	r3, #0
    2a56:	beq.w	4484 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b3c>
    2a5a:	ldr	r4, [pc, #760]	; (2d54 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x40c>)
    2a5c:	ldr	r0, [r4, #0]
        write_length_ += len;
    2a5e:	adds	r3, #2
    2a60:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    2a64:	add.w	r9, sp, #42	; 0x2a
        //
        int pos = 0; // into data
    2a68:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2a6c:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2a6e:	add.w	sl, r6, #544	; 0x220
    2a72:	b.n	2a7e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x136>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2a74:	cmp.w	r8, #1
    2a78:	bgt.w	3aba <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1172>
    2a7c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2a7e:	subs	r7, r5, r0
    2a80:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2a84:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2a86:	cmp	r7, r3
    2a88:	it	ge
    2a8a:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2a8c:	mov	r2, r7
          pos += to_copy;
    2a8e:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2a90:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2a94:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2a96:	add	r9, r7
          dst += to_copy;
    2a98:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2a9a:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2a9c:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2a9e:	bne.n	2a74 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x12c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2aa0:	movs	r2, #60	; 0x3c
    2aa2:	mov.w	r1, #512	; 0x200
    2aa6:	mov	r0, sl
    2aa8:	bl	9d50 <usb_mtp_send>
    2aac:	cmp	r0, #0
    2aae:	ble.n	2aa0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x158>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2ab0:	str.w	sl, [r4]
    2ab4:	b.n	2a74 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x12c>
    2ab6:	movw	r2, #56324	; 0xdc04
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2aba:	ldrb	r3, [r0, #0]
    2abc:	strh.w	r2, [sp, #46]	; 0x2e
    2ac0:	cmp	r3, #0
    2ac2:	beq.w	3b26 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x11de>
      {
        write_length_ += len;
    2ac6:	ldr	r3, [r0, #4]
    2ac8:	adds	r3, #2
    2aca:	adds	r3, #2
    2acc:	adds	r3, #1
    2ace:	adds	r3, #8
    2ad0:	b.n	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
    2ad2:	movw	r2, #56327	; 0xdc07
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2ad6:	ldrb	r3, [r0, #0]
    2ad8:	strh.w	r2, [sp, #50]	; 0x32
    2adc:	cmp	r3, #0
    2ade:	bne.n	29f6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2ae0:	ldr	r3, [r0, #4]
    2ae2:	cmp	r3, #0
    2ae4:	beq.w	4592 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c4a>
    2ae8:	ldr	r4, [pc, #616]	; (2d54 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x40c>)
    2aea:	ldr	r0, [r4, #0]
        write_length_ += len;
    2aec:	adds	r3, #2
    2aee:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    2af2:	add.w	r9, sp, #50	; 0x32
        //
        int pos = 0; // into data
    2af6:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2afa:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2afc:	add.w	sl, r6, #544	; 0x220
    2b00:	b.n	2b0c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c4>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2b02:	cmp.w	r8, #1
    2b06:	bgt.w	3f44 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x15fc>
    2b0a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2b0c:	subs	r7, r5, r0
    2b0e:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2b12:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2b14:	cmp	r7, r3
    2b16:	it	ge
    2b18:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2b1a:	mov	r2, r7
          pos += to_copy;
    2b1c:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2b1e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2b22:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2b24:	add	r9, r7
          dst += to_copy;
    2b26:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2b28:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2b2a:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2b2c:	bne.n	2b02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1ba>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2b2e:	movs	r2, #60	; 0x3c
    2b30:	mov.w	r1, #512	; 0x200
    2b34:	mov	r0, sl
    2b36:	bl	9d50 <usb_mtp_send>
    2b3a:	cmp	r0, #0
    2b3c:	ble.n	2b2e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1e6>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2b3e:	str.w	sl, [r4]
    2b42:	b.n	2b02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1ba>
    2b44:	movw	r2, #56328	; 0xdc08
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2b48:	ldrb	r3, [r0, #0]
    2b4a:	strh.w	r2, [sp, #54]	; 0x36
    2b4e:	cmp	r3, #0
    2b50:	bne.w	29f6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2b54:	ldr	r3, [r0, #4]
    2b56:	cmp	r3, #0
    2b58:	beq.w	449e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b56>
    2b5c:	ldr	r4, [pc, #500]	; (2d54 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x40c>)
    2b5e:	ldr	r0, [r4, #0]
        write_length_ += len;
    2b60:	adds	r3, #2
    2b62:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    2b66:	add.w	r9, sp, #54	; 0x36
        //
        int pos = 0; // into data
    2b6a:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2b6e:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2b70:	add.w	sl, r6, #544	; 0x220
    2b74:	b.n	2b80 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x238>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2b76:	cmp.w	r8, #1
    2b7a:	bgt.w	2cbc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x374>
    2b7e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2b80:	subs	r7, r5, r0
    2b82:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2b86:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2b88:	cmp	r7, r3
    2b8a:	it	ge
    2b8c:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2b8e:	mov	r2, r7
          pos += to_copy;
    2b90:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2b92:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2b96:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2b98:	add	r9, r7
          dst += to_copy;
    2b9a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2b9c:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2b9e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2ba0:	bne.n	2b76 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x22e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2ba2:	movs	r2, #60	; 0x3c
    2ba4:	mov.w	r1, #512	; 0x200
    2ba8:	mov	r0, sl
    2baa:	bl	9d50 <usb_mtp_send>
    2bae:	cmp	r0, #0
    2bb0:	ble.n	2ba2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x25a>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2bb2:	str.w	sl, [r4]
    2bb6:	b.n	2b76 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x22e>
    2bb8:	movw	r2, #56329	; 0xdc09
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2bbc:	ldrb	r3, [r0, #0]
    2bbe:	strh.w	r2, [sp, #58]	; 0x3a
    2bc2:	cmp	r3, #0
    2bc4:	bne.w	29f6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xae>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2bc8:	ldr	r3, [r0, #4]
    2bca:	cmp	r3, #0
    2bcc:	beq.w	4564 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c1c>
    2bd0:	ldr	r4, [pc, #384]	; (2d54 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x40c>)
    2bd2:	ldr	r0, [r4, #0]
        write_length_ += len;
    2bd4:	adds	r3, #2
    2bd6:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    2bda:	add.w	r9, sp, #58	; 0x3a
        //
        int pos = 0; // into data
    2bde:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2be2:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2be4:	add.w	sl, r6, #544	; 0x220
    2be8:	b.n	2bf4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x2ac>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2bea:	cmp.w	r8, #1
    2bee:	bgt.w	2d9a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x452>
    2bf2:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2bf4:	subs	r7, r5, r0
    2bf6:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2bfa:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2bfc:	cmp	r7, r3
    2bfe:	it	ge
    2c00:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2c02:	mov	r2, r7
          pos += to_copy;
    2c04:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2c06:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2c0a:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2c0c:	add	r9, r7
          dst += to_copy;
    2c0e:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2c10:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2c12:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2c14:	bne.n	2bea <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x2a2>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2c16:	movs	r2, #60	; 0x3c
    2c18:	mov.w	r1, #512	; 0x200
    2c1c:	mov	r0, sl
    2c1e:	bl	9d50 <usb_mtp_send>
    2c22:	cmp	r0, #0
    2c24:	ble.n	2c16 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x2ce>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2c26:	str.w	sl, [r4]
    2c2a:	b.n	2bea <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x2a2>
    2c2c:	movw	r2, #56331	; 0xdc0b
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2c30:	ldrb	r3, [r0, #0]
    2c32:	strh.w	r2, [sp, #62]	; 0x3e
    2c36:	cmp	r3, #0
    2c38:	bne.w	2a1c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2c3c:	ldr	r3, [r0, #4]
    2c3e:	cmp	r3, #0
    2c40:	beq.w	454a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c02>
    2c44:	ldr	r4, [pc, #268]	; (2d54 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x40c>)
    2c46:	ldr	r0, [r4, #0]
        write_length_ += len;
    2c48:	adds	r3, #2
    2c4a:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    2c4e:	add.w	r9, sp, #62	; 0x3e
        //
        int pos = 0; // into data
    2c52:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2c56:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2c58:	add.w	sl, r6, #544	; 0x220
    2c5c:	b.n	2c68 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x320>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2c5e:	cmp.w	r8, #1
    2c62:	bgt.w	2faa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x662>
    2c66:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2c68:	subs	r7, r5, r0
    2c6a:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2c6e:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2c70:	cmp	r7, r3
    2c72:	it	ge
    2c74:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2c76:	mov	r2, r7
          pos += to_copy;
    2c78:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2c7a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2c7e:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2c80:	add	r9, r7
          dst += to_copy;
    2c82:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2c84:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2c86:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2c88:	bne.n	2c5e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x316>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2c8a:	movs	r2, #60	; 0x3c
    2c8c:	mov.w	r1, #512	; 0x200
    2c90:	mov	r0, sl
    2c92:	bl	9d50 <usb_mtp_send>
    2c96:	cmp	r0, #0
    2c98:	ble.n	2c8a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x342>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2c9a:	str.w	sl, [r4]
    2c9e:	b.n	2c5e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x316>
    2ca0:	movw	r2, #56385	; 0xdc41
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2ca4:	ldrb	r3, [r0, #0]
    2ca6:	strh.w	r2, [sp, #66]	; 0x42
    2caa:	cmp	r3, #0
    2cac:	beq.w	37d6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe8e>
      {
        write_length_ += len;
    2cb0:	ldr	r3, [r0, #4]
    2cb2:	adds	r3, #2
    2cb4:	adds	r3, #2
    2cb6:	adds	r3, #1
    2cb8:	adds	r3, #8
    2cba:	b.n	2ace <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x186>
    2cbc:	movw	r1, #65535	; 0xffff
    2cc0:	ldrb	r2, [r6, #0]
    2cc2:	ldr	r3, [r6, #4]
    2cc4:	strh.w	r1, [sp, #52]	; 0x34
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2cc8:	cmp	r2, #0
    2cca:	bne.w	29fa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb2>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2cce:	cmp	r3, #0
    2cd0:	beq.w	457c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c34>
    2cd4:	ldr	r0, [r4, #0]
        write_length_ += len;
    2cd6:	adds	r3, #2
        
        const char * src=data;
    2cd8:	add.w	r9, sp, #52	; 0x34
        //
        int pos = 0; // into data
    2cdc:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2ce0:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2ce4:	str	r3, [r6, #4]
    2ce6:	b.n	2cf0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x3a8>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2ce8:	cmp.w	r8, #1
    2cec:	bgt.n	2d28 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x3e0>
    2cee:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2cf0:	subs	r7, r5, r0
    2cf2:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2cf6:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2cf8:	cmp	r7, r3
    2cfa:	it	ge
    2cfc:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2cfe:	mov	r2, r7
          pos += to_copy;
    2d00:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2d02:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2d06:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2d08:	add	r9, r7
          dst += to_copy;
    2d0a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2d0c:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2d0e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2d10:	bne.n	2ce8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x3a0>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2d12:	movs	r2, #60	; 0x3c
    2d14:	mov.w	r1, #512	; 0x200
    2d18:	mov	r0, sl
    2d1a:	bl	9d50 <usb_mtp_send>
    2d1e:	cmp	r0, #0
    2d20:	ble.n	2d12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x3ca>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2d22:	str.w	sl, [r4]
    2d26:	b.n	2ce8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x3a0>
    2d28:	movs	r1, #0
    2d2a:	ldrb	r2, [r6, #0]
    2d2c:	ldr	r3, [r6, #4]
    2d2e:	strb.w	r1, [sp, #17]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2d32:	cmp	r2, #0
    2d34:	bne.w	29fc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2d38:	cmp	r3, #0
    2d3a:	beq.w	4558 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c10>
    2d3e:	ldr	r0, [r4, #0]
        write_length_ += len;
    2d40:	adds	r3, #1
        
        const char * src=data;
    2d42:	add.w	r9, sp, #17
        //
        int pos = 0; // into data
    2d46:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2d4a:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2d4e:	str	r3, [r6, #4]
    2d50:	b.n	2d62 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x41a>
    2d52:	nop
    2d54:	.word	0x2000158c
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2d58:	cmp.w	r8, #0
    2d5c:	bgt.w	4154 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x180c>
    2d60:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2d62:	subs	r7, r5, r0
    2d64:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    2d68:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2d6a:	cmp	r7, r3
    2d6c:	it	ge
    2d6e:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2d70:	mov	r2, r7
          pos += to_copy;
    2d72:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2d74:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2d78:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2d7a:	add	r9, r7
          dst += to_copy;
    2d7c:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2d7e:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2d80:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2d82:	bne.n	2d58 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x410>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2d84:	movs	r2, #60	; 0x3c
    2d86:	mov.w	r1, #512	; 0x200
    2d8a:	mov	r0, sl
    2d8c:	bl	9d50 <usb_mtp_send>
    2d90:	cmp	r0, #0
    2d92:	ble.n	2d84 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x43c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2d94:	str.w	sl, [r4]
    2d98:	b.n	2d58 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x410>
    2d9a:	movw	r1, #65535	; 0xffff
    2d9e:	ldrb	r2, [r6, #0]
    2da0:	ldr	r3, [r6, #4]
    2da2:	strh.w	r1, [sp, #56]	; 0x38
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2da6:	cmp	r2, #0
    2da8:	bne.w	29fa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb2>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2dac:	cmp	r3, #0
    2dae:	beq.w	4686 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d3e>
    2db2:	ldr	r0, [r4, #0]
        write_length_ += len;
    2db4:	adds	r3, #2
        
        const char * src=data;
    2db6:	add.w	r9, sp, #56	; 0x38
        //
        int pos = 0; // into data
    2dba:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2dbe:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2dc2:	str	r3, [r6, #4]
    2dc4:	b.n	2dce <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x486>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2dc6:	cmp.w	r8, #1
    2dca:	bgt.n	2e06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4be>
    2dcc:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2dce:	subs	r7, r5, r0
    2dd0:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2dd4:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2dd6:	cmp	r7, r3
    2dd8:	it	ge
    2dda:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2ddc:	mov	r2, r7
          pos += to_copy;
    2dde:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2de0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2de4:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2de6:	add	r9, r7
          dst += to_copy;
    2de8:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2dea:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2dec:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2dee:	bne.n	2dc6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x47e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2df0:	movs	r2, #60	; 0x3c
    2df2:	mov.w	r1, #512	; 0x200
    2df6:	mov	r0, sl
    2df8:	bl	9d50 <usb_mtp_send>
    2dfc:	cmp	r0, #0
    2dfe:	ble.n	2df0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4a8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2e00:	str.w	sl, [r4]
    2e04:	b.n	2dc6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x47e>
    2e06:	movs	r1, #0
    2e08:	ldrb	r2, [r6, #0]
    2e0a:	ldr	r3, [r6, #4]
    2e0c:	strb.w	r1, [sp, #20]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2e10:	cmp	r2, #0
    2e12:	bne.w	29fc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2e16:	cmp	r3, #0
    2e18:	beq.w	467a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d32>
    2e1c:	ldr	r0, [r4, #0]
        write_length_ += len;
    2e1e:	adds	r3, #1
        
        const char * src=data;
    2e20:	add.w	r9, sp, #20
        //
        int pos = 0; // into data
    2e24:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2e28:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2e2c:	str	r3, [r6, #4]
    2e2e:	b.n	2e38 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4f0>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2e30:	cmp.w	r8, #0
    2e34:	bgt.n	2e70 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x528>
    2e36:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2e38:	subs	r7, r5, r0
    2e3a:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    2e3e:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2e40:	cmp	r7, r3
    2e42:	it	ge
    2e44:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2e46:	mov	r2, r7
          pos += to_copy;
    2e48:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2e4a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2e4e:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2e50:	add	r9, r7
          dst += to_copy;
    2e52:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2e54:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2e56:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2e58:	bne.n	2e30 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4e8>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2e5a:	movs	r2, #60	; 0x3c
    2e5c:	mov.w	r1, #512	; 0x200
    2e60:	mov	r0, sl
    2e62:	bl	9d50 <usb_mtp_send>
    2e66:	cmp	r0, #0
    2e68:	ble.n	2e5a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x512>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2e6a:	str.w	sl, [r4]
    2e6e:	b.n	2e30 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4e8>
    2e70:	movs	r1, #0
    2e72:	ldrb	r2, [r6, #0]
    2e74:	ldr	r3, [r6, #4]
    2e76:	strb.w	r1, [sp, #19]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2e7a:	cmp	r2, #0
    2e7c:	bne.w	29fe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb6>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2e80:	cmp	r3, #0
    2e82:	beq.w	466e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d26>
    2e86:	ldr	r0, [r4, #0]
        write_length_ += len;
    2e88:	adds	r3, #1
        
        const char * src=data;
    2e8a:	add.w	r9, sp, #19
        //
        int pos = 0; // into data
    2e8e:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2e92:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2e96:	str	r3, [r6, #4]
    2e98:	b.n	2ea2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x55a>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2e9a:	cmp.w	r8, #0
    2e9e:	bgt.n	2eda <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x592>
    2ea0:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2ea2:	subs	r7, r5, r0
    2ea4:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    2ea8:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2eaa:	cmp	r7, r3
    2eac:	it	ge
    2eae:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2eb0:	mov	r2, r7
          pos += to_copy;
    2eb2:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2eb4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2eb8:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2eba:	add	r9, r7
          dst += to_copy;
    2ebc:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2ebe:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2ec0:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2ec2:	bne.n	2e9a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x552>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2ec4:	movs	r2, #60	; 0x3c
    2ec6:	mov.w	r1, #512	; 0x200
    2eca:	mov	r0, sl
    2ecc:	bl	9d50 <usb_mtp_send>
    2ed0:	cmp	r0, #0
    2ed2:	ble.n	2ec4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x57c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2ed4:	str.w	sl, [r4]
    2ed8:	b.n	2e9a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x552>
    2eda:	movs	r1, #0
    2edc:	ldrb	r2, [r6, #0]
    2ede:	ldr	r3, [r6, #4]
    2ee0:	str	r1, [sp, #100]	; 0x64
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2ee2:	cmp	r2, #0
    2ee4:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2ee8:	cmp	r3, #0
    2eea:	beq.w	4662 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d1a>
    2eee:	ldr	r0, [r4, #0]
        write_length_ += len;
    2ef0:	adds	r3, #4
        
        const char * src=data;
    2ef2:	add.w	r9, sp, #100	; 0x64
        //
        int pos = 0; // into data
    2ef6:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2efa:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2efe:	str	r3, [r6, #4]
    2f00:	b.n	2f0a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5c2>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2f02:	cmp.w	r8, #3
    2f06:	bgt.n	2f42 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5fa>
    2f08:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2f0a:	subs	r7, r5, r0
    2f0c:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    2f10:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2f12:	cmp	r7, r3
    2f14:	it	ge
    2f16:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2f18:	mov	r2, r7
          pos += to_copy;
    2f1a:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2f1c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2f20:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2f22:	add	r9, r7
          dst += to_copy;
    2f24:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2f26:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2f28:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2f2a:	bne.n	2f02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5ba>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2f2c:	movs	r2, #60	; 0x3c
    2f2e:	mov.w	r1, #512	; 0x200
    2f32:	mov	r0, sl
    2f34:	bl	9d50 <usb_mtp_send>
    2f38:	cmp	r0, #0
    2f3a:	ble.n	2f2c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5e4>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2f3c:	str.w	sl, [r4]
    2f40:	b.n	2f02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5ba>
    2f42:	movs	r1, #0
    2f44:	ldrb	r2, [r6, #0]
    2f46:	ldr	r3, [r6, #4]
    2f48:	strb.w	r1, [sp, #18]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2f4c:	cmp	r2, #0
    2f4e:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2f52:	cmp	r3, #0
    2f54:	beq.w	453e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bf6>
    2f58:	ldr	r0, [r4, #0]
        write_length_ += len;
    2f5a:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2f5c:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    2f60:	add.w	r8, sp, #18
        //
        int pos = 0; // into data
    2f64:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2f66:	str	r3, [r6, #4]
    2f68:	b.n	2f72 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x62a>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2f6a:	cmp	r7, #0
    2f6c:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    2f70:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2f72:	subs	r6, r5, r0
    2f74:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    2f78:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2f7a:	cmp	r6, r3
    2f7c:	it	ge
    2f7e:	movge	r6, r3
          memcpy(dst,src,to_copy);
    2f80:	mov	r2, r6
          pos += to_copy;
    2f82:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2f84:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2f88:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2f8a:	add	r8, r6
          dst += to_copy;
    2f8c:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2f8e:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2f90:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2f92:	bne.n	2f6a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x622>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2f94:	movs	r2, #60	; 0x3c
    2f96:	mov.w	r1, #512	; 0x200
    2f9a:	mov	r0, r9
    2f9c:	bl	9d50 <usb_mtp_send>
    2fa0:	cmp	r0, #0
    2fa2:	ble.n	2f94 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x64c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    2fa4:	str.w	r9, [r4]
    2fa8:	b.n	2f6a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x622>
    2faa:	movs	r1, #6
    2fac:	ldrb	r2, [r6, #0]
    2fae:	ldr	r3, [r6, #4]
    2fb0:	strh.w	r1, [sp, #60]	; 0x3c
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    2fb4:	cmp	r2, #0
    2fb6:	bne.w	2a20 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    2fba:	cmp	r3, #0
    2fbc:	beq.w	4656 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d0e>
    2fc0:	ldr	r0, [r4, #0]
        write_length_ += len;
    2fc2:	adds	r3, #2
        
        const char * src=data;
    2fc4:	add.w	r9, sp, #60	; 0x3c
        //
        int pos = 0; // into data
    2fc8:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    2fcc:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    2fd0:	str	r3, [r6, #4]
    2fd2:	b.n	2fdc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x694>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    2fd4:	cmp.w	r8, #1
    2fd8:	bgt.n	3014 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6cc>
    2fda:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2fdc:	subs	r7, r5, r0
    2fde:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    2fe2:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    2fe4:	cmp	r7, r3
    2fe6:	it	ge
    2fe8:	movge	r7, r3
          memcpy(dst,src,to_copy);
    2fea:	mov	r2, r7
          pos += to_copy;
    2fec:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    2fee:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2ff2:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    2ff4:	add	r9, r7
          dst += to_copy;
    2ff6:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2ff8:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    2ffa:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    2ffc:	bne.n	2fd4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x68c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    2ffe:	movs	r2, #60	; 0x3c
    3000:	mov.w	r1, #512	; 0x200
    3004:	mov	r0, sl
    3006:	bl	9d50 <usb_mtp_send>
    300a:	cmp	r0, #0
    300c:	ble.n	2ffe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6b6>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    300e:	str.w	sl, [r4]
    3012:	b.n	2fd4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x68c>
    3014:	movs	r1, #0
    3016:	ldrb	r2, [r6, #0]
    3018:	ldr	r3, [r6, #4]
    301a:	strb.w	r1, [sp, #22]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    301e:	cmp	r2, #0
    3020:	bne.w	2a22 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xda>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3024:	cmp	r3, #0
    3026:	beq.w	464a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d02>
    302a:	ldr	r0, [r4, #0]
        write_length_ += len;
    302c:	adds	r3, #1
        
        const char * src=data;
    302e:	add.w	r9, sp, #22
        //
        int pos = 0; // into data
    3032:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3036:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    303a:	str	r3, [r6, #4]
    303c:	b.n	3046 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6fe>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    303e:	cmp.w	r8, #0
    3042:	bgt.n	307e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x736>
    3044:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3046:	subs	r7, r5, r0
    3048:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    304c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    304e:	cmp	r7, r3
    3050:	it	ge
    3052:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3054:	mov	r2, r7
          pos += to_copy;
    3056:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3058:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    305c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    305e:	add	r9, r7
          dst += to_copy;
    3060:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3062:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3064:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3066:	bne.n	303e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6f6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3068:	movs	r2, #60	; 0x3c
    306a:	mov.w	r1, #512	; 0x200
    306e:	mov	r0, sl
    3070:	bl	9d50 <usb_mtp_send>
    3074:	cmp	r0, #0
    3076:	ble.n	3068 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x720>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3078:	str.w	sl, [r4]
    307c:	b.n	303e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6f6>
    307e:	movs	r1, #0
    3080:	ldrb	r2, [r6, #0]
    3082:	ldr	r3, [r6, #4]
    3084:	str	r1, [sp, #108]	; 0x6c
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3086:	cmp	r2, #0
    3088:	bne.w	2a24 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xdc>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    308c:	cmp	r3, #0
    308e:	beq.w	463e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1cf6>
    3092:	ldr	r0, [r4, #0]
        write_length_ += len;
    3094:	adds	r3, #4
        
        const char * src=data;
    3096:	add.w	r9, sp, #108	; 0x6c
        //
        int pos = 0; // into data
    309a:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    309e:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    30a2:	str	r3, [r6, #4]
    30a4:	b.n	30ae <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x766>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    30a6:	cmp.w	r8, #3
    30aa:	bgt.n	30e6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x79e>
    30ac:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    30ae:	subs	r7, r5, r0
    30b0:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    30b4:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    30b6:	cmp	r7, r3
    30b8:	it	ge
    30ba:	movge	r7, r3
          memcpy(dst,src,to_copy);
    30bc:	mov	r2, r7
          pos += to_copy;
    30be:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    30c0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    30c4:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    30c6:	add	r9, r7
          dst += to_copy;
    30c8:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    30ca:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    30cc:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    30ce:	bne.n	30a6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x75e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    30d0:	movs	r2, #60	; 0x3c
    30d2:	mov.w	r1, #512	; 0x200
    30d6:	mov	r0, sl
    30d8:	bl	9d50 <usb_mtp_send>
    30dc:	cmp	r0, #0
    30de:	ble.n	30d0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x788>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    30e0:	str.w	sl, [r4]
    30e4:	b.n	30a6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x75e>
    30e6:	movs	r1, #0
    30e8:	ldrb	r2, [r6, #0]
    30ea:	ldr	r3, [r6, #4]
    30ec:	str	r1, [sp, #104]	; 0x68
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    30ee:	cmp	r2, #0
    30f0:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    30f4:	cmp	r3, #0
    30f6:	beq.w	4632 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1cea>
    30fa:	ldr	r0, [r4, #0]
        write_length_ += len;
    30fc:	adds	r3, #4
        
        const char * src=data;
    30fe:	add.w	r9, sp, #104	; 0x68
        //
        int pos = 0; // into data
    3102:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3106:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    310a:	str	r3, [r6, #4]
    310c:	b.n	3116 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x7ce>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    310e:	cmp.w	r8, #3
    3112:	bgt.n	314e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x806>
    3114:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3116:	subs	r7, r5, r0
    3118:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    311c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    311e:	cmp	r7, r3
    3120:	it	ge
    3122:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3124:	mov	r2, r7
          pos += to_copy;
    3126:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3128:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    312c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    312e:	add	r9, r7
          dst += to_copy;
    3130:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3132:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3134:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3136:	bne.n	310e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x7c6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3138:	movs	r2, #60	; 0x3c
    313a:	mov.w	r1, #512	; 0x200
    313e:	mov	r0, sl
    3140:	bl	9d50 <usb_mtp_send>
    3144:	cmp	r0, #0
    3146:	ble.n	3138 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x7f0>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3148:	str.w	sl, [r4]
    314c:	b.n	310e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x7c6>
    314e:	movs	r1, #0
    3150:	ldrb	r2, [r6, #0]
    3152:	ldr	r3, [r6, #4]
    3154:	strb.w	r1, [sp, #21]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3158:	cmp	r2, #0
    315a:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    315e:	cmp	r3, #0
    3160:	beq.w	45f4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1cac>
    3164:	ldr	r0, [r4, #0]
        write_length_ += len;
    3166:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3168:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    316c:	add.w	r8, sp, #21
        //
        int pos = 0; // into data
    3170:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3172:	str	r3, [r6, #4]
    3174:	b.n	317e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x836>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3176:	cmp	r7, #0
    3178:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    317c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    317e:	subs	r6, r5, r0
    3180:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    3184:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3186:	cmp	r6, r3
    3188:	it	ge
    318a:	movge	r6, r3
          memcpy(dst,src,to_copy);
    318c:	mov	r2, r6
          pos += to_copy;
    318e:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3190:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3194:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3196:	add	r8, r6
          dst += to_copy;
    3198:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    319a:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    319c:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    319e:	bne.n	3176 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x82e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    31a0:	movs	r2, #60	; 0x3c
    31a2:	mov.w	r1, #512	; 0x200
    31a6:	mov	r0, r9
    31a8:	bl	9d50 <usb_mtp_send>
    31ac:	cmp	r0, #0
    31ae:	ble.n	31a0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x858>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    31b0:	str.w	r9, [r4]
    31b4:	b.n	3176 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x82e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    31b6:	ldr	r3, [r0, #4]
    31b8:	cmp	r3, #0
    31ba:	beq.w	4624 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1cdc>
    31be:	ldr	r4, [pc, #756]	; (34b4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb6c>)
    31c0:	ldr	r0, [r4, #0]
        write_length_ += len;
    31c2:	adds	r3, #2
    31c4:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    31c8:	add.w	r9, sp, #36	; 0x24
        //
        int pos = 0; // into data
    31cc:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    31d0:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    31d2:	add.w	sl, r6, #544	; 0x220
    31d6:	b.n	31e0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x898>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    31d8:	cmp.w	r8, #1
    31dc:	bgt.n	3218 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x8d0>
    31de:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    31e0:	subs	r7, r5, r0
    31e2:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    31e6:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    31e8:	cmp	r7, r3
    31ea:	it	ge
    31ec:	movge	r7, r3
          memcpy(dst,src,to_copy);
    31ee:	mov	r2, r7
          pos += to_copy;
    31f0:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    31f2:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    31f6:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    31f8:	add	r9, r7
          dst += to_copy;
    31fa:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    31fc:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    31fe:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3200:	bne.n	31d8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x890>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3202:	movs	r2, #60	; 0x3c
    3204:	mov.w	r1, #512	; 0x200
    3208:	mov	r0, sl
    320a:	bl	9d50 <usb_mtp_send>
    320e:	cmp	r0, #0
    3210:	ble.n	3202 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x8ba>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3212:	str.w	sl, [r4]
    3216:	b.n	31d8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x890>
    3218:	movs	r1, #4
    321a:	ldrb	r2, [r6, #0]
    321c:	ldr	r3, [r6, #4]
    321e:	strh.w	r1, [sp, #34]	; 0x22
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3222:	cmp	r2, #0
    3224:	bne.w	2a3c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3228:	cmp	r3, #0
    322a:	beq.w	4618 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1cd0>
    322e:	ldr	r0, [r4, #0]
        write_length_ += len;
    3230:	adds	r3, #2
        
        const char * src=data;
    3232:	add.w	r9, sp, #34	; 0x22
        //
        int pos = 0; // into data
    3236:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    323a:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    323e:	str	r3, [r6, #4]
    3240:	b.n	324a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x902>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3242:	cmp.w	r8, #1
    3246:	bgt.n	3282 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x93a>
    3248:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    324a:	subs	r7, r5, r0
    324c:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3250:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3252:	cmp	r7, r3
    3254:	it	ge
    3256:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3258:	mov	r2, r7
          pos += to_copy;
    325a:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    325c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3260:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3262:	add	r9, r7
          dst += to_copy;
    3264:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3266:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3268:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    326a:	bne.n	3242 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x8fa>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    326c:	movs	r2, #60	; 0x3c
    326e:	mov.w	r1, #512	; 0x200
    3272:	mov	r0, sl
    3274:	bl	9d50 <usb_mtp_send>
    3278:	cmp	r0, #0
    327a:	ble.n	326c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x924>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    327c:	str.w	sl, [r4]
    3280:	b.n	3242 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x8fa>
    3282:	movs	r1, #0
    3284:	ldrb	r2, [r6, #0]
    3286:	ldr	r3, [r6, #4]
    3288:	strb.w	r1, [sp, #7]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    328c:	cmp	r2, #0
    328e:	bne.w	2a3e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf6>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3292:	cmp	r3, #0
    3294:	beq.w	460c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1cc4>
    3298:	ldr	r0, [r4, #0]
        write_length_ += len;
    329a:	adds	r3, #1
        
        const char * src=data;
    329c:	add.w	r9, sp, #7
        //
        int pos = 0; // into data
    32a0:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    32a4:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    32a8:	str	r3, [r6, #4]
    32aa:	b.n	32b4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x96c>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    32ac:	cmp.w	r8, #0
    32b0:	bgt.n	32ec <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x9a4>
    32b2:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    32b4:	subs	r7, r5, r0
    32b6:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    32ba:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    32bc:	cmp	r7, r3
    32be:	it	ge
    32c0:	movge	r7, r3
          memcpy(dst,src,to_copy);
    32c2:	mov	r2, r7
          pos += to_copy;
    32c4:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    32c6:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    32ca:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    32cc:	add	r9, r7
          dst += to_copy;
    32ce:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    32d0:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    32d2:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    32d4:	bne.n	32ac <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x964>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    32d6:	movs	r2, #60	; 0x3c
    32d8:	mov.w	r1, #512	; 0x200
    32dc:	mov	r0, sl
    32de:	bl	9d50 <usb_mtp_send>
    32e2:	cmp	r0, #0
    32e4:	ble.n	32d6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x98e>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    32e6:	str.w	sl, [r4]
    32ea:	b.n	32ac <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x964>
    32ec:	movs	r1, #0
    32ee:	ldrb	r2, [r6, #0]
    32f0:	ldr	r3, [r6, #4]
    32f2:	strh.w	r1, [sp, #32]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    32f6:	cmp	r2, #0
    32f8:	bne.w	2a40 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    32fc:	cmp	r3, #0
    32fe:	beq.w	4600 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1cb8>
    3302:	ldr	r0, [r4, #0]
        write_length_ += len;
    3304:	adds	r3, #2
        
        const char * src=data;
    3306:	add.w	r9, sp, #32
        //
        int pos = 0; // into data
    330a:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    330e:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3312:	str	r3, [r6, #4]
    3314:	b.n	331e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x9d6>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3316:	cmp.w	r8, #1
    331a:	bgt.n	3356 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa0e>
    331c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    331e:	subs	r7, r5, r0
    3320:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3324:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3326:	cmp	r7, r3
    3328:	it	ge
    332a:	movge	r7, r3
          memcpy(dst,src,to_copy);
    332c:	mov	r2, r7
          pos += to_copy;
    332e:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3330:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3334:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3336:	add	r9, r7
          dst += to_copy;
    3338:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    333a:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    333c:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    333e:	bne.n	3316 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x9ce>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3340:	movs	r2, #60	; 0x3c
    3342:	mov.w	r1, #512	; 0x200
    3346:	mov	r0, sl
    3348:	bl	9d50 <usb_mtp_send>
    334c:	cmp	r0, #0
    334e:	ble.n	3340 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x9f8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3350:	str.w	sl, [r4]
    3354:	b.n	3316 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x9ce>
    3356:	movs	r1, #0
    3358:	ldrb	r2, [r6, #0]
    335a:	ldr	r3, [r6, #4]
    335c:	str	r1, [sp, #80]	; 0x50
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    335e:	cmp	r2, #0
    3360:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3364:	cmp	r3, #0
    3366:	beq.w	4532 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bea>
    336a:	ldr	r0, [r4, #0]
        write_length_ += len;
    336c:	adds	r3, #4
        
        const char * src=data;
    336e:	add.w	r9, sp, #80	; 0x50
        //
        int pos = 0; // into data
    3372:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3376:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    337a:	str	r3, [r6, #4]
    337c:	b.n	3386 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa3e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    337e:	cmp.w	r8, #3
    3382:	bgt.n	33be <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa76>
    3384:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3386:	subs	r7, r5, r0
    3388:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    338c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    338e:	cmp	r7, r3
    3390:	it	ge
    3392:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3394:	mov	r2, r7
          pos += to_copy;
    3396:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3398:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    339c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    339e:	add	r9, r7
          dst += to_copy;
    33a0:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    33a2:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    33a4:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    33a6:	bne.n	337e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa36>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    33a8:	movs	r2, #60	; 0x3c
    33aa:	mov.w	r1, #512	; 0x200
    33ae:	mov	r0, sl
    33b0:	bl	9d50 <usb_mtp_send>
    33b4:	cmp	r0, #0
    33b6:	ble.n	33a8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa60>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    33b8:	str.w	sl, [r4]
    33bc:	b.n	337e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa36>
    33be:	movs	r1, #0
    33c0:	ldrb	r2, [r6, #0]
    33c2:	ldr	r3, [r6, #4]
    33c4:	strb.w	r1, [sp, #6]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    33c8:	cmp	r2, #0
    33ca:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    33ce:	cmp	r3, #0
    33d0:	beq.w	4526 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bde>
    33d4:	ldr	r0, [r4, #0]
        write_length_ += len;
    33d6:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    33d8:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    33dc:	add.w	r8, sp, #6
        //
        int pos = 0; // into data
    33e0:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    33e2:	str	r3, [r6, #4]
    33e4:	b.n	33ee <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xaa6>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    33e6:	cmp	r7, #0
    33e8:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    33ec:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    33ee:	subs	r6, r5, r0
    33f0:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    33f4:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    33f6:	cmp	r6, r3
    33f8:	it	ge
    33fa:	movge	r6, r3
          memcpy(dst,src,to_copy);
    33fc:	mov	r2, r6
          pos += to_copy;
    33fe:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3400:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3404:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3406:	add	r8, r6
          dst += to_copy;
    3408:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    340a:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    340c:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    340e:	bne.n	33e6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa9e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3410:	movs	r2, #60	; 0x3c
    3412:	mov.w	r1, #512	; 0x200
    3416:	mov	r0, r9
    3418:	bl	9d50 <usb_mtp_send>
    341c:	cmp	r0, #0
    341e:	ble.n	3410 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xac8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3420:	str.w	r9, [r4]
    3424:	b.n	33e6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa9e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3426:	ldr	r3, [r0, #4]
    3428:	cmp	r3, #0
    342a:	beq.w	45e6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c9e>
    342e:	ldr	r4, [pc, #132]	; (34b4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb6c>)
    3430:	ldr	r0, [r4, #0]
        write_length_ += len;
    3432:	adds	r3, #2
    3434:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    3438:	add.w	r9, sp, #30
        //
        int pos = 0; // into data
    343c:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3440:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3442:	add.w	sl, r6, #544	; 0x220
    3446:	b.n	3450 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb08>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3448:	cmp.w	r8, #1
    344c:	bgt.n	3488 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb40>
    344e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3450:	subs	r7, r5, r0
    3452:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3456:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3458:	cmp	r7, r3
    345a:	it	ge
    345c:	movge	r7, r3
          memcpy(dst,src,to_copy);
    345e:	mov	r2, r7
          pos += to_copy;
    3460:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3462:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3466:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3468:	add	r9, r7
          dst += to_copy;
    346a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    346c:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    346e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3470:	bne.n	3448 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb00>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3472:	movs	r2, #60	; 0x3c
    3474:	mov.w	r1, #512	; 0x200
    3478:	mov	r0, sl
    347a:	bl	9d50 <usb_mtp_send>
    347e:	cmp	r0, #0
    3480:	ble.n	3472 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb2a>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3482:	str.w	sl, [r4]
    3486:	b.n	3448 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb00>
    3488:	movs	r1, #6
    348a:	ldrb	r2, [r6, #0]
    348c:	ldr	r3, [r6, #4]
    348e:	strh.w	r1, [sp, #28]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3492:	cmp	r2, #0
    3494:	bne.w	2a20 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3498:	cmp	r3, #0
    349a:	beq.w	45da <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c92>
    349e:	ldr	r0, [r4, #0]
        write_length_ += len;
    34a0:	adds	r3, #2
        
        const char * src=data;
    34a2:	add.w	r9, sp, #28
        //
        int pos = 0; // into data
    34a6:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    34aa:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    34ae:	str	r3, [r6, #4]
    34b0:	b.n	34c0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb78>
    34b2:	nop
    34b4:	.word	0x2000158c
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    34b8:	cmp.w	r8, #1
    34bc:	bgt.n	34f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbb0>
    34be:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    34c0:	subs	r7, r5, r0
    34c2:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    34c6:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    34c8:	cmp	r7, r3
    34ca:	it	ge
    34cc:	movge	r7, r3
          memcpy(dst,src,to_copy);
    34ce:	mov	r2, r7
          pos += to_copy;
    34d0:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    34d2:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    34d6:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    34d8:	add	r9, r7
          dst += to_copy;
    34da:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    34dc:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    34de:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    34e0:	bne.n	34b8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb70>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    34e2:	movs	r2, #60	; 0x3c
    34e4:	mov.w	r1, #512	; 0x200
    34e8:	mov	r0, sl
    34ea:	bl	9d50 <usb_mtp_send>
    34ee:	cmp	r0, #0
    34f0:	ble.n	34e2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb9a>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    34f2:	str.w	sl, [r4]
    34f6:	b.n	34b8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb70>
    34f8:	movs	r1, #0
    34fa:	ldrb	r2, [r6, #0]
    34fc:	ldr	r3, [r6, #4]
    34fe:	strb.w	r1, [sp, #5]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3502:	cmp	r2, #0
    3504:	bne.w	2a22 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xda>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3508:	cmp	r3, #0
    350a:	beq.w	44d2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b8a>
    350e:	ldr	r0, [r4, #0]
        write_length_ += len;
    3510:	adds	r3, #1
        
        const char * src=data;
    3512:	add.w	r9, sp, #5
        //
        int pos = 0; // into data
    3516:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    351a:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    351e:	str	r3, [r6, #4]
    3520:	b.n	352c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe4>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3522:	cmp.w	r8, #0
    3526:	bgt.w	428e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1946>
    352a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    352c:	subs	r7, r5, r0
    352e:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    3532:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3534:	cmp	r7, r3
    3536:	it	ge
    3538:	movge	r7, r3
          memcpy(dst,src,to_copy);
    353a:	mov	r2, r7
          pos += to_copy;
    353c:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    353e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3542:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3544:	add	r9, r7
          dst += to_copy;
    3546:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3548:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    354a:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    354c:	bne.n	3522 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbda>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    354e:	movs	r2, #60	; 0x3c
    3550:	mov.w	r1, #512	; 0x200
    3554:	mov	r0, sl
    3556:	bl	9d50 <usb_mtp_send>
    355a:	cmp	r0, #0
    355c:	ble.n	354e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc06>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    355e:	str.w	sl, [r4]
    3562:	b.n	3522 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbda>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3564:	ldr	r3, [r0, #4]
    3566:	cmp	r3, #0
    3568:	beq.w	4502 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bba>
    356c:	ldr	r4, [pc, #756]	; (3864 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf1c>)
    356e:	ldr	r0, [r4, #0]
        write_length_ += len;
    3570:	adds	r3, #2
    3572:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    3576:	add.w	r9, sp, #70	; 0x46
        //
        int pos = 0; // into data
    357a:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    357e:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3580:	add.w	sl, r6, #544	; 0x220
    3584:	b.n	358e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc46>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3586:	cmp.w	r8, #1
    358a:	bgt.n	35c6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc7e>
    358c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    358e:	subs	r7, r5, r0
    3590:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3594:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3596:	cmp	r7, r3
    3598:	it	ge
    359a:	movge	r7, r3
          memcpy(dst,src,to_copy);
    359c:	mov	r2, r7
          pos += to_copy;
    359e:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    35a0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    35a4:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    35a6:	add	r9, r7
          dst += to_copy;
    35a8:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    35aa:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    35ac:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    35ae:	bne.n	3586 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc3e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    35b0:	movs	r2, #60	; 0x3c
    35b2:	mov.w	r1, #512	; 0x200
    35b6:	mov	r0, sl
    35b8:	bl	9d50 <usb_mtp_send>
    35bc:	cmp	r0, #0
    35be:	ble.n	35b0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc68>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    35c0:	str.w	sl, [r4]
    35c4:	b.n	3586 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc3e>
    35c6:	movw	r1, #65535	; 0xffff
    35ca:	ldrb	r2, [r6, #0]
    35cc:	ldr	r3, [r6, #4]
    35ce:	strh.w	r1, [sp, #68]	; 0x44
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    35d2:	cmp	r2, #0
    35d4:	bne.w	29fa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb2>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    35d8:	cmp	r3, #0
    35da:	beq.w	44f6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bae>
    35de:	ldr	r0, [r4, #0]
        write_length_ += len;
    35e0:	adds	r3, #2
        
        const char * src=data;
    35e2:	add.w	r9, sp, #68	; 0x44
        //
        int pos = 0; // into data
    35e6:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    35ea:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    35ee:	str	r3, [r6, #4]
    35f0:	b.n	35fa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xcb2>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    35f2:	cmp.w	r8, #1
    35f6:	bgt.n	3632 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xcea>
    35f8:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    35fa:	subs	r7, r5, r0
    35fc:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3600:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3602:	cmp	r7, r3
    3604:	it	ge
    3606:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3608:	mov	r2, r7
          pos += to_copy;
    360a:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    360c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3610:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3612:	add	r9, r7
          dst += to_copy;
    3614:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3616:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3618:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    361a:	bne.n	35f2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xcaa>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    361c:	movs	r2, #60	; 0x3c
    361e:	mov.w	r1, #512	; 0x200
    3622:	mov	r0, sl
    3624:	bl	9d50 <usb_mtp_send>
    3628:	cmp	r0, #0
    362a:	ble.n	361c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xcd4>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    362c:	str.w	sl, [r4]
    3630:	b.n	35f2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xcaa>
    3632:	movs	r1, #0
    3634:	ldrb	r2, [r6, #0]
    3636:	ldr	r3, [r6, #4]
    3638:	strb.w	r1, [sp, #27]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    363c:	cmp	r2, #0
    363e:	bne.w	29fc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3642:	cmp	r3, #0
    3644:	beq.w	44ea <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1ba2>
    3648:	ldr	r0, [r4, #0]
        write_length_ += len;
    364a:	adds	r3, #1
        
        const char * src=data;
    364c:	add.w	r9, sp, #27
        //
        int pos = 0; // into data
    3650:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3654:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3658:	str	r3, [r6, #4]
    365a:	b.n	3664 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd1c>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    365c:	cmp.w	r8, #0
    3660:	bgt.n	369c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd54>
    3662:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3664:	subs	r7, r5, r0
    3666:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    366a:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    366c:	cmp	r7, r3
    366e:	it	ge
    3670:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3672:	mov	r2, r7
          pos += to_copy;
    3674:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3676:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    367a:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    367c:	add	r9, r7
          dst += to_copy;
    367e:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3680:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3682:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3684:	bne.n	365c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd14>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3686:	movs	r2, #60	; 0x3c
    3688:	mov.w	r1, #512	; 0x200
    368c:	mov	r0, sl
    368e:	bl	9d50 <usb_mtp_send>
    3692:	cmp	r0, #0
    3694:	ble.n	3686 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd3e>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3696:	str.w	sl, [r4]
    369a:	b.n	365c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd14>
    369c:	movs	r1, #0
    369e:	ldrb	r2, [r6, #0]
    36a0:	ldr	r3, [r6, #4]
    36a2:	strb.w	r1, [sp, #26]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    36a6:	cmp	r2, #0
    36a8:	bne.w	29fe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb6>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    36ac:	cmp	r3, #0
    36ae:	beq.w	44de <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b96>
    36b2:	ldr	r0, [r4, #0]
        write_length_ += len;
    36b4:	adds	r3, #1
        
        const char * src=data;
    36b6:	add.w	r9, sp, #26
        //
        int pos = 0; // into data
    36ba:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    36be:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    36c2:	str	r3, [r6, #4]
    36c4:	b.n	36ce <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd86>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    36c6:	cmp.w	r8, #0
    36ca:	bgt.n	3706 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xdbe>
    36cc:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    36ce:	subs	r7, r5, r0
    36d0:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    36d4:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    36d6:	cmp	r7, r3
    36d8:	it	ge
    36da:	movge	r7, r3
          memcpy(dst,src,to_copy);
    36dc:	mov	r2, r7
          pos += to_copy;
    36de:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    36e0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    36e4:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    36e6:	add	r9, r7
          dst += to_copy;
    36e8:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    36ea:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    36ec:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    36ee:	bne.n	36c6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd7e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    36f0:	movs	r2, #60	; 0x3c
    36f2:	mov.w	r1, #512	; 0x200
    36f6:	mov	r0, sl
    36f8:	bl	9d50 <usb_mtp_send>
    36fc:	cmp	r0, #0
    36fe:	ble.n	36f0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xda8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3700:	str.w	sl, [r4]
    3704:	b.n	36c6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd7e>
    3706:	movs	r1, #0
    3708:	ldrb	r2, [r6, #0]
    370a:	ldr	r3, [r6, #4]
    370c:	str	r1, [sp, #116]	; 0x74
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    370e:	cmp	r2, #0
    3710:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3714:	cmp	r3, #0
    3716:	beq.w	451a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bd2>
    371a:	ldr	r0, [r4, #0]
        write_length_ += len;
    371c:	adds	r3, #4
        
        const char * src=data;
    371e:	add.w	r9, sp, #116	; 0x74
        //
        int pos = 0; // into data
    3722:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3726:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    372a:	str	r3, [r6, #4]
    372c:	b.n	3736 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xdee>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    372e:	cmp.w	r8, #3
    3732:	bgt.n	376e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe26>
    3734:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3736:	subs	r7, r5, r0
    3738:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    373c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    373e:	cmp	r7, r3
    3740:	it	ge
    3742:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3744:	mov	r2, r7
          pos += to_copy;
    3746:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3748:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    374c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    374e:	add	r9, r7
          dst += to_copy;
    3750:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3752:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3754:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3756:	bne.n	372e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xde6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3758:	movs	r2, #60	; 0x3c
    375a:	mov.w	r1, #512	; 0x200
    375e:	mov	r0, sl
    3760:	bl	9d50 <usb_mtp_send>
    3764:	cmp	r0, #0
    3766:	ble.n	3758 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe10>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3768:	str.w	sl, [r4]
    376c:	b.n	372e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xde6>
    376e:	movs	r1, #0
    3770:	ldrb	r2, [r6, #0]
    3772:	ldr	r3, [r6, #4]
    3774:	strb.w	r1, [sp, #25]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3778:	cmp	r2, #0
    377a:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    377e:	cmp	r3, #0
    3780:	beq.w	43c4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a7c>
    3784:	ldr	r0, [r4, #0]
        write_length_ += len;
    3786:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3788:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    378c:	add.w	r8, sp, #25
        //
        int pos = 0; // into data
    3790:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3792:	str	r3, [r6, #4]
    3794:	b.n	379e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe56>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3796:	cmp	r7, #0
    3798:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    379c:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    379e:	subs	r6, r5, r0
    37a0:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    37a4:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    37a6:	cmp	r6, r3
    37a8:	it	ge
    37aa:	movge	r6, r3
          memcpy(dst,src,to_copy);
    37ac:	mov	r2, r6
          pos += to_copy;
    37ae:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    37b0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    37b4:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    37b6:	add	r8, r6
          dst += to_copy;
    37b8:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    37ba:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    37bc:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    37be:	bne.n	3796 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe4e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    37c0:	movs	r2, #60	; 0x3c
    37c2:	mov.w	r1, #512	; 0x200
    37c6:	mov	r0, r9
    37c8:	bl	9d50 <usb_mtp_send>
    37cc:	cmp	r0, #0
    37ce:	ble.n	37c0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe78>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    37d0:	str.w	r9, [r4]
    37d4:	b.n	3796 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe4e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    37d6:	ldr	r3, [r0, #4]
    37d8:	cmp	r3, #0
    37da:	beq.w	44c4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b7c>
    37de:	ldr	r4, [pc, #132]	; (3864 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf1c>)
    37e0:	ldr	r0, [r4, #0]
        write_length_ += len;
    37e2:	adds	r3, #2
    37e4:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    37e8:	add.w	r9, sp, #66	; 0x42
        //
        int pos = 0; // into data
    37ec:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    37f0:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    37f2:	add.w	sl, r6, #544	; 0x220
    37f6:	b.n	3800 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xeb8>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    37f8:	cmp.w	r8, #1
    37fc:	bgt.n	3838 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xef0>
    37fe:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3800:	subs	r7, r5, r0
    3802:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3806:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3808:	cmp	r7, r3
    380a:	it	ge
    380c:	movge	r7, r3
          memcpy(dst,src,to_copy);
    380e:	mov	r2, r7
          pos += to_copy;
    3810:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3812:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3816:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3818:	add	r9, r7
          dst += to_copy;
    381a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    381c:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    381e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3820:	bne.n	37f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xeb0>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3822:	movs	r2, #60	; 0x3c
    3824:	mov.w	r1, #512	; 0x200
    3828:	mov	r0, sl
    382a:	bl	9d50 <usb_mtp_send>
    382e:	cmp	r0, #0
    3830:	ble.n	3822 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xeda>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3832:	str.w	sl, [r4]
    3836:	b.n	37f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xeb0>
    3838:	movs	r1, #10
    383a:	ldrb	r2, [r6, #0]
    383c:	ldr	r3, [r6, #4]
    383e:	strh.w	r1, [sp, #64]	; 0x40
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3842:	cmp	r2, #0
    3844:	bne.w	2cb4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x36c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3848:	cmp	r3, #0
    384a:	beq.w	44b8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b70>
    384e:	ldr	r0, [r4, #0]
        write_length_ += len;
    3850:	adds	r3, #2
        
        const char * src=data;
    3852:	add.w	r9, sp, #64	; 0x40
        //
        int pos = 0; // into data
    3856:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    385a:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    385e:	str	r3, [r6, #4]
    3860:	b.n	3870 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf28>
    3862:	nop
    3864:	.word	0x2000158c
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3868:	cmp.w	r8, #1
    386c:	bgt.n	38a8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf60>
    386e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3870:	subs	r7, r5, r0
    3872:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3876:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3878:	cmp	r7, r3
    387a:	it	ge
    387c:	movge	r7, r3
          memcpy(dst,src,to_copy);
    387e:	mov	r2, r7
          pos += to_copy;
    3880:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3882:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3886:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3888:	add	r9, r7
          dst += to_copy;
    388a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    388c:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    388e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3890:	bne.n	3868 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf20>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3892:	movs	r2, #60	; 0x3c
    3894:	mov.w	r1, #512	; 0x200
    3898:	mov	r0, sl
    389a:	bl	9d50 <usb_mtp_send>
    389e:	cmp	r0, #0
    38a0:	ble.n	3892 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf4a>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    38a2:	str.w	sl, [r4]
    38a6:	b.n	3868 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf20>
    38a8:	movs	r1, #0
    38aa:	ldrb	r2, [r6, #0]
    38ac:	ldr	r3, [r6, #4]
    38ae:	strb.w	r1, [sp, #24]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    38b2:	cmp	r2, #0
    38b4:	bne.w	2cb6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x36e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    38b8:	cmp	r3, #0
    38ba:	beq.w	44ac <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b64>
    38be:	ldr	r0, [r4, #0]
        write_length_ += len;
    38c0:	adds	r3, #1
        
        const char * src=data;
    38c2:	add.w	r9, sp, #24
        //
        int pos = 0; // into data
    38c6:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    38ca:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    38ce:	str	r3, [r6, #4]
    38d0:	b.n	38da <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf92>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    38d2:	cmp.w	r8, #0
    38d6:	bgt.n	3912 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xfca>
    38d8:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    38da:	subs	r7, r5, r0
    38dc:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    38e0:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    38e2:	cmp	r7, r3
    38e4:	it	ge
    38e6:	movge	r7, r3
          memcpy(dst,src,to_copy);
    38e8:	mov	r2, r7
          pos += to_copy;
    38ea:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    38ec:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    38f0:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    38f2:	add	r9, r7
          dst += to_copy;
    38f4:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    38f6:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    38f8:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    38fa:	bne.n	38d2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf8a>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    38fc:	movs	r2, #60	; 0x3c
    38fe:	mov.w	r1, #512	; 0x200
    3902:	mov	r0, sl
    3904:	bl	9d50 <usb_mtp_send>
    3908:	cmp	r0, #0
    390a:	ble.n	38fc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xfb4>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    390c:	str.w	sl, [r4]
    3910:	b.n	38d2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf8a>
    3912:	movs	r0, #0
    3914:	movs	r1, #0
    3916:	ldrb	r2, [r6, #0]
    3918:	ldr	r3, [r6, #4]
    391a:	strd	r0, r1, [sp, #136]	; 0x88
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    391e:	cmp	r2, #0
    3920:	bne.w	2cb8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x370>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3924:	cmp	r3, #0
    3926:	beq.w	45c4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c7c>
    392a:	ldr	r0, [r4, #0]
        write_length_ += len;
    392c:	adds	r3, #8
        
        const char * src=data;
    392e:	add.w	r9, sp, #136	; 0x88
        //
        int pos = 0; // into data
    3932:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3936:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    393a:	str	r3, [r6, #4]
    393c:	b.n	3946 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xffe>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    393e:	cmp.w	r8, #7
    3942:	bgt.n	397e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1036>
    3944:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3946:	subs	r7, r5, r0
    3948:	rsb	r3, r8, #8
          memcpy(dst,src,to_copy);
    394c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    394e:	cmp	r7, r3
    3950:	it	ge
    3952:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3954:	mov	r2, r7
          pos += to_copy;
    3956:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3958:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    395c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    395e:	add	r9, r7
          dst += to_copy;
    3960:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3962:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3964:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3966:	bne.n	393e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xff6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3968:	movs	r2, #60	; 0x3c
    396a:	mov.w	r1, #512	; 0x200
    396e:	mov	r0, sl
    3970:	bl	9d50 <usb_mtp_send>
    3974:	cmp	r0, #0
    3976:	ble.n	3968 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1020>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3978:	str.w	sl, [r4]
    397c:	b.n	393e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xff6>
    397e:	movs	r0, #0
    3980:	movs	r1, #0
    3982:	ldrb	r2, [r6, #0]
    3984:	ldr	r3, [r6, #4]
    3986:	strd	r0, r1, [sp, #128]	; 0x80
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    398a:	cmp	r2, #0
    398c:	bne.w	2ace <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x186>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3990:	cmp	r3, #0
    3992:	beq.w	45b8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c70>
    3996:	ldr	r0, [r4, #0]
        write_length_ += len;
    3998:	adds	r3, #8
        
        const char * src=data;
    399a:	add.w	r9, sp, #128	; 0x80
        //
        int pos = 0; // into data
    399e:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    39a2:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    39a6:	str	r3, [r6, #4]
    39a8:	b.n	39b2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x106a>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    39aa:	cmp.w	r8, #7
    39ae:	bgt.n	39ea <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10a2>
    39b0:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    39b2:	subs	r7, r5, r0
    39b4:	rsb	r3, r8, #8
          memcpy(dst,src,to_copy);
    39b8:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    39ba:	cmp	r7, r3
    39bc:	it	ge
    39be:	movge	r7, r3
          memcpy(dst,src,to_copy);
    39c0:	mov	r2, r7
          pos += to_copy;
    39c2:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    39c4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    39c8:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    39ca:	add	r9, r7
          dst += to_copy;
    39cc:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    39ce:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    39d0:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    39d2:	bne.n	39aa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1062>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    39d4:	movs	r2, #60	; 0x3c
    39d6:	mov.w	r1, #512	; 0x200
    39da:	mov	r0, sl
    39dc:	bl	9d50 <usb_mtp_send>
    39e0:	cmp	r0, #0
    39e2:	ble.n	39d4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x108c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    39e4:	str.w	sl, [r4]
    39e8:	b.n	39aa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1062>
    39ea:	movs	r1, #0
    39ec:	ldrb	r2, [r6, #0]
    39ee:	ldr	r3, [r6, #4]
    39f0:	str	r1, [sp, #112]	; 0x70
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    39f2:	cmp	r2, #0
    39f4:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    39f8:	cmp	r3, #0
    39fa:	beq.w	45ac <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c64>
    39fe:	ldr	r0, [r4, #0]
        write_length_ += len;
    3a00:	adds	r3, #4
        
        const char * src=data;
    3a02:	add.w	r9, sp, #112	; 0x70
        //
        int pos = 0; // into data
    3a06:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3a0a:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3a0e:	str	r3, [r6, #4]
    3a10:	b.n	3a1a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10d2>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3a12:	cmp.w	r8, #3
    3a16:	bgt.n	3a52 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x110a>
    3a18:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3a1a:	subs	r7, r5, r0
    3a1c:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    3a20:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3a22:	cmp	r7, r3
    3a24:	it	ge
    3a26:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3a28:	mov	r2, r7
          pos += to_copy;
    3a2a:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3a2c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3a30:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3a32:	add	r9, r7
          dst += to_copy;
    3a34:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3a36:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3a38:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3a3a:	bne.n	3a12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10ca>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3a3c:	movs	r2, #60	; 0x3c
    3a3e:	mov.w	r1, #512	; 0x200
    3a42:	mov	r0, sl
    3a44:	bl	9d50 <usb_mtp_send>
    3a48:	cmp	r0, #0
    3a4a:	ble.n	3a3c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10f4>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3a4c:	str.w	sl, [r4]
    3a50:	b.n	3a12 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10ca>
    3a52:	movs	r1, #0
    3a54:	ldrb	r2, [r6, #0]
    3a56:	ldr	r3, [r6, #4]
    3a58:	strb.w	r1, [sp, #23]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3a5c:	cmp	r2, #0
    3a5e:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3a62:	cmp	r3, #0
    3a64:	beq.w	45a0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c58>
    3a68:	ldr	r0, [r4, #0]
        write_length_ += len;
    3a6a:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3a6c:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    3a70:	add.w	r8, sp, #23
        //
        int pos = 0; // into data
    3a74:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3a76:	str	r3, [r6, #4]
    3a78:	b.n	3a82 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x113a>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3a7a:	cmp	r7, #0
    3a7c:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    3a80:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3a82:	subs	r6, r5, r0
    3a84:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    3a88:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3a8a:	cmp	r6, r3
    3a8c:	it	ge
    3a8e:	movge	r6, r3
          memcpy(dst,src,to_copy);
    3a90:	mov	r2, r6
          pos += to_copy;
    3a92:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3a94:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3a98:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3a9a:	add	r8, r6
          dst += to_copy;
    3a9c:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3a9e:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3aa0:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3aa2:	bne.n	3a7a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1132>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3aa4:	movs	r2, #60	; 0x3c
    3aa6:	mov.w	r1, #512	; 0x200
    3aaa:	mov	r0, r9
    3aac:	bl	9d50 <usb_mtp_send>
    3ab0:	cmp	r0, #0
    3ab2:	ble.n	3aa4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x115c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3ab4:	str.w	r9, [r4]
    3ab8:	b.n	3a7a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1132>
    3aba:	movs	r1, #4
    3abc:	ldrb	r2, [r6, #0]
    3abe:	ldr	r3, [r6, #4]
    3ac0:	strh.w	r1, [sp, #40]	; 0x28
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3ac4:	cmp	r2, #0
    3ac6:	bne.w	2a3c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3aca:	cmp	r3, #0
    3acc:	beq.w	4492 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b4a>
    3ad0:	ldr	r0, [r4, #0]
        write_length_ += len;
    3ad2:	adds	r3, #2
        
        const char * src=data;
    3ad4:	add.w	r9, sp, #40	; 0x28
        //
        int pos = 0; // into data
    3ad8:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3adc:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3ae0:	str	r3, [r6, #4]
    3ae2:	b.n	3aee <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x11a6>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3ae4:	cmp.w	r8, #1
    3ae8:	bgt.w	3cca <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1382>
    3aec:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3aee:	subs	r7, r5, r0
    3af0:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3af4:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3af6:	cmp	r7, r3
    3af8:	it	ge
    3afa:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3afc:	mov	r2, r7
          pos += to_copy;
    3afe:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3b00:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3b04:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3b06:	add	r9, r7
          dst += to_copy;
    3b08:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3b0a:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3b0c:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3b0e:	bne.n	3ae4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x119c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3b10:	movs	r2, #60	; 0x3c
    3b12:	mov.w	r1, #512	; 0x200
    3b16:	mov	r0, sl
    3b18:	bl	9d50 <usb_mtp_send>
    3b1c:	cmp	r0, #0
    3b1e:	ble.n	3b10 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x11c8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3b20:	str.w	sl, [r4]
    3b24:	b.n	3ae4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x119c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3b26:	ldr	r3, [r0, #4]
    3b28:	cmp	r3, #0
    3b2a:	beq.w	4442 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1afa>
    3b2e:	ldr	r4, [pc, #768]	; (3e30 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x14e8>)
    3b30:	ldr	r0, [r4, #0]
        write_length_ += len;
    3b32:	adds	r3, #2
    3b34:	add.w	r5, r6, #1056	; 0x420
        
        const char * src=data;
    3b38:	add.w	r9, sp, #46	; 0x2e
        //
        int pos = 0; // into data
    3b3c:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3b40:	str	r3, [r6, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3b42:	add.w	sl, r6, #544	; 0x220
    3b46:	b.n	3b50 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1208>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3b48:	cmp.w	r8, #1
    3b4c:	bgt.n	3b88 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1240>
    3b4e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3b50:	subs	r7, r5, r0
    3b52:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3b56:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3b58:	cmp	r7, r3
    3b5a:	it	ge
    3b5c:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3b5e:	mov	r2, r7
          pos += to_copy;
    3b60:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3b62:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3b66:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3b68:	add	r9, r7
          dst += to_copy;
    3b6a:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3b6c:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3b6e:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3b70:	bne.n	3b48 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1200>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3b72:	movs	r2, #60	; 0x3c
    3b74:	mov.w	r1, #512	; 0x200
    3b78:	mov	r0, sl
    3b7a:	bl	9d50 <usb_mtp_send>
    3b7e:	cmp	r0, #0
    3b80:	ble.n	3b72 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x122a>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3b82:	str.w	sl, [r4]
    3b86:	b.n	3b48 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1200>
    3b88:	movs	r1, #8
    3b8a:	ldrb	r2, [r6, #0]
    3b8c:	ldr	r3, [r6, #4]
    3b8e:	strh.w	r1, [sp, #44]	; 0x2c
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3b92:	cmp	r2, #0
    3b94:	bne.w	2aca <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x182>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3b98:	cmp	r3, #0
    3b9a:	beq.w	4436 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1aee>
    3b9e:	ldr	r0, [r4, #0]
        write_length_ += len;
    3ba0:	adds	r3, #2
        
        const char * src=data;
    3ba2:	add.w	r9, sp, #44	; 0x2c
        //
        int pos = 0; // into data
    3ba6:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3baa:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3bae:	str	r3, [r6, #4]
    3bb0:	b.n	3bba <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1272>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3bb2:	cmp.w	r8, #1
    3bb6:	bgt.n	3bf2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x12aa>
    3bb8:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3bba:	subs	r7, r5, r0
    3bbc:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3bc0:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3bc2:	cmp	r7, r3
    3bc4:	it	ge
    3bc6:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3bc8:	mov	r2, r7
          pos += to_copy;
    3bca:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3bcc:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3bd0:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3bd2:	add	r9, r7
          dst += to_copy;
    3bd4:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3bd6:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3bd8:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3bda:	bne.n	3bb2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x126a>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3bdc:	movs	r2, #60	; 0x3c
    3bde:	mov.w	r1, #512	; 0x200
    3be2:	mov	r0, sl
    3be4:	bl	9d50 <usb_mtp_send>
    3be8:	cmp	r0, #0
    3bea:	ble.n	3bdc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1294>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3bec:	str.w	sl, [r4]
    3bf0:	b.n	3bb2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x126a>
    3bf2:	movs	r1, #0
    3bf4:	ldrb	r2, [r6, #0]
    3bf6:	ldr	r3, [r6, #4]
    3bf8:	strb.w	r1, [sp, #11]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3bfc:	cmp	r2, #0
    3bfe:	bne.w	2acc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x184>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3c02:	cmp	r3, #0
    3c04:	beq.w	442a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1ae2>
    3c08:	ldr	r0, [r4, #0]
        write_length_ += len;
    3c0a:	adds	r3, #1
        
        const char * src=data;
    3c0c:	add.w	r9, sp, #11
        //
        int pos = 0; // into data
    3c10:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3c14:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3c18:	str	r3, [r6, #4]
    3c1a:	b.n	3c24 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x12dc>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3c1c:	cmp.w	r8, #0
    3c20:	bgt.n	3c5c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1314>
    3c22:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3c24:	subs	r7, r5, r0
    3c26:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    3c2a:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3c2c:	cmp	r7, r3
    3c2e:	it	ge
    3c30:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3c32:	mov	r2, r7
          pos += to_copy;
    3c34:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3c36:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3c3a:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3c3c:	add	r9, r7
          dst += to_copy;
    3c3e:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3c40:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3c42:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3c44:	bne.n	3c1c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x12d4>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3c46:	movs	r2, #60	; 0x3c
    3c48:	mov.w	r1, #512	; 0x200
    3c4c:	mov	r0, sl
    3c4e:	bl	9d50 <usb_mtp_send>
    3c52:	cmp	r0, #0
    3c54:	ble.n	3c46 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x12fe>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3c56:	str.w	sl, [r4]
    3c5a:	b.n	3c1c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x12d4>
    3c5c:	movs	r0, #0
    3c5e:	movs	r1, #0
    3c60:	ldrb	r2, [r6, #0]
    3c62:	ldr	r3, [r6, #4]
    3c64:	strd	r0, r1, [sp, #120]	; 0x78
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3c68:	cmp	r2, #0
    3c6a:	bne.w	2ace <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x186>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3c6e:	cmp	r3, #0
    3c70:	beq.w	4478 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b30>
    3c74:	ldr	r0, [r4, #0]
        write_length_ += len;
    3c76:	adds	r3, #8
        
        const char * src=data;
    3c78:	add.w	r9, sp, #120	; 0x78
        //
        int pos = 0; // into data
    3c7c:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3c80:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3c84:	str	r3, [r6, #4]
    3c86:	b.n	3c92 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x134a>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3c88:	cmp.w	r8, #7
    3c8c:	bgt.w	3e74 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x152c>
    3c90:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3c92:	subs	r7, r5, r0
    3c94:	rsb	r3, r8, #8
          memcpy(dst,src,to_copy);
    3c98:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3c9a:	cmp	r7, r3
    3c9c:	it	ge
    3c9e:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3ca0:	mov	r2, r7
          pos += to_copy;
    3ca2:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3ca4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3ca8:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3caa:	add	r9, r7
          dst += to_copy;
    3cac:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3cae:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3cb0:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3cb2:	bne.n	3c88 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1340>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3cb4:	movs	r2, #60	; 0x3c
    3cb6:	mov.w	r1, #512	; 0x200
    3cba:	mov	r0, sl
    3cbc:	bl	9d50 <usb_mtp_send>
    3cc0:	cmp	r0, #0
    3cc2:	ble.n	3cb4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x136c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3cc4:	str.w	sl, [r4]
    3cc8:	b.n	3c88 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1340>
    3cca:	movs	r1, #0
    3ccc:	ldrb	r2, [r6, #0]
    3cce:	ldr	r3, [r6, #4]
    3cd0:	strb.w	r1, [sp, #9]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3cd4:	cmp	r2, #0
    3cd6:	bne.w	2a3e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf6>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3cda:	cmp	r3, #0
    3cdc:	beq.w	446e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b26>
    3ce0:	ldr	r0, [r4, #0]
        write_length_ += len;
    3ce2:	adds	r3, #1
        
        const char * src=data;
    3ce4:	add.w	r9, sp, #9
        //
        int pos = 0; // into data
    3ce8:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3cec:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3cf0:	str	r3, [r6, #4]
    3cf2:	b.n	3cfc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x13b4>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3cf4:	cmp.w	r8, #0
    3cf8:	bgt.n	3d34 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x13ec>
    3cfa:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3cfc:	subs	r7, r5, r0
    3cfe:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    3d02:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3d04:	cmp	r7, r3
    3d06:	it	ge
    3d08:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3d0a:	mov	r2, r7
          pos += to_copy;
    3d0c:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3d0e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3d12:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3d14:	add	r9, r7
          dst += to_copy;
    3d16:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3d18:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3d1a:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3d1c:	bne.n	3cf4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x13ac>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3d1e:	movs	r2, #60	; 0x3c
    3d20:	mov.w	r1, #512	; 0x200
    3d24:	mov	r0, sl
    3d26:	bl	9d50 <usb_mtp_send>
    3d2a:	cmp	r0, #0
    3d2c:	ble.n	3d1e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x13d6>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3d2e:	str.w	sl, [r4]
    3d32:	b.n	3cf4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x13ac>
    3d34:	movs	r1, #0
    3d36:	ldrb	r2, [r6, #0]
    3d38:	ldr	r3, [r6, #4]
    3d3a:	strh.w	r1, [sp, #38]	; 0x26
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3d3e:	cmp	r2, #0
    3d40:	bne.w	2a40 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3d44:	cmp	r3, #0
    3d46:	beq.w	4464 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b1c>
    3d4a:	ldr	r0, [r4, #0]
        write_length_ += len;
    3d4c:	adds	r3, #2
        
        const char * src=data;
    3d4e:	add.w	r9, sp, #38	; 0x26
        //
        int pos = 0; // into data
    3d52:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3d56:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3d5a:	str	r3, [r6, #4]
    3d5c:	b.n	3d66 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x141e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3d5e:	cmp.w	r8, #1
    3d62:	bgt.n	3d9e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1456>
    3d64:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3d66:	subs	r7, r5, r0
    3d68:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3d6c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3d6e:	cmp	r7, r3
    3d70:	it	ge
    3d72:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3d74:	mov	r2, r7
          pos += to_copy;
    3d76:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3d78:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3d7c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3d7e:	add	r9, r7
          dst += to_copy;
    3d80:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3d82:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3d84:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3d86:	bne.n	3d5e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1416>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3d88:	movs	r2, #60	; 0x3c
    3d8a:	mov.w	r1, #512	; 0x200
    3d8e:	mov	r0, sl
    3d90:	bl	9d50 <usb_mtp_send>
    3d94:	cmp	r0, #0
    3d96:	ble.n	3d88 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1440>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3d98:	str.w	sl, [r4]
    3d9c:	b.n	3d5e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1416>
    3d9e:	movs	r1, #0
    3da0:	ldrb	r2, [r6, #0]
    3da2:	ldr	r3, [r6, #4]
    3da4:	str	r1, [sp, #84]	; 0x54
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3da6:	cmp	r2, #0
    3da8:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3dac:	cmp	r3, #0
    3dae:	beq.w	445a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b12>
    3db2:	ldr	r0, [r4, #0]
        write_length_ += len;
    3db4:	adds	r3, #4
        
        const char * src=data;
    3db6:	add.w	r9, sp, #84	; 0x54
        //
        int pos = 0; // into data
    3dba:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3dbe:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3dc2:	str	r3, [r6, #4]
    3dc4:	b.n	3dce <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1486>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3dc6:	cmp.w	r8, #3
    3dca:	bgt.n	3e06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x14be>
    3dcc:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3dce:	subs	r7, r5, r0
    3dd0:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    3dd4:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3dd6:	cmp	r7, r3
    3dd8:	it	ge
    3dda:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3ddc:	mov	r2, r7
          pos += to_copy;
    3dde:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3de0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3de4:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3de6:	add	r9, r7
          dst += to_copy;
    3de8:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3dea:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3dec:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3dee:	bne.n	3dc6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x147e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3df0:	movs	r2, #60	; 0x3c
    3df2:	mov.w	r1, #512	; 0x200
    3df6:	mov	r0, sl
    3df8:	bl	9d50 <usb_mtp_send>
    3dfc:	cmp	r0, #0
    3dfe:	ble.n	3df0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x14a8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3e00:	str.w	sl, [r4]
    3e04:	b.n	3dc6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x147e>
    3e06:	movs	r1, #0
    3e08:	ldrb	r2, [r6, #0]
    3e0a:	ldr	r3, [r6, #4]
    3e0c:	strb.w	r1, [sp, #8]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3e10:	cmp	r2, #0
    3e12:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3e16:	cmp	r3, #0
    3e18:	beq.w	4450 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1b08>
    3e1c:	ldr	r0, [r4, #0]
        write_length_ += len;
    3e1e:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3e20:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    3e24:	add.w	r8, sp, #8
        //
        int pos = 0; // into data
    3e28:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3e2a:	str	r3, [r6, #4]
    3e2c:	b.n	3e3c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x14f4>
    3e2e:	nop
    3e30:	.word	0x2000158c
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3e34:	cmp	r7, #0
    3e36:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    3e3a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3e3c:	subs	r6, r5, r0
    3e3e:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    3e42:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3e44:	cmp	r6, r3
    3e46:	it	ge
    3e48:	movge	r6, r3
          memcpy(dst,src,to_copy);
    3e4a:	mov	r2, r6
          pos += to_copy;
    3e4c:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3e4e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3e52:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3e54:	add	r8, r6
          dst += to_copy;
    3e56:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3e58:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3e5a:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3e5c:	bne.n	3e34 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x14ec>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3e5e:	movs	r2, #60	; 0x3c
    3e60:	mov.w	r1, #512	; 0x200
    3e64:	mov	r0, r9
    3e66:	bl	9d50 <usb_mtp_send>
    3e6a:	cmp	r0, #0
    3e6c:	ble.n	3e5e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1516>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3e6e:	str.w	r9, [r4]
    3e72:	b.n	3e34 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x14ec>
    3e74:	movs	r1, #0
    3e76:	ldrb	r2, [r6, #0]
    3e78:	ldr	r3, [r6, #4]
    3e7a:	str	r1, [sp, #88]	; 0x58
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3e7c:	cmp	r2, #0
    3e7e:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3e82:	cmp	r3, #0
    3e84:	beq.w	4420 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1ad8>
    3e88:	ldr	r0, [r4, #0]
        write_length_ += len;
    3e8a:	adds	r3, #4
        
        const char * src=data;
    3e8c:	add.w	r9, sp, #88	; 0x58
        //
        int pos = 0; // into data
    3e90:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3e94:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3e98:	str	r3, [r6, #4]
    3e9a:	b.n	3ea4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x155c>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3e9c:	cmp.w	r8, #3
    3ea0:	bgt.n	3edc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1594>
    3ea2:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3ea4:	subs	r7, r5, r0
    3ea6:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    3eaa:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3eac:	cmp	r7, r3
    3eae:	it	ge
    3eb0:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3eb2:	mov	r2, r7
          pos += to_copy;
    3eb4:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3eb6:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3eba:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3ebc:	add	r9, r7
          dst += to_copy;
    3ebe:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3ec0:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3ec2:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3ec4:	bne.n	3e9c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1554>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3ec6:	movs	r2, #60	; 0x3c
    3ec8:	mov.w	r1, #512	; 0x200
    3ecc:	mov	r0, sl
    3ece:	bl	9d50 <usb_mtp_send>
    3ed2:	cmp	r0, #0
    3ed4:	ble.n	3ec6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x157e>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3ed6:	str.w	sl, [r4]
    3eda:	b.n	3e9c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1554>
    3edc:	movs	r1, #0
    3ede:	ldrb	r2, [r6, #0]
    3ee0:	ldr	r3, [r6, #4]
    3ee2:	strb.w	r1, [sp, #10]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3ee6:	cmp	r2, #0
    3ee8:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3eec:	cmp	r3, #0
    3eee:	beq.w	4588 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c40>
    3ef2:	ldr	r0, [r4, #0]
        write_length_ += len;
    3ef4:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3ef6:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    3efa:	add.w	r8, sp, #10
        //
        int pos = 0; // into data
    3efe:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3f00:	str	r3, [r6, #4]
    3f02:	b.n	3f0c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x15c4>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3f04:	cmp	r7, #0
    3f06:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    3f0a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3f0c:	subs	r6, r5, r0
    3f0e:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    3f12:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3f14:	cmp	r6, r3
    3f16:	it	ge
    3f18:	movge	r6, r3
          memcpy(dst,src,to_copy);
    3f1a:	mov	r2, r6
          pos += to_copy;
    3f1c:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3f1e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3f22:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3f24:	add	r8, r6
          dst += to_copy;
    3f26:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3f28:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3f2a:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3f2c:	bne.n	3f04 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x15bc>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3f2e:	movs	r2, #60	; 0x3c
    3f30:	mov.w	r1, #512	; 0x200
    3f34:	mov	r0, r9
    3f36:	bl	9d50 <usb_mtp_send>
    3f3a:	cmp	r0, #0
    3f3c:	ble.n	3f2e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x15e6>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3f3e:	str.w	r9, [r4]
    3f42:	b.n	3f04 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x15bc>
    3f44:	movw	r1, #65535	; 0xffff
    3f48:	ldrb	r2, [r6, #0]
    3f4a:	ldr	r3, [r6, #4]
    3f4c:	strh.w	r1, [sp, #48]	; 0x30
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3f50:	cmp	r2, #0
    3f52:	bne.w	29fa <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb2>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3f56:	cmp	r3, #0
    3f58:	beq.w	4416 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1ace>
    3f5c:	ldr	r0, [r4, #0]
        write_length_ += len;
    3f5e:	adds	r3, #2
        
        const char * src=data;
    3f60:	add.w	r9, sp, #48	; 0x30
        //
        int pos = 0; // into data
    3f64:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3f68:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3f6c:	str	r3, [r6, #4]
    3f6e:	b.n	3f78 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1630>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3f70:	cmp.w	r8, #1
    3f74:	bgt.n	3fb0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1668>
    3f76:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3f78:	subs	r7, r5, r0
    3f7a:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    3f7e:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3f80:	cmp	r7, r3
    3f82:	it	ge
    3f84:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3f86:	mov	r2, r7
          pos += to_copy;
    3f88:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3f8a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3f8e:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3f90:	add	r9, r7
          dst += to_copy;
    3f92:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3f94:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3f96:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3f98:	bne.n	3f70 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1628>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    3f9a:	movs	r2, #60	; 0x3c
    3f9c:	mov.w	r1, #512	; 0x200
    3fa0:	mov	r0, sl
    3fa2:	bl	9d50 <usb_mtp_send>
    3fa6:	cmp	r0, #0
    3fa8:	ble.n	3f9a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1652>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    3faa:	str.w	sl, [r4]
    3fae:	b.n	3f70 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1628>
    3fb0:	movs	r1, #1
    3fb2:	ldrb	r2, [r6, #0]
    3fb4:	ldr	r3, [r6, #4]
    3fb6:	strb.w	r1, [sp, #14]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    3fba:	cmp	r2, #0
    3fbc:	bne.w	29fc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    3fc0:	cmp	r3, #0
    3fc2:	beq.w	440c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1ac4>
    3fc6:	ldr	r0, [r4, #0]
        write_length_ += len;
    3fc8:	adds	r3, #1
        
        const char * src=data;
    3fca:	add.w	r9, sp, #14
        //
        int pos = 0; // into data
    3fce:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    3fd2:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    3fd6:	str	r3, [r6, #4]
    3fd8:	b.n	3fe2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x169a>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    3fda:	cmp.w	r8, #0
    3fde:	bgt.n	401a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x16d2>
    3fe0:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3fe2:	subs	r7, r5, r0
    3fe4:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    3fe8:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    3fea:	cmp	r7, r3
    3fec:	it	ge
    3fee:	movge	r7, r3
          memcpy(dst,src,to_copy);
    3ff0:	mov	r2, r7
          pos += to_copy;
    3ff2:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    3ff4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    3ff8:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    3ffa:	add	r9, r7
          dst += to_copy;
    3ffc:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    3ffe:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4000:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4002:	bne.n	3fda <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1692>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4004:	movs	r2, #60	; 0x3c
    4006:	mov.w	r1, #512	; 0x200
    400a:	mov	r0, sl
    400c:	bl	9d50 <usb_mtp_send>
    4010:	cmp	r0, #0
    4012:	ble.n	4004 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x16bc>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4014:	str.w	sl, [r4]
    4018:	b.n	3fda <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1692>
    401a:	movs	r1, #0
    401c:	ldrb	r2, [r6, #0]
    401e:	ldr	r3, [r6, #4]
    4020:	strb.w	r1, [sp, #13]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4024:	cmp	r2, #0
    4026:	bne.w	29fe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb6>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    402a:	cmp	r3, #0
    402c:	beq.w	4402 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1aba>
    4030:	ldr	r0, [r4, #0]
        write_length_ += len;
    4032:	adds	r3, #1
        
        const char * src=data;
    4034:	add.w	r9, sp, #13
        //
        int pos = 0; // into data
    4038:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    403c:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4040:	str	r3, [r6, #4]
    4042:	b.n	404c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1704>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4044:	cmp.w	r8, #0
    4048:	bgt.n	4084 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x173c>
    404a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    404c:	subs	r7, r5, r0
    404e:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    4052:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4054:	cmp	r7, r3
    4056:	it	ge
    4058:	movge	r7, r3
          memcpy(dst,src,to_copy);
    405a:	mov	r2, r7
          pos += to_copy;
    405c:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    405e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4062:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4064:	add	r9, r7
          dst += to_copy;
    4066:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4068:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    406a:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    406c:	bne.n	4044 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x16fc>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    406e:	movs	r2, #60	; 0x3c
    4070:	mov.w	r1, #512	; 0x200
    4074:	mov	r0, sl
    4076:	bl	9d50 <usb_mtp_send>
    407a:	cmp	r0, #0
    407c:	ble.n	406e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1726>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    407e:	str.w	sl, [r4]
    4082:	b.n	4044 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x16fc>
    4084:	movs	r1, #0
    4086:	ldrb	r2, [r6, #0]
    4088:	ldr	r3, [r6, #4]
    408a:	str	r1, [sp, #92]	; 0x5c
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    408c:	cmp	r2, #0
    408e:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4092:	cmp	r3, #0
    4094:	beq.w	43f8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1ab0>
    4098:	ldr	r0, [r4, #0]
        write_length_ += len;
    409a:	adds	r3, #4
        
        const char * src=data;
    409c:	add.w	r9, sp, #92	; 0x5c
        //
        int pos = 0; // into data
    40a0:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    40a4:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    40a8:	str	r3, [r6, #4]
    40aa:	b.n	40b4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x176c>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    40ac:	cmp.w	r8, #3
    40b0:	bgt.n	40ec <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x17a4>
    40b2:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    40b4:	subs	r7, r5, r0
    40b6:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    40ba:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    40bc:	cmp	r7, r3
    40be:	it	ge
    40c0:	movge	r7, r3
          memcpy(dst,src,to_copy);
    40c2:	mov	r2, r7
          pos += to_copy;
    40c4:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    40c6:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    40ca:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    40cc:	add	r9, r7
          dst += to_copy;
    40ce:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    40d0:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    40d2:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    40d4:	bne.n	40ac <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1764>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    40d6:	movs	r2, #60	; 0x3c
    40d8:	mov.w	r1, #512	; 0x200
    40dc:	mov	r0, sl
    40de:	bl	9d50 <usb_mtp_send>
    40e2:	cmp	r0, #0
    40e4:	ble.n	40d6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x178e>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    40e6:	str.w	sl, [r4]
    40ea:	b.n	40ac <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1764>
    40ec:	movs	r1, #0
    40ee:	ldrb	r2, [r6, #0]
    40f0:	ldr	r3, [r6, #4]
    40f2:	strb.w	r1, [sp, #12]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    40f6:	cmp	r2, #0
    40f8:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    40fc:	cmp	r3, #0
    40fe:	beq.w	4572 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c2a>
    4102:	ldr	r0, [r4, #0]
        write_length_ += len;
    4104:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4106:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    410a:	add.w	r8, sp, #12
        //
        int pos = 0; // into data
    410e:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4110:	str	r3, [r6, #4]
    4112:	b.n	411c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x17d4>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4114:	cmp	r7, #0
    4116:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    411a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    411c:	subs	r6, r5, r0
    411e:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    4122:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4124:	cmp	r6, r3
    4126:	it	ge
    4128:	movge	r6, r3
          memcpy(dst,src,to_copy);
    412a:	mov	r2, r6
          pos += to_copy;
    412c:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    412e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4132:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4134:	add	r8, r6
          dst += to_copy;
    4136:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4138:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    413a:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    413c:	bne.n	4114 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x17cc>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    413e:	movs	r2, #60	; 0x3c
    4140:	mov.w	r1, #512	; 0x200
    4144:	mov	r0, r9
    4146:	bl	9d50 <usb_mtp_send>
    414a:	cmp	r0, #0
    414c:	ble.n	413e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x17f6>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    414e:	str.w	r9, [r4]
    4152:	b.n	4114 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x17cc>
    4154:	movs	r1, #0
    4156:	ldrb	r2, [r6, #0]
    4158:	ldr	r3, [r6, #4]
    415a:	strb.w	r1, [sp, #16]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    415e:	cmp	r2, #0
    4160:	bne.w	29fe <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb6>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4164:	cmp	r3, #0
    4166:	beq.w	43ee <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1aa6>
    416a:	ldr	r0, [r4, #0]
        write_length_ += len;
    416c:	adds	r3, #1
        
        const char * src=data;
    416e:	add.w	r9, sp, #16
        //
        int pos = 0; // into data
    4172:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4176:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    417a:	str	r3, [r6, #4]
    417c:	b.n	4186 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x183e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    417e:	cmp.w	r8, #0
    4182:	bgt.n	41be <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1876>
    4184:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4186:	subs	r7, r5, r0
    4188:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    418c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    418e:	cmp	r7, r3
    4190:	it	ge
    4192:	movge	r7, r3
          memcpy(dst,src,to_copy);
    4194:	mov	r2, r7
          pos += to_copy;
    4196:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4198:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    419c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    419e:	add	r9, r7
          dst += to_copy;
    41a0:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    41a2:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    41a4:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    41a6:	bne.n	417e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1836>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    41a8:	movs	r2, #60	; 0x3c
    41aa:	mov.w	r1, #512	; 0x200
    41ae:	mov	r0, sl
    41b0:	bl	9d50 <usb_mtp_send>
    41b4:	cmp	r0, #0
    41b6:	ble.n	41a8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1860>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    41b8:	str.w	sl, [r4]
    41bc:	b.n	417e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1836>
    41be:	movs	r1, #0
    41c0:	ldrb	r2, [r6, #0]
    41c2:	ldr	r3, [r6, #4]
    41c4:	str	r1, [sp, #96]	; 0x60
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    41c6:	cmp	r2, #0
    41c8:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    41cc:	cmp	r3, #0
    41ce:	beq.w	43e4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a9c>
    41d2:	ldr	r0, [r4, #0]
        write_length_ += len;
    41d4:	adds	r3, #4
        
        const char * src=data;
    41d6:	add.w	r9, sp, #96	; 0x60
        //
        int pos = 0; // into data
    41da:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    41de:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    41e2:	str	r3, [r6, #4]
    41e4:	b.n	41ee <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x18a6>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    41e6:	cmp.w	r8, #3
    41ea:	bgt.n	4226 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x18de>
    41ec:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    41ee:	subs	r7, r5, r0
    41f0:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    41f4:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    41f6:	cmp	r7, r3
    41f8:	it	ge
    41fa:	movge	r7, r3
          memcpy(dst,src,to_copy);
    41fc:	mov	r2, r7
          pos += to_copy;
    41fe:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4200:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4204:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4206:	add	r9, r7
          dst += to_copy;
    4208:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    420a:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    420c:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    420e:	bne.n	41e6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x189e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4210:	movs	r2, #60	; 0x3c
    4212:	mov.w	r1, #512	; 0x200
    4216:	mov	r0, sl
    4218:	bl	9d50 <usb_mtp_send>
    421c:	cmp	r0, #0
    421e:	ble.n	4210 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x18c8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4220:	str.w	sl, [r4]
    4224:	b.n	41e6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x189e>
    4226:	movs	r1, #0
    4228:	ldrb	r2, [r6, #0]
    422a:	ldr	r3, [r6, #4]
    422c:	strb.w	r1, [sp, #15]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4230:	cmp	r2, #0
    4232:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4236:	cmp	r3, #0
    4238:	beq.w	45d0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1c88>
    423c:	ldr	r0, [r4, #0]
        write_length_ += len;
    423e:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4240:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    4244:	add.w	r8, sp, #15
        //
        int pos = 0; // into data
    4248:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    424a:	str	r3, [r6, #4]
    424c:	b.n	4256 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x190e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    424e:	cmp	r7, #0
    4250:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    4254:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4256:	subs	r6, r5, r0
    4258:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    425c:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    425e:	cmp	r6, r3
    4260:	it	ge
    4262:	movge	r6, r3
          memcpy(dst,src,to_copy);
    4264:	mov	r2, r6
          pos += to_copy;
    4266:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4268:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    426c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    426e:	add	r8, r6
          dst += to_copy;
    4270:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4272:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4274:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4276:	bne.n	424e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1906>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4278:	movs	r2, #60	; 0x3c
    427a:	mov.w	r1, #512	; 0x200
    427e:	mov	r0, r9
    4280:	bl	9d50 <usb_mtp_send>
    4284:	cmp	r0, #0
    4286:	ble.n	4278 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1930>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4288:	str.w	r9, [r4]
    428c:	b.n	424e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1906>
    428e:	movs	r1, #0
    4290:	ldrb	r2, [r6, #0]
    4292:	ldr	r3, [r6, #4]
    4294:	str	r1, [sp, #76]	; 0x4c
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4296:	cmp	r2, #0
    4298:	bne.w	2a24 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xdc>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    429c:	cmp	r3, #0
    429e:	beq.w	43da <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a92>
    42a2:	ldr	r0, [r4, #0]
        write_length_ += len;
    42a4:	adds	r3, #4
        
        const char * src=data;
    42a6:	add.w	r9, sp, #76	; 0x4c
        //
        int pos = 0; // into data
    42aa:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    42ae:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    42b2:	str	r3, [r6, #4]
    42b4:	b.n	42be <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1976>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    42b6:	cmp.w	r8, #3
    42ba:	bgt.n	42f6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x19ae>
    42bc:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    42be:	subs	r7, r5, r0
    42c0:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    42c4:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    42c6:	cmp	r7, r3
    42c8:	it	ge
    42ca:	movge	r7, r3
          memcpy(dst,src,to_copy);
    42cc:	mov	r2, r7
          pos += to_copy;
    42ce:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    42d0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    42d4:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    42d6:	add	r9, r7
          dst += to_copy;
    42d8:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    42da:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    42dc:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    42de:	bne.n	42b6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x196e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    42e0:	movs	r2, #60	; 0x3c
    42e2:	mov.w	r1, #512	; 0x200
    42e6:	mov	r0, sl
    42e8:	bl	9d50 <usb_mtp_send>
    42ec:	cmp	r0, #0
    42ee:	ble.n	42e0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1998>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    42f0:	str.w	sl, [r4]
    42f4:	b.n	42b6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x196e>
    42f6:	movs	r1, #0
    42f8:	ldrb	r2, [r6, #0]
    42fa:	ldr	r3, [r6, #4]
    42fc:	str	r1, [sp, #72]	; 0x48
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    42fe:	cmp	r2, #0
    4300:	bne.w	2a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4304:	cmp	r3, #0
    4306:	beq.n	43d0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a88>
    4308:	ldr	r0, [r4, #0]
        write_length_ += len;
    430a:	adds	r3, #4
        
        const char * src=data;
    430c:	add.w	r9, sp, #72	; 0x48
        //
        int pos = 0; // into data
    4310:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4314:	add.w	sl, r6, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4318:	str	r3, [r6, #4]
    431a:	b.n	4324 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x19dc>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    431c:	cmp.w	r8, #3
    4320:	bgt.n	435c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a14>
    4322:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4324:	subs	r7, r5, r0
    4326:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    432a:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    432c:	cmp	r7, r3
    432e:	it	ge
    4330:	movge	r7, r3
          memcpy(dst,src,to_copy);
    4332:	mov	r2, r7
          pos += to_copy;
    4334:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4336:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    433a:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    433c:	add	r9, r7
          dst += to_copy;
    433e:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4340:	cmp	r7, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4342:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4344:	bne.n	431c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x19d4>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4346:	movs	r2, #60	; 0x3c
    4348:	mov.w	r1, #512	; 0x200
    434c:	mov	r0, sl
    434e:	bl	9d50 <usb_mtp_send>
    4352:	cmp	r0, #0
    4354:	ble.n	4346 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x19fe>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4356:	str.w	sl, [r4]
    435a:	b.n	431c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x19d4>
    435c:	movs	r1, #0
    435e:	ldrb	r2, [r6, #0]
    4360:	ldr	r3, [r6, #4]
    4362:	strb.w	r1, [sp, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4366:	cmp	r2, #0
    4368:	bne.w	2a02 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xba>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    436c:	cmp	r3, #0
    436e:	beq.w	4510 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1bc8>
    4372:	ldr	r0, [r4, #0]
        write_length_ += len;
    4374:	adds	r3, #1
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4376:	add.w	r9, r6, #544	; 0x220
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    437a:	add.w	r8, sp, #4
        //
        int pos = 0; // into data
    437e:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4380:	str	r3, [r6, #4]
    4382:	b.n	438c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a44>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4384:	cmp	r7, #0
    4386:	bgt.w	2a06 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbe>
    438a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    438c:	subs	r6, r5, r0
    438e:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    4392:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4394:	cmp	r6, r3
    4396:	it	ge
    4398:	movge	r6, r3
          memcpy(dst,src,to_copy);
    439a:	mov	r2, r6
          pos += to_copy;
    439c:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    439e:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    43a2:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    43a4:	add	r8, r6
          dst += to_copy;
    43a6:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    43a8:	cmp	r6, r5
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    43aa:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    43ac:	bne.n	4384 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a3c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    43ae:	movs	r2, #60	; 0x3c
    43b0:	mov.w	r1, #512	; 0x200
    43b4:	mov	r0, r9
    43b6:	bl	9d50 <usb_mtp_send>
    43ba:	cmp	r0, #0
    43bc:	ble.n	43ae <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a66>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    43be:	str.w	r9, [r4]
    43c2:	b.n	4384 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a3c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    43c4:	add.w	r2, r6, #544	; 0x220
    43c8:	mov	r0, r2
    43ca:	str	r2, [r4, #0]
    43cc:	b.w	3786 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe3e>
    43d0:	add.w	r2, r6, #544	; 0x220
    43d4:	mov	r0, r2
    43d6:	str	r2, [r4, #0]
    43d8:	b.n	430a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x19c2>
    43da:	add.w	r2, r6, #544	; 0x220
    43de:	mov	r0, r2
    43e0:	str	r2, [r4, #0]
    43e2:	b.n	42a4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x195c>
    43e4:	add.w	r2, r6, #544	; 0x220
    43e8:	mov	r0, r2
    43ea:	str	r2, [r4, #0]
    43ec:	b.n	41d4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x188c>
    43ee:	add.w	r2, r6, #544	; 0x220
    43f2:	mov	r0, r2
    43f4:	str	r2, [r4, #0]
    43f6:	b.n	416c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1824>
    43f8:	add.w	r2, r6, #544	; 0x220
    43fc:	mov	r0, r2
    43fe:	str	r2, [r4, #0]
    4400:	b.n	409a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1752>
    4402:	add.w	r2, r6, #544	; 0x220
    4406:	mov	r0, r2
    4408:	str	r2, [r4, #0]
    440a:	b.n	4032 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x16ea>
    440c:	add.w	r2, r6, #544	; 0x220
    4410:	mov	r0, r2
    4412:	str	r2, [r4, #0]
    4414:	b.n	3fc8 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1680>
    4416:	add.w	r2, r6, #544	; 0x220
    441a:	mov	r0, r2
    441c:	str	r2, [r4, #0]
    441e:	b.n	3f5e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1616>
    4420:	add.w	r2, r6, #544	; 0x220
    4424:	mov	r0, r2
    4426:	str	r2, [r4, #0]
    4428:	b.n	3e8a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1542>
    442a:	add.w	r2, r6, #544	; 0x220
    442e:	mov	r0, r2
    4430:	str	r2, [r4, #0]
    4432:	b.w	3c0a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x12c2>
    4436:	add.w	r2, r6, #544	; 0x220
    443a:	mov	r0, r2
    443c:	str	r2, [r4, #0]
    443e:	b.w	3ba0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1258>
    4442:	add.w	r2, r0, #544	; 0x220
    4446:	ldr	r4, [pc, #588]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    4448:	mov	r0, r2
    444a:	str	r2, [r4, #0]
    444c:	b.w	3b32 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x11ea>
    4450:	add.w	r2, r6, #544	; 0x220
    4454:	mov	r0, r2
    4456:	str	r2, [r4, #0]
    4458:	b.n	3e1e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x14d6>
    445a:	add.w	r2, r6, #544	; 0x220
    445e:	mov	r0, r2
    4460:	str	r2, [r4, #0]
    4462:	b.n	3db4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x146c>
    4464:	add.w	r2, r6, #544	; 0x220
    4468:	mov	r0, r2
    446a:	str	r2, [r4, #0]
    446c:	b.n	3d4c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1404>
    446e:	add.w	r2, r6, #544	; 0x220
    4472:	mov	r0, r2
    4474:	str	r2, [r4, #0]
    4476:	b.n	3ce2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x139a>
    4478:	add.w	r2, r6, #544	; 0x220
    447c:	mov	r0, r2
    447e:	str	r2, [r4, #0]
    4480:	b.w	3c76 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x132e>
    4484:	add.w	r2, r0, #544	; 0x220
    4488:	ldr	r4, [pc, #520]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    448a:	mov	r0, r2
    448c:	str	r2, [r4, #0]
    448e:	b.w	2a5e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x116>
    4492:	add.w	r2, r6, #544	; 0x220
    4496:	mov	r0, r2
    4498:	str	r2, [r4, #0]
    449a:	b.w	3ad2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x118a>
    449e:	add.w	r2, r0, #544	; 0x220
    44a2:	ldr	r4, [pc, #496]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    44a4:	mov	r0, r2
    44a6:	str	r2, [r4, #0]
    44a8:	b.w	2b60 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x218>
    44ac:	add.w	r2, r6, #544	; 0x220
    44b0:	mov	r0, r2
    44b2:	str	r2, [r4, #0]
    44b4:	b.w	38c0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf78>
    44b8:	add.w	r2, r6, #544	; 0x220
    44bc:	mov	r0, r2
    44be:	str	r2, [r4, #0]
    44c0:	b.w	3850 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xf08>
    44c4:	add.w	r2, r0, #544	; 0x220
    44c8:	ldr	r4, [pc, #456]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    44ca:	mov	r0, r2
    44cc:	str	r2, [r4, #0]
    44ce:	b.w	37e2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xe9a>
    44d2:	add.w	r2, r6, #544	; 0x220
    44d6:	mov	r0, r2
    44d8:	str	r2, [r4, #0]
    44da:	b.w	3510 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xbc8>
    44de:	add.w	r2, r6, #544	; 0x220
    44e2:	mov	r0, r2
    44e4:	str	r2, [r4, #0]
    44e6:	b.w	36b4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd6c>
    44ea:	add.w	r2, r6, #544	; 0x220
    44ee:	mov	r0, r2
    44f0:	str	r2, [r4, #0]
    44f2:	b.w	364a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xd02>
    44f6:	add.w	r2, r6, #544	; 0x220
    44fa:	mov	r0, r2
    44fc:	str	r2, [r4, #0]
    44fe:	b.w	35e0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc98>
    4502:	add.w	r2, r0, #544	; 0x220
    4506:	ldr	r4, [pc, #396]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    4508:	mov	r0, r2
    450a:	str	r2, [r4, #0]
    450c:	b.w	3570 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xc28>
    4510:	add.w	r2, r6, #544	; 0x220
    4514:	mov	r0, r2
    4516:	str	r2, [r4, #0]
    4518:	b.n	4374 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a2c>
    451a:	add.w	r2, r6, #544	; 0x220
    451e:	mov	r0, r2
    4520:	str	r2, [r4, #0]
    4522:	b.w	371c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xdd4>
    4526:	add.w	r2, r6, #544	; 0x220
    452a:	mov	r0, r2
    452c:	str	r2, [r4, #0]
    452e:	b.w	33d6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa8e>
    4532:	add.w	r2, r6, #544	; 0x220
    4536:	mov	r0, r2
    4538:	str	r2, [r4, #0]
    453a:	b.w	336c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xa24>
    453e:	add.w	r2, r6, #544	; 0x220
    4542:	mov	r0, r2
    4544:	str	r2, [r4, #0]
    4546:	b.w	2f5a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x612>
    454a:	add.w	r2, r0, #544	; 0x220
    454e:	ldr	r4, [pc, #324]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    4550:	mov	r0, r2
    4552:	str	r2, [r4, #0]
    4554:	b.w	2c48 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x300>
    4558:	add.w	r2, r6, #544	; 0x220
    455c:	mov	r0, r2
    455e:	str	r2, [r4, #0]
    4560:	b.w	2d40 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x3f8>
    4564:	add.w	r2, r0, #544	; 0x220
    4568:	ldr	r4, [pc, #296]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    456a:	mov	r0, r2
    456c:	str	r2, [r4, #0]
    456e:	b.w	2bd4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x28c>
    4572:	add.w	r2, r6, #544	; 0x220
    4576:	mov	r0, r2
    4578:	str	r2, [r4, #0]
    457a:	b.n	4104 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x17bc>
    457c:	add.w	r2, r6, #544	; 0x220
    4580:	mov	r0, r2
    4582:	str	r2, [r4, #0]
    4584:	b.w	2cd6 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x38e>
    4588:	add.w	r2, r6, #544	; 0x220
    458c:	mov	r0, r2
    458e:	str	r2, [r4, #0]
    4590:	b.n	3ef4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x15ac>
    4592:	add.w	r2, r0, #544	; 0x220
    4596:	ldr	r4, [pc, #252]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    4598:	mov	r0, r2
    459a:	str	r2, [r4, #0]
    459c:	b.w	2aec <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1a4>
    45a0:	add.w	r2, r6, #544	; 0x220
    45a4:	mov	r0, r2
    45a6:	str	r2, [r4, #0]
    45a8:	b.w	3a6a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1122>
    45ac:	add.w	r2, r6, #544	; 0x220
    45b0:	mov	r0, r2
    45b2:	str	r2, [r4, #0]
    45b4:	b.w	3a00 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x10b8>
    45b8:	add.w	r2, r6, #544	; 0x220
    45bc:	mov	r0, r2
    45be:	str	r2, [r4, #0]
    45c0:	b.w	3998 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1050>
    45c4:	add.w	r2, r6, #544	; 0x220
    45c8:	mov	r0, r2
    45ca:	str	r2, [r4, #0]
    45cc:	b.w	392c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xfe4>
    45d0:	add.w	r2, r6, #544	; 0x220
    45d4:	mov	r0, r2
    45d6:	str	r2, [r4, #0]
    45d8:	b.n	423e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x18f6>
    45da:	add.w	r2, r6, #544	; 0x220
    45de:	mov	r0, r2
    45e0:	str	r2, [r4, #0]
    45e2:	b.w	34a0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xb58>
    45e6:	add.w	r2, r0, #544	; 0x220
    45ea:	ldr	r4, [pc, #168]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    45ec:	mov	r0, r2
    45ee:	str	r2, [r4, #0]
    45f0:	b.w	3432 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0xaea>
    45f4:	add.w	r2, r6, #544	; 0x220
    45f8:	mov	r0, r2
    45fa:	str	r2, [r4, #0]
    45fc:	b.w	3166 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x81e>
    4600:	add.w	r2, r6, #544	; 0x220
    4604:	mov	r0, r2
    4606:	str	r2, [r4, #0]
    4608:	b.w	3304 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x9bc>
    460c:	add.w	r2, r6, #544	; 0x220
    4610:	mov	r0, r2
    4612:	str	r2, [r4, #0]
    4614:	b.w	329a <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x952>
    4618:	add.w	r2, r6, #544	; 0x220
    461c:	mov	r0, r2
    461e:	str	r2, [r4, #0]
    4620:	b.w	3230 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x8e8>
    4624:	add.w	r2, r0, #544	; 0x220
    4628:	ldr	r4, [pc, #104]	; (4694 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x1d4c>)
    462a:	mov	r0, r2
    462c:	str	r2, [r4, #0]
    462e:	b.w	31c2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x87a>
    4632:	add.w	r2, r6, #544	; 0x220
    4636:	mov	r0, r2
    4638:	str	r2, [r4, #0]
    463a:	b.w	30fc <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x7b4>
    463e:	add.w	r2, r6, #544	; 0x220
    4642:	mov	r0, r2
    4644:	str	r2, [r4, #0]
    4646:	b.w	3094 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x74c>
    464a:	add.w	r2, r6, #544	; 0x220
    464e:	mov	r0, r2
    4650:	str	r2, [r4, #0]
    4652:	b.w	302c <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x6e4>
    4656:	add.w	r2, r6, #544	; 0x220
    465a:	mov	r0, r2
    465c:	str	r2, [r4, #0]
    465e:	b.w	2fc2 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x67a>
    4662:	add.w	r2, r6, #544	; 0x220
    4666:	mov	r0, r2
    4668:	str	r2, [r4, #0]
    466a:	b.w	2ef0 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x5a8>
    466e:	add.w	r2, r6, #544	; 0x220
    4672:	mov	r0, r2
    4674:	str	r2, [r4, #0]
    4676:	b.w	2e88 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x540>
    467a:	add.w	r2, r6, #544	; 0x220
    467e:	mov	r0, r2
    4680:	str	r2, [r4, #0]
    4682:	b.w	2e1e <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x4d6>
    4686:	add.w	r2, r6, #544	; 0x220
    468a:	mov	r0, r2
    468c:	str	r2, [r4, #0]
    468e:	b.w	2db4 <MTPD::getObjectPropDesc(unsigned long, unsigned long)+0x46c>
    4692:	nop
    4694:	.word	0x2000158c

00004698 <MTPD::getObjectPropValue(unsigned long, unsigned long)>:
        default:
          break;
      }
    }

    void getObjectPropValue(uint32_t p1, uint32_t p2)
    4698:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    469c:	sub	sp, #332	; 0x14c
    469e:	mov	r4, r2
    46a0:	mov	r5, r0
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].eofSector()); }

    char * getName(uint32_t store) {return zFs[store].getName();}

    uint32_t Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
    { return zFs[0].Info(handle, filename, size, parent);}
    46a2:	ldr	r0, [pc, #668]	; (4940 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x2a8>)
    46a4:	add.w	r8, sp, #36	; 0x24
    46a8:	add	r3, sp, #32
    46aa:	add	r2, sp, #72	; 0x48
        default:
          break;
      }
    }

    void getObjectPropValue(uint32_t p1, uint32_t p2)
    46ac:	mov	r6, r1
    { return (uint64_t)512 *(uint64_t)(zFs[store].totalSectors() - zFs[store].eofSector()); }

    char * getName(uint32_t store) {return zFs[store].getName();}

    uint32_t Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
    { return zFs[0].Info(handle, filename, size, parent);}
    46ae:	str.w	r8, [sp]
    46b2:	bl	6d64 <zeroFS_class::Info(unsigned long, char*, unsigned long*, unsigned long*)>
      uint16_t store = 0;
      uint32_t storage = Store2Storage(store);

      uint32_t dir = (size == 0xFFFFFFFFUL);

      switch(p2)
    46b6:	mvn.w	r3, #56320	; 0xdc00
      mFS.Info(p1, filename, &size, &parent);

      uint16_t store = 0;
      uint32_t storage = Store2Storage(store);

      uint32_t dir = (size == 0xFFFFFFFFUL);
    46ba:	ldr	r2, [sp, #32]

      switch(p2)
    46bc:	add	r3, r4
    46be:	cmp	r3, #67	; 0x43
    46c0:	bhi.n	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    46c2:	tbh	[pc, r3, lsl #1]
    46c6:	.short	0x0044
    46c8:	.word	0x009e008c
    46cc:	.word	0x004d00a9
    46d0:	.word	0x00b1004d
    46d4:	.word	0x0141012f
    46d8:	.word	0x00ed004d
    46dc:	.word	0x004d004d
    46e0:	.word	0x004d004d
    46e4:	.word	0x004d004d
    46e8:	.word	0x004d004d
    46ec:	.word	0x004d004d
    46f0:	.word	0x004d004d
    46f4:	.word	0x004d004d
    46f8:	.word	0x004d004d
    46fc:	.word	0x004d004d
    4700:	.word	0x004d004d
    4704:	.word	0x004d004d
    4708:	.word	0x004d004d
    470c:	.word	0x004d004d
    4710:	.word	0x004d004d
    4714:	.word	0x004d004d
    4718:	.word	0x004d004d
    471c:	.word	0x004d004d
    4720:	.word	0x004d004d
    4724:	.word	0x004d004d
    4728:	.word	0x004d004d
    472c:	.word	0x004d004d
    4730:	.word	0x004d004d
    4734:	.word	0x004d004d
    4738:	.word	0x004d004d
    473c:	.word	0x004d004d
    4740:	.word	0x004d004d
    4744:	.word	0x0125004d
    4748:	.word	0x004d004d
    474c:	.short	0x0050
    474e:	movs	r2, #1
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4750:	ldrb	r3, [r5, #0]
    4752:	str	r2, [sp, #40]	; 0x28
    4754:	cmp	r3, #0
    4756:	beq.w	4cba <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x622>
      {
        write_length_ += len;
    475a:	ldr	r3, [r5, #4]
    475c:	adds	r3, #4
    475e:	str	r3, [r5, #4]
          writestring(filename);
          break;
        default:
          break;
      }
    }
    4760:	add	sp, #332	; 0x14c
    4762:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    4766:	ldrb.w	r4, [sp, #72]	; 0x48
    476a:	cmp	r4, #0
    476c:	bne.w	4a54 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x3bc>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4770:	ldrb	r3, [r5, #0]
    4772:	strb.w	r4, [sp, #18]
    4776:	cmp	r3, #0
    4778:	bne.w	4932 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x29a>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    477c:	ldr	r3, [r5, #4]
    477e:	cmp	r3, #0
    4780:	beq.w	511c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa84>
    4784:	ldr	r4, [pc, #444]	; (4944 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x2ac>)
    4786:	ldr	r0, [r4, #0]
        write_length_ += len;
    4788:	adds	r3, #1
        
        const char * src=data;
    478a:	add.w	r6, sp, #18
    478e:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4792:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4796:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    4798:	mov.w	r9, #0
    479c:	b.n	47a6 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x10e>
        while(pos<len)
    479e:	cmp.w	r9, #0
    47a2:	bgt.n	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    47a4:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    47a6:	subs	r5, r7, r0
    47a8:	rsb	r3, r9, #1
          memcpy(dst,src,to_copy);
    47ac:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    47ae:	cmp	r5, r3
    47b0:	it	ge
    47b2:	movge	r5, r3
          memcpy(dst,src,to_copy);
    47b4:	mov	r2, r5
          pos += to_copy;
    47b6:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    47b8:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    47bc:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    47be:	add	r6, r5
          dst += to_copy;
    47c0:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    47c2:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    47c4:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    47c6:	bne.n	479e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x106>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    47c8:	movs	r2, #60	; 0x3c
    47ca:	mov.w	r1, #512	; 0x200
    47ce:	mov	r0, r8
    47d0:	bl	9d50 <usb_mtp_send>
    47d4:	cmp	r0, #0
    47d6:	ble.n	47c8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x130>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    47d8:	str.w	r8, [r4]
    47dc:	b.n	479e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x106>
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(storage);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    47de:	adds	r2, #1
    47e0:	movw	r3, #12289	; 0x3001
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    47e4:	ldrb	r2, [r5, #0]
      {
        case MTP_PROPERTY_STORAGE_ID:         //0xDC01:
          write32(storage);
          break;
        case MTP_PROPERTY_OBJECT_FORMAT:      //0xDC02:
          write16(dir?0x3001:0x3000);
    47e6:	it	ne
    47e8:	movne.w	r3, #12288	; 0x3000
    47ec:	strh.w	r3, [sp, #20]
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    47f0:	ldr	r3, [r5, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    47f2:	cmp	r2, #0
    47f4:	beq.w	4d80 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x6e8>
      {
        write_length_ += len;
    47f8:	adds	r3, #2
    47fa:	str	r3, [r5, #4]
          writestring(filename);
          break;
        default:
          break;
      }
    }
    47fc:	add	sp, #332	; 0x14c
    47fe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4802:	movs	r2, #0
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4804:	ldrb	r3, [r5, #0]
    4806:	strh.w	r2, [sp, #22]
    480a:	cmp	r3, #0
    480c:	beq.w	4d1c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x684>
      {
        write_length_ += len;
    4810:	ldr	r3, [r5, #4]
    4812:	adds	r3, #2
    4814:	str	r3, [r5, #4]
    4816:	b.n	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4818:	ldrb	r3, [r5, #0]
    481a:	str	r2, [sp, #48]	; 0x30
    481c:	cmp	r3, #0
    481e:	beq.w	4bec <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x554>
      {
        write_length_ += len;
    4822:	ldr	r3, [r5, #4]
    4824:	adds	r3, #4
    4826:	b.n	475c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc4>

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    4828:	ldrb.w	r4, [sp, #72]	; 0x48
    482c:	cmp	r4, #0
    482e:	bne.w	49b8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x320>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4832:	ldrb	r3, [r5, #0]
    4834:	strb.w	r4, [sp, #14]
    4838:	cmp	r3, #0
    483a:	bne.n	4932 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x29a>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    483c:	ldr	r3, [r5, #4]
    483e:	cmp	r3, #0
    4840:	beq.w	5136 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa9e>
    4844:	ldr	r4, [pc, #252]	; (4944 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x2ac>)
    4846:	ldr	r0, [r4, #0]
        write_length_ += len;
    4848:	adds	r3, #1
        
        const char * src=data;
    484a:	add.w	r6, sp, #14
    484e:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4852:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4856:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    4858:	mov.w	r9, #0
    485c:	b.n	4868 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1d0>
        while(pos<len)
    485e:	cmp.w	r9, #0
    4862:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    4866:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4868:	subs	r5, r7, r0
    486a:	rsb	r3, r9, #1
          memcpy(dst,src,to_copy);
    486e:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4870:	cmp	r5, r3
    4872:	it	ge
    4874:	movge	r5, r3
          memcpy(dst,src,to_copy);
    4876:	mov	r2, r5
          pos += to_copy;
    4878:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    487a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    487e:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4880:	add	r6, r5
          dst += to_copy;
    4882:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4884:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4886:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4888:	bne.n	485e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1c6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    488a:	movs	r2, #60	; 0x3c
    488c:	mov.w	r1, #512	; 0x200
    4890:	mov	r0, r8
    4892:	bl	9d50 <usb_mtp_send>
    4896:	cmp	r0, #0
    4898:	ble.n	488a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1f2>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    489a:	str.w	r8, [r4]
    489e:	b.n	485e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1c6>
    48a0:	ldr.w	r2, [r8]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    48a4:	ldrb	r3, [r5, #0]
    48a6:	str	r2, [sp, #52]	; 0x34
    48a8:	cmp	r3, #0
    48aa:	bne.w	475a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc2>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    48ae:	ldr	r3, [r5, #4]
    48b0:	cmp	r3, #0
    48b2:	beq.w	5102 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa6a>
    48b6:	ldr	r4, [pc, #140]	; (4944 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x2ac>)
    48b8:	ldr	r0, [r4, #0]
        write_length_ += len;
    48ba:	adds	r3, #4
        
        const char * src=data;
    48bc:	add	r6, sp, #52	; 0x34
    48be:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    48c2:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    48c6:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    48c8:	mov.w	r9, #0
    48cc:	b.n	48d8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x240>
        while(pos<len)
    48ce:	cmp.w	r9, #3
    48d2:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    48d6:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    48d8:	subs	r5, r7, r0
    48da:	rsb	r3, r9, #4
          memcpy(dst,src,to_copy);
    48de:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    48e0:	cmp	r5, r3
    48e2:	it	ge
    48e4:	movge	r5, r3
          memcpy(dst,src,to_copy);
    48e6:	mov	r2, r5
          pos += to_copy;
    48e8:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    48ea:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    48ee:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    48f0:	add	r6, r5
          dst += to_copy;
    48f2:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    48f4:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    48f6:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    48f8:	bne.n	48ce <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x236>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    48fa:	movs	r2, #60	; 0x3c
    48fc:	mov.w	r1, #512	; 0x200
    4900:	mov	r0, r8
    4902:	bl	9d50 <usb_mtp_send>
    4906:	cmp	r0, #0
    4908:	ble.n	48fa <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x262>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    490a:	str.w	r8, [r4]
    490e:	b.n	48ce <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x236>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4910:	ldrb	r3, [r5, #0]
    4912:	str	r6, [sp, #60]	; 0x3c
    4914:	cmp	r3, #0
    4916:	beq.w	4de0 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x748>
      {
        write_length_ += len;
    491a:	ldr	r3, [r5, #4]
    491c:	adds	r3, #4
    491e:	adds	r3, #4
    4920:	adds	r3, #4
    4922:	b.n	475c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc4>
    4924:	movs	r2, #0
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4926:	ldrb	r3, [r5, #0]
    4928:	strb.w	r2, [sp, #16]
    492c:	cmp	r3, #0
    492e:	beq.w	4f78 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8e0>
      {
        write_length_ += len;
    4932:	ldr	r3, [r5, #4]
    4934:	adds	r3, #1
    4936:	str	r3, [r5, #4]
          writestring(filename);
          break;
        default:
          break;
      }
    }
    4938:	add	sp, #332	; 0x14c
    493a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    493e:	nop
    4940:	.word	0x200015e4
    4944:	.word	0x2000158c
    4948:	movs	r2, #0
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    494a:	ldrb	r3, [r5, #0]
    494c:	strb.w	r2, [sp, #17]
    4950:	cmp	r3, #0
    4952:	bne.n	4932 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x29a>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4954:	ldr	r3, [r5, #4]
    4956:	cmp	r3, #0
    4958:	beq.w	5110 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa78>
    495c:	ldr	r4, [pc, #752]	; (4c50 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5b8>)
    495e:	ldr	r0, [r4, #0]
        write_length_ += len;
    4960:	adds	r3, #1
        
        const char * src=data;
    4962:	add.w	r6, sp, #17
    4966:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    496a:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    496e:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    4970:	mov.w	r9, #0
    4974:	b.n	4980 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x2e8>
        while(pos<len)
    4976:	cmp.w	r9, #0
    497a:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    497e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4980:	subs	r5, r7, r0
    4982:	rsb	r3, r9, #1
          memcpy(dst,src,to_copy);
    4986:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4988:	cmp	r5, r3
    498a:	it	ge
    498c:	movge	r5, r3
          memcpy(dst,src,to_copy);
    498e:	mov	r2, r5
          pos += to_copy;
    4990:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4992:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4996:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4998:	add	r6, r5
          dst += to_copy;
    499a:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    499c:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    499e:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    49a0:	bne.n	4976 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x2de>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    49a2:	movs	r2, #60	; 0x3c
    49a4:	mov.w	r1, #512	; 0x200
    49a8:	mov	r0, r8
    49aa:	bl	9d50 <usb_mtp_send>
    49ae:	cmp	r0, #0
    49b0:	ble.n	49a2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x30a>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    49b2:	str.w	r8, [r4]
    49b6:	b.n	4976 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x2de>
#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
    49b8:	add	r0, sp, #72	; 0x48
    49ba:	bl	c080 <strlen>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    49be:	ldrb	r2, [r5, #0]
    49c0:	adds	r0, #1
      {
        write_length_ += len;
    49c2:	ldr	r3, [r5, #4]
    49c4:	strb.w	r0, [sp, #15]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    49c8:	cmp	r2, #0
    49ca:	beq.w	5016 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x97e>
      {
        write_length_ += len;
    49ce:	adds	r3, #1
    49d0:	str	r3, [r5, #4]
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    49d2:	add.w	r8, sp, #72	; 0x48
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    49d6:	add.w	sl, r5, #544	; 0x220
    49da:	b.n	49ea <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x352>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    49dc:	adds	r3, #2
    49de:	str	r3, [r5, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    49e0:	ldrb.w	r4, [r8, #1]!
    49e4:	cmp	r4, #0
    49e6:	beq.w	4b80 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x4e8>
    49ea:	strh.w	r4, [sp, #26]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    49ee:	cmp	r2, #0
    49f0:	bne.n	49dc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x344>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    49f2:	ldr	r4, [pc, #604]	; (4c50 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5b8>)
    49f4:	cmp	r3, #0
    49f6:	beq.n	4aea <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x452>
    49f8:	ldr	r0, [r4, #0]
        write_length_ += len;
    49fa:	adds	r3, #2
    49fc:	add.w	r9, r5, #1056	; 0x420
        
        const char * src=data;
    4a00:	add.w	r7, sp, #26
        //
        int pos = 0; // into data
    4a04:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4a06:	str	r3, [r5, #4]
    4a08:	b.n	4a10 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x378>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4a0a:	cmp	r6, #1
    4a0c:	bgt.n	4a4e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x3b6>
    4a0e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4a10:	rsb	r2, r0, r9
    4a14:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
    4a18:	mov	r1, r7
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4a1a:	cmp	r2, r3
    4a1c:	it	ge
    4a1e:	movge	r2, r3
    4a20:	mov	fp, r2
          memcpy(dst,src,to_copy);
          pos += to_copy;
    4a22:	add	r6, r2
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4a24:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4a28:	ldr	r2, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4a2a:	add	r7, fp
          dst += to_copy;
    4a2c:	add.w	r3, r2, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4a30:	cmp	r3, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4a32:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4a34:	bne.n	4a0a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x372>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4a36:	movs	r2, #60	; 0x3c
    4a38:	mov.w	r1, #512	; 0x200
    4a3c:	mov	r0, sl
    4a3e:	bl	9d50 <usb_mtp_send>
    4a42:	cmp	r0, #0
    4a44:	ble.n	4a36 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x39e>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4a46:	cmp	r6, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4a48:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4a4c:	ble.n	4a0e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x376>
    4a4e:	ldrb	r2, [r5, #0]
    4a50:	ldr	r3, [r5, #4]
    4a52:	b.n	49e0 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x348>
#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
    4a54:	add	r0, sp, #72	; 0x48
    4a56:	bl	c080 <strlen>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4a5a:	ldrb	r2, [r5, #0]
    4a5c:	adds	r0, #1
      {
        write_length_ += len;
    4a5e:	ldr	r3, [r5, #4]
    4a60:	strb.w	r0, [sp, #19]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4a64:	cmp	r2, #0
    4a66:	beq.w	5076 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x9de>
      {
        write_length_ += len;
    4a6a:	adds	r3, #1
    4a6c:	str	r3, [r5, #4]
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    4a6e:	add	r7, sp, #72	; 0x48
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4a70:	add.w	sl, r5, #544	; 0x220
    4a74:	b.n	4a82 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x3ea>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    4a76:	adds	r3, #2
    4a78:	str	r3, [r5, #4]
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    4a7a:	ldrb.w	r4, [r7, #1]!
    4a7e:	cmp	r4, #0
    4a80:	beq.n	4b06 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x46e>
    4a82:	strh.w	r4, [sp, #30]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4a86:	cmp	r2, #0
    4a88:	bne.n	4a76 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x3de>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4a8a:	ldr	r4, [pc, #452]	; (4c50 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5b8>)
    4a8c:	cbz	r3, 4af2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x45a>
    4a8e:	ldr	r0, [r4, #0]
        write_length_ += len;
    4a90:	adds	r3, #2
    4a92:	add.w	r9, r5, #1056	; 0x420
        
        const char * src=data;
    4a96:	add.w	r8, sp, #30
        //
        int pos = 0; // into data
    4a9a:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4a9c:	str	r3, [r5, #4]
    4a9e:	b.n	4aa6 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x40e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4aa0:	cmp	r6, #1
    4aa2:	bgt.n	4ae4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x44c>
    4aa4:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4aa6:	rsb	r2, r0, r9
    4aaa:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
    4aae:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4ab0:	cmp	r2, r3
    4ab2:	it	ge
    4ab4:	movge	r2, r3
    4ab6:	mov	fp, r2
          memcpy(dst,src,to_copy);
          pos += to_copy;
    4ab8:	add	r6, r2
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4aba:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4abe:	ldr	r2, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4ac0:	add	r8, fp
          dst += to_copy;
    4ac2:	add.w	r3, r2, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4ac6:	cmp	r3, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4ac8:	str	r3, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4aca:	bne.n	4aa0 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x408>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4acc:	movs	r2, #60	; 0x3c
    4ace:	mov.w	r1, #512	; 0x200
    4ad2:	mov	r0, sl
    4ad4:	bl	9d50 <usb_mtp_send>
    4ad8:	cmp	r0, #0
    4ada:	ble.n	4acc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x434>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4adc:	cmp	r6, #1
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4ade:	str.w	sl, [r4]
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4ae2:	ble.n	4aa4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x40c>
    4ae4:	ldrb	r2, [r5, #0]
    4ae6:	ldr	r3, [r5, #4]
    4ae8:	b.n	4a7a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x3e2>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4aea:	mov	r0, sl
    4aec:	str.w	sl, [r4]
    4af0:	b.n	49fa <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x362>
    4af2:	mov	r0, sl
    4af4:	str.w	sl, [r4]
    4af8:	b.n	4a90 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x3f8>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    4afa:	ldrb.w	r4, [sp, #72]	; 0x48
    4afe:	ldrb	r2, [r5, #0]
    4b00:	ldr	r3, [r5, #4]
    4b02:	cmp	r4, #0
    4b04:	bne.n	4a6e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x3d6>
    4b06:	movs	r1, #0
    4b08:	strh.w	r1, [sp, #28]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4b0c:	cmp	r2, #0
    4b0e:	bne.w	47f8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x160>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4b12:	cmp	r3, #0
    4b14:	beq.w	5168 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xad0>
    4b18:	ldr	r4, [pc, #308]	; (4c50 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5b8>)
    4b1a:	ldr	r0, [r4, #0]
        write_length_ += len;
    4b1c:	adds	r3, #2
        
        const char * src=data;
    4b1e:	add	r6, sp, #28
    4b20:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4b24:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4b28:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    4b2a:	mov.w	r9, #0
    4b2e:	b.n	4b3a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x4a2>
        while(pos<len)
    4b30:	cmp.w	r9, #1
    4b34:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    4b38:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4b3a:	subs	r5, r7, r0
    4b3c:	rsb	r3, r9, #2
          memcpy(dst,src,to_copy);
    4b40:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4b42:	cmp	r5, r3
    4b44:	it	ge
    4b46:	movge	r5, r3
          memcpy(dst,src,to_copy);
    4b48:	mov	r2, r5
          pos += to_copy;
    4b4a:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4b4c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4b50:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4b52:	add	r6, r5
          dst += to_copy;
    4b54:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4b56:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4b58:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4b5a:	bne.n	4b30 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x498>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4b5c:	movs	r2, #60	; 0x3c
    4b5e:	mov.w	r1, #512	; 0x200
    4b62:	mov	r0, r8
    4b64:	bl	9d50 <usb_mtp_send>
    4b68:	cmp	r0, #0
    4b6a:	ble.n	4b5c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x4c4>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4b6c:	str.w	r8, [r4]
    4b70:	b.n	4b30 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x498>
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    4b72:	ldrb.w	r4, [sp, #72]	; 0x48
    4b76:	ldrb	r2, [r5, #0]
    4b78:	ldr	r3, [r5, #4]
    4b7a:	cmp	r4, #0
    4b7c:	bne.w	49d2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x33a>
    4b80:	movs	r1, #0
    4b82:	strh.w	r1, [sp, #24]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4b86:	cmp	r2, #0
    4b88:	bne.w	47f8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x160>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4b8c:	cmp	r3, #0
    4b8e:	beq.w	5150 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xab8>
    4b92:	ldr	r4, [pc, #188]	; (4c50 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5b8>)
    4b94:	ldr	r0, [r4, #0]
        write_length_ += len;
    4b96:	adds	r3, #2
        
        const char * src=data;
    4b98:	add	r6, sp, #24
    4b9a:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4b9e:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4ba2:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    4ba4:	mov.w	r9, #0
    4ba8:	b.n	4bb4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x51c>
        while(pos<len)
    4baa:	cmp.w	r9, #1
    4bae:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    4bb2:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4bb4:	subs	r5, r7, r0
    4bb6:	rsb	r3, r9, #2
          memcpy(dst,src,to_copy);
    4bba:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4bbc:	cmp	r5, r3
    4bbe:	it	ge
    4bc0:	movge	r5, r3
          memcpy(dst,src,to_copy);
    4bc2:	mov	r2, r5
          pos += to_copy;
    4bc4:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4bc6:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4bca:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4bcc:	add	r6, r5
          dst += to_copy;
    4bce:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4bd0:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4bd2:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4bd4:	bne.n	4baa <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x512>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4bd6:	movs	r2, #60	; 0x3c
    4bd8:	mov.w	r1, #512	; 0x200
    4bdc:	mov	r0, r8
    4bde:	bl	9d50 <usb_mtp_send>
    4be2:	cmp	r0, #0
    4be4:	ble.n	4bd6 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x53e>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4be6:	str.w	r8, [r4]
    4bea:	b.n	4baa <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x512>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4bec:	ldr	r3, [r5, #4]
    4bee:	cmp	r3, #0
    4bf0:	beq.w	4fe0 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x948>
    4bf4:	ldr	r4, [pc, #88]	; (4c50 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5b8>)
    4bf6:	ldr	r0, [r4, #0]
        write_length_ += len;
    4bf8:	adds	r3, #4
        
        const char * src=data;
    4bfa:	add.w	r9, sp, #48	; 0x30
    4bfe:	add.w	r6, r5, #1056	; 0x420
        //
        int pos = 0; // into data
    4c02:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4c06:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4c08:	add.w	sl, r5, #544	; 0x220
    4c0c:	b.n	4c16 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x57e>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4c0e:	cmp.w	r8, #3
    4c12:	bgt.n	4c54 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5bc>
    4c14:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4c16:	subs	r7, r6, r0
    4c18:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    4c1c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4c1e:	cmp	r7, r3
    4c20:	it	ge
    4c22:	movge	r7, r3
          memcpy(dst,src,to_copy);
    4c24:	mov	r2, r7
          pos += to_copy;
    4c26:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4c28:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4c2c:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4c2e:	add	r9, r7
          dst += to_copy;
    4c30:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4c32:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4c34:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4c36:	bne.n	4c0e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x576>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4c38:	movs	r2, #60	; 0x3c
    4c3a:	mov.w	r1, #512	; 0x200
    4c3e:	mov	r0, sl
    4c40:	bl	9d50 <usb_mtp_send>
    4c44:	cmp	r0, #0
    4c46:	ble.n	4c38 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5a0>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4c48:	str.w	sl, [r4]
    4c4c:	b.n	4c0e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x576>
    4c4e:	nop
    4c50:	.word	0x2000158c
    4c54:	movs	r3, #0
    4c56:	ldrb	r2, [r5, #0]
    4c58:	str	r3, [sp, #44]	; 0x2c
    4c5a:	ldr	r3, [r5, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4c5c:	cmp	r2, #0
    4c5e:	bne.w	475c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4c62:	cmp	r3, #0
    4c64:	beq.w	50f8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa60>
    4c68:	ldr	r0, [r4, #0]
        write_length_ += len;
    4c6a:	adds	r3, #4
        
        const char * src=data;
    4c6c:	add.w	r8, sp, #44	; 0x2c
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4c70:	add.w	r9, r5, #544	; 0x220
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    4c74:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4c76:	str	r3, [r5, #4]
    4c78:	b.n	4c82 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5ea>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4c7a:	cmp	r7, #3
    4c7c:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    4c80:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4c82:	subs	r5, r6, r0
    4c84:	rsb	r3, r7, #4
          memcpy(dst,src,to_copy);
    4c88:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4c8a:	cmp	r5, r3
    4c8c:	it	ge
    4c8e:	movge	r5, r3
          memcpy(dst,src,to_copy);
    4c90:	mov	r2, r5
          pos += to_copy;
    4c92:	add	r7, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4c94:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4c98:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4c9a:	add	r8, r5
          dst += to_copy;
    4c9c:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4c9e:	cmp	r5, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4ca0:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4ca2:	bne.n	4c7a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5e2>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4ca4:	movs	r2, #60	; 0x3c
    4ca6:	mov.w	r1, #512	; 0x200
    4caa:	mov	r0, r9
    4cac:	bl	9d50 <usb_mtp_send>
    4cb0:	cmp	r0, #0
    4cb2:	ble.n	4ca4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x60c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4cb4:	str.w	r9, [r4]
    4cb8:	b.n	4c7a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5e2>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4cba:	ldr	r3, [r5, #4]
    4cbc:	cmp	r3, #0
    4cbe:	beq.w	50ec <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa54>
    4cc2:	ldr	r4, [pc, #792]	; (4fdc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x944>)
    4cc4:	ldr	r0, [r4, #0]
        write_length_ += len;
    4cc6:	adds	r3, #4
        
        const char * src=data;
    4cc8:	add	r6, sp, #40	; 0x28
    4cca:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4cce:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4cd2:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    4cd4:	mov.w	r9, #0
    4cd8:	b.n	4ce4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x64c>
        while(pos<len)
    4cda:	cmp.w	r9, #3
    4cde:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    4ce2:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4ce4:	subs	r5, r7, r0
    4ce6:	rsb	r3, r9, #4
          memcpy(dst,src,to_copy);
    4cea:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4cec:	cmp	r5, r3
    4cee:	it	ge
    4cf0:	movge	r5, r3
          memcpy(dst,src,to_copy);
    4cf2:	mov	r2, r5
          pos += to_copy;
    4cf4:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4cf6:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4cfa:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4cfc:	add	r6, r5
          dst += to_copy;
    4cfe:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4d00:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4d02:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4d04:	bne.n	4cda <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x642>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4d06:	movs	r2, #60	; 0x3c
    4d08:	mov.w	r1, #512	; 0x200
    4d0c:	mov	r0, r8
    4d0e:	bl	9d50 <usb_mtp_send>
    4d12:	cmp	r0, #0
    4d14:	ble.n	4d06 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x66e>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4d16:	str.w	r8, [r4]
    4d1a:	b.n	4cda <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x642>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4d1c:	ldr	r3, [r5, #4]
    4d1e:	cmp	r3, #0
    4d20:	beq.w	50e0 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa48>
    4d24:	ldr	r4, [pc, #692]	; (4fdc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x944>)
    4d26:	ldr	r0, [r4, #0]
        write_length_ += len;
    4d28:	adds	r3, #2
        
        const char * src=data;
    4d2a:	add.w	r6, sp, #22
    4d2e:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4d32:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4d36:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    4d38:	mov.w	r9, #0
    4d3c:	b.n	4d48 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x6b0>
        while(pos<len)
    4d3e:	cmp.w	r9, #1
    4d42:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    4d46:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4d48:	subs	r5, r7, r0
    4d4a:	rsb	r3, r9, #2
          memcpy(dst,src,to_copy);
    4d4e:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4d50:	cmp	r5, r3
    4d52:	it	ge
    4d54:	movge	r5, r3
          memcpy(dst,src,to_copy);
    4d56:	mov	r2, r5
          pos += to_copy;
    4d58:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4d5a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4d5e:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4d60:	add	r6, r5
          dst += to_copy;
    4d62:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4d64:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4d66:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4d68:	bne.n	4d3e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x6a6>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4d6a:	movs	r2, #60	; 0x3c
    4d6c:	mov.w	r1, #512	; 0x200
    4d70:	mov	r0, r8
    4d72:	bl	9d50 <usb_mtp_send>
    4d76:	cmp	r0, #0
    4d78:	ble.n	4d6a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x6d2>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4d7a:	str.w	r8, [r4]
    4d7e:	b.n	4d3e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x6a6>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4d80:	cmp	r3, #0
    4d82:	beq.w	50d4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa3c>
    4d86:	ldr	r4, [pc, #596]	; (4fdc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x944>)
    4d88:	ldr	r0, [r4, #0]
        write_length_ += len;
    4d8a:	adds	r3, #2
        
        const char * src=data;
    4d8c:	add	r6, sp, #20
    4d8e:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4d92:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4d96:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    4d98:	mov.w	r9, #0
    4d9c:	b.n	4da8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x710>
        while(pos<len)
    4d9e:	cmp.w	r9, #1
    4da2:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    4da6:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4da8:	subs	r5, r7, r0
    4daa:	rsb	r3, r9, #2
          memcpy(dst,src,to_copy);
    4dae:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4db0:	cmp	r5, r3
    4db2:	it	ge
    4db4:	movge	r5, r3
          memcpy(dst,src,to_copy);
    4db6:	mov	r2, r5
          pos += to_copy;
    4db8:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4dba:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4dbe:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4dc0:	add	r6, r5
          dst += to_copy;
    4dc2:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4dc4:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4dc6:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4dc8:	bne.n	4d9e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x706>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4dca:	movs	r2, #60	; 0x3c
    4dcc:	mov.w	r1, #512	; 0x200
    4dd0:	mov	r0, r8
    4dd2:	bl	9d50 <usb_mtp_send>
    4dd6:	cmp	r0, #0
    4dd8:	ble.n	4dca <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x732>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4dda:	str.w	r8, [r4]
    4dde:	b.n	4d9e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x706>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4de0:	ldr	r3, [r5, #4]
    4de2:	cmp	r3, #0
    4de4:	beq.w	500a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x972>
    4de8:	ldr	r4, [pc, #496]	; (4fdc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x944>)
    4dea:	ldr	r0, [r4, #0]
        write_length_ += len;
    4dec:	adds	r3, #4
        
        const char * src=data;
    4dee:	add.w	sl, sp, #60	; 0x3c
    4df2:	add.w	r6, r5, #1056	; 0x420
        //
        int pos = 0; // into data
    4df6:	mov.w	r9, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4dfa:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4dfc:	add.w	fp, r5, #544	; 0x220
    4e00:	b.n	4e0a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x772>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4e02:	cmp.w	r9, #3
    4e06:	bgt.n	4e42 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x7aa>
    4e08:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4e0a:	subs	r7, r6, r0
    4e0c:	rsb	r3, r9, #4
          memcpy(dst,src,to_copy);
    4e10:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4e12:	cmp	r7, r3
    4e14:	it	ge
    4e16:	movge	r7, r3
          memcpy(dst,src,to_copy);
    4e18:	mov	r2, r7
          pos += to_copy;
    4e1a:	add	r9, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4e1c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4e20:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4e22:	add	sl, r7
          dst += to_copy;
    4e24:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4e26:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4e28:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4e2a:	bne.n	4e02 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x76a>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4e2c:	movs	r2, #60	; 0x3c
    4e2e:	mov.w	r1, #512	; 0x200
    4e32:	mov	r0, fp
    4e34:	bl	9d50 <usb_mtp_send>
    4e38:	cmp	r0, #0
    4e3a:	ble.n	4e2c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x794>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4e3c:	str.w	fp, [r4]
    4e40:	b.n	4e02 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x76a>
    4e42:	ldr.w	r3, [r8]
    4e46:	ldrb	r2, [r5, #0]
    4e48:	str	r3, [sp, #56]	; 0x38
    4e4a:	ldr	r3, [r5, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4e4c:	cmp	r2, #0
    4e4e:	bne.w	491e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x286>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4e52:	cmp	r3, #0
    4e54:	beq.w	5000 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x968>
    4e58:	ldr	r0, [r4, #0]
        write_length_ += len;
    4e5a:	adds	r3, #4
        
        const char * src=data;
    4e5c:	add.w	r9, sp, #56	; 0x38
        //
        int pos = 0; // into data
    4e60:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4e64:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4e68:	str	r3, [r5, #4]
    4e6a:	b.n	4e74 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x7dc>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4e6c:	cmp.w	r8, #3
    4e70:	bgt.n	4eac <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x814>
    4e72:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4e74:	subs	r7, r6, r0
    4e76:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    4e7a:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4e7c:	cmp	r7, r3
    4e7e:	it	ge
    4e80:	movge	r7, r3
          memcpy(dst,src,to_copy);
    4e82:	mov	r2, r7
          pos += to_copy;
    4e84:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4e86:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4e8a:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4e8c:	add	r9, r7
          dst += to_copy;
    4e8e:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4e90:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4e92:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4e94:	bne.n	4e6c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x7d4>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4e96:	movs	r2, #60	; 0x3c
    4e98:	mov.w	r1, #512	; 0x200
    4e9c:	mov	r0, sl
    4e9e:	bl	9d50 <usb_mtp_send>
    4ea2:	cmp	r0, #0
    4ea4:	ble.n	4e96 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x7fe>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4ea6:	str.w	sl, [r4]
    4eaa:	b.n	4e6c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x7d4>
    4eac:	movs	r3, #1
    4eae:	ldrb	r2, [r5, #0]
    4eb0:	str	r3, [sp, #64]	; 0x40
    4eb2:	ldr	r3, [r5, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4eb4:	cmp	r2, #0
    4eb6:	bne.w	4920 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x288>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4eba:	cmp	r3, #0
    4ebc:	beq.w	4ff6 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x95e>
    4ec0:	ldr	r0, [r4, #0]
        write_length_ += len;
    4ec2:	adds	r3, #4
        
        const char * src=data;
    4ec4:	add.w	r9, sp, #64	; 0x40
        //
        int pos = 0; // into data
    4ec8:	mov.w	r8, #0
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4ecc:	add.w	sl, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4ed0:	str	r3, [r5, #4]
    4ed2:	b.n	4edc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x844>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4ed4:	cmp.w	r8, #3
    4ed8:	bgt.n	4f14 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x87c>
    4eda:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4edc:	subs	r7, r6, r0
    4ede:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    4ee2:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4ee4:	cmp	r7, r3
    4ee6:	it	ge
    4ee8:	movge	r7, r3
          memcpy(dst,src,to_copy);
    4eea:	mov	r2, r7
          pos += to_copy;
    4eec:	add	r8, r7
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4eee:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4ef2:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4ef4:	add	r9, r7
          dst += to_copy;
    4ef6:	add	r7, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4ef8:	cmp	r7, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4efa:	str	r7, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4efc:	bne.n	4ed4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x83c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4efe:	movs	r2, #60	; 0x3c
    4f00:	mov.w	r1, #512	; 0x200
    4f04:	mov	r0, sl
    4f06:	bl	9d50 <usb_mtp_send>
    4f0a:	cmp	r0, #0
    4f0c:	ble.n	4efe <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x866>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4f0e:	str.w	sl, [r4]
    4f12:	b.n	4ed4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x83c>
    4f14:	movs	r3, #0
    4f16:	ldrb	r2, [r5, #0]
    4f18:	str	r3, [sp, #68]	; 0x44
    4f1a:	ldr	r3, [r5, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    4f1c:	cmp	r2, #0
    4f1e:	bne.w	475c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4f22:	cmp	r3, #0
    4f24:	beq.n	4fec <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x954>
    4f26:	ldr	r0, [r4, #0]
        write_length_ += len;
    4f28:	adds	r3, #4
        
        const char * src=data;
    4f2a:	add.w	r8, sp, #68	; 0x44
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4f2e:	add.w	r9, r5, #544	; 0x220
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    4f32:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4f34:	str	r3, [r5, #4]
    4f36:	b.n	4f40 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a8>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    4f38:	cmp	r7, #3
    4f3a:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    4f3e:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4f40:	subs	r5, r6, r0
    4f42:	rsb	r3, r7, #4
          memcpy(dst,src,to_copy);
    4f46:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4f48:	cmp	r5, r3
    4f4a:	it	ge
    4f4c:	movge	r5, r3
          memcpy(dst,src,to_copy);
    4f4e:	mov	r2, r5
          pos += to_copy;
    4f50:	add	r7, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4f52:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4f56:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4f58:	add	r8, r5
          dst += to_copy;
    4f5a:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4f5c:	cmp	r5, r6
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4f5e:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4f60:	bne.n	4f38 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a0>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4f62:	movs	r2, #60	; 0x3c
    4f64:	mov.w	r1, #512	; 0x200
    4f68:	mov	r0, r9
    4f6a:	bl	9d50 <usb_mtp_send>
    4f6e:	cmp	r0, #0
    4f70:	ble.n	4f62 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8ca>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4f72:	str.w	r9, [r4]
    4f76:	b.n	4f38 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8a0>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4f78:	ldr	r3, [r5, #4]
    4f7a:	cmp	r3, #0
    4f7c:	beq.w	512a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa92>
    4f80:	ldr	r4, [pc, #88]	; (4fdc <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x944>)
    4f82:	ldr	r0, [r4, #0]
        write_length_ += len;
    4f84:	adds	r3, #1
        
        const char * src=data;
    4f86:	add	r6, sp, #16
    4f88:	add.w	r7, r5, #1056	; 0x420
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    4f8c:	add.w	r8, r5, #544	; 0x220
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    4f90:	str	r3, [r5, #4]
        
        const char * src=data;
        //
        int pos = 0; // into data
    4f92:	mov.w	r9, #0
    4f96:	b.n	4fa2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x90a>
        while(pos<len)
    4f98:	cmp.w	r9, #0
    4f9c:	bgt.w	4760 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xc8>
    4fa0:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4fa2:	subs	r5, r7, r0
    4fa4:	rsb	r3, r9, #1
          memcpy(dst,src,to_copy);
    4fa8:	mov	r1, r6
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    4faa:	cmp	r5, r3
    4fac:	it	ge
    4fae:	movge	r5, r3
          memcpy(dst,src,to_copy);
    4fb0:	mov	r2, r5
          pos += to_copy;
    4fb2:	add	r9, r5
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    4fb4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4fb8:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    4fba:	add	r6, r5
          dst += to_copy;
    4fbc:	add	r5, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4fbe:	cmp	r5, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    4fc0:	str	r5, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    4fc2:	bne.n	4f98 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x900>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    4fc4:	movs	r2, #60	; 0x3c
    4fc6:	mov.w	r1, #512	; 0x200
    4fca:	mov	r0, r8
    4fcc:	bl	9d50 <usb_mtp_send>
    4fd0:	cmp	r0, #0
    4fd2:	ble.n	4fc4 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x92c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    4fd4:	str.w	r8, [r4]
    4fd8:	b.n	4f98 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x900>
    4fda:	nop
    4fdc:	.word	0x2000158c
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    4fe0:	add.w	r2, r5, #544	; 0x220
    4fe4:	ldr	r4, [pc, #396]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    4fe6:	mov	r0, r2
    4fe8:	str	r2, [r4, #0]
    4fea:	b.n	4bf8 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x560>
    4fec:	add.w	r2, r5, #544	; 0x220
    4ff0:	mov	r0, r2
    4ff2:	str	r2, [r4, #0]
    4ff4:	b.n	4f28 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x890>
    4ff6:	add.w	r2, r5, #544	; 0x220
    4ffa:	mov	r0, r2
    4ffc:	str	r2, [r4, #0]
    4ffe:	b.n	4ec2 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x82a>
    5000:	add.w	r2, r5, #544	; 0x220
    5004:	mov	r0, r2
    5006:	str	r2, [r4, #0]
    5008:	b.n	4e5a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x7c2>
    500a:	add.w	r2, r5, #544	; 0x220
    500e:	ldr	r4, [pc, #356]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    5010:	mov	r0, r2
    5012:	str	r2, [r4, #0]
    5014:	b.n	4dec <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x754>
    5016:	cmp	r3, #0
    5018:	beq.w	5144 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xaac>
    501c:	ldr	r4, [pc, #340]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    501e:	ldr	r0, [r4, #0]
        write_length_ += len;
    5020:	adds	r3, #1
        
        const char * src=data;
    5022:	add.w	r8, sp, #15
    5026:	add.w	r9, r5, #1056	; 0x420
        //
        int pos = 0; // into data
    502a:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    502c:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    502e:	add.w	sl, r5, #544	; 0x220
    5032:	b.n	503c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x9a4>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    5034:	cmp	r7, #0
    5036:	bgt.w	4b72 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x4da>
    503a:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    503c:	rsb	r6, r0, r9
    5040:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    5044:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5046:	cmp	r6, r3
    5048:	it	ge
    504a:	movge	r6, r3
          memcpy(dst,src,to_copy);
    504c:	mov	r2, r6
          pos += to_copy;
    504e:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    5050:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5054:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5056:	add	r8, r6
          dst += to_copy;
    5058:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    505a:	cmp	r6, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    505c:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    505e:	bne.n	5034 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x99c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5060:	movs	r2, #60	; 0x3c
    5062:	mov.w	r1, #512	; 0x200
    5066:	mov	r0, sl
    5068:	bl	9d50 <usb_mtp_send>
    506c:	cmp	r0, #0
    506e:	ble.n	5060 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x9c8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    5070:	str.w	sl, [r4]
    5074:	b.n	5034 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x99c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5076:	cmp	r3, #0
    5078:	beq.n	515c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xac4>
    507a:	ldr	r4, [pc, #248]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    507c:	ldr	r0, [r4, #0]
        write_length_ += len;
    507e:	adds	r3, #1
        
        const char * src=data;
    5080:	add.w	r8, sp, #19
    5084:	add.w	r9, r5, #1056	; 0x420
        //
        int pos = 0; // into data
    5088:	movs	r7, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    508a:	str	r3, [r5, #4]
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
    508c:	add.w	sl, r5, #544	; 0x220
    5090:	b.n	509a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa02>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    5092:	cmp	r7, #0
    5094:	bgt.w	4afa <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x462>
    5098:	ldr	r0, [r4, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    509a:	rsb	r6, r0, r9
    509e:	rsb	r3, r7, #1
          memcpy(dst,src,to_copy);
    50a2:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    50a4:	cmp	r6, r3
    50a6:	it	ge
    50a8:	movge	r6, r3
          memcpy(dst,src,to_copy);
    50aa:	mov	r2, r6
          pos += to_copy;
    50ac:	add	r7, r6
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    50ae:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    50b2:	ldr	r3, [r4, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    50b4:	add	r8, r6
          dst += to_copy;
    50b6:	add	r6, r3
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    50b8:	cmp	r6, r9
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    50ba:	str	r6, [r4, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    50bc:	bne.n	5092 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x9fa>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    50be:	movs	r2, #60	; 0x3c
    50c0:	mov.w	r1, #512	; 0x200
    50c4:	mov	r0, sl
    50c6:	bl	9d50 <usb_mtp_send>
    50ca:	cmp	r0, #0
    50cc:	ble.n	50be <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xa26>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    50ce:	str.w	sl, [r4]
    50d2:	b.n	5092 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x9fa>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    50d4:	add.w	r2, r5, #544	; 0x220
    50d8:	ldr	r4, [pc, #152]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    50da:	mov	r0, r2
    50dc:	str	r2, [r4, #0]
    50de:	b.n	4d8a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x6f2>
    50e0:	add.w	r2, r5, #544	; 0x220
    50e4:	ldr	r4, [pc, #140]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    50e6:	mov	r0, r2
    50e8:	str	r2, [r4, #0]
    50ea:	b.n	4d28 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x690>
    50ec:	add.w	r2, r5, #544	; 0x220
    50f0:	ldr	r4, [pc, #128]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    50f2:	mov	r0, r2
    50f4:	str	r2, [r4, #0]
    50f6:	b.n	4cc6 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x62e>
    50f8:	add.w	r2, r5, #544	; 0x220
    50fc:	mov	r0, r2
    50fe:	str	r2, [r4, #0]
    5100:	b.n	4c6a <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x5d2>
    5102:	add.w	r2, r5, #544	; 0x220
    5106:	ldr	r4, [pc, #108]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    5108:	mov	r0, r2
    510a:	str	r2, [r4, #0]
    510c:	b.w	48ba <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x222>
    5110:	add.w	r2, r5, #544	; 0x220
    5114:	ldr	r4, [pc, #92]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    5116:	mov	r0, r2
    5118:	str	r2, [r4, #0]
    511a:	b.n	4960 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x2c8>
    511c:	add.w	r2, r5, #544	; 0x220
    5120:	ldr	r4, [pc, #80]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    5122:	mov	r0, r2
    5124:	str	r2, [r4, #0]
    5126:	b.w	4788 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xf0>
    512a:	add.w	r2, r5, #544	; 0x220
    512e:	ldr	r4, [pc, #68]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    5130:	mov	r0, r2
    5132:	str	r2, [r4, #0]
    5134:	b.n	4f84 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x8ec>
    5136:	add.w	r2, r5, #544	; 0x220
    513a:	ldr	r4, [pc, #56]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    513c:	mov	r0, r2
    513e:	str	r2, [r4, #0]
    5140:	b.w	4848 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x1b0>
    5144:	add.w	r2, r5, #544	; 0x220
    5148:	ldr	r4, [pc, #40]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    514a:	mov	r0, r2
    514c:	str	r2, [r4, #0]
    514e:	b.n	5020 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x988>
    5150:	add.w	r2, r5, #544	; 0x220
    5154:	ldr	r4, [pc, #28]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    5156:	mov	r0, r2
    5158:	str	r2, [r4, #0]
    515a:	b.n	4b96 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x4fe>
    515c:	add.w	r2, r5, #544	; 0x220
    5160:	ldr	r4, [pc, #16]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    5162:	mov	r0, r2
    5164:	str	r2, [r4, #0]
    5166:	b.n	507e <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x9e6>
    5168:	add.w	r2, r5, #544	; 0x220
    516c:	ldr	r4, [pc, #4]	; (5174 <MTPD::getObjectPropValue(unsigned long, unsigned long)+0xadc>)
    516e:	mov	r0, r2
    5170:	str	r2, [r4, #0]
    5172:	b.n	4b1c <MTPD::getObjectPropValue(unsigned long, unsigned long)+0x484>
    5174:	.word	0x2000158c

00005178 <loop>:
}

#include "mtp_t4.h"
MTPD    mtpd;

extern "C" void loop() {
    5178:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    517c:	sub	sp, #108	; 0x6c
    }
*/

public:
    void loop(void)
    { if(!usb_mtp_available()) return;
    517e:	bl	9e1c <usb_mtp_available>
    5182:	cbnz	r0, 518a <loop+0x12>
  mtpd.loop();
  // put your main code here, to run repeatedly:
}
    5184:	add	sp, #108	; 0x6c
    5186:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      return usb_mtp_recv(data_buffer,60);
    }

    int fetch_packet(uint8_t *data_buffer)
    {
      return usb_mtp_recv(data_buffer,60);
    518a:	ldr	r4, [pc, #768]	; (548c <loop+0x314>)
    518c:	movs	r1, #60	; 0x3c
    518e:	add.w	r0, r4, #32
    5192:	bl	9ca0 <usb_mtp_recv>
*/

public:
    void loop(void)
    { if(!usb_mtp_available()) return;
      if(fetch_packet(rx_data_buffer))
    5196:	cmp	r0, #0
    5198:	beq.n	5184 <loop+0xc>
      { printContainer(); // to switch on set debug to 1 at beginning of file
    519a:	ldr	r0, [r4, #40]	; 0x28
    519c:	ldrh	r1, [r4, #36]	; 0x24
    519e:	ldr	r3, [r4, #32]
    51a0:	str	r0, [sp, #4]
    51a2:	str	r1, [sp, #0]
    51a4:	ldrh	r2, [r4, #38]	; 0x26
    51a6:	ldr	r1, [pc, #744]	; (5490 <loop+0x318>)
    51a8:	ldr	r0, [pc, #744]	; (5494 <loop+0x31c>)
    51aa:	bl	a028 <Print::printf(char const*, ...)>
    51ae:	ldr	r3, [r4, #32]
    51b0:	cmp	r3, #12
    51b2:	bhi.w	5410 <loop+0x298>
    51b6:	ldr	r1, [pc, #736]	; (5498 <loop+0x320>)
    51b8:	ldr	r0, [pc, #728]	; (5494 <loop+0x31c>)
    51ba:	bl	a028 <Print::printf(char const*, ...)>
        int typ= CONTAINER->type;
        //TID=id;

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds
    51be:	ldrh.w	r9, [r4, #36]	; 0x24
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        //TID=id;

        int return_code =0x2001; //OK use as default value
    51c2:	movw	r1, #8197	; 0x2005
    51c6:	movw	r2, #8193	; 0x2001
    void loop(void)
    { if(!usb_mtp_available()) return;
      if(fetch_packet(rx_data_buffer))
      { printContainer(); // to switch on set debug to 1 at beginning of file

        int op = CONTAINER->op;
    51ca:	ldrh	r3, [r4, #38]	; 0x26

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    51cc:	movw	r0, #4108	; 0x100c
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        //TID=id;

        int return_code =0x2001; //OK use as default value
    51d0:	cmp.w	r9, #2
    51d4:	ite	eq
    51d6:	moveq	r5, r1
    51d8:	movne	r5, r2
      { printContainer(); // to switch on set debug to 1 at beginning of file

        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
    51da:	ldr.w	r8, [r4, #52]	; 0x34

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    51de:	cmp	r3, r0
      if(fetch_packet(rx_data_buffer))
      { printContainer(); // to switch on set debug to 1 at beginning of file

        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
        int p2 = CONTAINER->params[1];
    51e0:	ldr.w	r9, [r4, #48]	; 0x30
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
        int typ= CONTAINER->type;
        //TID=id;

        int return_code =0x2001; //OK use as default value
    51e4:	str	r5, [sp, #16]
    { if(!usb_mtp_available()) return;
      if(fetch_packet(rx_data_buffer))
      { printContainer(); // to switch on set debug to 1 at beginning of file

        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
    51e6:	ldr	r5, [r4, #44]	; 0x2c
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
        int id = CONTAINER->transaction_id;
        int len= CONTAINER->len;
    51e8:	ldr	r6, [r4, #32]
    { if(!usb_mtp_available()) return;
      if(fetch_packet(rx_data_buffer))
      { printContainer(); // to switch on set debug to 1 at beginning of file

        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
    51ea:	str	r5, [sp, #8]
        int p2 = CONTAINER->params[1];
        int p3 = CONTAINER->params[2];
        int id = CONTAINER->transaction_id;
    51ec:	ldr	r5, [r4, #40]	; 0x28
    51ee:	str	r5, [sp, #12]

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    51f0:	beq.w	587e <loop+0x706>
    51f4:	bhi.n	5236 <loop+0xbe>
    51f6:	movw	r2, #4101	; 0x1005
    51fa:	cmp	r3, r2
    51fc:	beq.w	5896 <loop+0x71e>
    5200:	bls.w	535e <loop+0x1e6>
    5204:	movw	r2, #4104	; 0x1008
    5208:	cmp	r3, r2
    520a:	beq.w	597e <loop+0x806>
    520e:	bhi.w	545c <loop+0x2e4>
    5212:	movw	r2, #4102	; 0x1006
    5216:	cmp	r3, r2
    5218:	beq.w	5958 <loop+0x7e0>
    521c:	movw	r2, #4103	; 0x1007
    5220:	cmp	r3, r2
    5222:	bne.w	586c <loop+0x6f4>
                p1 = GetNumObjects(p1, p3);
            }
            break;

          case 0x1007:  // GetObjectHandles
            if (p2) 
    5226:	cmp.w	r9, #0
    522a:	beq.w	5f48 <loop+0xdd0>
    522e:	ldr	r5, [sp, #8]
    5230:	movw	r9, #8212	; 0x2014
    5234:	b.n	5268 <loop+0xf0>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    5236:	movw	r0, #4122	; 0x101a
    523a:	cmp	r3, r0
    523c:	beq.w	5950 <loop+0x7d8>
    5240:	bhi.n	5298 <loop+0x120>
    5242:	movw	r2, #4116	; 0x1014
    5246:	cmp	r3, r2
    5248:	beq.w	55ea <loop+0x472>
    524c:	bhi.w	5440 <loop+0x2c8>
    5250:	movw	r2, #4109	; 0x100d
    5254:	cmp	r3, r2
    5256:	beq.w	5874 <loop+0x6fc>
    525a:	movw	r2, #4112	; 0x1010
    525e:	cmp	r3, r2
    5260:	bne.w	586c <loop+0x6f4>
    5264:	ldr	r5, [sp, #8]
    5266:	mov	r9, r1
            CONTAINER->params[0]=p1;
            #if DEBUG >1
              printContainer(); // to switch on set debug to 2 at beginning of file
            #endif

            memcpy(tx_data_buffer,rx_data_buffer,len);
    5268:	ldr	r1, [pc, #560]	; (549c <loop+0x324>)
              return_code = 0x2005;  // operation not supported
              break;
        }
        if(return_code)
        {
            CONTAINER->type=3;
    526a:	movs	r3, #3
            CONTAINER->len=len;
            CONTAINER->op=return_code;
            CONTAINER->transaction_id=id;
    526c:	ldr	r7, [sp, #12]
            CONTAINER->params[0]=p1;
            #if DEBUG >1
              printContainer(); // to switch on set debug to 2 at beginning of file
            #endif

            memcpy(tx_data_buffer,rx_data_buffer,len);
    526e:	mov	r2, r6
    5270:	add.w	r0, r1, #512	; 0x200
              break;
        }
        if(return_code)
        {
            CONTAINER->type=3;
            CONTAINER->len=len;
    5274:	str	r6, [r4, #32]
            CONTAINER->op=return_code;
    5276:	strh.w	r9, [r4, #38]	; 0x26
            CONTAINER->transaction_id=id;
    527a:	str	r7, [r4, #40]	; 0x28
            CONTAINER->params[0]=p1;
    527c:	str	r5, [r4, #44]	; 0x2c
              return_code = 0x2005;  // operation not supported
              break;
        }
        if(return_code)
        {
            CONTAINER->type=3;
    527e:	strh	r3, [r4, #36]	; 0x24
            CONTAINER->params[0]=p1;
            #if DEBUG >1
              printContainer(); // to switch on set debug to 2 at beginning of file
            #endif

            memcpy(tx_data_buffer,rx_data_buffer,len);
    5280:	bl	7f58 <memcpy>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5284:	movs	r2, #60	; 0x3c
    5286:	mov	r1, r6
    5288:	ldr	r0, [pc, #532]	; (54a0 <loop+0x328>)
    528a:	bl	9d50 <usb_mtp_send>
    528e:	cmp	r0, #0
    5290:	ble.n	5284 <loop+0x10c>
    5292:	add	sp, #108	; 0x6c
    5294:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    5298:	movw	r2, #38914	; 0x9802
    529c:	cmp	r3, r2
    529e:	beq.w	5776 <loop+0x5fe>
    52a2:	bhi.w	54b8 <loop+0x340>
    52a6:	movw	r2, #4123	; 0x101b
    52aa:	cmp	r3, r2
    52ac:	beq.w	5408 <loop+0x290>
    52b0:	movw	r2, #38913	; 0x9801
    52b4:	cmp	r3, r2
    52b6:	bne.w	586c <loop+0x6f4>
  }

    void getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    52ba:	ldr	r1, [pc, #488]	; (54a4 <loop+0x32c>)
          case 0x101B:  // GetPartialObject
//              TRANSMIT1(GetPartialObject(p1,p2,p3));
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    52bc:	movs	r2, #1
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    52be:	movs	r3, #4
    52c0:	ldr	r7, [pc, #484]	; (54a8 <loop+0x330>)
  }

    void getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    52c2:	ldr	r1, [r1, #0]
          case 0x101B:  // GetPartialObject
//              TRANSMIT1(GetPartialObject(p1,p2,p3));
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    52c4:	strb	r2, [r4, #0]
  }

    void getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    52c6:	cmp	r1, #0
    52c8:	beq.w	637e <loop+0x1206>
    52cc:	ldr	r1, [pc, #476]	; (54ac <loop+0x334>)
    52ce:	movs	r0, #0
    52d0:	mov	sl, r7
    52d2:	ldr	r5, [pc, #476]	; (54b0 <loop+0x338>)
    52d4:	str	r1, [sp, #24]
    52d6:	sub.w	r1, r7, #512	; 0x200
    52da:	str	r6, [sp, #28]
    52dc:	mov	r9, r0
    52de:	str	r1, [sp, #20]
    52e0:	movw	r1, #56321	; 0xdc01
    52e4:	b.n	5300 <loop+0x188>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    52e6:	adds	r3, #2
  }

    void getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    52e8:	ldr	r2, [pc, #440]	; (54a4 <loop+0x32c>)
    52ea:	add.w	r9, r9, #1
    52ee:	ldr	r2, [r2, #0]
    52f0:	cmp	r2, r9
    52f2:	bls.w	5c0a <loop+0xa92>
    52f6:	ldr	r2, [sp, #24]
    52f8:	ldrh.w	r1, [r2, #2]!
    52fc:	str	r2, [sp, #24]
    52fe:	ldrb	r2, [r4, #0]
    5300:	strh.w	r1, [sp, #70]	; 0x46
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5304:	cmp	r2, #0
    5306:	bne.n	52e6 <loop+0x16e>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5308:	cmp	r3, #0
    530a:	beq.w	5b26 <loop+0x9ae>
    530e:	ldr	r0, [r5, #0]
        write_length_ += len;
    5310:	adds	r3, #2
        
        const char * src=data;
    5312:	add.w	r8, sp, #70	; 0x46
        //
        int pos = 0; // into data
    5316:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5318:	str	r3, [r4, #4]
    531a:	b.n	5324 <loop+0x1ac>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    531c:	cmp	r6, #1
    531e:	bgt.w	5486 <loop+0x30e>
    5322:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5324:	rsb	fp, r0, sl
    5328:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
    532c:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    532e:	cmp	fp, r3
    5330:	it	ge
    5332:	movge	fp, r3
          memcpy(dst,src,to_copy);
    5334:	mov	r2, fp
          pos += to_copy;
    5336:	add	r6, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    5338:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    533c:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    533e:	add	r8, fp
          dst += to_copy;
    5340:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5342:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5344:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5346:	bne.n	531c <loop+0x1a4>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5348:	movs	r2, #60	; 0x3c
    534a:	mov.w	r1, #512	; 0x200
    534e:	ldr	r0, [pc, #336]	; (54a0 <loop+0x328>)
    5350:	bl	9d50 <usb_mtp_send>
    5354:	cmp	r0, #0
    5356:	ble.n	5348 <loop+0x1d0>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    5358:	ldr	r3, [sp, #20]
    535a:	str	r3, [r5, #0]
    535c:	b.n	531c <loop+0x1a4>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    535e:	movw	r2, #4098	; 0x1002
    5362:	cmp	r3, r2
    5364:	beq.w	5888 <loop+0x710>
    5368:	bls.w	5552 <loop+0x3da>
    536c:	movw	r2, #4099	; 0x1003
    5370:	cmp	r3, r2
    5372:	beq.n	5408 <loop+0x290>
    5374:	movw	r2, #4100	; 0x1004
    5378:	cmp	r3, r2
    537a:	bne.w	586c <loop+0x6f4>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    537e:	ldr	r2, [pc, #288]	; (54a0 <loop+0x328>)

          case 0x1003:  // CloseSession
            break;

          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    5380:	mov.w	r9, #20
    5384:	movs	r1, #0
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5386:	ldr	r5, [pc, #296]	; (54b0 <loop+0x338>)

          case 0x1003:  // CloseSession
            break;

          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    5388:	mov.w	ip, #2
    538c:	add.w	r7, r2, #512	; 0x200
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5390:	mov.w	lr, #12

          case 0x1003:  // CloseSession
            break;

          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    5394:	strh.w	r3, [sp, #98]	; 0x62
    5398:	ldr	r3, [sp, #12]
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    539a:	mov	r0, r2

          case 0x1003:  // CloseSession
            break;

          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    539c:	str.w	r9, [sp, #92]	; 0x5c
    53a0:	mov	r8, r7
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    53a2:	str	r2, [sp, #20]
        
        const char * src=data;
        //
        int pos = 0; // into data
    53a4:	mov	r9, r1

          case 0x1003:  // CloseSession
            break;

          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    53a6:	str	r3, [sp, #100]	; 0x64
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    53a8:	add.w	sl, sp, #92	; 0x5c
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    53ac:	str	r2, [r5, #0]

          case 0x1003:  // CloseSession
            break;

          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    53ae:	strh.w	ip, [sp, #96]	; 0x60
    53b2:	strb	r1, [r4, #0]
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    53b4:	str.w	lr, [r4, #4]
    53b8:	b.n	53c4 <loop+0x24c>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    53ba:	cmp.w	r9, #11
    53be:	bgt.w	5bd4 <loop+0xa5c>
    53c2:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    53c4:	rsb	fp, r0, r8
    53c8:	rsb	r3, r9, #12
          memcpy(dst,src,to_copy);
    53cc:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    53ce:	cmp	fp, r3
    53d0:	it	ge
    53d2:	movge	fp, r3
          memcpy(dst,src,to_copy);
    53d4:	mov	r2, fp
          pos += to_copy;
    53d6:	add	r9, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    53d8:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    53dc:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    53de:	add	sl, fp
          dst += to_copy;
    53e0:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    53e2:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    53e4:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    53e6:	bne.n	53ba <loop+0x242>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    53e8:	movs	r2, #60	; 0x3c
    53ea:	mov.w	r1, #512	; 0x200
    53ee:	ldr	r0, [pc, #176]	; (54a0 <loop+0x328>)
    53f0:	bl	9d50 <usb_mtp_send>
    53f4:	cmp	r0, #0
    53f6:	ble.n	53e8 <loop+0x270>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    53f8:	ldr	r3, [pc, #164]	; (54a0 <loop+0x328>)
    53fa:	str	r3, [r5, #0]
    53fc:	b.n	53ba <loop+0x242>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    53fe:	movw	r2, #38916	; 0x9804
    5402:	cmp	r3, r2
    5404:	bne.w	586c <loop+0x6f4>
    5408:	ldrh.w	r9, [sp, #16]
    540c:	ldr	r5, [sp, #8]
    540e:	b.n	5268 <loop+0xf0>

public:
    void loop(void)
    { if(!usb_mtp_available()) return;
      if(fetch_packet(rx_data_buffer))
      { printContainer(); // to switch on set debug to 1 at beginning of file
    5410:	ldr	r2, [r4, #44]	; 0x2c
    5412:	ldr	r1, [pc, #160]	; (54b4 <loop+0x33c>)
    5414:	ldr	r0, [pc, #124]	; (5494 <loop+0x31c>)
    5416:	bl	a028 <Print::printf(char const*, ...)>
    541a:	ldr	r3, [r4, #32]
    541c:	cmp	r3, #16
    541e:	bls.w	51b6 <loop+0x3e>
    5422:	ldr	r2, [r4, #48]	; 0x30
    5424:	ldr	r1, [pc, #140]	; (54b4 <loop+0x33c>)
    5426:	ldr	r0, [pc, #108]	; (5494 <loop+0x31c>)
    5428:	bl	a028 <Print::printf(char const*, ...)>
    542c:	ldr	r3, [r4, #32]
    542e:	cmp	r3, #20
    5430:	bls.w	51b6 <loop+0x3e>
    5434:	ldr	r2, [r4, #52]	; 0x34
    5436:	ldr	r1, [pc, #124]	; (54b4 <loop+0x33c>)
    5438:	ldr	r0, [pc, #88]	; (5494 <loop+0x31c>)
    543a:	bl	a028 <Print::printf(char const*, ...)>
    543e:	b.n	51b6 <loop+0x3e>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    5440:	movw	r2, #4117	; 0x1015
    5444:	cmp	r3, r2
    5446:	beq.w	5a32 <loop+0x8ba>
    544a:	movw	r2, #4121	; 0x1019
    544e:	cmp	r3, r2
    5450:	bne.w	586c <loop+0x6f4>
    5454:	ldr	r5, [sp, #8]
    5456:	mov	r9, r1
    5458:	movs	r6, #12
    545a:	b.n	5268 <loop+0xf0>
    545c:	movw	r2, #4105	; 0x1009
    5460:	cmp	r3, r2
    5462:	beq.w	56a8 <loop+0x530>
    5466:	movw	r2, #4107	; 0x100b
    546a:	cmp	r3, r2
    546c:	bne.w	586c <loop+0x6f4>
          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
            break;

          case 0x100B:  // DeleteObject
              if (p2) {
    5470:	movw	r3, #8210	; 0x2012
    5474:	movw	r2, #8212	; 0x2014
    5478:	ldr	r5, [sp, #8]
    547a:	cmp.w	r9, #0
    547e:	ite	eq
    5480:	moveq	r9, r3
    5482:	movne	r9, r2
    5484:	b.n	5268 <loop+0xf0>
    5486:	ldr	r3, [r4, #4]
    5488:	b.n	52e8 <loop+0x170>
    548a:	nop
    548c:	.word	0x20006060
    5490:	.word	0x200001cc
    5494:	.word	0x20000bac
    5498:	.word	0x200001e0
    549c:	.word	0x20006080
    54a0:	.word	0x20006280
    54a4:	.word	0x20000b74
    54a8:	.word	0x20006480
    54ac:	.word	0x20000018
    54b0:	.word	0x2000158c
    54b4:	.word	0x200001dc

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    54b8:	movw	r2, #38915	; 0x9803
    54bc:	cmp	r3, r2
    54be:	bne.n	53fe <loop+0x286>
          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
              TRANSMIT(getObjectPropValue(p1,p2));
    54c0:	mov.w	fp, #0
    54c4:	movs	r3, #1
    54c6:	mov	r2, r9
    54c8:	ldr	r1, [sp, #8]
    54ca:	ldr	r0, [pc, #760]	; (57c4 <loop+0x64c>)
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    54cc:	mov	r8, fp
          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
              TRANSMIT(getObjectPropValue(p1,p2));
    54ce:	strb	r3, [r4, #0]
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    54d0:	add.w	sl, sp, #92	; 0x5c
          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
              TRANSMIT(getObjectPropValue(p1,p2));
    54d4:	str.w	fp, [r4, #4]
    54d8:	bl	4698 <MTPD::getObjectPropValue(unsigned long, unsigned long)>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    54dc:	ldr	r5, [pc, #744]	; (57c8 <loop+0x650>)
        write_length_ += len;
    54de:	movs	r2, #12
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    54e0:	ldr	r3, [pc, #744]	; (57cc <loop+0x654>)
          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
              TRANSMIT(getObjectPropValue(p1,p2));
    54e2:	mov.w	lr, #2
    54e6:	ldr	r1, [r4, #4]
    54e8:	add.w	r7, r3, #512	; 0x200
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    54ec:	mov	r0, r3
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    54ee:	str	r3, [r5, #0]
          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
              TRANSMIT(getObjectPropValue(p1,p2));
    54f0:	add	r1, r2
    54f2:	ldrh	r3, [r4, #38]	; 0x26
    54f4:	str	r1, [sp, #20]
    54f6:	strh.w	r3, [sp, #98]	; 0x62
    54fa:	ldr	r3, [r4, #40]	; 0x28
    54fc:	strb.w	fp, [r4]
    5500:	str	r1, [sp, #92]	; 0x5c
    5502:	strh.w	lr, [sp, #96]	; 0x60
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5506:	str	r2, [r4, #4]
          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
              TRANSMIT(getObjectPropValue(p1,p2));
    5508:	str	r3, [sp, #100]	; 0x64
    550a:	b.n	5516 <loop+0x39e>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    550c:	cmp.w	r8, #11
    5510:	bgt.w	5846 <loop+0x6ce>
    5514:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5516:	ldr	r3, [pc, #696]	; (57d0 <loop+0x658>)
          memcpy(dst,src,to_copy);
    5518:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    551a:	rsb	fp, r0, r3
    551e:	rsb	r3, r8, #12
    5522:	cmp	fp, r3
    5524:	it	ge
    5526:	movge	fp, r3
          memcpy(dst,src,to_copy);
    5528:	mov	r2, fp
          pos += to_copy;
    552a:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    552c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5530:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5532:	add	sl, fp
          dst += to_copy;
    5534:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5536:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5538:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    553a:	bne.n	550c <loop+0x394>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    553c:	movs	r2, #60	; 0x3c
    553e:	mov.w	r1, #512	; 0x200
    5542:	ldr	r0, [pc, #648]	; (57cc <loop+0x654>)
    5544:	bl	9d50 <usb_mtp_send>
    5548:	cmp	r0, #0
    554a:	ble.n	553c <loop+0x3c4>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    554c:	ldr	r3, [pc, #636]	; (57cc <loop+0x654>)
    554e:	str	r3, [r5, #0]
    5550:	b.n	550c <loop+0x394>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    5552:	movw	r2, #4097	; 0x1001
    5556:	cmp	r3, r2
    5558:	bne.w	586c <loop+0x6f4>
        {
          case 0x1001:
            TRANSMIT(WriteDescriptor());
    555c:	mov.w	fp, #0
    5560:	movs	r3, #1
    5562:	ldr	r0, [pc, #608]	; (57c4 <loop+0x64c>)
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    5564:	add.w	r9, sp, #92	; 0x5c
        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
        {
          case 0x1001:
            TRANSMIT(WriteDescriptor());
    5568:	str.w	fp, [r4, #4]
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    556c:	mov	r8, fp
        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
        {
          case 0x1001:
            TRANSMIT(WriteDescriptor());
    556e:	strb	r3, [r4, #0]
    5570:	bl	71c <MTPD::WriteDescriptor()>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5574:	ldr	r5, [pc, #592]	; (57c8 <loop+0x650>)
        write_length_ += len;
    5576:	movs	r2, #12
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5578:	ldr	r3, [pc, #592]	; (57cc <loop+0x654>)
        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
        {
          case 0x1001:
            TRANSMIT(WriteDescriptor());
    557a:	mov.w	lr, #2
    557e:	ldr	r1, [r4, #4]
    5580:	add.w	r7, r3, #512	; 0x200
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5584:	mov	r0, r3
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5586:	str	r3, [r5, #0]
        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
        {
          case 0x1001:
            TRANSMIT(WriteDescriptor());
    5588:	add	r1, r2
    558a:	ldrh	r3, [r4, #38]	; 0x26
    558c:	strb.w	fp, [r4]
    5590:	mov	fp, r7
    5592:	strh.w	r3, [sp, #98]	; 0x62
    5596:	ldr	r3, [r4, #40]	; 0x28
    5598:	str	r1, [sp, #20]
    559a:	str	r1, [sp, #92]	; 0x5c
    559c:	strh.w	lr, [sp, #96]	; 0x60
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    55a0:	str	r2, [r4, #4]
        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
        {
          case 0x1001:
            TRANSMIT(WriteDescriptor());
    55a2:	str	r3, [sp, #100]	; 0x64
    55a4:	b.n	55b0 <loop+0x438>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    55a6:	cmp.w	r8, #11
    55aa:	bgt.w	5754 <loop+0x5dc>
    55ae:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    55b0:	rsb	sl, r0, fp
    55b4:	rsb	r3, r8, #12
          memcpy(dst,src,to_copy);
    55b8:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    55ba:	cmp	sl, r3
    55bc:	it	ge
    55be:	movge	sl, r3
          memcpy(dst,src,to_copy);
    55c0:	mov	r2, sl
          pos += to_copy;
    55c2:	add	r8, sl
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    55c4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    55c8:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    55ca:	add	r9, sl
          dst += to_copy;
    55cc:	add	r3, sl
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    55ce:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    55d0:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    55d2:	bne.n	55a6 <loop+0x42e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    55d4:	movs	r2, #60	; 0x3c
    55d6:	mov.w	r1, #512	; 0x200
    55da:	ldr	r0, [pc, #496]	; (57cc <loop+0x654>)
    55dc:	bl	9d50 <usb_mtp_send>
    55e0:	cmp	r0, #0
    55e2:	ble.n	55d4 <loop+0x45c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    55e4:	ldr	r3, [pc, #484]	; (57cc <loop+0x654>)
    55e6:	str	r3, [r5, #0]
    55e8:	b.n	55a6 <loop+0x42e>
        break;
    }
  }

  void GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    55ea:	movw	r2, #54274	; 0xd402
    55ee:	ldr	r1, [sp, #8]
//              if(!SendObject()) return_code = 0x2005;
              len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    55f0:	movs	r7, #1
    55f2:	ldr	r5, [pc, #464]	; (57c4 <loop+0x64c>)
        break;
    }
  }

  void GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    55f4:	cmp	r1, r2
//              if(!SendObject()) return_code = 0x2005;
              len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    55f6:	mov.w	r8, #0
    55fa:	strb	r7, [r4, #0]
        break;
    }
  }

  void GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    55fc:	bne.w	5efa <loop+0xd82>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    5600:	movs	r3, #5
  void GetDevicePropValue(uint32_t prop) {
    switch (prop) {
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    5602:	ldr	r1, [pc, #464]	; (57d4 <loop+0x65c>)
    5604:	mov	r0, r5
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    5606:	str	r3, [r5, #4]
  void GetDevicePropValue(uint32_t prop) {
    switch (prop) {
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    5608:	bl	4cc <MTPD::writestring(char const*)>
    560c:	ldr	r1, [pc, #452]	; (57d4 <loop+0x65c>)
    560e:	mov	r0, r5
    5610:	bl	4cc <MTPD::writestring(char const*)>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5614:	ldrb	r3, [r5, #0]
    5616:	strb.w	r8, [sp, #48]	; 0x30
    561a:	cmp	r3, #0
    561c:	beq.w	618e <loop+0x1016>
      {
        write_length_ += len;
    5620:	ldr	r2, [r5, #4]
    5622:	ldrh	r3, [r5, #38]	; 0x26
    5624:	adds	r2, #13
    5626:	ldr	r0, [r5, #40]	; 0x28
    5628:	str	r2, [sp, #24]
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    562a:	ldr	r2, [pc, #416]	; (57cc <loop+0x654>)
//              if(!SendObject()) return_code = 0x2005;
              len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    562c:	mov.w	r9, #0
    5630:	mov.w	ip, #2
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5634:	ldr	r5, [pc, #400]	; (57c8 <loop+0x650>)
    5636:	add.w	r7, r2, #512	; 0x200
        write_length_ += len;
    563a:	mov.w	lr, #12
//              if(!SendObject()) return_code = 0x2005;
              len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    563e:	ldr	r1, [sp, #24]
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    5640:	mov	r8, r9
//              if(!SendObject()) return_code = 0x2005;
              len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    5642:	str	r0, [sp, #100]	; 0x64
    5644:	mov	sl, r7
    5646:	strb.w	r9, [r4]
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    564a:	mov	r0, r2
    564c:	str	r2, [sp, #20]
        
        const char * src=data;
    564e:	add.w	r9, sp, #92	; 0x5c
//              if(!SendObject()) return_code = 0x2005;
              len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    5652:	str	r1, [sp, #92]	; 0x5c
    5654:	strh.w	r3, [sp, #98]	; 0x62
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5658:	str	r2, [r5, #0]
//              if(!SendObject()) return_code = 0x2005;
              len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    565a:	strh.w	ip, [sp, #96]	; 0x60
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    565e:	str.w	lr, [r4, #4]
    5662:	b.n	566e <loop+0x4f6>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    5664:	cmp.w	r8, #11
    5668:	bgt.w	5b34 <loop+0x9bc>
    566c:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    566e:	rsb	fp, r0, sl
    5672:	rsb	r3, r8, #12
          memcpy(dst,src,to_copy);
    5676:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5678:	cmp	fp, r3
    567a:	it	ge
    567c:	movge	fp, r3
          memcpy(dst,src,to_copy);
    567e:	mov	r2, fp
          pos += to_copy;
    5680:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    5682:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5686:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5688:	add	r9, fp
          dst += to_copy;
    568a:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    568c:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    568e:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5690:	bne.n	5664 <loop+0x4ec>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5692:	movs	r2, #60	; 0x3c
    5694:	mov.w	r1, #512	; 0x200
    5698:	ldr	r0, [pc, #304]	; (57cc <loop+0x654>)
    569a:	bl	9d50 <usb_mtp_send>
    569e:	cmp	r0, #0
    56a0:	ble.n	5692 <loop+0x51a>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    56a2:	ldr	r3, [pc, #296]	; (57cc <loop+0x654>)
    56a4:	str	r3, [r5, #0]
    56a6:	b.n	5664 <loop+0x4ec>
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    56a8:	movs	r3, #1
    56aa:	movs	r2, #0
    char * getName(uint32_t store) {return zFs[store].getName();}

    uint32_t Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    56ac:	ldr	r1, [sp, #8]
    56ae:	ldr	r0, [pc, #296]	; (57d8 <loop+0x660>)
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    56b0:	strb	r3, [r4, #0]
    56b2:	str	r2, [r4, #4]
    char * getName(uint32_t store) {return zFs[store].getName();}

    uint32_t Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    56b4:	bl	6dd8 <zeroFS_class::GetSize(unsigned long)>

    void GetObject(uint32_t object_id) 
    {
      uint32_t size = mFS.GetSize(object_id);

      if (write_get_length_) {
    56b8:	ldrb	r3, [r4, #0]
    char * getName(uint32_t store) {return zFs[store].getName();}

    uint32_t Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    56ba:	mov	fp, r0
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    56bc:	ldr	r7, [pc, #260]	; (57c4 <loop+0x64c>)

    void GetObject(uint32_t object_id) 
    {
      uint32_t size = mFS.GetSize(object_id);

      if (write_get_length_) {
    56be:	cmp	r3, #0
    56c0:	bne.w	5f04 <loop+0xd8c>
        uint32_t pos = 0; // into data
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;

        disk_pos=DISK_BUFFER_SIZE;
    56c4:	movw	r2, #9248	; 0x2420
    56c8:	mov.w	r1, #8192	; 0x2000
      } else 
      { 
        uint32_t pos = 0; // into data
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;
    56cc:	lsrs	r0, r0, #9

        disk_pos=DISK_BUFFER_SIZE;
    56ce:	str	r1, [r7, r2]
      } else 
      { 
        uint32_t pos = 0; // into data
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;
    56d0:	str	r0, [sp, #28]

        disk_pos=DISK_BUFFER_SIZE;
        while(pos<size)
    56d2:	cmp.w	fp, #0
    56d6:	beq.w	6466 <loop+0x12ee>
    56da:	mov	sl, r3
    { if(!usb_mtp_available()) return;
      if(fetch_packet(rx_data_buffer))
      { printContainer(); // to switch on set debug to 1 at beginning of file

        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
    56dc:	ldr	r3, [sp, #8]
    56de:	str	r6, [sp, #32]
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;

        disk_pos=DISK_BUFFER_SIZE;
        while(pos<size)
    56e0:	mov.w	r9, #12
    { if(!usb_mtp_available()) return;
      if(fetch_packet(rx_data_buffer))
      { printContainer(); // to switch on set debug to 1 at beginning of file

        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
    56e4:	str	r3, [sp, #24]
    56e6:	add.w	r3, r7, #544	; 0x220
    56ea:	mov	r6, r1
    56ec:	add.w	r7, r7, #1056	; 0x420
    56f0:	str	r3, [sp, #20]
    56f2:	add.w	r5, r3, #8704	; 0x2200
    56f6:	mov	r8, r3
    56f8:	b.n	5702 <loop+0x58a>
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;

        disk_pos=DISK_BUFFER_SIZE;
        while(pos<size)
    56fa:	cmp	fp, sl
    56fc:	bls.w	5d4a <loop+0xbd2>
    5700:	ldr	r6, [r5, #0]
        {
          if(disk_pos==DISK_BUFFER_SIZE)
    5702:	cmp.w	r6, #8192	; 0x2000
    5706:	beq.w	5b00 <loop+0x988>
    570a:	rsb	r2, r6, #8192	; 0x2000
    570e:	adds	r1, r7, r6
            count-=MCOUNT;

            disk_pos=0;
          }

          uint32_t to_copy = min(size-pos,MTP_TX_SIZE-len);
    5710:	rsb	r6, r9, #512	; 0x200
    5714:	rsb	r3, sl, fp
          to_copy = min (to_copy, DISK_BUFFER_SIZE-disk_pos);

          memcpy(tx_data_buffer+len,disk_buffer+disk_pos,to_copy);
    5718:	add.w	r0, r8, r9
            count-=MCOUNT;

            disk_pos=0;
          }

          uint32_t to_copy = min(size-pos,MTP_TX_SIZE-len);
    571c:	cmp	r6, r3
    571e:	it	cs
    5720:	movcs	r6, r3
          to_copy = min (to_copy, DISK_BUFFER_SIZE-disk_pos);
    5722:	cmp	r6, r2
    5724:	it	cs
    5726:	movcs	r6, r2

          memcpy(tx_data_buffer+len,disk_buffer+disk_pos,to_copy);
    5728:	mov	r2, r6
          disk_pos += to_copy;
          pos += to_copy;
          len += to_copy;
    572a:	add	r9, r6
          }

          uint32_t to_copy = min(size-pos,MTP_TX_SIZE-len);
          to_copy = min (to_copy, DISK_BUFFER_SIZE-disk_pos);

          memcpy(tx_data_buffer+len,disk_buffer+disk_pos,to_copy);
    572c:	bl	7f58 <memcpy>
          disk_pos += to_copy;
    5730:	ldr	r3, [r5, #0]
          pos += to_copy;
    5732:	add	sl, r6
          len += to_copy;

          if(len==MTP_TX_SIZE)
    5734:	cmp.w	r9, #512	; 0x200

          uint32_t to_copy = min(size-pos,MTP_TX_SIZE-len);
          to_copy = min (to_copy, DISK_BUFFER_SIZE-disk_pos);

          memcpy(tx_data_buffer+len,disk_buffer+disk_pos,to_copy);
          disk_pos += to_copy;
    5738:	add	r6, r3
    573a:	str	r6, [r5, #0]
          pos += to_copy;
          len += to_copy;

          if(len==MTP_TX_SIZE)
    573c:	bne.n	56fa <loop+0x582>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    573e:	movs	r2, #60	; 0x3c
    5740:	mov.w	r1, #512	; 0x200
    5744:	ldr	r0, [pc, #132]	; (57cc <loop+0x654>)
    5746:	bl	9d50 <usb_mtp_send>
    574a:	cmp	r0, #0
    574c:	ble.n	573e <loop+0x5c6>
          pos += to_copy;
          len += to_copy;

          if(len==MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            len=0;
    574e:	mov.w	r9, #0
    5752:	b.n	56fa <loop+0x582>
        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
        {
          case 0x1001:
            TRANSMIT(WriteDescriptor());
    5754:	ldr	r3, [sp, #20]
    5756:	ldr	r0, [pc, #108]	; (57c4 <loop+0x64c>)
    5758:	ubfx	r5, r3, #0, #9
    575c:	bl	71c <MTPD::WriteDescriptor()>
    5760:	cmp	r5, #0
    5762:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5766:	movs	r2, #60	; 0x3c
    5768:	mov	r1, r5
    576a:	ldr	r0, [pc, #96]	; (57cc <loop+0x654>)
    576c:	bl	9d50 <usb_mtp_send>
    5770:	cmp	r0, #0
    5772:	ble.n	5766 <loop+0x5ee>
    5774:	b.n	5408 <loop+0x290>
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
    5776:	mov.w	fp, #0
    577a:	movs	r3, #1
    577c:	mov	r2, r9
    577e:	ldr	r1, [sp, #8]
    5780:	ldr	r0, [pc, #64]	; (57c4 <loop+0x64c>)
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    5782:	mov	r8, fp
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
    5784:	strb	r3, [r4, #0]
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    5786:	add.w	sl, sp, #92	; 0x5c
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
    578a:	str.w	fp, [r4, #4]
    578e:	bl	2948 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5792:	ldr	r5, [pc, #52]	; (57c8 <loop+0x650>)
        write_length_ += len;
    5794:	movs	r2, #12
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5796:	ldr	r3, [pc, #52]	; (57cc <loop+0x654>)
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
    5798:	mov.w	lr, #2
    579c:	ldr	r1, [r4, #4]
    579e:	add.w	r7, r3, #512	; 0x200
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    57a2:	mov	r0, r3
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    57a4:	str	r3, [r5, #0]
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
    57a6:	add	r1, r2
    57a8:	ldrh	r3, [r4, #38]	; 0x26
    57aa:	str	r1, [sp, #20]
    57ac:	strh.w	r3, [sp, #98]	; 0x62
    57b0:	ldr	r3, [r4, #40]	; 0x28
    57b2:	strb.w	fp, [r4]
    57b6:	str	r1, [sp, #92]	; 0x5c
    57b8:	strh.w	lr, [sp, #96]	; 0x60
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    57bc:	str	r2, [r4, #4]
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
    57be:	str	r3, [sp, #100]	; 0x64
    57c0:	b.n	57e4 <loop+0x66c>
    57c2:	nop
    57c4:	.word	0x20006060
    57c8:	.word	0x2000158c
    57cc:	.word	0x20006280
    57d0:	.word	0x20006480
    57d4:	.word	0x200001b8
    57d8:	.word	0x200015e4
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    57dc:	cmp.w	r8, #11
    57e0:	bgt.n	5820 <loop+0x6a8>
    57e2:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    57e4:	ldr	r3, [pc, #768]	; (5ae8 <loop+0x970>)
          memcpy(dst,src,to_copy);
    57e6:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    57e8:	rsb	fp, r0, r3
    57ec:	rsb	r3, r8, #12
    57f0:	cmp	fp, r3
    57f2:	it	ge
    57f4:	movge	fp, r3
          memcpy(dst,src,to_copy);
    57f6:	mov	r2, fp
          pos += to_copy;
    57f8:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    57fa:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    57fe:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5800:	add	sl, fp
          dst += to_copy;
    5802:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5804:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5806:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5808:	bne.n	57dc <loop+0x664>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    580a:	movs	r2, #60	; 0x3c
    580c:	mov.w	r1, #512	; 0x200
    5810:	ldr	r0, [pc, #728]	; (5aec <loop+0x974>)
    5812:	bl	9d50 <usb_mtp_send>
    5816:	cmp	r0, #0
    5818:	ble.n	580a <loop+0x692>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    581a:	ldr	r3, [pc, #720]	; (5aec <loop+0x974>)
    581c:	str	r3, [r5, #0]
    581e:	b.n	57dc <loop+0x664>
          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
              break;

          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
    5820:	ldr	r3, [sp, #20]
    5822:	mov	r2, r9
    5824:	ldr	r1, [sp, #8]
    5826:	ubfx	r5, r3, #0, #9
    582a:	ldr	r0, [pc, #708]	; (5af0 <loop+0x978>)
    582c:	bl	2948 <MTPD::getObjectPropDesc(unsigned long, unsigned long)>
    5830:	cmp	r5, #0
    5832:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5836:	movs	r2, #60	; 0x3c
    5838:	mov	r1, r5
    583a:	ldr	r0, [pc, #688]	; (5aec <loop+0x974>)
    583c:	bl	9d50 <usb_mtp_send>
    5840:	cmp	r0, #0
    5842:	ble.n	5836 <loop+0x6be>
    5844:	b.n	5408 <loop+0x290>
          case 0x9802:  // getObjectPropDesc
              TRANSMIT(getObjectPropDesc(p1,p2));
              break;

          case 0x9803:  // getObjectPropertyValue
              TRANSMIT(getObjectPropValue(p1,p2));
    5846:	ldr	r3, [sp, #20]
    5848:	mov	r2, r9
    584a:	ldr	r1, [sp, #8]
    584c:	ubfx	r5, r3, #0, #9
    5850:	ldr	r0, [pc, #668]	; (5af0 <loop+0x978>)
    5852:	bl	4698 <MTPD::getObjectPropValue(unsigned long, unsigned long)>
    5856:	cmp	r5, #0
    5858:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    585c:	movs	r2, #60	; 0x3c
    585e:	mov	r1, r5
    5860:	ldr	r0, [pc, #648]	; (5aec <loop+0x974>)
    5862:	bl	9d50 <usb_mtp_send>
    5866:	cmp	r0, #0
    5868:	ble.n	585c <loop+0x6e4>
    586a:	b.n	5408 <loop+0x290>
    586c:	ldr	r5, [sp, #8]
    586e:	movw	r9, #8197	; 0x2005
    5872:	b.n	5268 <loop+0xf0>
    5874:	ldrh.w	r9, [sp, #16]
    5878:	movs	r6, #12
    587a:	ldr	r5, [sp, #8]
    587c:	b.n	5268 <loop+0xf0>
    587e:	ldrh.w	r9, [sp, #16]
    5882:	movs	r6, #24
    5884:	ldr	r5, [sp, #8]
    5886:	b.n	5268 <loop+0xf0>
      return mFS_copy(handle,store1,newHandle);
    }
*/    
    void openSession(uint32_t id)
    {
      sessionID_ = id;
    5888:	ldr	r2, [sp, #8]
    588a:	ldr	r3, [pc, #616]	; (5af4 <loop+0x97c>)
    588c:	ldrh.w	r9, [sp, #16]
    5890:	mov	r5, r2
    5892:	str	r2, [r3, #0]
    5894:	b.n	5268 <loop+0xf0>
    5896:	ldr	r2, [sp, #8]
    5898:	movw	r1, #10864	; 0x2a70
    589c:	ldr	r3, [pc, #600]	; (5af8 <loop+0x980>)
    589e:	subs	r2, #1
    58a0:	ldr	r7, [pc, #580]	; (5ae8 <loop+0x970>)
    58a2:	mla	r3, r1, r2, r3

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    58a6:	ldrb.w	r2, [r3, #110]	; 0x6e
    58aa:	adds	r3, #110	; 0x6e
    58ac:	cmp	r2, #0
    58ae:	beq.w	5f1c <loop+0xda4>
    58b2:	movs	r1, #29
    58b4:	mov	sl, r7
    58b6:	b.n	58ba <loop+0x742>
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    58b8:	mov	r1, r0
    58ba:	uxth	r5, r2
    58bc:	ldrb.w	r2, [r3, #1]!
    58c0:	adds	r0, r1, #2
    58c2:	cmp	r2, #0
    58c4:	bne.n	58b8 <loop+0x740>
    58c6:	adds	r1, #3
    58c8:	strh.w	r5, [sp, #54]	; 0x36
    58cc:	strh.w	r2, [sp, #52]	; 0x34
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    58d0:	ldr	r3, [pc, #536]	; (5aec <loop+0x974>)
          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
            break;

          case 0x1005:  // GetStorageInfo
            TRANSMIT(GetStorageInfo(p1));
    58d2:	add.w	r2, r1, #12
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    58d6:	ldr	r5, [pc, #548]	; (5afc <loop+0x984>)
    58d8:	mov.w	r8, #0
        write_length_ += len;
    58dc:	mov	r0, r3
          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
            break;

          case 0x1005:  // GetStorageInfo
            TRANSMIT(GetStorageInfo(p1));
    58de:	mov.w	lr, #2
    58e2:	ldrh	r1, [r4, #38]	; 0x26
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    58e4:	mov.w	ip, #12
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    58e8:	str	r3, [r5, #0]
        write_length_ += len;
        
        const char * src=data;
    58ea:	add.w	r9, sp, #92	; 0x5c
          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
            break;

          case 0x1005:  // GetStorageInfo
            TRANSMIT(GetStorageInfo(p1));
    58ee:	ldr	r3, [r4, #40]	; 0x28
    58f0:	str	r2, [sp, #20]
    58f2:	str	r2, [sp, #92]	; 0x5c
    58f4:	strb.w	r8, [sp, #47]	; 0x2f
    58f8:	strb.w	r8, [r4]
    58fc:	strh.w	lr, [sp, #96]	; 0x60
    5900:	strh.w	r1, [sp, #98]	; 0x62
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5904:	str.w	ip, [r4, #4]
          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
            break;

          case 0x1005:  // GetStorageInfo
            TRANSMIT(GetStorageInfo(p1));
    5908:	str	r3, [sp, #100]	; 0x64
    590a:	b.n	5916 <loop+0x79e>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    590c:	cmp.w	r8, #11
    5910:	bgt.w	5bb0 <loop+0xa38>
    5914:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5916:	rsb	fp, r0, sl
    591a:	rsb	r3, r8, #12
          memcpy(dst,src,to_copy);
    591e:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5920:	cmp	fp, r3
    5922:	it	ge
    5924:	movge	fp, r3
          memcpy(dst,src,to_copy);
    5926:	mov	r2, fp
          pos += to_copy;
    5928:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    592a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    592e:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5930:	add	r9, fp
          dst += to_copy;
    5932:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5934:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5936:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5938:	bne.n	590c <loop+0x794>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    593a:	movs	r2, #60	; 0x3c
    593c:	mov.w	r1, #512	; 0x200
    5940:	ldr	r0, [pc, #424]	; (5aec <loop+0x974>)
    5942:	bl	9d50 <usb_mtp_send>
    5946:	cmp	r0, #0
    5948:	ble.n	593a <loop+0x7c2>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    594a:	ldr	r3, [pc, #416]	; (5aec <loop+0x974>)
    594c:	str	r3, [r5, #0]
    594e:	b.n	590c <loop+0x794>

        int return_code =0x2001; //OK use as default value

        if(typ==2) return_code=0x2005; // we should only get cmds

        switch (op)
    5950:	mov	r5, r1
    5952:	mov	r9, r2
    5954:	movs	r6, #16
    5956:	b.n	5268 <loop+0xf0>
          case 0x1005:  // GetStorageInfo
            TRANSMIT(GetStorageInfo(p1));
            break;

          case 0x1006:  // GetNumObjects
            if (p2) 
    5958:	cmp.w	r9, #0
    595c:	bne.w	522e <loop+0xb6>
{
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    5960:	ldr	r3, [sp, #8]
    5962:	movw	r0, #10864	; 0x2a70
    5966:	ldr	r2, [pc, #400]	; (5af8 <loop+0x980>)
    5968:	mov	r1, r8
    596a:	subs	r3, #1
    596c:	mla	r0, r0, r3, r2
    5970:	adds	r0, #80	; 0x50
    5972:	bl	6c94 <zeroFS_class::Count(unsigned long)>
    5976:	ldrh.w	r9, [sp, #16]
    597a:	mov	r5, r0
    597c:	b.n	5268 <loop+0xf0>
              TRANSMIT(GetObjectHandles(p1, p3));
            }
            break;

          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
    597e:	mov.w	r9, #0
    5982:	movs	r3, #1
    5984:	ldr	r1, [sp, #8]
    5986:	ldr	r0, [pc, #360]	; (5af0 <loop+0x978>)
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    5988:	mov	r8, r9
              TRANSMIT(GetObjectHandles(p1, p3));
            }
            break;

          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
    598a:	str.w	r9, [r4, #4]
    598e:	strb	r3, [r4, #0]
    5990:	bl	1dc8 <MTPD::GetObjectInfo(unsigned long)>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5994:	ldr	r5, [pc, #356]	; (5afc <loop+0x984>)
        write_length_ += len;
    5996:	movs	r2, #12
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5998:	ldr	r3, [pc, #336]	; (5aec <loop+0x974>)
              TRANSMIT(GetObjectHandles(p1, p3));
            }
            break;

          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
    599a:	mov.w	lr, #2
    599e:	ldr	r1, [r4, #4]
    59a0:	add.w	r7, r3, #512	; 0x200
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    59a4:	mov	r0, r3
              TRANSMIT(GetObjectHandles(p1, p3));
            }
            break;

          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
    59a6:	add	r1, r2
    59a8:	ldrh.w	ip, [r4, #38]	; 0x26
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    59ac:	str	r3, [r5, #0]
    59ae:	mov	fp, r7
              TRANSMIT(GetObjectHandles(p1, p3));
            }
            break;

          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
    59b0:	ldr	r3, [r4, #40]	; 0x28
    59b2:	strb.w	r9, [r4]
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    59b6:	add.w	r9, sp, #92	; 0x5c
              TRANSMIT(GetObjectHandles(p1, p3));
            }
            break;

          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
    59ba:	str	r1, [sp, #20]
    59bc:	str	r1, [sp, #92]	; 0x5c
    59be:	strh.w	lr, [sp, #96]	; 0x60
    59c2:	strh.w	ip, [sp, #98]	; 0x62
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    59c6:	str	r2, [r4, #4]
              TRANSMIT(GetObjectHandles(p1, p3));
            }
            break;

          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
    59c8:	str	r3, [sp, #100]	; 0x64
    59ca:	b.n	59d4 <loop+0x85c>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    59cc:	cmp.w	r8, #11
    59d0:	bgt.n	5a0e <loop+0x896>
    59d2:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    59d4:	rsb	sl, r0, fp
    59d8:	rsb	r3, r8, #12
          memcpy(dst,src,to_copy);
    59dc:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    59de:	cmp	sl, r3
    59e0:	it	ge
    59e2:	movge	sl, r3
          memcpy(dst,src,to_copy);
    59e4:	mov	r2, sl
          pos += to_copy;
    59e6:	add	r8, sl
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    59e8:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    59ec:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    59ee:	add	r9, sl
          dst += to_copy;
    59f0:	add	r3, sl
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    59f2:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    59f4:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    59f6:	bne.n	59cc <loop+0x854>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    59f8:	movs	r2, #60	; 0x3c
    59fa:	mov.w	r1, #512	; 0x200
    59fe:	ldr	r0, [pc, #236]	; (5aec <loop+0x974>)
    5a00:	bl	9d50 <usb_mtp_send>
    5a04:	cmp	r0, #0
    5a06:	ble.n	59f8 <loop+0x880>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    5a08:	ldr	r3, [pc, #224]	; (5aec <loop+0x974>)
    5a0a:	str	r3, [r5, #0]
    5a0c:	b.n	59cc <loop+0x854>
              TRANSMIT(GetObjectHandles(p1, p3));
            }
            break;

          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
    5a0e:	ldr	r3, [sp, #20]
    5a10:	ldr	r1, [sp, #8]
    5a12:	ubfx	r5, r3, #0, #9
    5a16:	ldr	r0, [pc, #216]	; (5af0 <loop+0x978>)
    5a18:	bl	1dc8 <MTPD::GetObjectInfo(unsigned long)>
    5a1c:	cmp	r5, #0
    5a1e:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5a22:	movs	r2, #60	; 0x3c
    5a24:	mov	r1, r5
    5a26:	ldr	r0, [pc, #196]	; (5aec <loop+0x974>)
    5a28:	bl	9d50 <usb_mtp_send>
    5a2c:	cmp	r0, #0
    5a2e:	ble.n	5a22 <loop+0x8aa>
    5a30:	b.n	5408 <loop+0x290>
      }
    }
  }

  void GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    5a32:	movw	r3, #54274	; 0xd402
    5a36:	ldr	r2, [sp, #8]
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    5a38:	mov.w	fp, #1
      }
    }
  }

  void GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    5a3c:	cmp	r2, r3
    5a3e:	beq.w	5f22 <loop+0xdaa>
    5a42:	movs	r3, #12
    5a44:	str	r3, [sp, #24]
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5a46:	ldr	r3, [pc, #164]	; (5aec <loop+0x974>)
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    5a48:	movs	r2, #0
    5a4a:	ldr	r0, [sp, #24]
    5a4c:	mov.w	ip, #2
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5a50:	ldr	r5, [pc, #168]	; (5afc <loop+0x984>)
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    5a52:	movw	lr, #4117	; 0x1015
    5a56:	add.w	r7, r3, #512	; 0x200
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5a5a:	movs	r1, #12
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    5a5c:	str	r0, [sp, #92]	; 0x5c
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    5a5e:	mov	r8, r2
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    5a60:	ldr	r0, [sp, #12]
    5a62:	mov	r9, r7
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5a64:	str	r3, [sp, #20]
        
        const char * src=data;
    5a66:	add.w	sl, sp, #92	; 0x5c
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    5a6a:	str	r0, [sp, #100]	; 0x64
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5a6c:	mov	r0, r3
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5a6e:	str	r3, [r5, #0]
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    5a70:	strh.w	ip, [sp, #96]	; 0x60
    5a74:	strh.w	lr, [sp, #98]	; 0x62
    5a78:	strb	r2, [r4, #0]
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5a7a:	str	r1, [r4, #4]
    5a7c:	b.n	5a86 <loop+0x90e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    5a7e:	cmp.w	r8, #11
    5a82:	bgt.n	5ac0 <loop+0x948>
    5a84:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5a86:	rsb	fp, r0, r9
    5a8a:	rsb	r3, r8, #12
          memcpy(dst,src,to_copy);
    5a8e:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5a90:	cmp	fp, r3
    5a92:	it	ge
    5a94:	movge	fp, r3
          memcpy(dst,src,to_copy);
    5a96:	mov	r2, fp
          pos += to_copy;
    5a98:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    5a9a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5a9e:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5aa0:	add	sl, fp
          dst += to_copy;
    5aa2:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5aa4:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5aa6:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5aa8:	bne.n	5a7e <loop+0x906>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5aaa:	movs	r2, #60	; 0x3c
    5aac:	mov.w	r1, #512	; 0x200
    5ab0:	ldr	r0, [pc, #56]	; (5aec <loop+0x974>)
    5ab2:	bl	9d50 <usb_mtp_send>
    5ab6:	cmp	r0, #0
    5ab8:	ble.n	5aaa <loop+0x932>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    5aba:	ldr	r3, [pc, #48]	; (5aec <loop+0x974>)
    5abc:	str	r3, [r5, #0]
    5abe:	b.n	5a7e <loop+0x906>
      }
    }
  }

  void GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    5ac0:	movw	r3, #54274	; 0xd402
    5ac4:	ldr	r2, [sp, #8]
    5ac6:	cmp	r2, r3
    5ac8:	beq.w	61a6 <loop+0x102e>
          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
              break;

          case 0x1015:  // GetDevicePropvalue
              TRANSMIT(GetDevicePropValue(p1));
    5acc:	ldr	r3, [sp, #24]
    5ace:	ubfx	r5, r3, #0, #9
    5ad2:	cmp	r5, #0
    5ad4:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5ad8:	movs	r2, #60	; 0x3c
    5ada:	mov	r1, r5
    5adc:	ldr	r0, [pc, #12]	; (5aec <loop+0x974>)
    5ade:	bl	9d50 <usb_mtp_send>
    5ae2:	cmp	r0, #0
    5ae4:	ble.n	5ad8 <loop+0x960>
    5ae6:	b.n	5408 <loop+0x290>
    5ae8:	.word	0x20006480
    5aec:	.word	0x20006280
    5af0:	.word	0x20006060
    5af4:	.word	0x20001590
    5af8:	.word	0x20001594
    5afc:	.word	0x2000158c
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    
    uint32_t Read(uint32_t handle, char* out, uint32_t count) 
    { return zFs[0].Read(handle, out, count);}
    5b00:	ldr	r0, [sp, #28]
    5b02:	ldr	r1, [sp, #24]
    5b04:	mov	r3, r0
    5b06:	cmp	r0, #16
          if(disk_pos==DISK_BUFFER_SIZE)
          {
//            uint32_t nread=min(size-pos,(uint32_t)DISK_BUFFER_SIZE);
//            mFS.Read(object_id,size,pos,(char *)disk_buffer,nread);
            sector = mFS.Read(sector, (char *)disk_buffer, min(count,MCOUNT));
            count-=MCOUNT;
    5b08:	sub.w	r0, r0, #16
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    
    uint32_t Read(uint32_t handle, char* out, uint32_t count) 
    { return zFs[0].Read(handle, out, count);}
    5b0c:	ldr	r2, [pc, #664]	; (5da8 <loop+0xc30>)
    5b0e:	it	cs
    5b10:	movcs	r3, #16
          if(disk_pos==DISK_BUFFER_SIZE)
          {
//            uint32_t nread=min(size-pos,(uint32_t)DISK_BUFFER_SIZE);
//            mFS.Read(object_id,size,pos,(char *)disk_buffer,nread);
            sector = mFS.Read(sector, (char *)disk_buffer, min(count,MCOUNT));
            count-=MCOUNT;
    5b12:	str	r0, [sp, #28]
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    
    uint32_t Read(uint32_t handle, char* out, uint32_t count) 
    { return zFs[0].Read(handle, out, count);}
    5b14:	ldr	r0, [pc, #660]	; (5dac <loop+0xc34>)
    5b16:	bl	6e0c <zeroFS_class::Read(unsigned long, char*, unsigned long)>
//            uint32_t nread=min(size-pos,(uint32_t)DISK_BUFFER_SIZE);
//            mFS.Read(object_id,size,pos,(char *)disk_buffer,nread);
            sector = mFS.Read(sector, (char *)disk_buffer, min(count,MCOUNT));
            count-=MCOUNT;

            disk_pos=0;
    5b1a:	movs	r3, #0
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    
    uint32_t Read(uint32_t handle, char* out, uint32_t count) 
    { return zFs[0].Read(handle, out, count);}
    5b1c:	str	r0, [sp, #24]
//            uint32_t nread=min(size-pos,(uint32_t)DISK_BUFFER_SIZE);
//            mFS.Read(object_id,size,pos,(char *)disk_buffer,nread);
            sector = mFS.Read(sector, (char *)disk_buffer, min(count,MCOUNT));
            count-=MCOUNT;

            disk_pos=0;
    5b1e:	mov	r2, r6
    5b20:	ldr	r1, [pc, #644]	; (5da8 <loop+0xc30>)
    5b22:	str	r3, [r5, #0]
    5b24:	b.n	5710 <loop+0x598>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5b26:	ldr	r2, [sp, #20]
    5b28:	str	r2, [r5, #0]
    5b2a:	ldr	r2, [pc, #644]	; (5db0 <loop+0xc38>)
    5b2c:	str	r2, [sp, #20]
    5b2e:	mov	r0, r2
    5b30:	b.w	5310 <loop+0x198>
        break;
    }
  }

  void GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    5b34:	movw	r3, #54274	; 0xd402
    5b38:	ldr	r1, [sp, #8]
    5b3a:	cmp	r1, r3
    5b3c:	bne.n	5b94 <loop+0xa1c>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5b3e:	ldr	r3, [pc, #628]	; (5db4 <loop+0xc3c>)
    5b40:	ldrb	r2, [r4, #0]
    5b42:	strh.w	r1, [sp, #56]	; 0x38
      {
        write_length_ += len;
    5b46:	ldr	r3, [r3, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5b48:	cmp	r2, #0
    5b4a:	beq.w	6258 <loop+0x10e0>
    5b4e:	movw	r2, #65535	; 0xffff
      {
        write_length_ += len;
    5b52:	adds	r3, #2
    5b54:	strh.w	r2, [sp, #58]	; 0x3a
    5b58:	movs	r2, #0
    5b5a:	adds	r3, #2
    5b5c:	strb.w	r2, [sp, #49]	; 0x31
    5b60:	adds	r3, #1
    5b62:	str	r3, [r4, #4]
  void GetDevicePropValue(uint32_t prop) {
    switch (prop) {
      case 0xd402: // friendly name
        // This is the name we'll actually see in the windows explorer.
        // Should probably be configurable.
        writestring(MTP_NAME);
    5b64:	ldr.w	r8, [pc, #588]	; 5db4 <loop+0xc3c>
    5b68:	ldr	r1, [pc, #588]	; (5db8 <loop+0xc40>)
    5b6a:	mov	r0, r8
    5b6c:	bl	4cc <MTPD::writestring(char const*)>
    5b70:	mov	r0, r8
    5b72:	ldr	r1, [pc, #580]	; (5db8 <loop+0xc40>)
    5b74:	bl	4cc <MTPD::writestring(char const*)>
    5b78:	movs	r2, #0
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5b7a:	ldrb	r3, [r4, #0]
    5b7c:	strb.w	r2, [sp, #50]	; 0x32
    5b80:	cmp	r3, #0
    5b82:	beq.w	5fec <loop+0xe74>
      {
        write_length_ += len;
    5b86:	ldr.w	r3, [r8, #4]
    5b8a:	ldr	r2, [sp, #92]	; 0x5c
    5b8c:	adds	r3, #1
    5b8e:	str	r2, [sp, #24]
    5b90:	str.w	r3, [r8, #4]
//              if(!SendObject()) return_code = 0x2005;
              len = 12;
              break;

          case 0x1014:  // GetDevicePropDesc
              TRANSMIT(GetDevicePropDesc(p1));
    5b94:	ldr	r3, [sp, #24]
    5b96:	ubfx	r5, r3, #0, #9
    5b9a:	cmp	r5, #0
    5b9c:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5ba0:	movs	r2, #60	; 0x3c
    5ba2:	mov	r1, r5
    5ba4:	ldr	r0, [pc, #520]	; (5db0 <loop+0xc38>)
    5ba6:	bl	9d50 <usb_mtp_send>
    5baa:	cmp	r0, #0
    5bac:	ble.n	5ba0 <loop+0xa28>
    5bae:	b.n	5408 <loop+0x290>
          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
            break;

          case 0x1005:  // GetStorageInfo
            TRANSMIT(GetStorageInfo(p1));
    5bb0:	ldr	r3, [sp, #20]
    5bb2:	ldr	r1, [sp, #8]
    5bb4:	ubfx	r5, r3, #0, #9
    5bb8:	ldr	r0, [pc, #504]	; (5db4 <loop+0xc3c>)
    5bba:	bl	1780 <MTPD::GetStorageInfo(unsigned long)>
    5bbe:	cmp	r5, #0
    5bc0:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5bc4:	movs	r2, #60	; 0x3c
    5bc6:	mov	r1, r5
    5bc8:	ldr	r0, [pc, #484]	; (5db0 <loop+0xc38>)
    5bca:	bl	9d50 <usb_mtp_send>
    5bce:	cmp	r0, #0
    5bd0:	ble.n	5bc4 <loop+0xa4c>
    5bd2:	b.n	5408 <loop+0x290>
    5bd4:	movs	r2, #1
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5bd6:	ldr	r3, [pc, #476]	; (5db4 <loop+0xc3c>)
    5bd8:	ldrb	r1, [r4, #0]
    5bda:	str	r2, [sp, #72]	; 0x48
      {
        write_length_ += len;
    5bdc:	ldr	r3, [r3, #4]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5bde:	cmp	r1, #0
    5be0:	beq.w	604c <loop+0xed4>
      {
        write_length_ += len;
    5be4:	adds	r3, #4
    5be6:	str	r2, [sp, #76]	; 0x4c
    5be8:	adds	r3, #4
    5bea:	str	r3, [r4, #4]

          case 0x1003:  // CloseSession
            break;

          case 0x1004:  // GetStorageIDs
              TRANSMIT(WriteStorageIDs());
    5bec:	ldr	r5, [sp, #92]	; 0x5c
    5bee:	ubfx	r5, r5, #0, #9
    5bf2:	cmp	r5, #0
    5bf4:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5bf8:	movs	r2, #60	; 0x3c
    5bfa:	mov	r1, r5
    5bfc:	ldr	r0, [pc, #432]	; (5db0 <loop+0xc38>)
    5bfe:	bl	9d50 <usb_mtp_send>
    5c02:	cmp	r0, #0
    5c04:	ble.n	5bf8 <loop+0xa80>
    5c06:	b.w	5408 <loop+0x290>
    5c0a:	ldr	r6, [sp, #28]
          case 0x101B:  // GetPartialObject
//              TRANSMIT1(GetPartialObject(p1,p2,p3));
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    5c0c:	adds	r3, #12
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5c0e:	ldr	r2, [sp, #20]
          case 0x101B:  // GetPartialObject
//              TRANSMIT1(GetPartialObject(p1,p2,p3));
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    5c10:	ldrh	r0, [r4, #38]	; 0x26
    5c12:	mov.w	ip, #2
    5c16:	str	r3, [sp, #92]	; 0x5c
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5c18:	movs	r1, #12
    5c1a:	ldr	r3, [pc, #404]	; (5db0 <loop+0xc38>)
        
        const char * src=data;
    5c1c:	add.w	r9, sp, #92	; 0x5c
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5c20:	str	r2, [r5, #0]
          case 0x101B:  // GetPartialObject
//              TRANSMIT1(GetPartialObject(p1,p2,p3));
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    5c22:	movs	r2, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5c24:	str	r3, [sp, #20]
          case 0x101B:  // GetPartialObject
//              TRANSMIT1(GetPartialObject(p1,p2,p3));
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    5c26:	strh.w	r0, [sp, #98]	; 0x62
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5c2a:	mov	r0, r3
          case 0x101B:  // GetPartialObject
//              TRANSMIT1(GetPartialObject(p1,p2,p3));
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    5c2c:	ldr	r3, [r4, #40]	; 0x28
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    5c2e:	mov	r8, r2
          case 0x101B:  // GetPartialObject
//              TRANSMIT1(GetPartialObject(p1,p2,p3));
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    5c30:	strh.w	ip, [sp, #96]	; 0x60
    5c34:	str	r3, [sp, #100]	; 0x64
    5c36:	strb	r2, [r4, #0]
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5c38:	str	r1, [r4, #4]
    5c3a:	b.n	5c44 <loop+0xacc>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    5c3c:	cmp.w	r8, #11
    5c40:	bgt.n	5c7e <loop+0xb06>
    5c42:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5c44:	rsb	fp, r0, sl
    5c48:	rsb	r3, r8, #12
          memcpy(dst,src,to_copy);
    5c4c:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5c4e:	cmp	fp, r3
    5c50:	it	ge
    5c52:	movge	fp, r3
          memcpy(dst,src,to_copy);
    5c54:	mov	r2, fp
          pos += to_copy;
    5c56:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    5c58:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5c5c:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5c5e:	add	r9, fp
          dst += to_copy;
    5c60:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5c62:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5c64:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5c66:	bne.n	5c3c <loop+0xac4>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5c68:	movs	r2, #60	; 0x3c
    5c6a:	mov.w	r1, #512	; 0x200
    5c6e:	ldr	r0, [pc, #320]	; (5db0 <loop+0xc38>)
    5c70:	bl	9d50 <usb_mtp_send>
    5c74:	cmp	r0, #0
    5c76:	ble.n	5c68 <loop+0xaf0>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    5c78:	ldr	r3, [pc, #308]	; (5db0 <loop+0xc38>)
    5c7a:	str	r3, [r5, #0]
    5c7c:	b.n	5c3c <loop+0xac4>
    }
  }

    void getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
    5c7e:	ldr	r3, [pc, #316]	; (5dbc <loop+0xc44>)
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5c80:	ldrb	r1, [r4, #0]
    }
  }

    void getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
    5c82:	ldr	r3, [r3, #0]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5c84:	ldr	r2, [pc, #300]	; (5db4 <loop+0xc3c>)
    5c86:	str	r3, [sp, #88]	; 0x58
    5c88:	cmp	r1, #0
    5c8a:	beq.w	6130 <loop+0xfb8>
      {
        write_length_ += len;
    5c8e:	ldr	r1, [r2, #4]
    5c90:	adds	r1, #4
    5c92:	str	r1, [r2, #4]
  }

    void getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    5c94:	cmp	r3, #0
    5c96:	beq.n	5d2c <loop+0xbb4>
    5c98:	ldr	r3, [pc, #292]	; (5dc0 <loop+0xc48>)
    5c9a:	movw	r2, #56321	; 0xdc01
    5c9e:	str	r6, [sp, #28]
    5ca0:	str	r3, [sp, #24]
    5ca2:	movs	r3, #0
    5ca4:	mov	r9, r3
    5ca6:	b.n	5cc2 <loop+0xb4a>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    5ca8:	ldr	r3, [r0, #4]
    5caa:	adds	r3, #2
    5cac:	str	r3, [r0, #4]
  }

    void getObjectPropsSupported(uint32_t p1)
    {
      write32(propertyListNum);
      for(uint32_t ii=0; ii<propertyListNum;ii++) write16(propertyList[ii]);
    5cae:	ldr	r3, [pc, #268]	; (5dbc <loop+0xc44>)
    5cb0:	add.w	r9, r9, #1
    5cb4:	ldr	r3, [r3, #0]
    5cb6:	cmp	r3, r9
    5cb8:	bls.n	5d2a <loop+0xbb2>
    5cba:	ldr	r3, [sp, #24]
    5cbc:	ldrh.w	r2, [r3, #2]!
    5cc0:	str	r3, [sp, #24]
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    5cc2:	ldrb	r3, [r4, #0]
    5cc4:	strh.w	r2, [sp, #68]	; 0x44
    5cc8:	ldr	r0, [pc, #232]	; (5db4 <loop+0xc3c>)
    5cca:	cmp	r3, #0
    5ccc:	bne.n	5ca8 <loop+0xb30>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5cce:	ldr	r3, [r0, #4]
    5cd0:	cbz	r3, 5d20 <loop+0xba8>
    5cd2:	ldr	r0, [r5, #0]
        write_length_ += len;
    5cd4:	adds	r3, #2
        
        const char * src=data;
    5cd6:	add.w	r8, sp, #68	; 0x44
        //
        int pos = 0; // into data
    5cda:	movs	r6, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5cdc:	str	r3, [r4, #4]
    5cde:	b.n	5ce6 <loop+0xb6e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    5ce0:	cmp	r6, #1
    5ce2:	bgt.n	5cae <loop+0xb36>
    5ce4:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5ce6:	rsb	fp, r0, sl
    5cea:	rsb	r3, r6, #2
          memcpy(dst,src,to_copy);
    5cee:	mov	r1, r8
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5cf0:	cmp	fp, r3
    5cf2:	it	ge
    5cf4:	movge	fp, r3
          memcpy(dst,src,to_copy);
    5cf6:	mov	r2, fp
          pos += to_copy;
    5cf8:	add	r6, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    5cfa:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5cfe:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5d00:	add	r8, fp
          dst += to_copy;
    5d02:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5d04:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5d06:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5d08:	bne.n	5ce0 <loop+0xb68>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5d0a:	movs	r2, #60	; 0x3c
    5d0c:	mov.w	r1, #512	; 0x200
    5d10:	ldr	r0, [pc, #156]	; (5db0 <loop+0xc38>)
    5d12:	bl	9d50 <usb_mtp_send>
    5d16:	cmp	r0, #0
    5d18:	ble.n	5d0a <loop+0xb92>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    5d1a:	ldr	r3, [pc, #148]	; (5db0 <loop+0xc38>)
    5d1c:	str	r3, [r5, #0]
    5d1e:	b.n	5ce0 <loop+0xb68>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5d20:	ldr	r2, [sp, #20]
    5d22:	add.w	r0, r0, #544	; 0x220
    5d26:	str	r2, [r5, #0]
    5d28:	b.n	5cd4 <loop+0xb5c>
    5d2a:	ldr	r6, [sp, #28]
          case 0x101B:  // GetPartialObject
//              TRANSMIT1(GetPartialObject(p1,p2,p3));
              break;

          case 0x9801:  // getObjectPropsSupported
              TRANSMIT(getObjectPropsSupported(p1));
    5d2c:	ldr	r5, [sp, #92]	; 0x5c
    5d2e:	ubfx	r5, r5, #0, #9
    5d32:	cmp	r5, #0
    5d34:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5d38:	movs	r2, #60	; 0x3c
    5d3a:	mov	r1, r5
    5d3c:	ldr	r0, [pc, #112]	; (5db0 <loop+0xc38>)
    5d3e:	bl	9d50 <usb_mtp_send>
    5d42:	cmp	r0, #0
    5d44:	ble.n	5d38 <loop+0xbc0>
    5d46:	b.w	5408 <loop+0x290>
    5d4a:	ldr	r6, [sp, #32]
          if(len==MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            len=0;
          }
        }
        if(len>0)
    5d4c:	cmp.w	r9, #0
    5d50:	beq.w	5fe8 <loop+0xe70>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5d54:	ldr	r5, [pc, #92]	; (5db4 <loop+0xc3c>)
    5d56:	movs	r2, #60	; 0x3c
    5d58:	mov.w	r1, #512	; 0x200
    5d5c:	add.w	r0, r5, #544	; 0x220
    5d60:	bl	9d50 <usb_mtp_send>
    5d64:	cmp	r0, #0
    5d66:	ble.n	5d54 <loop+0xbdc>
    5d68:	ldr	r3, [r5, #4]
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    5d6a:	adds	r3, #12
    5d6c:	ldr.w	sl, [pc, #56]	; 5da8 <loop+0xc30>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5d70:	ldr	r5, [pc, #80]	; (5dc4 <loop+0xc4c>)
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    5d72:	mov.w	ip, #2
    5d76:	mov	r0, r3
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5d78:	sub.w	r2, sl, #512	; 0x200
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    5d7c:	str	r3, [sp, #24]
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    5d7e:	add.w	r9, sp, #92	; 0x5c
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5d82:	ldr	r3, [sp, #20]
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    5d84:	ldrh.w	lr, [r4, #38]	; 0x26
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5d88:	str	r2, [sp, #20]
    5d8a:	movs	r2, #12
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5d8c:	str	r3, [r5, #0]
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    5d8e:	movs	r3, #0
    5d90:	ldr	r1, [r4, #40]	; 0x28
    5d92:	str	r0, [sp, #92]	; 0x5c
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    5d94:	mov	r8, r3
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5d96:	ldr	r0, [sp, #20]
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    5d98:	strh.w	ip, [sp, #96]	; 0x60
    5d9c:	strh.w	lr, [sp, #98]	; 0x62
    5da0:	str	r1, [sp, #100]	; 0x64
    5da2:	strb	r3, [r4, #0]
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5da4:	str	r2, [r4, #4]
    5da6:	b.n	5dd0 <loop+0xc58>
    5da8:	.word	0x20006480
    5dac:	.word	0x200015e4
    5db0:	.word	0x20006280
    5db4:	.word	0x20006060
    5db8:	.word	0x200001b8
    5dbc:	.word	0x20000b74
    5dc0:	.word	0x20000018
    5dc4:	.word	0x2000158c
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    5dc8:	cmp.w	r8, #11
    5dcc:	bgt.n	5e0a <loop+0xc92>
    5dce:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5dd0:	rsb	fp, r0, sl
    5dd4:	rsb	r3, r8, #12
          memcpy(dst,src,to_copy);
    5dd8:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5dda:	cmp	fp, r3
    5ddc:	it	ge
    5dde:	movge	fp, r3
          memcpy(dst,src,to_copy);
    5de0:	mov	r2, fp
          pos += to_copy;
    5de2:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    5de4:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5de8:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5dea:	add	r9, fp
          dst += to_copy;
    5dec:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5dee:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5df0:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5df2:	bne.n	5dc8 <loop+0xc50>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5df4:	movs	r2, #60	; 0x3c
    5df6:	mov.w	r1, #512	; 0x200
    5dfa:	ldr	r0, [pc, #712]	; (60c4 <loop+0xf4c>)
    5dfc:	bl	9d50 <usb_mtp_send>
    5e00:	cmp	r0, #0
    5e02:	ble.n	5df4 <loop+0xc7c>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    5e04:	ldr	r3, [pc, #700]	; (60c4 <loop+0xf4c>)
    5e06:	str	r3, [r5, #0]
    5e08:	b.n	5dc8 <loop+0xc50>
    char * getName(uint32_t store) {return zFs[store].getName();}

    uint32_t Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    5e0a:	ldr	r1, [sp, #8]
    5e0c:	ldr	r0, [pc, #696]	; (60c8 <loop+0xf50>)
    5e0e:	bl	6dd8 <zeroFS_class::GetSize(unsigned long)>

    void GetObject(uint32_t object_id) 
    {
      uint32_t size = mFS.GetSize(object_id);

      if (write_get_length_) {
    5e12:	ldrb	r3, [r4, #0]
    char * getName(uint32_t store) {return zFs[store].getName();}

    uint32_t Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    5e14:	mov	fp, r0

    void GetObject(uint32_t object_id) 
    {
      uint32_t size = mFS.GetSize(object_id);

      if (write_get_length_) {
    5e16:	ldr	r2, [pc, #692]	; (60cc <loop+0xf54>)
    5e18:	cmp	r3, #0
    5e1a:	bne.n	5f14 <loop+0xd9c>
        uint32_t pos = 0; // into data
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;

        disk_pos=DISK_BUFFER_SIZE;
    5e1c:	movw	r0, #9248	; 0x2420
    5e20:	mov.w	r1, #8192	; 0x2000
      } else 
      { 
        uint32_t pos = 0; // into data
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;
    5e24:	mov.w	r5, fp, lsr #9

        disk_pos=DISK_BUFFER_SIZE;
    5e28:	str	r1, [r2, r0]
      } else 
      { 
        uint32_t pos = 0; // into data
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;
    5e2a:	str	r5, [sp, #28]

        disk_pos=DISK_BUFFER_SIZE;
        while(pos<size)
    5e2c:	cmp.w	fp, #0
    5e30:	beq.n	5ea6 <loop+0xd2e>
    5e32:	mov	sl, r3
    { if(!usb_mtp_available()) return;
      if(fetch_packet(rx_data_buffer))
      { printContainer(); // to switch on set debug to 1 at beginning of file

        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
    5e34:	ldr	r3, [sp, #8]
    5e36:	str	r6, [sp, #36]	; 0x24
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;

        disk_pos=DISK_BUFFER_SIZE;
        while(pos<size)
    5e38:	mov.w	r9, #12
    { if(!usb_mtp_available()) return;
      if(fetch_packet(rx_data_buffer))
      { printContainer(); // to switch on set debug to 1 at beginning of file

        int op = CONTAINER->op;
        int p1 = CONTAINER->params[0];
    5e3c:	str	r3, [sp, #32]
    5e3e:	mov	r6, r1
    5e40:	ldr	r5, [pc, #652]	; (60d0 <loop+0xf58>)
    5e42:	ldr.w	r8, [sp, #20]
    5e46:	b.n	5e4e <loop+0xcd6>
        uint32_t len = sizeof(MTPHeader);
        uint32_t sector = object_id;
        uint32_t count = size / 512;

        disk_pos=DISK_BUFFER_SIZE;
        while(pos<size)
    5e48:	cmp	fp, sl
    5e4a:	bls.n	5e9e <loop+0xd26>
    5e4c:	ldr	r6, [r5, #0]
        {
          if(disk_pos==DISK_BUFFER_SIZE)
    5e4e:	cmp.w	r6, #8192	; 0x2000
    5e52:	beq.n	5ed4 <loop+0xd5c>
    5e54:	rsb	r2, r6, #8192	; 0x2000
    5e58:	adds	r1, r7, r6
            count-=MCOUNT;

            disk_pos=0;
          }

          uint32_t to_copy = min(size-pos,MTP_TX_SIZE-len);
    5e5a:	rsb	r6, r9, #512	; 0x200
    5e5e:	rsb	r3, sl, fp
          to_copy = min (to_copy, DISK_BUFFER_SIZE-disk_pos);

          memcpy(tx_data_buffer+len,disk_buffer+disk_pos,to_copy);
    5e62:	add.w	r0, r8, r9
            count-=MCOUNT;

            disk_pos=0;
          }

          uint32_t to_copy = min(size-pos,MTP_TX_SIZE-len);
    5e66:	cmp	r6, r3
    5e68:	it	cs
    5e6a:	movcs	r6, r3
          to_copy = min (to_copy, DISK_BUFFER_SIZE-disk_pos);
    5e6c:	cmp	r6, r2
    5e6e:	it	cs
    5e70:	movcs	r6, r2

          memcpy(tx_data_buffer+len,disk_buffer+disk_pos,to_copy);
    5e72:	mov	r2, r6
          disk_pos += to_copy;
          pos += to_copy;
          len += to_copy;
    5e74:	add	r9, r6
          }

          uint32_t to_copy = min(size-pos,MTP_TX_SIZE-len);
          to_copy = min (to_copy, DISK_BUFFER_SIZE-disk_pos);

          memcpy(tx_data_buffer+len,disk_buffer+disk_pos,to_copy);
    5e76:	bl	7f58 <memcpy>
          disk_pos += to_copy;
    5e7a:	ldr	r3, [r5, #0]
          pos += to_copy;
    5e7c:	add	sl, r6
          len += to_copy;

          if(len==MTP_TX_SIZE)
    5e7e:	cmp.w	r9, #512	; 0x200

          uint32_t to_copy = min(size-pos,MTP_TX_SIZE-len);
          to_copy = min (to_copy, DISK_BUFFER_SIZE-disk_pos);

          memcpy(tx_data_buffer+len,disk_buffer+disk_pos,to_copy);
          disk_pos += to_copy;
    5e82:	add	r6, r3
    5e84:	str	r6, [r5, #0]
          pos += to_copy;
          len += to_copy;

          if(len==MTP_TX_SIZE)
    5e86:	bne.n	5e48 <loop+0xcd0>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5e88:	movs	r2, #60	; 0x3c
    5e8a:	mov.w	r1, #512	; 0x200
    5e8e:	ldr	r0, [pc, #564]	; (60c4 <loop+0xf4c>)
    5e90:	bl	9d50 <usb_mtp_send>
    5e94:	cmp	r0, #0
    5e96:	ble.n	5e88 <loop+0xd10>
          pos += to_copy;
          len += to_copy;

          if(len==MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            len=0;
    5e98:	mov.w	r9, #0
    5e9c:	b.n	5e48 <loop+0xcd0>
    5e9e:	ldr	r6, [sp, #36]	; 0x24
          }
        }
        if(len>0)
    5ea0:	cmp.w	r9, #0
    5ea4:	beq.n	5eb6 <loop+0xd3e>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5ea6:	movs	r2, #60	; 0x3c
    5ea8:	mov.w	r1, #512	; 0x200
    5eac:	ldr	r0, [pc, #532]	; (60c4 <loop+0xf4c>)
    5eae:	bl	9d50 <usb_mtp_send>
    5eb2:	cmp	r0, #0
    5eb4:	ble.n	5ea6 <loop+0xd2e>
          case 0x1008:  // GetObjectInfo
            TRANSMIT(GetObjectInfo(p1));
            break;

          case 0x1009:  // GetObject
            TRANSMIT(GetObject(p1));
    5eb6:	ldr	r3, [sp, #24]
    5eb8:	ubfx	r5, r3, #0, #9
    5ebc:	cmp	r5, #0
    5ebe:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5ec2:	movs	r2, #60	; 0x3c
    5ec4:	mov	r1, r5
    5ec6:	ldr	r0, [pc, #508]	; (60c4 <loop+0xf4c>)
    5ec8:	bl	9d50 <usb_mtp_send>
    5ecc:	cmp	r0, #0
    5ece:	ble.n	5ec2 <loop+0xd4a>
    5ed0:	b.w	5408 <loop+0x290>
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    
    uint32_t Read(uint32_t handle, char* out, uint32_t count) 
    { return zFs[0].Read(handle, out, count);}
    5ed4:	ldr	r0, [sp, #28]
    5ed6:	ldr	r1, [sp, #32]
    5ed8:	mov	r3, r0
    5eda:	cmp	r0, #16
          if(disk_pos==DISK_BUFFER_SIZE)
          {
//            uint32_t nread=min(size-pos,(uint32_t)DISK_BUFFER_SIZE);
//            mFS.Read(object_id,size,pos,(char *)disk_buffer,nread);
            sector = mFS.Read(sector, (char *)disk_buffer, min(count,MCOUNT));
            count-=MCOUNT;
    5edc:	sub.w	r0, r0, #16
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    
    uint32_t Read(uint32_t handle, char* out, uint32_t count) 
    { return zFs[0].Read(handle, out, count);}
    5ee0:	ldr	r2, [pc, #496]	; (60d4 <loop+0xf5c>)
    5ee2:	it	cs
    5ee4:	movcs	r3, #16
          if(disk_pos==DISK_BUFFER_SIZE)
          {
//            uint32_t nread=min(size-pos,(uint32_t)DISK_BUFFER_SIZE);
//            mFS.Read(object_id,size,pos,(char *)disk_buffer,nread);
            sector = mFS.Read(sector, (char *)disk_buffer, min(count,MCOUNT));
            count-=MCOUNT;
    5ee6:	str	r0, [sp, #28]
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    
    uint32_t Read(uint32_t handle, char* out, uint32_t count) 
    { return zFs[0].Read(handle, out, count);}
    5ee8:	ldr	r0, [pc, #476]	; (60c8 <loop+0xf50>)
    5eea:	bl	6e0c <zeroFS_class::Read(unsigned long, char*, unsigned long)>
//            uint32_t nread=min(size-pos,(uint32_t)DISK_BUFFER_SIZE);
//            mFS.Read(object_id,size,pos,(char *)disk_buffer,nread);
            sector = mFS.Read(sector, (char *)disk_buffer, min(count,MCOUNT));
            count-=MCOUNT;

            disk_pos=0;
    5eee:	movs	r3, #0
    { return zFs[0].Info(handle, filename, size, parent);}

    uint32_t GetSize(uint32_t handle) {return zFs[0].GetSize(handle);}
    
    uint32_t Read(uint32_t handle, char* out, uint32_t count) 
    { return zFs[0].Read(handle, out, count);}
    5ef0:	str	r0, [sp, #32]
//            uint32_t nread=min(size-pos,(uint32_t)DISK_BUFFER_SIZE);
//            mFS.Read(object_id,size,pos,(char *)disk_buffer,nread);
            sector = mFS.Read(sector, (char *)disk_buffer, min(count,MCOUNT));
            count-=MCOUNT;

            disk_pos=0;
    5ef2:	mov	r2, r6
    5ef4:	ldr	r1, [pc, #476]	; (60d4 <loop+0xf5c>)
    5ef6:	str	r3, [r5, #0]
    5ef8:	b.n	5e5a <loop+0xce2>
        break;
    }
  }

  void GetDevicePropDesc(uint32_t prop) {
    switch (prop) {
    5efa:	movs	r2, #12
    5efc:	ldr	r0, [sp, #12]
    5efe:	str	r2, [sp, #24]
    5f00:	b.w	562a <loop+0x4b2>
    void GetObject(uint32_t object_id) 
    {
      uint32_t size = mFS.GetSize(object_id);

      if (write_get_length_) {
        write_length_ += size;
    5f04:	ldr	r3, [r7, #4]
    5f06:	add.w	r2, r7, #544	; 0x220
    5f0a:	add.w	r7, r7, #1056	; 0x420
    5f0e:	str	r2, [sp, #20]
    5f10:	add	r3, r0
    5f12:	b.n	5d6a <loop+0xbf2>
    5f14:	ldr	r3, [r2, #4]
    5f16:	add	r3, r0
    5f18:	str	r3, [r2, #4]
    5f1a:	b.n	5eb6 <loop+0xd3e>

#define Store2Storage(x) (x+1)
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    5f1c:	movs	r1, #28
    5f1e:	mov	sl, r7
    5f20:	b.n	58d0 <loop+0x758>
      }
    }
  }

  void GetDevicePropValue(uint32_t prop) {
    switch (prop) {
    5f22:	movs	r3, #84	; 0x54
    5f24:	ldr	r2, [pc, #432]	; (60d8 <loop+0xf60>)
    5f26:	b.n	5f2a <loop+0xdb2>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    5f28:	mov	fp, r1
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5f2a:	uxth	r0, r3
    5f2c:	ldrb.w	r3, [r2, #1]!
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    5f30:	add.w	r1, fp, #2
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    5f34:	cmp	r3, #0
    5f36:	bne.n	5f28 <loop+0xdb0>
    5f38:	add.w	r2, fp, #16
    5f3c:	strh.w	r0, [sp, #62]	; 0x3e
    5f40:	strh.w	r3, [sp, #60]	; 0x3c
    5f44:	str	r2, [sp, #24]
    5f46:	b.n	5a46 <loop+0x8ce>
{
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    5f48:	ldr	r2, [sp, #8]
    5f4a:	movw	r5, #10864	; 0x2a70
    5f4e:	ldr	r3, [pc, #396]	; (60dc <loop+0xf64>)
          case 0x1007:  // GetObjectHandles
            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    5f50:	movs	r0, #1
{
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    5f52:	subs	r2, #1
    5f54:	mov	r1, r8
          case 0x1007:  // GetObjectHandles
            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    5f56:	strb	r0, [r4, #0]
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    5f58:	mov	sl, r9
{
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    5f5a:	mla	r3, r5, r2, r3
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5f5e:	ldr	r5, [pc, #384]	; (60e0 <loop+0xf68>)
          case 0x1007:  // GetObjectHandles
            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    5f60:	str.w	r9, [r4, #4]
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
    5f64:	add.w	fp, sp, #92	; 0x5c
{
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    5f68:	adds	r3, #80	; 0x50
    5f6a:	mov	r0, r3
    5f6c:	str	r3, [sp, #24]
    5f6e:	bl	6c94 <zeroFS_class::Count(unsigned long)>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5f72:	ldr	r3, [pc, #336]	; (60c4 <loop+0xf4c>)
          case 0x1007:  // GetObjectHandles
            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    5f74:	lsls	r0, r0, #2
    5f76:	movs	r1, #2
    5f78:	add.w	r7, r3, #512	; 0x200
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5f7c:	str	r3, [sp, #20]
          case 0x1007:  // GetObjectHandles
            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    5f7e:	add.w	r2, r0, #16
    5f82:	ldrh.w	lr, [r4, #38]	; 0x26
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5f86:	mov	r0, r3
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5f88:	str	r3, [r5, #0]
          case 0x1007:  // GetObjectHandles
            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    5f8a:	str	r2, [sp, #92]	; 0x5c
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5f8c:	movs	r2, #12
          case 0x1007:  // GetObjectHandles
            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    5f8e:	ldr	r3, [r4, #40]	; 0x28
    5f90:	strb.w	r9, [r4]
    5f94:	strh.w	r1, [sp, #96]	; 0x60
    5f98:	strh.w	lr, [sp, #98]	; 0x62
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    5f9c:	str	r2, [r4, #4]
          case 0x1007:  // GetObjectHandles
            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    5f9e:	str	r3, [sp, #100]	; 0x64
    5fa0:	b.n	5fac <loop+0xe34>
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    5fa2:	cmp.w	sl, #11
    5fa6:	bgt.w	63a0 <loop+0x1228>
    5faa:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5fac:	ldr	r3, [pc, #292]	; (60d4 <loop+0xf5c>)
          memcpy(dst,src,to_copy);
    5fae:	mov	r1, fp
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    5fb0:	rsb	r9, r0, r3
    5fb4:	rsb	r3, sl, #12
    5fb8:	cmp	r9, r3
    5fba:	it	ge
    5fbc:	movge	r9, r3
          memcpy(dst,src,to_copy);
    5fbe:	mov	r2, r9
          pos += to_copy;
    5fc0:	add	sl, r9
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    5fc2:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5fc6:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    5fc8:	add	fp, r9
          dst += to_copy;
    5fca:	add	r3, r9
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5fcc:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    5fce:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    5fd0:	bne.n	5fa2 <loop+0xe2a>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    5fd2:	movs	r2, #60	; 0x3c
    5fd4:	mov.w	r1, #512	; 0x200
    5fd8:	ldr	r0, [pc, #232]	; (60c4 <loop+0xf4c>)
    5fda:	bl	9d50 <usb_mtp_send>
    5fde:	cmp	r0, #0
    5fe0:	ble.n	5fd2 <loop+0xe5a>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    5fe2:	ldr	r3, [pc, #224]	; (60c4 <loop+0xf4c>)
    5fe4:	str	r3, [r5, #0]
    5fe6:	b.n	5fa2 <loop+0xe2a>
    5fe8:	ldr	r3, [r4, #4]
    5fea:	b.n	5d6a <loop+0xbf2>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    5fec:	ldr.w	r3, [r8, #4]
    5ff0:	cbnz	r3, 5ff6 <loop+0xe7e>
    5ff2:	ldr	r2, [sp, #20]
    5ff4:	str	r2, [r5, #0]
        write_length_ += len;
    5ff6:	adds	r3, #1
        
        const char * src=data;
    5ff8:	add.w	r9, sp, #50	; 0x32
        //
        int pos = 0; // into data
    5ffc:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    6000:	str	r3, [r4, #4]
    6002:	b.n	600a <loop+0xe92>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    6004:	cmp.w	r8, #0
    6008:	bgt.n	6046 <loop+0xece>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
    600a:	ldr	r0, [r5, #0]
          int to_copy = min(len - pos, avail);
    600c:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    6010:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    6012:	rsb	fp, r0, sl
    6016:	cmp	fp, r3
    6018:	it	ge
    601a:	movge	fp, r3
          memcpy(dst,src,to_copy);
    601c:	mov	r2, fp
          pos += to_copy;
    601e:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    6020:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6024:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    6026:	add	r9, fp
          dst += to_copy;
    6028:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    602a:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    602c:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    602e:	bne.n	6004 <loop+0xe8c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    6030:	movs	r2, #60	; 0x3c
    6032:	mov.w	r1, #512	; 0x200
    6036:	ldr	r0, [pc, #140]	; (60c4 <loop+0xf4c>)
    6038:	bl	9d50 <usb_mtp_send>
    603c:	cmp	r0, #0
    603e:	ble.n	6030 <loop+0xeb8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    6040:	ldr	r3, [pc, #128]	; (60c4 <loop+0xf4c>)
    6042:	str	r3, [r5, #0]
    6044:	b.n	6004 <loop+0xe8c>
    6046:	ldr	r3, [sp, #92]	; 0x5c
    6048:	str	r3, [sp, #24]
    604a:	b.n	5b94 <loop+0xa1c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    604c:	cbnz	r3, 6052 <loop+0xeda>
    604e:	ldr	r2, [sp, #20]
    6050:	str	r2, [r5, #0]
        write_length_ += len;
    6052:	adds	r3, #4
        
        const char * src=data;
    6054:	add.w	sl, sp, #72	; 0x48
        //
        int pos = 0; // into data
    6058:	mov.w	r9, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    605c:	str	r3, [r4, #4]
    605e:	b.n	6066 <loop+0xeee>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    6060:	cmp.w	r9, #3
    6064:	bgt.n	60a2 <loop+0xf2a>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
    6066:	ldr	r0, [r5, #0]
          int to_copy = min(len - pos, avail);
    6068:	rsb	r3, r9, #4
          memcpy(dst,src,to_copy);
    606c:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    606e:	rsb	fp, r0, r8
    6072:	cmp	fp, r3
    6074:	it	ge
    6076:	movge	fp, r3
          memcpy(dst,src,to_copy);
    6078:	mov	r2, fp
          pos += to_copy;
    607a:	add	r9, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    607c:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6080:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    6082:	add	sl, fp
          dst += to_copy;
    6084:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6086:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6088:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    608a:	bne.n	6060 <loop+0xee8>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    608c:	movs	r2, #60	; 0x3c
    608e:	mov.w	r1, #512	; 0x200
    6092:	ldr	r0, [pc, #48]	; (60c4 <loop+0xf4c>)
    6094:	bl	9d50 <usb_mtp_send>
    6098:	cmp	r0, #0
    609a:	ble.n	608c <loop+0xf14>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    609c:	ldr	r3, [pc, #36]	; (60c4 <loop+0xf4c>)
    609e:	str	r3, [r5, #0]
    60a0:	b.n	6060 <loop+0xee8>
    60a2:	movs	r1, #1
    60a4:	ldrb	r2, [r4, #0]
    60a6:	ldr	r3, [r4, #4]
    60a8:	str	r1, [sp, #76]	; 0x4c
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    60aa:	cmp	r2, #0
    60ac:	bne.w	5be8 <loop+0xa70>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    60b0:	cmp	r3, #0
    60b2:	beq.n	6128 <loop+0xfb0>
    60b4:	ldr	r0, [r5, #0]
        write_length_ += len;
    60b6:	adds	r3, #4
        
        const char * src=data;
    60b8:	add.w	sl, sp, #76	; 0x4c
        //
        int pos = 0; // into data
    60bc:	mov.w	r9, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    60c0:	str	r3, [r4, #4]
    60c2:	b.n	60ee <loop+0xf76>
    60c4:	.word	0x20006280
    60c8:	.word	0x200015e4
    60cc:	.word	0x20006060
    60d0:	.word	0x20008480
    60d4:	.word	0x20006480
    60d8:	.word	0x200001b8
    60dc:	.word	0x20001594
    60e0:	.word	0x2000158c
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    60e4:	cmp.w	r9, #3
    60e8:	bgt.w	5bec <loop+0xa74>
    60ec:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    60ee:	rsb	fp, r0, r8
    60f2:	rsb	r3, r9, #4
          memcpy(dst,src,to_copy);
    60f6:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    60f8:	cmp	fp, r3
    60fa:	it	ge
    60fc:	movge	fp, r3
          memcpy(dst,src,to_copy);
    60fe:	mov	r2, fp
          pos += to_copy;
    6100:	add	r9, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    6102:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6106:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    6108:	add	sl, fp
          dst += to_copy;
    610a:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    610c:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    610e:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6110:	bne.n	60e4 <loop+0xf6c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    6112:	movs	r2, #60	; 0x3c
    6114:	mov.w	r1, #512	; 0x200
    6118:	ldr	r0, [pc, #624]	; (638c <loop+0x1214>)
    611a:	bl	9d50 <usb_mtp_send>
    611e:	cmp	r0, #0
    6120:	ble.n	6112 <loop+0xf9a>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    6122:	ldr	r3, [pc, #616]	; (638c <loop+0x1214>)
    6124:	str	r3, [r5, #0]
    6126:	b.n	60e4 <loop+0xf6c>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    6128:	ldr	r2, [sp, #20]
    612a:	ldr	r0, [pc, #608]	; (638c <loop+0x1214>)
    612c:	str	r2, [r5, #0]
    612e:	b.n	60b6 <loop+0xf3e>
    6130:	ldr	r3, [r2, #4]
    6132:	cbnz	r3, 6138 <loop+0xfc0>
    6134:	ldr	r2, [sp, #20]
    6136:	str	r2, [r5, #0]
        write_length_ += len;
    6138:	adds	r3, #4
        
        const char * src=data;
    613a:	add.w	r9, sp, #88	; 0x58
        //
        int pos = 0; // into data
    613e:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    6142:	str	r3, [r4, #4]
    6144:	b.n	614c <loop+0xfd4>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    6146:	cmp.w	r8, #3
    614a:	bgt.n	6188 <loop+0x1010>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
    614c:	ldr	r0, [r5, #0]
          int to_copy = min(len - pos, avail);
    614e:	rsb	r3, r8, #4
          memcpy(dst,src,to_copy);
    6152:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    6154:	rsb	fp, r0, sl
    6158:	cmp	fp, r3
    615a:	it	ge
    615c:	movge	fp, r3
          memcpy(dst,src,to_copy);
    615e:	mov	r2, fp
          pos += to_copy;
    6160:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    6162:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6166:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    6168:	add	r9, fp
          dst += to_copy;
    616a:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    616c:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    616e:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6170:	bne.n	6146 <loop+0xfce>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    6172:	movs	r2, #60	; 0x3c
    6174:	mov.w	r1, #512	; 0x200
    6178:	ldr	r0, [pc, #528]	; (638c <loop+0x1214>)
    617a:	bl	9d50 <usb_mtp_send>
    617e:	cmp	r0, #0
    6180:	ble.n	6172 <loop+0xffa>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    6182:	ldr	r3, [pc, #520]	; (638c <loop+0x1214>)
    6184:	str	r3, [r5, #0]
    6186:	b.n	6146 <loop+0xfce>
    6188:	ldr	r3, [pc, #516]	; (6390 <loop+0x1218>)
    618a:	ldr	r3, [r3, #0]
    618c:	b.n	5c94 <loop+0xb1c>
    618e:	mov	r2, r7
    6190:	mov	r0, r5
    6192:	add	r1, sp, #48	; 0x30
    6194:	bl	7c <MTPD::write(char const*, int) [clone .part.8]>
    6198:	ldr	r2, [r5, #4]
    619a:	ldrh	r3, [r5, #38]	; 0x26
    619c:	adds	r2, #12
    619e:	ldr	r0, [r5, #40]	; 0x28
    61a0:	str	r2, [sp, #24]
    61a2:	b.w	562a <loop+0x4b2>
    61a6:	movs	r1, #7
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    61a8:	ldrb	r2, [r4, #0]
    61aa:	ldr	r3, [pc, #488]	; (6394 <loop+0x121c>)
    61ac:	strb.w	r1, [sp, #51]	; 0x33
    61b0:	cmp	r2, #0
    61b2:	beq.w	6472 <loop+0x12fa>
      {
        write_length_ += len;
    61b6:	ldr	r2, [r3, #4]
    61b8:	adds	r2, #1
    61ba:	str	r2, [r3, #4]
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
        
        const char * src=data;
        //
        int pos = 0; // into data
    61bc:	ldr	r0, [pc, #472]	; (6398 <loop+0x1220>)
    61be:	movs	r2, #84	; 0x54
    61c0:	ldrb	r1, [r4, #0]
    61c2:	ldr	r3, [r4, #4]
    61c4:	mov	fp, r0
    61c6:	str	r6, [sp, #24]
    61c8:	b.n	61d4 <loop+0x105c>
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    61ca:	adds	r3, #2
#define Storage2Store(x) (x-1)

  void writestring(const char* str) {
    if (*str) 
    { write8(strlen(str) + 1);
      while (*str) {  write16(*str);  ++str;  } write16(0);
    61cc:	ldrb.w	r2, [fp, #1]!
    61d0:	cmp	r2, #0
    61d2:	beq.n	6242 <loop+0x10ca>
    61d4:	strh.w	r2, [sp, #66]	; 0x42
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    61d8:	cmp	r1, #0
    61da:	bne.n	61ca <loop+0x1052>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    61dc:	cbz	r3, 6236 <loop+0x10be>
    61de:	ldr	r0, [r5, #0]
        write_length_ += len;
    61e0:	adds	r3, #2
        
        const char * src=data;
    61e2:	add.w	sl, sp, #66	; 0x42
        //
        int pos = 0; // into data
    61e6:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    61ea:	str	r3, [r4, #4]
    61ec:	b.n	61f6 <loop+0x107e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    61ee:	cmp.w	r8, #1
    61f2:	bgt.n	6230 <loop+0x10b8>
    61f4:	ldr	r0, [r5, #0]
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    61f6:	rsb	r2, r0, r9
    61fa:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    61fe:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    6200:	cmp	r2, r3
    6202:	it	ge
    6204:	movge	r2, r3
    6206:	mov	r6, r2
          memcpy(dst,src,to_copy);
          pos += to_copy;
    6208:	add	r8, r2
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    620a:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    620e:	ldr	r2, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    6210:	add	sl, r6
          dst += to_copy;
    6212:	adds	r3, r2, r6
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6214:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6216:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6218:	bne.n	61ee <loop+0x1076>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    621a:	movs	r2, #60	; 0x3c
    621c:	mov.w	r1, #512	; 0x200
    6220:	ldr	r0, [pc, #360]	; (638c <loop+0x1214>)
    6222:	bl	9d50 <usb_mtp_send>
    6226:	cmp	r0, #0
    6228:	ble.n	621a <loop+0x10a2>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    622a:	ldr	r3, [sp, #20]
    622c:	str	r3, [r5, #0]
    622e:	b.n	61ee <loop+0x1076>
    6230:	ldrb	r1, [r4, #0]
    6232:	ldr	r3, [r4, #4]
    6234:	b.n	61cc <loop+0x1054>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    6236:	ldr	r2, [sp, #20]
    6238:	str	r2, [r5, #0]
    623a:	ldr	r2, [pc, #336]	; (638c <loop+0x1214>)
    623c:	str	r2, [sp, #20]
    623e:	mov	r0, r2
    6240:	b.n	61e0 <loop+0x1068>
    6242:	ldr	r6, [sp, #24]
    6244:	strh.w	r2, [sp, #64]	; 0x40
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    6248:	cmp	r1, #0
    624a:	beq.w	64cc <loop+0x1354>
      {
        write_length_ += len;
    624e:	adds	r3, #2
    6250:	ldr	r2, [sp, #92]	; 0x5c
    6252:	str	r3, [r4, #4]
    6254:	str	r2, [sp, #24]
    6256:	b.n	5acc <loop+0x954>
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    6258:	cbnz	r3, 625e <loop+0x10e6>
    625a:	ldr	r2, [sp, #20]
    625c:	str	r2, [r5, #0]
        write_length_ += len;
    625e:	adds	r3, #2
        
        const char * src=data;
    6260:	add.w	r9, sp, #56	; 0x38
        //
        int pos = 0; // into data
    6264:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    6268:	str	r3, [r4, #4]
    626a:	b.n	6272 <loop+0x10fa>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    626c:	cmp.w	r8, #1
    6270:	bgt.n	62ae <loop+0x1136>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
    6272:	ldr	r0, [r5, #0]
          int to_copy = min(len - pos, avail);
    6274:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    6278:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    627a:	rsb	fp, r0, sl
    627e:	cmp	fp, r3
    6280:	it	ge
    6282:	movge	fp, r3
          memcpy(dst,src,to_copy);
    6284:	mov	r2, fp
          pos += to_copy;
    6286:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    6288:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    628c:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    628e:	add	r9, fp
          dst += to_copy;
    6290:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6292:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6294:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6296:	bne.n	626c <loop+0x10f4>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    6298:	movs	r2, #60	; 0x3c
    629a:	mov.w	r1, #512	; 0x200
    629e:	ldr	r0, [pc, #236]	; (638c <loop+0x1214>)
    62a0:	bl	9d50 <usb_mtp_send>
    62a4:	cmp	r0, #0
    62a6:	ble.n	6298 <loop+0x1120>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    62a8:	ldr	r3, [pc, #224]	; (638c <loop+0x1214>)
    62aa:	str	r3, [r5, #0]
    62ac:	b.n	626c <loop+0x10f4>
    62ae:	movw	r1, #65535	; 0xffff
    62b2:	ldrb	r2, [r4, #0]
    62b4:	ldr	r3, [r4, #4]
    62b6:	strh.w	r1, [sp, #58]	; 0x3a
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    62ba:	cmp	r2, #0
    62bc:	bne.w	5b58 <loop+0x9e0>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    62c0:	cbnz	r3, 62c6 <loop+0x114e>
    62c2:	ldr	r2, [sp, #20]
    62c4:	str	r2, [r5, #0]
        write_length_ += len;
    62c6:	adds	r3, #2
        
        const char * src=data;
    62c8:	add.w	r9, sp, #58	; 0x3a
        //
        int pos = 0; // into data
    62cc:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    62d0:	str	r3, [r4, #4]
    62d2:	b.n	62da <loop+0x1162>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    62d4:	cmp.w	r8, #1
    62d8:	bgt.n	6316 <loop+0x119e>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
    62da:	ldr	r0, [r5, #0]
          int to_copy = min(len - pos, avail);
    62dc:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    62e0:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    62e2:	rsb	fp, r0, sl
    62e6:	cmp	fp, r3
    62e8:	it	ge
    62ea:	movge	fp, r3
          memcpy(dst,src,to_copy);
    62ec:	mov	r2, fp
          pos += to_copy;
    62ee:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    62f0:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    62f4:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    62f6:	add	r9, fp
          dst += to_copy;
    62f8:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    62fa:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    62fc:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    62fe:	bne.n	62d4 <loop+0x115c>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    6300:	movs	r2, #60	; 0x3c
    6302:	mov.w	r1, #512	; 0x200
    6306:	ldr	r0, [pc, #132]	; (638c <loop+0x1214>)
    6308:	bl	9d50 <usb_mtp_send>
    630c:	cmp	r0, #0
    630e:	ble.n	6300 <loop+0x1188>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    6310:	ldr	r3, [pc, #120]	; (638c <loop+0x1214>)
    6312:	str	r3, [r5, #0]
    6314:	b.n	62d4 <loop+0x115c>
    6316:	movs	r1, #0
    6318:	ldrb	r2, [r4, #0]
    631a:	ldr	r3, [r4, #4]
    631c:	strb.w	r1, [sp, #49]	; 0x31
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    6320:	cmp	r2, #0
    6322:	bne.w	5b60 <loop+0x9e8>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    6326:	cbnz	r3, 632c <loop+0x11b4>
    6328:	ldr	r2, [sp, #20]
    632a:	str	r2, [r5, #0]
        write_length_ += len;
    632c:	adds	r3, #1
        
        const char * src=data;
    632e:	add.w	r9, sp, #49	; 0x31
        //
        int pos = 0; // into data
    6332:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    6336:	str	r3, [r4, #4]
    6338:	b.n	6342 <loop+0x11ca>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    633a:	cmp.w	r8, #0
    633e:	bgt.w	5b64 <loop+0x9ec>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
    6342:	ldr	r0, [r5, #0]
          int to_copy = min(len - pos, avail);
    6344:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    6348:	mov	r1, r9
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    634a:	rsb	fp, r0, sl
    634e:	cmp	fp, r3
    6350:	it	ge
    6352:	movge	fp, r3
          memcpy(dst,src,to_copy);
    6354:	mov	r2, fp
          pos += to_copy;
    6356:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    6358:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    635c:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    635e:	add	r9, fp
          dst += to_copy;
    6360:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6362:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6364:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6366:	bne.n	633a <loop+0x11c2>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    6368:	movs	r2, #60	; 0x3c
    636a:	mov.w	r1, #512	; 0x200
    636e:	ldr	r0, [pc, #28]	; (638c <loop+0x1214>)
    6370:	bl	9d50 <usb_mtp_send>
    6374:	cmp	r0, #0
    6376:	ble.n	6368 <loop+0x11f0>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    6378:	ldr	r3, [pc, #16]	; (638c <loop+0x1214>)
    637a:	str	r3, [r5, #0]
    637c:	b.n	633a <loop+0x11c2>
    637e:	sub.w	r2, r7, #512	; 0x200
    6382:	ldr	r5, [pc, #24]	; (639c <loop+0x1224>)
    6384:	mov	sl, r7
    6386:	str	r2, [sp, #20]
    6388:	b.n	5c0c <loop+0xa94>
    638a:	nop
    638c:	.word	0x20006280
    6390:	.word	0x20000b74
    6394:	.word	0x20006060
    6398:	.word	0x200001b8
    639c:	.word	0x2000158c
  }

  void GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);

    if (write_get_length_) {
    63a0:	ldrb	r3, [r4, #0]
{
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    63a2:	mov	r1, r8
  }

  void GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);

    if (write_get_length_) {
    63a4:	ldr.w	r9, [pc, #412]	; 6544 <loop+0x13cc>
{
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    63a8:	ldr	r0, [sp, #24]
  }

  void GetObjectHandles(uint32_t storage, uint32_t parent) 
  { uint32_t store = Storage2Store(storage);

    if (write_get_length_) {
    63aa:	cmp	r3, #0
    63ac:	bne.w	652a <loop+0x13b2>
{
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    63b0:	bl	6c94 <zeroFS_class::Count(unsigned long)>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    63b4:	ldrb.w	r3, [r9]
    63b8:	str	r0, [sp, #84]	; 0x54
    63ba:	cmp	r3, #0
    63bc:	beq.w	6538 <loop+0x13c0>
      {
        write_length_ += len;
    63c0:	ldr.w	r3, [r9, #4]
    63c4:	adds	r3, #4
    63c6:	str.w	r3, [r9, #4]

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    63ca:	ldr.w	sl, [pc, #380]	; 6548 <loop+0x13d0>
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    uint32_t Next(uint32_t store) {return zFs[store].Next();}
    63ce:	ldr	r0, [sp, #24]
    63d0:	bl	6d28 <zeroFS_class::Next()>
    {
      uint32_t num=0;
      num=GetNumObjects(storage,parent);
      write32(num);
      uint32_t handle;
      while((handle=mFS.Next(store))) write32(handle);
    63d4:	cbz	r0, 63ee <loop+0x1276>
    {
      return usb_mtp_recv(data_buffer,60);
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
    63d6:	ldrb	r2, [r4, #0]
    63d8:	str	r0, [sp, #80]	; 0x50
    63da:	ldr	r3, [pc, #360]	; (6544 <loop+0x13cc>)
    63dc:	cbz	r2, 640c <loop+0x1294>
      {
        write_length_ += len;
    63de:	ldr	r2, [r3, #4]
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    uint32_t Next(uint32_t store) {return zFs[store].Next();}
    63e0:	ldr	r0, [sp, #24]
    }

    void write(const char *data, int len) 
    { if (write_get_length_) 
      {
        write_length_ += len;
    63e2:	adds	r2, #4
    63e4:	str	r2, [r3, #4]
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    uint32_t Next(uint32_t store) {return zFs[store].Next();}
    63e6:	bl	6d28 <zeroFS_class::Next()>
    {
      uint32_t num=0;
      num=GetNumObjects(storage,parent);
      write32(num);
      uint32_t handle;
      while((handle=mFS.Next(store))) write32(handle);
    63ea:	cmp	r0, #0
    63ec:	bne.n	63d6 <loop+0x125e>
          case 0x1007:  // GetObjectHandles
            if (p2) 
            { return_code = 0x2014; // spec by format unsupported
            } else 
            { 
              TRANSMIT(GetObjectHandles(p1, p3));
    63ee:	ldr	r5, [sp, #92]	; 0x5c
    63f0:	ubfx	r5, r5, #0, #9
    63f4:	cmp	r5, #0
    63f6:	beq.w	5408 <loop+0x290>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    63fa:	movs	r2, #60	; 0x3c
    63fc:	mov	r1, r5
    63fe:	ldr	r0, [pc, #328]	; (6548 <loop+0x13d0>)
    6400:	bl	9d50 <usb_mtp_send>
    6404:	cmp	r0, #0
    6406:	ble.n	63fa <loop+0x1282>
    6408:	b.w	5408 <loop+0x290>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    640c:	ldr	r3, [r3, #4]
    640e:	cbnz	r3, 6414 <loop+0x129c>
    6410:	ldr	r2, [sp, #20]
    6412:	str	r2, [r5, #0]
        write_length_ += len;
    6414:	adds	r3, #4
        
        const char * src=data;
    6416:	add.w	fp, sp, #80	; 0x50
        //
        int pos = 0; // into data
    641a:	mov.w	r9, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    641e:	str	r3, [r4, #4]
    6420:	b.n	6428 <loop+0x12b0>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    6422:	cmp.w	r9, #3
    6426:	bgt.n	63ce <loop+0x1256>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
    6428:	ldr	r0, [r5, #0]
          int to_copy = min(len - pos, avail);
    642a:	rsb	r3, r9, #4
    642e:	ldr	r2, [pc, #284]	; (654c <loop+0x13d4>)
          memcpy(dst,src,to_copy);
    6430:	mov	r1, fp
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    6432:	rsb	r8, r0, r2
    6436:	cmp	r8, r3
    6438:	it	ge
    643a:	movge	r8, r3
          memcpy(dst,src,to_copy);
    643c:	mov	r2, r8
          pos += to_copy;
    643e:	add	r9, r8
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    6440:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6444:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    6446:	add	fp, r8
          dst += to_copy;
    6448:	add	r3, r8
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    644a:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    644c:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    644e:	bne.n	6422 <loop+0x12aa>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    6450:	movs	r2, #60	; 0x3c
    6452:	mov.w	r1, #512	; 0x200
    6456:	ldr	r0, [pc, #240]	; (6548 <loop+0x13d0>)
    6458:	bl	9d50 <usb_mtp_send>
    645c:	cmp	r0, #0
    645e:	ble.n	6450 <loop+0x12d8>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    6460:	str.w	sl, [r5]
    6464:	b.n	6422 <loop+0x12aa>
    6466:	add.w	r3, r7, #544	; 0x220
    646a:	add.w	r7, r7, #1056	; 0x420
    646e:	str	r3, [sp, #20]
    6470:	b.n	5d54 <loop+0xbdc>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    6472:	ldr	r3, [r3, #4]
    6474:	cbnz	r3, 647a <loop+0x1302>
    6476:	ldr	r2, [sp, #20]
    6478:	str	r2, [r5, #0]
        write_length_ += len;
    647a:	adds	r3, #1
        
        const char * src=data;
    647c:	add.w	sl, sp, #51	; 0x33
        //
        int pos = 0; // into data
    6480:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    6484:	str	r3, [r4, #4]
    6486:	b.n	6490 <loop+0x1318>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    6488:	cmp.w	r8, #0
    648c:	bgt.w	61bc <loop+0x1044>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
    6490:	ldr	r0, [r5, #0]
          int to_copy = min(len - pos, avail);
    6492:	rsb	r3, r8, #1
          memcpy(dst,src,to_copy);
    6496:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    6498:	rsb	fp, r0, r9
    649c:	cmp	fp, r3
    649e:	it	ge
    64a0:	movge	fp, r3
          memcpy(dst,src,to_copy);
    64a2:	mov	r2, fp
          pos += to_copy;
    64a4:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    64a6:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    64aa:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    64ac:	add	sl, fp
          dst += to_copy;
    64ae:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    64b0:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    64b2:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    64b4:	bne.n	6488 <loop+0x1310>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    64b6:	movs	r2, #60	; 0x3c
    64b8:	mov.w	r1, #512	; 0x200
    64bc:	ldr	r0, [pc, #136]	; (6548 <loop+0x13d0>)
    64be:	bl	9d50 <usb_mtp_send>
    64c2:	cmp	r0, #0
    64c4:	ble.n	64b6 <loop+0x133e>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    64c6:	ldr	r3, [pc, #128]	; (6548 <loop+0x13d0>)
    64c8:	str	r3, [r5, #0]
    64ca:	b.n	6488 <loop+0x1310>
        write_length_ += len;
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
    64cc:	cbnz	r3, 64d2 <loop+0x135a>
    64ce:	ldr	r2, [sp, #20]
    64d0:	str	r2, [r5, #0]
        write_length_ += len;
    64d2:	adds	r3, #2
        
        const char * src=data;
    64d4:	add.w	sl, sp, #64	; 0x40
        //
        int pos = 0; // into data
    64d8:	mov.w	r8, #0
      } 
      else 
      { 
        static uint8_t *dst=0;
        if(!write_length_) dst=tx_data_buffer;   
        write_length_ += len;
    64dc:	str	r3, [r4, #4]
    64de:	b.n	64e6 <loop+0x136e>
        
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
    64e0:	cmp.w	r8, #1
    64e4:	bgt.n	6522 <loop+0x13aa>
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
    64e6:	ldr	r0, [r5, #0]
          int to_copy = min(len - pos, avail);
    64e8:	rsb	r3, r8, #2
          memcpy(dst,src,to_copy);
    64ec:	mov	r1, sl
        const char * src=data;
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
    64ee:	rsb	fp, r0, r9
    64f2:	cmp	fp, r3
    64f4:	it	ge
    64f6:	movge	fp, r3
          memcpy(dst,src,to_copy);
    64f8:	mov	r2, fp
          pos += to_copy;
    64fa:	add	r8, fp
        //
        int pos = 0; // into data
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
    64fc:	bl	7f58 <memcpy>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6500:	ldr	r3, [r5, #0]
        while(pos<len)
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
    6502:	add	sl, fp
          dst += to_copy;
    6504:	add	r3, fp
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    6506:	cmp	r3, r7
        { int avail = tx_data_buffer+MTP_TX_SIZE - dst;
          int to_copy = min(len - pos, avail);
          memcpy(dst,src,to_copy);
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
    6508:	str	r3, [r5, #0]
          if(dst == tx_data_buffer+MTP_TX_SIZE)
    650a:	bne.n	64e0 <loop+0x1368>

#elif defined(__IMXRT1062__)  

    int push_packet(uint8_t *data_buffer,uint32_t len)
    {
      while(usb_mtp_send(data_buffer,len,60)<=0) ;
    650c:	movs	r2, #60	; 0x3c
    650e:	mov.w	r1, #512	; 0x200
    6512:	ldr	r0, [pc, #52]	; (6548 <loop+0x13d0>)
    6514:	bl	9d50 <usb_mtp_send>
    6518:	cmp	r0, #0
    651a:	ble.n	650c <loop+0x1394>
          pos += to_copy;
          src += to_copy;
          dst += to_copy;
          if(dst == tx_data_buffer+MTP_TX_SIZE)
          { push_packet(tx_data_buffer,MTP_TX_SIZE);
            dst=tx_data_buffer;
    651c:	ldr	r3, [sp, #20]
    651e:	str	r3, [r5, #0]
    6520:	b.n	64e0 <loop+0x1368>
    6522:	ldr	r3, [sp, #92]	; 0x5c
    6524:	str	r3, [sp, #24]
    6526:	b.w	5acc <loop+0x954>
{
   char name[80];
   zeroFS_class zFs[1];

public:
    uint32_t Count(uint32_t store,uint32_t parent) {return zFs[store].Count(parent);}
    652a:	bl	6c94 <zeroFS_class::Count(unsigned long)>
  { uint32_t store = Storage2Store(storage);

    if (write_get_length_) {
      write_length_ = GetNumObjects(storage, parent);
      write_length_++;
      write_length_ *= 4;
    652e:	adds	r0, #1
    6530:	lsls	r3, r0, #2
    6532:	str.w	r3, [r9, #4]
    6536:	b.n	63ee <loop+0x1276>
    6538:	mov	r0, r9
    653a:	movs	r2, #4
    653c:	add	r1, sp, #84	; 0x54
    653e:	bl	7c <MTPD::write(char const*, int) [clone .part.8]>
    6542:	b.n	63ca <loop+0x1252>
    6544:	.word	0x20006060
    6548:	.word	0x20006280
    654c:	.word	0x20006480

00006550 <_GLOBAL__sub_I_zFS>:
    6550:	push	{r4, lr}
  T_FILE,
} HDR_TYPE;

//#include "FS.h"

class zeroFS_class //: public FS
    6552:	mov.w	r4, #2048	; 0x800
    6556:	movs	r1, #0
    6558:	ldr	r0, [pc, #32]	; (657c <_GLOBAL__sub_I_zFS+0x2c>)
    655a:	mov	r2, r4
    655c:	bl	b73c <memset>
    6560:	mov	r2, r4
    6562:	movs	r1, #0
    6564:	ldr	r0, [pc, #24]	; (6580 <_GLOBAL__sub_I_zFS+0x30>)
    6566:	bl	b73c <memset>
#define MTP_SERNR "1234"
#define MTP_NAME  "Teensy"

#define USE_EVENTS 1

class MTPD {
    656a:	ldr	r3, [pc, #24]	; (6584 <_GLOBAL__sub_I_zFS+0x34>)
    656c:	movs	r2, #0
    656e:	movw	r1, #9248	; 0x2420
    6572:	strb	r2, [r3, #0]
    6574:	str	r2, [r3, #4]
    6576:	str	r2, [r3, r1]
    6578:	pop	{r4, pc}
    657a:	nop
    657c:	.word	0x2000a710
    6580:	.word	0x20003854
    6584:	.word	0x20006060

00006588 <Print::write(char const*)>:
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    6588:	push	{r4, r5, r6, lr}
    658a:	mov	r4, r0
    658c:	mov	r0, r1
    658e:	mov	r5, r1
    6590:	bl	c080 <strlen>
    6594:	ldr	r3, [r4, #0]
    6596:	mov	r2, r0
    6598:	mov	r1, r5
    659a:	mov	r0, r4
    659c:	ldr	r3, [r3, #4]
    659e:	ldmia.w	sp!, {r4, r5, r6, lr}
    65a2:	bx	r3

000065a4 <printSector(char*)>:
  uint8_t  mbrSig0;
  uint8_t  mbrSig1;
} __attribute__((packed)) MBR_t;

void printSector(char *buff)
{
    65a4:	push	{r3, r4, r5, lr}
    65a6:	mov	r5, r0
  for(int ii=0;ii<512; ii++)
    65a8:	movs	r4, #0
  if((ii+1)%16) Serial.printf("%02x ",buff[ii]); else Serial.printf("%02x\n",buff[ii]);
    65aa:	adds	r4, #1
    65ac:	ldr	r1, [pc, #28]	; (65cc <printSector(char*)+0x28>)
    65ae:	ldr	r0, [pc, #32]	; (65d0 <printSector(char*)+0x2c>)
    65b0:	lsls	r3, r4, #28
    65b2:	ldrb	r2, [r5, #0]
    65b4:	bne.n	65ba <printSector(char*)+0x16>
    65b6:	ldr	r1, [pc, #28]	; (65d4 <printSector(char*)+0x30>)
    65b8:	ldr	r0, [pc, #20]	; (65d0 <printSector(char*)+0x2c>)
    65ba:	bl	a028 <Print::printf(char const*, ...)>
  uint8_t  mbrSig1;
} __attribute__((packed)) MBR_t;

void printSector(char *buff)
{
  for(int ii=0;ii<512; ii++)
    65be:	cmp.w	r4, #512	; 0x200
    65c2:	add.w	r5, r5, #1
    65c6:	bne.n	65aa <printSector(char*)+0x6>
    65c8:	pop	{r3, r4, r5, pc}
    65ca:	nop
    65cc:	.word	0x200001e4
    65d0:	.word	0x20000bac
    65d4:	.word	0x200001ec

000065d8 <die(char const*, DRESULT)>:
  if((ii+1)%16) Serial.printf("%02x ",buff[ii]); else Serial.printf("%02x\n",buff[ii]);
}

void die(const char * txt, DRESULT res)
{
    65d8:	push	{r3, lr}
    65da:	mov	r4, r1
	virtual int availableForWrite(void)		{ return 0; }
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
    65dc:	mov	r1, r0
    65de:	ldr	r0, [pc, #24]	; (65f8 <die(char const*, DRESULT)+0x20>)
    65e0:	bl	6588 <Print::write(char const*)>
    65e4:	ldr	r1, [pc, #20]	; (65fc <die(char const*, DRESULT)+0x24>)
    65e6:	ldr	r0, [pc, #16]	; (65f8 <die(char const*, DRESULT)+0x20>)
    65e8:	bl	6588 <Print::write(char const*)>
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
	size_t print(int n)				{ return print((long)n); }
    65ec:	mov	r1, r4
    65ee:	ldr	r0, [pc, #8]	; (65f8 <die(char const*, DRESULT)+0x20>)
    65f0:	bl	a0c8 <Print::print(long)>
    65f4:	b.n	65f4 <die(char const*, DRESULT)+0x1c>
    65f6:	nop
    65f8:	.word	0x20000bac
    65fc:	.word	0x200001d8

00006600 <zeroFS_class::Create(HDR_TYPE, char const*)>:
    Create(type, name);
  }
  Serial.println(write_sector,HEX);
}
void zeroFS_class::Create(HDR_TYPE type, const char *name)
{
    6600:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  //
  memset(&hdr,0,sizeof(hdr));
    6604:	movw	r6, #8304	; 0x2070
    Create(type, name);
  }
  Serial.println(write_sector,HEX);
}
void zeroFS_class::Create(HDR_TYPE type, const char *name)
{
    6608:	mov	r4, r0
    660a:	mov	r5, r1
    660c:	mov	sl, r2
  //
  memset(&hdr,0,sizeof(hdr));
    660e:	add	r6, r0
    6610:	mov.w	r2, #512	; 0x200
    6614:	movs	r1, #0
    6616:	movw	r8, #8304	; 0x2070
    661a:	mov	r0, r6
  hdr.magic=MAGIC;
    661c:	ldr	r7, [pc, #196]	; (66e4 <zeroFS_class::Create(HDR_TYPE, char const*)+0xe4>)
  Serial.println(write_sector,HEX);
}
void zeroFS_class::Create(HDR_TYPE type, const char *name)
{
  //
  memset(&hdr,0,sizeof(hdr));
    661e:	bl	b73c <memset>
  hdr.magic=MAGIC;
  hdr.type=type;
  hdr.prev=write_sector;
    6622:	ldr	r3, [r4, #4]
void zeroFS_class::Create(HDR_TYPE type, const char *name)
{
  //
  memset(&hdr,0,sizeof(hdr));
  hdr.magic=MAGIC;
  hdr.type=type;
    6624:	movw	r2, #8308	; 0x2074
  hdr.prev=write_sector;
  hdr.sect=write_sector;
    6628:	movw	r1, #8312	; 0x2078
}
void zeroFS_class::Create(HDR_TYPE type, const char *name)
{
  //
  memset(&hdr,0,sizeof(hdr));
  hdr.magic=MAGIC;
    662c:	str.w	r7, [r4, r8]
  hdr.type=type;
  hdr.prev=write_sector;
    6630:	movw	r9, #8316	; 0x207c
void zeroFS_class::Create(HDR_TYPE type, const char *name)
{
  //
  memset(&hdr,0,sizeof(hdr));
  hdr.magic=MAGIC;
  hdr.type=type;
    6634:	str	r5, [r4, r2]
  hdr.prev=write_sector;
  hdr.sect=write_sector;
  hdr.next=0xFFFFFFFF;
    6636:	add.w	r2, r4, #8320	; 0x2080
  //
  memset(&hdr,0,sizeof(hdr));
  hdr.magic=MAGIC;
  hdr.type=type;
  hdr.prev=write_sector;
  hdr.sect=write_sector;
    663a:	str	r3, [r4, r1]
  hdr.next=0xFFFFFFFF;
    663c:	mov.w	r1, #4294967295
{
  //
  memset(&hdr,0,sizeof(hdr));
  hdr.magic=MAGIC;
  hdr.type=type;
  hdr.prev=write_sector;
    6640:	str.w	r3, [r4, r9]
  hdr.millis=millis();
  hdr.micros=micros();
  strcpy(hdr.name,name);
  
  {    
    if(hdr_list[type].magic==MAGIC)
    6644:	mov.w	r8, r5, lsl #9
  memset(&hdr,0,sizeof(hdr));
  hdr.magic=MAGIC;
  hdr.type=type;
  hdr.prev=write_sector;
  hdr.sect=write_sector;
  hdr.next=0xFFFFFFFF;
    6648:	str	r1, [r2, #0]
  hdr.ctime=rtc_get();
    664a:	bl	9300 <rtc_get>
    664e:	movw	r3, #8332	; 0x208c
    6652:	ldr	r2, [pc, #148]	; (66e8 <zeroFS_class::Create(HDR_TYPE, char const*)+0xe8>)
    6654:	str	r0, [r4, r3]
  hdr.millis=millis();
    6656:	movw	r3, #8336	; 0x2090
    665a:	ldr	r2, [r2, #0]
    665c:	str	r2, [r4, r3]
  hdr.micros=micros();
    665e:	bl	91c0 <micros>
    6662:	movw	r3, #8340	; 0x2094
  strcpy(hdr.name,name);
    6666:	mov	r1, sl
  hdr.prev=write_sector;
  hdr.sect=write_sector;
  hdr.next=0xFFFFFFFF;
  hdr.ctime=rtc_get();
  hdr.millis=millis();
  hdr.micros=micros();
    6668:	str	r0, [r4, r3]
  strcpy(hdr.name,name);
    666a:	movw	r0, #8344	; 0x2098
    666e:	add	r0, r4
    6670:	bl	bf1c <strcpy>
  
  {    
    if(hdr_list[type].magic==MAGIC)
    6674:	add.w	r3, r4, r8
    6678:	movw	r2, #8816	; 0x2270
    667c:	ldr	r2, [r3, r2]
    667e:	cmp	r2, r7
    6680:	beq.n	66d0 <zeroFS_class::Create(HDR_TYPE, char const*)+0xd0>
    {  hdr.prev = hdr_list[type].sect;
    }
    
    if(type==T_ROOT)
    6682:	cbnz	r5, 66bc <zeroFS_class::Create(HDR_TYPE, char const*)+0xbc>
    {
      hdr.parent = 0xfffffffful;
    6684:	movw	r3, #8324	; 0x2084
    6688:	mov.w	r2, #4294967295
    668c:	str	r2, [r4, r3]
      hdr.parent = hdr_list[type-1].sect;
    }

    // write hdr to disk
    BYTE* buff = (BYTE *) &hdr;
    DWORD sector = hdr.sect;
    668e:	movw	r2, #8312	; 0x2078
    UINT count = 1;
    
    if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write1",res);
    6692:	movs	r3, #1
    6694:	mov	r1, r6
    6696:	ldrb	r0, [r4, #28]
    6698:	ldr	r2, [r4, r2]
    669a:	bl	6eb4 <disk_write>
    669e:	cbnz	r0, 66dc <zeroFS_class::Create(HDR_TYPE, char const*)+0xdc>

    memcpy(&hdr_list[type],&hdr, sizeof(hdr));
    66a0:	movw	r0, #8816	; 0x2270
    66a4:	mov	r1, r6
    66a6:	mov.w	r2, #512	; 0x200
    66aa:	add	r0, r8
    66ac:	add	r0, r4
    66ae:	bl	7f58 <memcpy>
    write_sector=write_sector+1;
    66b2:	ldr	r3, [r4, #4]
    66b4:	adds	r3, #1
    66b6:	str	r3, [r4, #4]
    66b8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    {
      hdr.parent = 0xfffffffful;
    }
    else
    {
      hdr.parent = hdr_list[type-1].sect;
    66bc:	subs	r5, #1
    66be:	movw	r2, #8824	; 0x2278
    66c2:	movw	r3, #8324	; 0x2084
    66c6:	add.w	r5, r4, r5, lsl #9
    66ca:	ldr	r2, [r5, r2]
    66cc:	str	r2, [r4, r3]
    66ce:	b.n	668e <zeroFS_class::Create(HDR_TYPE, char const*)+0x8e>
  hdr.micros=micros();
  strcpy(hdr.name,name);
  
  {    
    if(hdr_list[type].magic==MAGIC)
    {  hdr.prev = hdr_list[type].sect;
    66d0:	movw	r2, #8824	; 0x2278
    66d4:	ldr	r3, [r3, r2]
    66d6:	str.w	r3, [r4, r9]
    66da:	b.n	6682 <zeroFS_class::Create(HDR_TYPE, char const*)+0x82>
    // write hdr to disk
    BYTE* buff = (BYTE *) &hdr;
    DWORD sector = hdr.sect;
    UINT count = 1;
    
    if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write1",res);
    66dc:	mov	r1, r0
    66de:	ldr	r0, [pc, #12]	; (66ec <zeroFS_class::Create(HDR_TYPE, char const*)+0xec>)
    66e0:	bl	65d8 <die(char const*, DRESULT)>
    66e4:	.word	0x6f72657a
    66e8:	.word	0x2000b144
    66ec:	.word	0x200001f4

000066f0 <zeroFS_class::Create(HDR_TYPE, int)>:
  fixEOF();
  return true;
}

void zeroFS_class::Create(HDR_TYPE type, int flag)
{
    66f0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    66f4:	mov	r4, r0
    66f6:	sub	sp, #84	; 0x54
  if(type==T_ROOT)
    66f8:	cmp	r1, #0
    66fa:	bne.n	6780 <zeroFS_class::Create(HDR_TYPE, int)+0x90>
  {
    memset(&hdr_list,0,4*sizeof(HDR_t));
    66fc:	movw	r0, #8816	; 0x2270
    6700:	mov	r5, r2
    6702:	mov.w	r2, #2048	; 0x800
    6706:	add	r0, r4
    6708:	bl	b73c <memset>
    if(flag==0) // initialize start to root sector
    670c:	cbz	r5, 6762 <zeroFS_class::Create(HDR_TYPE, int)+0x72>
      eof_sector=root_sector;
      hdr_list[type].prev=write_sector;
    }
    else        // continue at end of previous session
    {   uint32_t sector = root_sector;
        BYTE* buff = (BYTE *) &hdr;
    670e:	movw	r6, #8304	; 0x2070
          if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
          if(hdr.magic!=MAGIC) break;       // gone over eof_sector
          if(hdr.next==0xFFFFFFFFul) break; // reached last unclosed header
          
          sector = write_sector = eof_sector = hdr.next; 
          hdr_list[type].prev=hdr.sect;
    6712:	movw	r8, #8828	; 0x227c
    6716:	movw	r7, #8312	; 0x2078
      write_sector = root_sector;
      eof_sector=root_sector;
      hdr_list[type].prev=write_sector;
    }
    else        // continue at end of previous session
    {   uint32_t sector = root_sector;
    671a:	ldr	r5, [r4, #0]
        BYTE* buff = (BYTE *) &hdr;
    671c:	add	r6, r4
          if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
          if(hdr.magic!=MAGIC) break;       // gone over eof_sector
          if(hdr.next==0xFFFFFFFFul) break; // reached last unclosed header
          
          sector = write_sector = eof_sector = hdr.next; 
          hdr_list[type].prev=hdr.sect;
    671e:	add	r8, r4
    6720:	add	r7, r4
        UINT count = 1;

        while(1)
        {
          if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
          if(hdr.magic!=MAGIC) break;       // gone over eof_sector
    6722:	ldr.w	r9, [pc, #140]	; 67b0 <zeroFS_class::Create(HDR_TYPE, int)+0xc0>
    6726:	b.n	673c <zeroFS_class::Create(HDR_TYPE, int)+0x4c>
          if(hdr.next==0xFFFFFFFFul) break; // reached last unclosed header
    6728:	add.w	r3, r4, #8320	; 0x2080
    672c:	ldr	r5, [r3, #0]
    672e:	adds	r3, r5, #1
    6730:	beq.n	6798 <zeroFS_class::Create(HDR_TYPE, int)+0xa8>
          
          sector = write_sector = eof_sector = hdr.next; 
          hdr_list[type].prev=hdr.sect;
    6732:	ldr	r3, [r7, #0]
        {
          if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
          if(hdr.magic!=MAGIC) break;       // gone over eof_sector
          if(hdr.next==0xFFFFFFFFul) break; // reached last unclosed header
          
          sector = write_sector = eof_sector = hdr.next; 
    6734:	str	r5, [r4, #16]
    6736:	str	r5, [r4, #4]
          hdr_list[type].prev=hdr.sect;
    6738:	str.w	r3, [r8]
        BYTE* buff = (BYTE *) &hdr;
        UINT count = 1;

        while(1)
        {
          if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    673c:	movs	r3, #1
    673e:	mov	r2, r5
    6740:	mov	r1, r6
    6742:	ldrb	r0, [r4, #28]
    6744:	bl	6e70 <disk_read>
    6748:	cbnz	r0, 679c <zeroFS_class::Create(HDR_TYPE, int)+0xac>
          if(hdr.magic!=MAGIC) break;       // gone over eof_sector
    674a:	ldr	r3, [r6, #0]
    674c:	cmp	r3, r9
    674e:	beq.n	6728 <zeroFS_class::Create(HDR_TYPE, int)+0x38>
          if(hdr.next==0xFFFFFFFFul) break; // reached last unclosed header
          
          sector = write_sector = eof_sector = hdr.next; 
          hdr_list[type].prev=hdr.sect;
        }
        if((sector==root_sector) && (hdr.magic != MAGIC))
    6750:	ldr	r2, [r4, #0]
    6752:	cmp	r5, r2
    6754:	bne.n	6798 <zeroFS_class::Create(HDR_TYPE, int)+0xa8>
        { // fall back to root_sector
            write_sector = eof_sector = root_sector;
            hdr_list[type].prev=write_sector;
    6756:	movw	r3, #8828	; 0x227c
          sector = write_sector = eof_sector = hdr.next; 
          hdr_list[type].prev=hdr.sect;
        }
        if((sector==root_sector) && (hdr.magic != MAGIC))
        { // fall back to root_sector
            write_sector = eof_sector = root_sector;
    675a:	str	r2, [r4, #16]
    675c:	str	r2, [r4, #4]
            hdr_list[type].prev=write_sector;
    675e:	str	r2, [r4, r3]
    6760:	b.n	676e <zeroFS_class::Create(HDR_TYPE, int)+0x7e>
  if(type==T_ROOT)
  {
    memset(&hdr_list,0,4*sizeof(HDR_t));
    if(flag==0) // initialize start to root sector
    { 
      write_sector = root_sector;
    6762:	ldr	r2, [r4, #0]
      eof_sector=root_sector;
      hdr_list[type].prev=write_sector;
    6764:	movw	r3, #8828	; 0x227c
  if(type==T_ROOT)
  {
    memset(&hdr_list,0,4*sizeof(HDR_t));
    if(flag==0) // initialize start to root sector
    { 
      write_sector = root_sector;
    6768:	str	r2, [r4, #4]
      eof_sector=root_sector;
    676a:	str	r2, [r4, #16]
      hdr_list[type].prev=write_sector;
    676c:	str	r2, [r4, r3]
            write_sector = eof_sector = root_sector;
            hdr_list[type].prev=write_sector;
        }
    }
    char name[80];
    sprintf(name,"R_0X%08x",(unsigned int)write_sector);
    676e:	ldr	r1, [pc, #52]	; (67a4 <zeroFS_class::Create(HDR_TYPE, int)+0xb4>)
    6770:	mov	r0, sp
    6772:	bl	bbe4 <sprintf>
    Create(type, name);
    6776:	mov	r2, sp
    6778:	movs	r1, #0
    677a:	mov	r0, r4
    677c:	bl	6600 <zeroFS_class::Create(HDR_TYPE, char const*)>

	size_t print(unsigned char n, int base)		{ return printNumber(n, base, 0); }
	size_t print(int n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned int n, int base)		{ return printNumber(n, base, 0); }
	size_t print(long n, int base)			{ return (base == 10) ? print(n) : printNumber(n, base, 0); }
	size_t print(unsigned long n, int base)		{ return printNumber(n, base, 0); }
    6780:	ldr	r1, [r4, #4]
    6782:	movs	r3, #0
    6784:	movs	r2, #16
    6786:	ldr	r0, [pc, #32]	; (67a8 <zeroFS_class::Create(HDR_TYPE, int)+0xb8>)
    6788:	bl	a048 <Print::printNumber(unsigned long, unsigned char, unsigned char)>

	size_t println(unsigned char n, int base)	{ return print(n, base) + println(); }
	size_t println(int n, int base)			{ return print(n, base) + println(); }
	size_t println(unsigned int n, int base)	{ return print(n, base) + println(); }
	size_t println(long n, int base)		{ return print(n, base) + println(); }
	size_t println(unsigned long n, int base)	{ return print(n, base) + println(); }
    678c:	ldr	r0, [pc, #24]	; (67a8 <zeroFS_class::Create(HDR_TYPE, int)+0xb8>)
    678e:	bl	9ff8 <Print::println()>
  }
  Serial.println(write_sector,HEX);
}
    6792:	add	sp, #84	; 0x54
    6794:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    6798:	ldr	r2, [r4, #4]
    679a:	b.n	676e <zeroFS_class::Create(HDR_TYPE, int)+0x7e>
        BYTE* buff = (BYTE *) &hdr;
        UINT count = 1;

        while(1)
        {
          if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    679c:	mov	r1, r0
    679e:	ldr	r0, [pc, #12]	; (67ac <zeroFS_class::Create(HDR_TYPE, int)+0xbc>)
    67a0:	bl	65d8 <die(char const*, DRESULT)>
    67a4:	.word	0x20000204
    67a8:	.word	0x20000bac
    67ac:	.word	0x200001fc
    67b0:	.word	0x6f72657a

000067b4 <zeroFS_class::Open(HDR_TYPE)>:
    write_sector=write_sector+1;
  }
}
void zeroFS_class::Open(HDR_TYPE type)
{ // opens first file of level type
    hdr_sector=root_sector+(type);
    67b4:	ldr	r3, [r0, #0]
    67b6:	add	r1, r3
    read_sector=hdr_sector+1;
    67b8:	adds	r3, r1, #1
    write_sector=write_sector+1;
  }
}
void zeroFS_class::Open(HDR_TYPE type)
{ // opens first file of level type
    hdr_sector=root_sector+(type);
    67ba:	str	r1, [r0, #8]
    read_sector=hdr_sector+1;
    67bc:	str	r3, [r0, #12]
    67be:	bx	lr

000067c0 <zeroFS_class::Open(HDR_TYPE, char const*)>:
}
void zeroFS_class::Open(HDR_TYPE type, const char *name)
{ // opens specific file of level type
    67c0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  //Open(type); // this set hdr_sector
  //int16_t found=0;
  uint32_t sector = hdr_sector+1;
    67c4:	ldr	r4, [r0, #8]
  while(1)
  { // read hdr from disk
    BYTE* buff = (BYTE *) &hdr;
    67c6:	movw	r8, #8304	; 0x2070
    UINT count = 1;
    
    if(sector==eof_sector)  break;
    67ca:	ldr	r3, [r0, #16]
{ // opens first file of level type
    hdr_sector=root_sector+(type);
    read_sector=hdr_sector+1;
}
void zeroFS_class::Open(HDR_TYPE type, const char *name)
{ // opens specific file of level type
    67cc:	mov	r6, r2

  //Open(type); // this set hdr_sector
  //int16_t found=0;
  uint32_t sector = hdr_sector+1;
    67ce:	adds	r4, #1
  while(1)
  { // read hdr from disk
    BYTE* buff = (BYTE *) &hdr;
    67d0:	add	r8, r0
    UINT count = 1;
    
    if(sector==eof_sector)  break;
    67d2:	cmp	r4, r3
    67d4:	beq.n	681e <zeroFS_class::Open(HDR_TYPE, char const*)+0x5e>
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read1",res);
    if(!strcmp(hdr.name,name)) break;
    67d6:	movw	r7, #8344	; 0x2098
    67da:	mov	r5, r0
    sector=hdr.next;
    67dc:	add.w	r9, r0, #8320	; 0x2080
    UINT count = 1;
    
    if(sector==eof_sector)  break;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read1",res);
    if(!strcmp(hdr.name,name)) break;
    67e0:	add	r7, r0
    67e2:	b.n	67ee <zeroFS_class::Open(HDR_TYPE, char const*)+0x2e>
    sector=hdr.next;
    67e4:	ldr.w	r4, [r9]
  while(1)
  { // read hdr from disk
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(sector==eof_sector)  break;
    67e8:	ldr	r3, [r5, #16]
    67ea:	cmp	r3, r4
    67ec:	beq.n	681e <zeroFS_class::Open(HDR_TYPE, char const*)+0x5e>
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read1",res);
    67ee:	movs	r3, #1
    67f0:	mov	r2, r4
    67f2:	mov	r1, r8
    67f4:	ldrb	r0, [r5, #28]
    67f6:	bl	6e70 <disk_read>
    67fa:	cbnz	r0, 683c <zeroFS_class::Open(HDR_TYPE, char const*)+0x7c>
    if(!strcmp(hdr.name,name)) break;
    67fc:	mov	r1, r6
    67fe:	mov	r0, r7
    6800:	bl	bc48 <strcmp>
    6804:	cmp	r0, #0
    6806:	bne.n	67e4 <zeroFS_class::Open(HDR_TYPE, char const*)+0x24>
    sector=hdr.next;
  }
  if(sector==eof_sector) 
    6808:	ldr	r3, [r5, #16]
    680a:	cmp	r3, r4
    680c:	beq.n	681e <zeroFS_class::Open(HDR_TYPE, char const*)+0x5e>
  { Serial.print(name); Serial.println(" not found"); while(1);
    return; // end of list
  }
  //
  hdr_sector=hdr.sect;
    680e:	movw	r3, #8312	; 0x2078
    6812:	ldr	r3, [r5, r3]
  read_sector=hdr_sector+1;
    6814:	adds	r2, r3, #1
  if(sector==eof_sector) 
  { Serial.print(name); Serial.println(" not found"); while(1);
    return; // end of list
  }
  //
  hdr_sector=hdr.sect;
    6816:	str	r3, [r5, #8]
  read_sector=hdr_sector+1;
    6818:	str	r2, [r5, #12]
}
    681a:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
    681e:	mov	r0, r6
    6820:	bl	c080 <strlen>
    6824:	mov	r1, r0
    6826:	mov	r0, r6
    6828:	bl	86c8 <usb_serial_write>
    682c:	movs	r1, #10
    682e:	ldr	r0, [pc, #20]	; (6844 <zeroFS_class::Open(HDR_TYPE, char const*)+0x84>)
    6830:	bl	86c8 <usb_serial_write>
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
    6834:	ldr	r0, [pc, #16]	; (6848 <zeroFS_class::Open(HDR_TYPE, char const*)+0x88>)
    6836:	bl	9ff8 <Print::println()>
    683a:	b.n	683a <zeroFS_class::Open(HDR_TYPE, char const*)+0x7a>
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(sector==eof_sector)  break;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read1",res);
    683c:	mov	r1, r0
    683e:	ldr	r0, [pc, #12]	; (684c <zeroFS_class::Open(HDR_TYPE, char const*)+0x8c>)
    6840:	bl	65d8 <die(char const*, DRESULT)>
    6844:	.word	0x20000218
    6848:	.word	0x20000bac
    684c:	.word	0x20000210

00006850 <zeroFS_class::Close(HDR_TYPE)>:
  //
  hdr_sector=hdr.sect;
  read_sector=hdr_sector+1;
}
void zeroFS_class::Close(HDR_TYPE type)
{
    6850:	push	{r4, r5, r6, lr}
    6852:	mov	r4, r0
  if(type==T_ROOT)
    6854:	mov	r5, r1
    6856:	cbnz	r1, 6876 <zeroFS_class::Close(HDR_TYPE)+0x26>
  {
    memset(&hdr,0,sizeof(hdr));
    6858:	movw	r6, #8304	; 0x2070
    685c:	mov.w	r2, #512	; 0x200
    6860:	add	r6, r0
    6862:	mov	r0, r6
    6864:	bl	b73c <memset>
    BYTE* buff = (BYTE *) &hdr;
    DWORD sector = write_sector;
    UINT count = 1;
      
    if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write2",res);
    6868:	mov	r1, r6
    686a:	movs	r3, #1
    686c:	ldr	r2, [r4, #4]
    686e:	ldrb	r0, [r4, #28]
    6870:	bl	6eb4 <disk_write>
    6874:	cbnz	r0, 689c <zeroFS_class::Close(HDR_TYPE)+0x4c>

  }
  
  hdr_list[type].next=write_sector;
    6876:	lsls	r3, r5, #9
  //
  BYTE* buff = (BYTE *) &hdr_list[type];
    6878:	movw	r1, #8816	; 0x2270
      
    if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write2",res);

  }
  
  hdr_list[type].next=write_sector;
    687c:	ldr	r0, [r4, #4]
  //
  BYTE* buff = (BYTE *) &hdr_list[type];
  DWORD sector = hdr_list[type].sect;
    687e:	movw	r5, #8824	; 0x2278
      
    if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write2",res);

  }
  
  hdr_list[type].next=write_sector;
    6882:	adds	r2, r4, r3
  //
  BYTE* buff = (BYTE *) &hdr_list[type];
    6884:	add	r1, r3
  DWORD sector = hdr_list[type].sect;
  UINT count = 1;
      
  if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write2",res);
    6886:	movs	r3, #1
      
    if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write2",res);

  }
  
  hdr_list[type].next=write_sector;
    6888:	add.w	r6, r2, #8832	; 0x2280
  //
  BYTE* buff = (BYTE *) &hdr_list[type];
  DWORD sector = hdr_list[type].sect;
  UINT count = 1;
      
  if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write2",res);
    688c:	add	r1, r4
      
    if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write2",res);

  }
  
  hdr_list[type].next=write_sector;
    688e:	str	r0, [r6, #0]
  //
  BYTE* buff = (BYTE *) &hdr_list[type];
  DWORD sector = hdr_list[type].sect;
  UINT count = 1;
      
  if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write2",res);
    6890:	ldrb	r0, [r4, #28]
    6892:	ldr	r2, [r2, r5]
    6894:	bl	6eb4 <disk_write>
    6898:	cbnz	r0, 689c <zeroFS_class::Close(HDR_TYPE)+0x4c>
    689a:	pop	{r4, r5, r6, pc}
    689c:	mov	r1, r0
    689e:	ldr	r0, [pc, #4]	; (68a4 <zeroFS_class::Close(HDR_TYPE)+0x54>)
    68a0:	bl	65d8 <die(char const*, DRESULT)>
    68a4:	.word	0x20000224

000068a8 <zeroFS_class::Write(void*, unsigned long)>:
  
}
void zeroFS_class::Write(void * data, uint32_t ndat)
{
    68a8:	push	{r3, r4, r5, lr}
    68aa:	mov	r4, r0
      BYTE* buff = (BYTE *) data;
      DWORD sector = write_sector;
      UINT count = ndat/512;
    68ac:	lsrs	r5, r2, #9
      
      if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write3",res);
    68ae:	ldrb	r0, [r0, #28]
    68b0:	mov	r3, r5
    68b2:	ldr	r2, [r4, #4]
    68b4:	bl	6eb4 <disk_write>
    68b8:	cbnz	r0, 68c2 <zeroFS_class::Write(void*, unsigned long)+0x1a>

      write_sector += count;
    68ba:	ldr	r3, [r4, #4]
    68bc:	add	r5, r3
    68be:	str	r5, [r4, #4]
    68c0:	pop	{r3, r4, r5, pc}
{
      BYTE* buff = (BYTE *) data;
      DWORD sector = write_sector;
      UINT count = ndat/512;
      
      if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write3",res);
    68c2:	mov	r1, r0
    68c4:	ldr	r0, [pc, #4]	; (68cc <zeroFS_class::Write(void*, unsigned long)+0x24>)
    68c6:	bl	65d8 <die(char const*, DRESULT)>
    68ca:	nop
    68cc:	.word	0x2000022c

000068d0 <zeroFS_class::Read(void*, unsigned long)>:

      write_sector += count;
  
}
void zeroFS_class::Read(void * data, uint32_t ndat)
{
    68d0:	push	{r3, r4, r5, lr}
    68d2:	mov	r4, r0
      BYTE* buff = (BYTE *) data;
      DWORD sector = read_sector;
      UINT count = ndat/512;
    68d4:	lsrs	r5, r2, #9
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read2",res);
    68d6:	ldrb	r0, [r0, #28]
    68d8:	mov	r3, r5
    68da:	ldr	r2, [r4, #12]
    68dc:	bl	6e70 <disk_read>
    68e0:	cbnz	r0, 68ea <zeroFS_class::Read(void*, unsigned long)+0x1a>

      read_sector += count;
    68e2:	ldr	r3, [r4, #12]
    68e4:	add	r5, r3
    68e6:	str	r5, [r4, #12]
    68e8:	pop	{r3, r4, r5, pc}
void zeroFS_class::Read(void * data, uint32_t ndat)
{
      BYTE* buff = (BYTE *) data;
      DWORD sector = read_sector;
      UINT count = ndat/512;
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read2",res);
    68ea:	mov	r1, r0
    68ec:	ldr	r0, [pc, #4]	; (68f4 <zeroFS_class::Read(void*, unsigned long)+0x24>)
    68ee:	bl	65d8 <die(char const*, DRESULT)>
    68f2:	nop
    68f4:	.word	0x20000234

000068f8 <zeroFS_class::ListAll()>:

      read_sector += count;
}
void zeroFS_class::ListAll(void)
{
    68f8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    68fc:	movw	r8, #8304	; 0x2070
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    //
    if(hdr.type==1) Serial.println(); 
    6900:	movw	r5, #8308	; 0x2074
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read2",res);

      read_sector += count;
}
void zeroFS_class::ListAll(void)
{
    6904:	sub	sp, #12
    6906:	mov	r6, r0
  uint32_t sector = root_sector;
    6908:	ldr	r7, [r0, #0]
    690a:	add	r8, r0
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    //
    if(hdr.type==1) Serial.println(); 
    690c:	add	r5, r0
  while(1)
  {
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    690e:	movs	r3, #1
    6910:	mov	r2, r7
    6912:	mov	r1, r8
    6914:	ldrb	r0, [r6, #28]
    6916:	bl	6e70 <disk_read>
    691a:	cmp	r0, #0
    691c:	bne.n	69ac <zeroFS_class::ListAll()+0xb4>
    //
    if(hdr.type==1) Serial.println(); 
    691e:	ldr	r3, [r5, #0]
    6920:	cmp	r3, #1
    6922:	beq.n	69a2 <zeroFS_class::ListAll()+0xaa>
    for(int ii=0;ii<(int)(hdr.type); ii++) Serial.print("  ");
    6924:	cmp	r3, #0
    6926:	ble.n	693a <zeroFS_class::ListAll()+0x42>
    6928:	movs	r4, #0
    692a:	movs	r1, #2
    692c:	ldr	r0, [pc, #132]	; (69b4 <zeroFS_class::ListAll()+0xbc>)
    692e:	bl	86c8 <usb_serial_write>
    6932:	adds	r4, #1
    6934:	ldr	r3, [r5, #0]
    6936:	cmp	r3, r4
    6938:	bgt.n	692a <zeroFS_class::ListAll()+0x32>
    Serial.printf("%x %x %x %x ",hdr.prev,hdr.sect,hdr.next,hdr.parent);
    693a:	movw	r1, #8324	; 0x2084
    693e:	add.w	r9, r6, #8320	; 0x2080
    6942:	movw	r4, #8312	; 0x2078
    6946:	movw	r2, #8316	; 0x207c
    694a:	add	r1, r6
    694c:	ldr.w	r0, [r9]
    6950:	add	r4, r6
    6952:	add	r2, r6
    6954:	ldr	r1, [r1, #0]
    6956:	ldr	r3, [r4, #0]
    6958:	ldr	r2, [r2, #0]
    695a:	stmia.w	sp, {r0, r1}
    695e:	ldr	r1, [pc, #88]	; (69b8 <zeroFS_class::ListAll()+0xc0>)
    6960:	ldr	r0, [pc, #88]	; (69bc <zeroFS_class::ListAll()+0xc4>)
    6962:	bl	a028 <Print::printf(char const*, ...)>
    Serial.printf("%d %d %s\n",hdr.type,hdr.next-hdr.sect,hdr.name); Serial.flush();
    6966:	movw	r1, #8344	; 0x2098
    696a:	ldr.w	r0, [r9]
    696e:	ldr	r3, [r4, #0]
    6970:	add	r1, r6
    6972:	ldr	r2, [r5, #0]
    6974:	subs	r3, r0, r3
    6976:	str	r1, [sp, #0]
    6978:	ldr	r0, [pc, #64]	; (69bc <zeroFS_class::ListAll()+0xc4>)
    697a:	ldr	r1, [pc, #68]	; (69c0 <zeroFS_class::ListAll()+0xc8>)
    697c:	bl	a028 <Print::printf(char const*, ...)>
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    6980:	bl	872c <usb_serial_flush_output>
    if(hdr.type<3) 
    6984:	ldr	r3, [r5, #0]
    6986:	cmp	r3, #2
    6988:	bhi.n	698e <zeroFS_class::ListAll()+0x96>
    {
      sector++;
    698a:	adds	r7, #1
    698c:	b.n	690e <zeroFS_class::ListAll()+0x16>
    }
    else
    { if(hdr.next==0xFFFFFFFF) break;
    698e:	ldr.w	r7, [r9]
    6992:	adds	r3, r7, #1
    6994:	beq.n	699c <zeroFS_class::ListAll()+0xa4>
      sector = hdr.next;
      if(sector==eof_sector) break; // end of data reached
    6996:	ldr	r3, [r6, #16]
    6998:	cmp	r7, r3
    699a:	bne.n	690e <zeroFS_class::ListAll()+0x16>
    }
  }
}
    699c:	add	sp, #12
    699e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    //
    if(hdr.type==1) Serial.println(); 
    69a2:	ldr	r0, [pc, #24]	; (69bc <zeroFS_class::ListAll()+0xc4>)
    69a4:	bl	9ff8 <Print::println()>
    69a8:	ldr	r3, [r5, #0]
    69aa:	b.n	6924 <zeroFS_class::ListAll()+0x2c>
  while(1)
  {
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    69ac:	mov	r1, r0
    69ae:	ldr	r0, [pc, #20]	; (69c4 <zeroFS_class::ListAll()+0xcc>)
    69b0:	bl	65d8 <die(char const*, DRESULT)>
    69b4:	.word	0x20000258
    69b8:	.word	0x2000023c
    69bc:	.word	0x20000bac
    69c0:	.word	0x2000024c
    69c4:	.word	0x200001fc

000069c8 <zeroFS_class::List()>:
      if(sector==eof_sector) break; // end of data reached
    }
  }
}
void zeroFS_class::List(void)
{
    69c8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    69cc:	movw	r9, #8304	; 0x2070
  {
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read4",res);
    if(old_type &&(hdr.type != old_type)) break; // next higher level
    69d0:	movw	r5, #8308	; 0x2074
    old_type=hdr.type;
    //
    if(hdr.next==0xFFFFFFFF) break;
    for(int ii=0;ii<(int)(hdr.type); ii++) Serial.print("  ");
//    Serial.printf("%x %x %x ",hdr.prev,hdr.sect,hdr.next);
    Serial.printf("%d %d %s\n",hdr.type,hdr.next-hdr.sect,hdr.name); Serial.flush();
    69d4:	movw	sl, #8312	; 0x2078
      if(sector==eof_sector) break; // end of data reached
    }
  }
}
void zeroFS_class::List(void)
{
    69d8:	sub	sp, #8
    69da:	mov	r6, r0
  //int16_t done=0;
  
  uint32_t old_type=0;
  uint32_t sector = read_sector;
    69dc:	ldr	r2, [r0, #12]
    69de:	add	r9, r0
  {
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read4",res);
    if(old_type &&(hdr.type != old_type)) break; // next higher level
    69e0:	add	r5, r0
    old_type=hdr.type;
    //
    if(hdr.next==0xFFFFFFFF) break;
    for(int ii=0;ii<(int)(hdr.type); ii++) Serial.print("  ");
//    Serial.printf("%x %x %x ",hdr.prev,hdr.sect,hdr.next);
    Serial.printf("%d %d %s\n",hdr.type,hdr.next-hdr.sect,hdr.name); Serial.flush();
    69e2:	add	sl, r0
}
void zeroFS_class::List(void)
{
  //int16_t done=0;
  
  uint32_t old_type=0;
    69e4:	mov.w	r8, #0
  while(1)
  {
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read4",res);
    69e8:	movs	r3, #1
    69ea:	mov	r1, r9
    69ec:	ldrb	r0, [r6, #28]
    69ee:	bl	6e70 <disk_read>
    69f2:	cmp	r0, #0
    69f4:	bne.n	6a5c <zeroFS_class::List()+0x94>
    if(old_type &&(hdr.type != old_type)) break; // next higher level
    69f6:	cmp.w	r8, #0
    69fa:	bne.n	6a4c <zeroFS_class::List()+0x84>
    69fc:	ldr.w	r8, [r5]
    old_type=hdr.type;
    //
    if(hdr.next==0xFFFFFFFF) break;
    6a00:	add.w	r7, r6, #8320	; 0x2080
    6a04:	ldr	r0, [r7, #0]
    6a06:	adds	r3, r0, #1
    6a08:	beq.n	6a46 <zeroFS_class::List()+0x7e>
    for(int ii=0;ii<(int)(hdr.type); ii++) Serial.print("  ");
    6a0a:	cmp.w	r8, #0
    6a0e:	ble.n	6a58 <zeroFS_class::List()+0x90>
    6a10:	movs	r4, #0
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    6a12:	movs	r1, #2
    6a14:	ldr	r0, [pc, #76]	; (6a64 <zeroFS_class::List()+0x9c>)
    6a16:	bl	86c8 <usb_serial_write>
    6a1a:	adds	r4, #1
    6a1c:	ldr	r2, [r5, #0]
    6a1e:	cmp	r2, r4
    6a20:	bgt.n	6a12 <zeroFS_class::List()+0x4a>
    6a22:	ldr	r0, [r7, #0]
//    Serial.printf("%x %x %x ",hdr.prev,hdr.sect,hdr.next);
    Serial.printf("%d %d %s\n",hdr.type,hdr.next-hdr.sect,hdr.name); Serial.flush();
    6a24:	movw	r4, #8344	; 0x2098
    6a28:	ldr.w	r3, [sl]
    6a2c:	ldr	r1, [pc, #56]	; (6a68 <zeroFS_class::List()+0xa0>)
    6a2e:	add	r4, r6
    6a30:	subs	r3, r0, r3
    6a32:	ldr	r0, [pc, #56]	; (6a6c <zeroFS_class::List()+0xa4>)
    6a34:	str	r4, [sp, #0]
    6a36:	bl	a028 <Print::printf(char const*, ...)>
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    6a3a:	bl	872c <usb_serial_flush_output>
    sector = hdr.next;
    6a3e:	ldr	r2, [r7, #0]
    if(sector==eof_sector) break; // end of data reached
    6a40:	ldr	r3, [r6, #16]
    6a42:	cmp	r2, r3
    6a44:	bne.n	69e8 <zeroFS_class::List()+0x20>
  }
}
    6a46:	add	sp, #8
    6a48:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  {
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read4",res);
    if(old_type &&(hdr.type != old_type)) break; // next higher level
    6a4c:	ldr	r3, [r5, #0]
    6a4e:	cmp	r8, r3
    6a50:	beq.n	6a00 <zeroFS_class::List()+0x38>
//    Serial.printf("%x %x %x ",hdr.prev,hdr.sect,hdr.next);
    Serial.printf("%d %d %s\n",hdr.type,hdr.next-hdr.sect,hdr.name); Serial.flush();
    sector = hdr.next;
    if(sector==eof_sector) break; // end of data reached
  }
}
    6a52:	add	sp, #8
    6a54:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read4",res);
    if(old_type &&(hdr.type != old_type)) break; // next higher level
    old_type=hdr.type;
    //
    if(hdr.next==0xFFFFFFFF) break;
    for(int ii=0;ii<(int)(hdr.type); ii++) Serial.print("  ");
    6a58:	mov	r2, r8
    6a5a:	b.n	6a24 <zeroFS_class::List()+0x5c>
  while(1)
  {
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read4",res);
    6a5c:	mov	r1, r0
    6a5e:	ldr	r0, [pc, #16]	; (6a70 <zeroFS_class::List()+0xa8>)
    6a60:	bl	65d8 <die(char const*, DRESULT)>
    6a64:	.word	0x20000258
    6a68:	.word	0x2000024c
    6a6c:	.word	0x20000bac
    6a70:	.word	0x2000025c

00006a74 <zeroFS_class::findEOF()>:
    if(sector==eof_sector) break; // end of data reached
  }
}

void zeroFS_class::findEOF(void)
{
    6a74:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
//  int16_t done=0;
  
//  uint32_t old_type=0;
  uint32_t sector = root_sector;
    BYTE* buff = (BYTE *) &hdr;
    6a78:	movw	r5, #8304	; 0x2070
void zeroFS_class::findEOF(void)
{
//  int16_t done=0;
  
//  uint32_t old_type=0;
  uint32_t sector = root_sector;
    6a7c:	ldr	r6, [r0, #0]
    if(sector==eof_sector) break; // end of data reached
  }
}

void zeroFS_class::findEOF(void)
{
    6a7e:	mov	r4, r0

    // root level
    eof_sector=sector;
    while(1) // should only be 1 root header, but ....
    {   if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read5",res);
        if(hdr.magic != MAGIC) break; 
    6a80:	ldr.w	r8, [pc, #200]	; 6b4c <zeroFS_class::findEOF()+0xd8>
{
//  int16_t done=0;
  
//  uint32_t old_type=0;
  uint32_t sector = root_sector;
    BYTE* buff = (BYTE *) &hdr;
    6a84:	add	r5, r0
    // root level
    eof_sector=sector;
    while(1) // should only be 1 root header, but ....
    {   if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read5",res);
        if(hdr.magic != MAGIC) break; 
        if(hdr.next==0xFFFFFFFF) break; 
    6a86:	add.w	r7, r0, #8320	; 0x2080
  uint32_t sector = root_sector;
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;

    // root level
    eof_sector=sector;
    6a8a:	str	r6, [r0, #16]
    6a8c:	b.n	6a98 <zeroFS_class::findEOF()+0x24>
    while(1) // should only be 1 root header, but ....
    {   if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read5",res);
        if(hdr.magic != MAGIC) break; 
        if(hdr.next==0xFFFFFFFF) break; 
    6a8e:	ldr	r3, [r7, #0]
    6a90:	adds	r0, r3, #1
    6a92:	beq.n	6ab2 <zeroFS_class::findEOF()+0x3e>
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;

    // root level
    eof_sector=sector;
    while(1) // should only be 1 root header, but ....
    6a94:	mov	r6, r3
    {   if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read5",res);
        if(hdr.magic != MAGIC) break; 
        if(hdr.next==0xFFFFFFFF) break; 
        sector=hdr.next;
        eof_sector=sector;
    6a96:	str	r3, [r4, #16]
    UINT count = 1;

    // root level
    eof_sector=sector;
    while(1) // should only be 1 root header, but ....
    {   if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read5",res);
    6a98:	movs	r3, #1
    6a9a:	mov	r2, r6
    6a9c:	mov	r1, r5
    6a9e:	ldrb	r0, [r4, #28]
    6aa0:	bl	6e70 <disk_read>
    6aa4:	cmp	r0, #0
    6aa6:	bne.n	6b32 <zeroFS_class::findEOF()+0xbe>
        if(hdr.magic != MAGIC) break; 
    6aa8:	ldr	r3, [r5, #0]
    6aaa:	cmp	r3, r8
    6aac:	beq.n	6a8e <zeroFS_class::findEOF()+0x1a>
    6aae:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if(hdr.next==0xFFFFFFFF) break; 
        sector=hdr.next;
        eof_sector=sector;
    }
    if(hdr.type != T_ROOT)
    6ab2:	movw	r3, #8308	; 0x2074
    6ab6:	ldr	r3, [r4, r3]
    6ab8:	cmp	r3, #0
    6aba:	bne.n	6aae <zeroFS_class::findEOF()+0x3a>
    { //Serial.print("EOF1 "); Serial.println(eof_sector,HEX);
      return;
    }

    // go to trial level
    sector++;
    6abc:	adds	r6, #1
    eof_sector=sector;
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read6",res);
        if(hdr.magic != MAGIC) break; 
    6abe:	ldr.w	r8, [pc, #140]	; 6b4c <zeroFS_class::findEOF()+0xd8>
      return;
    }

    // go to trial level
    sector++;
    eof_sector=sector;
    6ac2:	str	r6, [r4, #16]
    6ac4:	b.n	6ad0 <zeroFS_class::findEOF()+0x5c>
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read6",res);
        if(hdr.magic != MAGIC) break; 
        if(hdr.next==0xFFFFFFFF) break; 
    6ac6:	ldr	r3, [r7, #0]
    6ac8:	adds	r1, r3, #1
    6aca:	beq.n	6ae6 <zeroFS_class::findEOF()+0x72>
    }

    // go to trial level
    sector++;
    eof_sector=sector;
    while(1)
    6acc:	mov	r6, r3
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read6",res);
        if(hdr.magic != MAGIC) break; 
        if(hdr.next==0xFFFFFFFF) break; 
        sector=hdr.next;
        eof_sector=sector;
    6ace:	str	r3, [r4, #16]
    // go to trial level
    sector++;
    eof_sector=sector;
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read6",res);
    6ad0:	movs	r3, #1
    6ad2:	mov	r2, r6
    6ad4:	mov	r1, r5
    6ad6:	ldrb	r0, [r4, #28]
    6ad8:	bl	6e70 <disk_read>
    6adc:	cbnz	r0, 6b3a <zeroFS_class::findEOF()+0xc6>
        if(hdr.magic != MAGIC) break; 
    6ade:	ldr	r3, [r5, #0]
    6ae0:	cmp	r3, r8
    6ae2:	beq.n	6ac6 <zeroFS_class::findEOF()+0x52>
    6ae4:	b.n	6aae <zeroFS_class::findEOF()+0x3a>
    { //Serial.print("EOF2 "); Serial.println(eof_sector,HEX);
      return;
    }

    // go to day level
    sector++;
    6ae6:	adds	r6, #1
    eof_sector=sector;
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read7",res);
        if(hdr.magic != MAGIC) break; 
    6ae8:	ldr.w	r8, [pc, #96]	; 6b4c <zeroFS_class::findEOF()+0xd8>
      return;
    }

    // go to day level
    sector++;
    eof_sector=sector;
    6aec:	str	r6, [r4, #16]
    6aee:	b.n	6afa <zeroFS_class::findEOF()+0x86>
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read7",res);
        if(hdr.magic != MAGIC) break; 
        if(hdr.next==0xFFFFFFFF) break; 
    6af0:	ldr	r3, [r7, #0]
    6af2:	adds	r2, r3, #1
    6af4:	beq.n	6b10 <zeroFS_class::findEOF()+0x9c>
    }

    // go to day level
    sector++;
    eof_sector=sector;
    while(1)
    6af6:	mov	r6, r3
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read7",res);
        if(hdr.magic != MAGIC) break; 
        if(hdr.next==0xFFFFFFFF) break; 
        sector=hdr.next;
        eof_sector=sector;
    6af8:	str	r3, [r4, #16]
    // go to day level
    sector++;
    eof_sector=sector;
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read7",res);
    6afa:	movs	r3, #1
    6afc:	mov	r2, r6
    6afe:	mov	r1, r5
    6b00:	ldrb	r0, [r4, #28]
    6b02:	bl	6e70 <disk_read>
    6b06:	cbnz	r0, 6b42 <zeroFS_class::findEOF()+0xce>
        if(hdr.magic != MAGIC) break; 
    6b08:	ldr	r3, [r5, #0]
    6b0a:	cmp	r3, r8
    6b0c:	beq.n	6af0 <zeroFS_class::findEOF()+0x7c>
    6b0e:	b.n	6aae <zeroFS_class::findEOF()+0x3a>
    if(hdr.magic != MAGIC) // reached end of list
    {// Serial.print("EOF3 "); Serial.println(eof_sector,HEX);
      return;
    }
    // go to file level
    sector++;
    6b10:	adds	r2, r6, #1
    eof_sector=sector;
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read7",res);
        if(hdr.magic != MAGIC) break; 
    6b12:	ldr	r6, [pc, #56]	; (6b4c <zeroFS_class::findEOF()+0xd8>)
    6b14:	b.n	6b1c <zeroFS_class::findEOF()+0xa8>
        if(hdr.next==0xFFFFFFFF) break; 
    6b16:	ldr	r2, [r7, #0]
    6b18:	adds	r3, r2, #1
    6b1a:	beq.n	6aae <zeroFS_class::findEOF()+0x3a>
    {// Serial.print("EOF3 "); Serial.println(eof_sector,HEX);
      return;
    }
    // go to file level
    sector++;
    eof_sector=sector;
    6b1c:	str	r2, [r4, #16]
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read7",res);
    6b1e:	movs	r3, #1
    6b20:	mov	r1, r5
    6b22:	ldrb	r0, [r4, #28]
    6b24:	bl	6e70 <disk_read>
    6b28:	cbnz	r0, 6b42 <zeroFS_class::findEOF()+0xce>
        if(hdr.magic != MAGIC) break; 
    6b2a:	ldr	r3, [r5, #0]
    6b2c:	cmp	r3, r6
    6b2e:	beq.n	6b16 <zeroFS_class::findEOF()+0xa2>
    6b30:	b.n	6aae <zeroFS_class::findEOF()+0x3a>
    UINT count = 1;

    // root level
    eof_sector=sector;
    while(1) // should only be 1 root header, but ....
    {   if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read5",res);
    6b32:	mov	r1, r0
    6b34:	ldr	r0, [pc, #24]	; (6b50 <zeroFS_class::findEOF()+0xdc>)
    6b36:	bl	65d8 <die(char const*, DRESULT)>
    // go to trial level
    sector++;
    eof_sector=sector;
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read6",res);
    6b3a:	mov	r1, r0
    6b3c:	ldr	r0, [pc, #20]	; (6b54 <zeroFS_class::findEOF()+0xe0>)
    6b3e:	bl	65d8 <die(char const*, DRESULT)>
    // go to file level
    sector++;
    eof_sector=sector;
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read7",res);
    6b42:	mov	r1, r0
    6b44:	ldr	r0, [pc, #16]	; (6b58 <zeroFS_class::findEOF()+0xe4>)
    6b46:	bl	65d8 <die(char const*, DRESULT)>
    6b4a:	nop
    6b4c:	.word	0x6f72657a
    6b50:	.word	0x20000264
    6b54:	.word	0x2000026c
    6b58:	.word	0x20000274

00006b5c <zeroFS_class::fixEOF()>:
    }
    //Serial.print("EOF4 "); Serial.println(eof_sector,HEX);
}

void zeroFS_class::fixEOF(void)
{
    6b5c:	push	{r3, r4, r5, r6, r7, lr}
  //int16_t done=0;
  
    if(eof_sector==root_sector) return;
    6b5e:	ldr	r5, [r0, #0]
    6b60:	ldr	r3, [r0, #16]
    6b62:	cmp	r3, r5
    6b64:	beq.n	6b96 <zeroFS_class::fixEOF()+0x3a>

    // root level;
  //uint32_t old_type=0;
  uint32_t sector = root_sector;
    BYTE* buff = (BYTE *) &hdr;
    6b66:	movw	r6, #8304	; 0x2070
    6b6a:	mov	r4, r0
    UINT count = 1;
    
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read8",res);
        if((hdr.next== eof_sector) || (hdr.next==0xFFFFFFFF)) break; 
    6b6c:	add.w	r7, r0, #8320	; 0x2080
    if(eof_sector==root_sector) return;

    // root level;
  //uint32_t old_type=0;
  uint32_t sector = root_sector;
    BYTE* buff = (BYTE *) &hdr;
    6b70:	add	r6, r0
    6b72:	b.n	6b7a <zeroFS_class::fixEOF()+0x1e>
    UINT count = 1;
    
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read8",res);
        if((hdr.next== eof_sector) || (hdr.next==0xFFFFFFFF)) break; 
    6b74:	adds	r1, r3, #1
    6b76:	beq.n	6b98 <zeroFS_class::fixEOF()+0x3c>
    6b78:	mov	r5, r3
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read8",res);
    6b7a:	movs	r3, #1
    6b7c:	mov	r2, r5
    6b7e:	mov	r1, r6
    6b80:	ldrb	r0, [r4, #28]
    6b82:	bl	6e70 <disk_read>
    6b86:	cmp	r0, #0
    6b88:	bne.n	6bea <zeroFS_class::fixEOF()+0x8e>
        if((hdr.next== eof_sector) || (hdr.next==0xFFFFFFFF)) break; 
    6b8a:	ldr	r3, [r7, #0]
    6b8c:	ldr	r2, [r4, #16]
    6b8e:	cmp	r3, r2
    6b90:	bne.n	6b74 <zeroFS_class::fixEOF()+0x18>
        sector=hdr.next;
    }
    if(hdr.next == 0xFFFFFFFF) 
    6b92:	adds	r0, r2, #1
    6b94:	beq.n	6b98 <zeroFS_class::fixEOF()+0x3c>
    6b96:	pop	{r3, r4, r5, r6, r7, pc}
    { hdr.next=eof_sector;
      BYTE* buff = (BYTE *) &hdr;
      DWORD sector = hdr.sect;
    6b98:	movw	r1, #8312	; 0x2078
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read8",res);
        if((hdr.next== eof_sector) || (hdr.next==0xFFFFFFFF)) break; 
        sector=hdr.next;
    }
    if(hdr.next == 0xFFFFFFFF) 
    { hdr.next=eof_sector;
    6b9c:	str	r2, [r7, #0]
      BYTE* buff = (BYTE *) &hdr;
      DWORD sector = hdr.sect;
      UINT count = 1;
        
      if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write4",res);
    6b9e:	movs	r3, #1
    6ba0:	ldrb	r0, [r4, #28]
    6ba2:	ldr	r2, [r4, r1]
    6ba4:	mov	r1, r6
    6ba6:	bl	6eb4 <disk_write>
    6baa:	cbnz	r0, 6bfa <zeroFS_class::fixEOF()+0x9e>
    }
    else
     return;

    // go to day level
    sector++;
    6bac:	adds	r2, r5, #1
    6bae:	b.n	6bb4 <zeroFS_class::fixEOF()+0x58>
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read9",res);
        if((hdr.next==eof_sector) || (hdr.next==0xFFFFFFFF)) break; 
    6bb0:	adds	r1, r2, #1
    6bb2:	beq.n	6bcc <zeroFS_class::fixEOF()+0x70>

    // go to day level
    sector++;
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read9",res);
    6bb4:	movs	r3, #1
    6bb6:	mov	r1, r6
    6bb8:	ldrb	r0, [r4, #28]
    6bba:	bl	6e70 <disk_read>
    6bbe:	cbnz	r0, 6bf2 <zeroFS_class::fixEOF()+0x96>
        if((hdr.next==eof_sector) || (hdr.next==0xFFFFFFFF)) break; 
    6bc0:	ldr	r2, [r7, #0]
    6bc2:	ldr	r3, [r4, #16]
    6bc4:	cmp	r2, r3
    6bc6:	bne.n	6bb0 <zeroFS_class::fixEOF()+0x54>
        sector=hdr.next;
    }
    if(hdr.next == 0xFFFFFFFF) 
    6bc8:	adds	r2, r3, #1
    6bca:	bne.n	6b96 <zeroFS_class::fixEOF()+0x3a>
    { hdr.next=eof_sector;
      BYTE* buff = (BYTE *) &hdr;
      DWORD sector = hdr.sect;
    6bcc:	movw	r2, #8312	; 0x2078
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read9",res);
        if((hdr.next==eof_sector) || (hdr.next==0xFFFFFFFF)) break; 
        sector=hdr.next;
    }
    if(hdr.next == 0xFFFFFFFF) 
    { hdr.next=eof_sector;
    6bd0:	str	r3, [r7, #0]
      BYTE* buff = (BYTE *) &hdr;
      DWORD sector = hdr.sect;
      UINT count = 1;
        
      if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write5",res);
    6bd2:	mov	r1, r6
    6bd4:	ldrb	r0, [r4, #28]
    6bd6:	ldr	r2, [r4, r2]
    6bd8:	movs	r3, #1
    6bda:	bl	6eb4 <disk_write>
    6bde:	cmp	r0, #0
    6be0:	beq.n	6b96 <zeroFS_class::fixEOF()+0x3a>
    6be2:	mov	r1, r0
    6be4:	ldr	r0, [pc, #28]	; (6c04 <zeroFS_class::fixEOF()+0xa8>)
    6be6:	bl	65d8 <die(char const*, DRESULT)>
    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read8",res);
    6bea:	mov	r1, r0
    6bec:	ldr	r0, [pc, #24]	; (6c08 <zeroFS_class::fixEOF()+0xac>)
    6bee:	bl	65d8 <die(char const*, DRESULT)>

    // go to day level
    sector++;
    while(1)
    {
        if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read9",res);
    6bf2:	mov	r1, r0
    6bf4:	ldr	r0, [pc, #20]	; (6c0c <zeroFS_class::fixEOF()+0xb0>)
    6bf6:	bl	65d8 <die(char const*, DRESULT)>
    { hdr.next=eof_sector;
      BYTE* buff = (BYTE *) &hdr;
      DWORD sector = hdr.sect;
      UINT count = 1;
        
      if(DRESULT res = disk_write (pdrv, buff, sector, count)) die("write4",res);
    6bfa:	mov	r1, r0
    6bfc:	ldr	r0, [pc, #16]	; (6c10 <zeroFS_class::fixEOF()+0xb4>)
    6bfe:	bl	65d8 <die(char const*, DRESULT)>
    6c02:	nop
    6c04:	.word	0x20000294
    6c08:	.word	0x2000027c
    6c0c:	.word	0x2000028c
    6c10:	.word	0x20000284

00006c14 <zeroFS_class::Init(unsigned char, unsigned char, char const*)>:
void die(const char * txt, DRESULT res)
{
  Serial.print(txt); Serial.print(" "); Serial.print(res); while(1);
}
bool zeroFS_class::Init(BYTE device, BYTE cs, const char *str)
{
    6c14:	push	{r4, r5, lr}
    6c16:	mov	r4, r0
    6c18:	mov	r5, r2
// DEV_MSC
// DEV_USB

  pdrv = DEV_SPI;
  if(device==254) pdrv=DEV_SDHC;
  pdrv = device;
    6c1a:	strb	r1, [r0, #28]
void die(const char * txt, DRESULT res)
{
  Serial.print(txt); Serial.print(" "); Serial.print(res); while(1);
}
bool zeroFS_class::Init(BYTE device, BYTE cs, const char *str)
{
    6c1c:	sub.w	sp, sp, #516	; 0x204
// DEV_USB

  pdrv = DEV_SPI;
  if(device==254) pdrv=DEV_SDHC;
  pdrv = device;
  strlcpy(name,str,80);
    6c20:	movs	r2, #80	; 0x50
    6c22:	mov	r1, r3
    6c24:	adds	r0, #30
    6c26:	bl	c02c <strlcpy>
  csel=cs;
    6c2a:	strb	r5, [r4, #29]

  MBR_t mbr;

  if(DSTATUS stat = disk_initialize(pdrv))
    6c2c:	ldrb	r0, [r4, #28]
    6c2e:	bl	6e3c <disk_initialize>
    6c32:	mov	r5, r0
    6c34:	cbz	r0, 6c52 <zeroFS_class::Init(unsigned char, unsigned char, char const*)+0x3e>
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    6c36:	movs	r1, #24
    6c38:	ldr	r0, [pc, #76]	; (6c88 <zeroFS_class::Init(unsigned char, unsigned char, char const*)+0x74>)
    6c3a:	bl	86c8 <usb_serial_write>
	size_t print(const String &s);
	size_t print(char c)				{ return write((uint8_t)c); }
	size_t print(const char s[])			{ return write(s); }
	size_t print(const __FlashStringHelper *f)	{ return write((const char *)f); }

	size_t print(uint8_t b)				{ return printNumber(b, 10, 0); }
    6c3e:	mov	r1, r5
    6c40:	movs	r3, #0
    6c42:	movs	r2, #10
    6c44:	ldr	r0, [pc, #68]	; (6c8c <zeroFS_class::Init(unsigned char, unsigned char, char const*)+0x78>)
    6c46:	bl	a048 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
	size_t println(const __FlashStringHelper *f)	{ return print(f) + println(); }

	size_t println(uint8_t b)			{ return print(b) + println(); }
    6c4a:	ldr	r0, [pc, #64]	; (6c8c <zeroFS_class::Init(unsigned char, unsigned char, char const*)+0x78>)
    6c4c:	bl	9ff8 <Print::println()>
    6c50:	b.n	6c50 <zeroFS_class::Init(unsigned char, unsigned char, char const*)+0x3c>

  BYTE* buff = (BYTE *) &mbr;
  DWORD sector = 0;
  UINT count = 1;
  
  if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("init",res);
    6c52:	mov	r2, r0
    6c54:	mov	r1, sp
    6c56:	movs	r3, #1
    6c58:	ldrb	r0, [r4, #28]
    6c5a:	bl	6e70 <disk_read>
    6c5e:	mov	r1, r0
    6c60:	cbnz	r0, 6c82 <zeroFS_class::Init(unsigned char, unsigned char, char const*)+0x6e>
  Serial.println(mbr.mbrSig0,HEX); //0x55
  Serial.println(mbr.mbrSig1,HEX); //0xAA
  }  
  #endif

  root_sector=mbr.part[0].firstSector;
    6c62:	ldr.w	r2, [sp, #454]	; 0x1c6
  total_sectors=mbr.part[0].totalSectors;

  // clean up earlier disk usage
  findEOF();
    6c66:	mov	r0, r4
  Serial.println(mbr.mbrSig1,HEX); //0xAA
  }  
  #endif

  root_sector=mbr.part[0].firstSector;
  total_sectors=mbr.part[0].totalSectors;
    6c68:	ldr.w	r3, [sp, #458]	; 0x1ca
  Serial.println(mbr.mbrSig0,HEX); //0x55
  Serial.println(mbr.mbrSig1,HEX); //0xAA
  }  
  #endif

  root_sector=mbr.part[0].firstSector;
    6c6c:	str	r2, [r4, #0]
  total_sectors=mbr.part[0].totalSectors;
    6c6e:	str	r3, [r4, #24]

  // clean up earlier disk usage
  findEOF();
    6c70:	bl	6a74 <zeroFS_class::findEOF()>
  fixEOF();
    6c74:	mov	r0, r4
    6c76:	bl	6b5c <zeroFS_class::fixEOF()>
  return true;
}
    6c7a:	movs	r0, #1
    6c7c:	add.w	sp, sp, #516	; 0x204
    6c80:	pop	{r4, r5, pc}

  BYTE* buff = (BYTE *) &mbr;
  DWORD sector = 0;
  UINT count = 1;
  
  if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("init",res);
    6c82:	ldr	r0, [pc, #12]	; (6c90 <zeroFS_class::Init(unsigned char, unsigned char, char const*)+0x7c>)
    6c84:	bl	65d8 <die(char const*, DRESULT)>
    6c88:	.word	0x2000029c
    6c8c:	.word	0x20000bac
    6c90:	.word	0x200002b8

00006c94 <zeroFS_class::Count(unsigned long)>:
/*********************** for MTP **********************/

uint32_t zeroFS_class::Count(uint32_t parent)
{
  parent_sector=parent;
  if(parent==0xfffffffful)
    6c94:	adds	r3, r1, #1


/*********************** for MTP **********************/

uint32_t zeroFS_class::Count(uint32_t parent)
{
    6c96:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    6c9a:	mov	r4, r0
  parent_sector=parent;
    6c9c:	str	r1, [r0, #20]
  if(parent==0xfffffffful)
    6c9e:	beq.n	6cee <zeroFS_class::Count(unsigned long)+0x5a>
    read_sector=root_sector;
    return cnt;
  }
  else
  {
    uint32_t sector = parent+1;
    6ca0:	add.w	r9, r1, #1
    6ca4:	movw	r7, #8304	; 0x2070
    uint32_t cnt=0;
    HDR_TYPE type=(HDR_TYPE) 0;
    6ca8:	movs	r6, #0
      UINT count = 1;
      
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
      if(type==0) 
        type=(HDR_TYPE) hdr.type;
      else if(hdr.type != (HDR_TYPE) type) 
    6caa:	movw	r8, #8308	; 0x2074
    read_sector=root_sector;
    return cnt;
  }
  else
  {
    uint32_t sector = parent+1;
    6cae:	mov	r2, r9
    6cb0:	add	r7, r0
    uint32_t cnt=0;
    6cb2:	mov	r5, r6
      UINT count = 1;
      
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
      if(type==0) 
        type=(HDR_TYPE) hdr.type;
      else if(hdr.type != (HDR_TYPE) type) 
    6cb4:	add	r8, r0
        break; 
      cnt++;
      sector = hdr.next;
    6cb6:	add.w	sl, r0, #8320	; 0x2080
    6cba:	b.n	6ccc <zeroFS_class::Count(unsigned long)+0x38>
      BYTE* buff = (BYTE *) &hdr;
      UINT count = 1;
      
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
      if(type==0) 
        type=(HDR_TYPE) hdr.type;
    6cbc:	ldrb.w	r6, [r8]
      else if(hdr.type != (HDR_TYPE) type) 
        break; 
      cnt++;
      sector = hdr.next;
    6cc0:	ldr.w	r2, [sl]
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
      if(type==0) 
        type=(HDR_TYPE) hdr.type;
      else if(hdr.type != (HDR_TYPE) type) 
        break; 
      cnt++;
    6cc4:	adds	r5, #1
      sector = hdr.next;
      if(sector==eof_sector) break; // end of data reached
    6cc6:	ldr	r3, [r4, #16]
    6cc8:	cmp	r2, r3
    6cca:	beq.n	6ce4 <zeroFS_class::Count(unsigned long)+0x50>
    while(1)
    {
      BYTE* buff = (BYTE *) &hdr;
      UINT count = 1;
      
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    6ccc:	movs	r3, #1
    6cce:	mov	r1, r7
    6cd0:	ldrb	r0, [r4, #28]
    6cd2:	bl	6e70 <disk_read>
    6cd6:	cbnz	r0, 6d1c <zeroFS_class::Count(unsigned long)+0x88>
      if(type==0) 
    6cd8:	cmp	r6, #0
    6cda:	beq.n	6cbc <zeroFS_class::Count(unsigned long)+0x28>
        type=(HDR_TYPE) hdr.type;
      else if(hdr.type != (HDR_TYPE) type) 
    6cdc:	ldr.w	r3, [r8]
    6ce0:	cmp	r3, r6
    6ce2:	beq.n	6cc0 <zeroFS_class::Count(unsigned long)+0x2c>
      cnt++;
      sector = hdr.next;
      if(sector==eof_sector) break; // end of data reached
    }
    read_sector=parent+1;
    return cnt;
    6ce4:	mov	r0, r5
        break; 
      cnt++;
      sector = hdr.next;
      if(sector==eof_sector) break; // end of data reached
    }
    read_sector=parent+1;
    6ce6:	str.w	r9, [r4, #12]
    return cnt;
  }
}
    6cea:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6cee:	movw	r6, #8304	; 0x2070

uint32_t zeroFS_class::Count(uint32_t parent)
{
  parent_sector=parent;
  if(parent==0xfffffffful)
  { uint32_t sector = root_sector;
    6cf2:	ldr	r2, [r0, #0]
    uint32_t cnt=0;
    6cf4:	movs	r5, #0
      BYTE* buff = (BYTE *) &hdr;
      UINT count = 1;
      
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
      cnt++;      
      sector = hdr.next;
    6cf6:	add.w	r7, r0, #8320	; 0x2080
    6cfa:	add	r6, r0
    while(1)
    {
      BYTE* buff = (BYTE *) &hdr;
      UINT count = 1;
      
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    6cfc:	movs	r3, #1
    6cfe:	mov	r1, r6
    6d00:	ldrb	r0, [r4, #28]
    6d02:	bl	6e70 <disk_read>
    6d06:	cbnz	r0, 6d1c <zeroFS_class::Count(unsigned long)+0x88>
      cnt++;      
      sector = hdr.next;
    6d08:	ldr	r2, [r7, #0]
    {
      BYTE* buff = (BYTE *) &hdr;
      UINT count = 1;
      
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
      cnt++;      
    6d0a:	adds	r5, #1
      sector = hdr.next;
      if(sector==eof_sector) break; // end of data reached
    6d0c:	ldr	r3, [r4, #16]
    6d0e:	cmp	r2, r3
    6d10:	bne.n	6cfc <zeroFS_class::Count(unsigned long)+0x68>
    }
    read_sector=root_sector;
    6d12:	ldr	r3, [r4, #0]
    {
      BYTE* buff = (BYTE *) &hdr;
      UINT count = 1;
      
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
      cnt++;      
    6d14:	mov	r0, r5
      sector = hdr.next;
      if(sector==eof_sector) break; // end of data reached
    }
    read_sector=root_sector;
    6d16:	str	r3, [r4, #12]
    return cnt;
    6d18:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    while(1)
    {
      BYTE* buff = (BYTE *) &hdr;
      UINT count = 1;
      
      if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read3",res);
    6d1c:	mov	r1, r0
    6d1e:	ldr	r0, [pc, #4]	; (6d24 <zeroFS_class::Count(unsigned long)+0x90>)
    6d20:	bl	65d8 <die(char const*, DRESULT)>
    6d24:	.word	0x200001fc

00006d28 <zeroFS_class::Next()>:
  }
}
uint32_t zeroFS_class::Next(void)
{
  //uint32_t old_type=0;
  uint32_t sector = read_sector;
    6d28:	ldr	r2, [r0, #12]
  HDR_TYPE type=T_ROOT;

  if(sector==eof_sector) return 0;
    6d2a:	ldr	r3, [r0, #16]
    6d2c:	cmp	r2, r3
    6d2e:	beq.n	6d54 <zeroFS_class::Next()+0x2c>

    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read4",res);
    6d30:	movw	r1, #8304	; 0x2070
    6d34:	movs	r3, #1
    read_sector=parent+1;
    return cnt;
  }
}
uint32_t zeroFS_class::Next(void)
{
    6d36:	push	{r4, lr}
    6d38:	mov	r4, r0
  if(sector==eof_sector) return 0;

    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read4",res);
    6d3a:	ldrb	r0, [r0, #28]
    6d3c:	add	r1, r4
    6d3e:	bl	6e70 <disk_read>
    6d42:	cbnz	r0, 6d58 <zeroFS_class::Next()+0x30>
    if(type==0) 
      type=(HDR_TYPE) hdr.type;
    else if((HDR_TYPE) hdr.type != type) 
      return 0; 

    read_sector= hdr.next;
    6d44:	add.w	r3, r4, #8320	; 0x2080
    return hdr.sect;
    6d48:	movw	r2, #8312	; 0x2078
    if(type==0) 
      type=(HDR_TYPE) hdr.type;
    else if((HDR_TYPE) hdr.type != type) 
      return 0; 

    read_sector= hdr.next;
    6d4c:	ldr	r3, [r3, #0]
    return hdr.sect;
    6d4e:	ldr	r0, [r4, r2]
    if(type==0) 
      type=(HDR_TYPE) hdr.type;
    else if((HDR_TYPE) hdr.type != type) 
      return 0; 

    read_sector= hdr.next;
    6d50:	str	r3, [r4, #12]
    return hdr.sect;
    6d52:	pop	{r4, pc}
{
  //uint32_t old_type=0;
  uint32_t sector = read_sector;
  HDR_TYPE type=T_ROOT;

  if(sector==eof_sector) return 0;
    6d54:	movs	r0, #0
    6d56:	bx	lr

    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;
    
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read4",res);
    6d58:	mov	r1, r0
    6d5a:	ldr	r0, [pc, #4]	; (6d60 <zeroFS_class::Next()+0x38>)
    6d5c:	bl	65d8 <die(char const*, DRESULT)>
    6d60:	.word	0x2000025c

00006d64 <zeroFS_class::Info(unsigned long, char*, unsigned long*, unsigned long*)>:
    read_sector= hdr.next;
    return hdr.sect;
}

uint32_t zeroFS_class::Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
{
    6d64:	push	{r4, r5, r6, lr}
  //uint32_t old_type=0;
  uint32_t sector = handle;
  if(sector==eof_sector) return 0;
    6d66:	ldr	r4, [r0, #16]
    6d68:	cmp	r1, r4
    6d6a:	beq.n	6db2 <zeroFS_class::Info(unsigned long, char*, unsigned long*, unsigned long*)+0x4e>
    6d6c:	mov	r4, r0
    6d6e:	mov	r5, r2
    6d70:	mov	r2, r1

    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;

    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read5",res);
    6d72:	movw	r1, #8304	; 0x2070
    6d76:	mov	r6, r3
    6d78:	ldrb	r0, [r0, #28]
    6d7a:	movs	r3, #1
    6d7c:	add	r1, r4
    6d7e:	bl	6e70 <disk_read>
    6d82:	cbnz	r0, 6dca <zeroFS_class::Info(unsigned long, char*, unsigned long*, unsigned long*)+0x66>

    strcpy(filename,hdr.name);
    6d84:	movw	r1, #8344	; 0x2098
    6d88:	mov	r0, r5
    6d8a:	add	r1, r4
    6d8c:	bl	bf1c <strcpy>
    if(hdr.type==T_FILE)
    6d90:	movw	r3, #8308	; 0x2074
    6d94:	ldr	r3, [r4, r3]
    6d96:	cmp	r3, #3
    6d98:	beq.n	6db6 <zeroFS_class::Info(unsigned long, char*, unsigned long*, unsigned long*)+0x52>
    {
      *size=512*(hdr.next-hdr.sect);
    }
    else
    {
      *size=0xFFFFFFFFul;
    6d9a:	mov.w	r3, #4294967295
    6d9e:	str	r3, [r6, #0]
    }
    *parent=hdr.parent;
    6da0:	movw	r2, #8324	; 0x2084
    return hdr.sect;
    6da4:	movw	r3, #8312	; 0x2078
    }
    else
    {
      *size=0xFFFFFFFFul;
    }
    *parent=hdr.parent;
    6da8:	ldr	r1, [sp, #16]
    6daa:	ldr	r2, [r4, r2]
    6dac:	str	r2, [r1, #0]
    return hdr.sect;
    6dae:	ldr	r0, [r4, r3]
    6db0:	pop	{r4, r5, r6, pc}

uint32_t zeroFS_class::Info(uint32_t handle, char *filename, uint32_t *size, uint32_t *parent)
{
  //uint32_t old_type=0;
  uint32_t sector = handle;
  if(sector==eof_sector) return 0;
    6db2:	movs	r0, #0
    {
      *size=0xFFFFFFFFul;
    }
    *parent=hdr.parent;
    return hdr.sect;
}
    6db4:	pop	{r4, r5, r6, pc}
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read5",res);

    strcpy(filename,hdr.name);
    if(hdr.type==T_FILE)
    {
      *size=512*(hdr.next-hdr.sect);
    6db6:	add.w	r3, r4, #8320	; 0x2080
    6dba:	movw	r2, #8312	; 0x2078
    6dbe:	ldr	r3, [r3, #0]
    6dc0:	ldr	r2, [r4, r2]
    6dc2:	subs	r3, r3, r2
    6dc4:	lsls	r3, r3, #9
    6dc6:	str	r3, [r6, #0]
    6dc8:	b.n	6da0 <zeroFS_class::Info(unsigned long, char*, unsigned long*, unsigned long*)+0x3c>
  if(sector==eof_sector) return 0;

    BYTE* buff = (BYTE *) &hdr;
    UINT count = 1;

    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read5",res);
    6dca:	mov	r1, r0
    6dcc:	ldr	r0, [pc, #4]	; (6dd4 <zeroFS_class::Info(unsigned long, char*, unsigned long*, unsigned long*)+0x70>)
    6dce:	bl	65d8 <die(char const*, DRESULT)>
    6dd2:	nop
    6dd4:	.word	0x20000264

00006dd8 <zeroFS_class::GetSize(unsigned long)>:
    *parent=hdr.parent;
    return hdr.sect;
}

  uint32_t zeroFS_class::GetSize(uint32_t handle) 
  {
    6dd8:	push	{r4, lr}
    BYTE* buff = (BYTE *) &hdr;
    uint32_t sector=handle;
    UINT count = 1;
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read6",res);
    6dda:	mov	r2, r1
    *parent=hdr.parent;
    return hdr.sect;
}

  uint32_t zeroFS_class::GetSize(uint32_t handle) 
  {
    6ddc:	mov	r4, r0
    BYTE* buff = (BYTE *) &hdr;
    uint32_t sector=handle;
    UINT count = 1;
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read6",res);
    6dde:	movw	r1, #8304	; 0x2070
    6de2:	movs	r3, #1
    6de4:	ldrb	r0, [r0, #28]
    6de6:	add	r1, r4
    6de8:	bl	6e70 <disk_read>
    6dec:	cbnz	r0, 6e00 <zeroFS_class::GetSize(unsigned long)+0x28>

    return 512*(hdr.next-hdr.sect);
    6dee:	add.w	r3, r4, #8320	; 0x2080
    6df2:	movw	r2, #8312	; 0x2078
    6df6:	ldr	r3, [r3, #0]
    6df8:	ldr	r0, [r4, r2]
    6dfa:	subs	r0, r3, r0
  }
    6dfc:	lsls	r0, r0, #9
    6dfe:	pop	{r4, pc}
  uint32_t zeroFS_class::GetSize(uint32_t handle) 
  {
    BYTE* buff = (BYTE *) &hdr;
    uint32_t sector=handle;
    UINT count = 1;
    if(DRESULT res = disk_read (pdrv, buff, sector, count)) die("read6",res);
    6e00:	mov	r1, r0
    6e02:	ldr	r0, [pc, #4]	; (6e08 <zeroFS_class::GetSize(unsigned long)+0x30>)
    6e04:	bl	65d8 <die(char const*, DRESULT)>
    6e08:	.word	0x2000026c

00006e0c <zeroFS_class::Read(unsigned long, char*, unsigned long)>:
    // keep sector number for next call
    old_sector=sector;
  }

  uint32_t zeroFS_class::Read(uint32_t sector, char* out, uint32_t count) 
  { if(DRESULT res = disk_read (pdrv, (BYTE*)out, sector, count)) die("read_",res);
    6e0c:	push	{r3, r4, r5, lr}
    6e0e:	mov	r4, r1
    6e10:	ldrb	r0, [r0, #28]
    6e12:	mov	r1, r2
    6e14:	mov	r5, r3
    6e16:	mov	r2, r4
    6e18:	bl	6e70 <disk_read>
    6e1c:	cbnz	r0, 6e22 <zeroFS_class::Read(unsigned long, char*, unsigned long)+0x16>
    return sector+count;
    6e1e:	adds	r0, r4, r5
    6e20:	pop	{r3, r4, r5, pc}
    // keep sector number for next call
    old_sector=sector;
  }

  uint32_t zeroFS_class::Read(uint32_t sector, char* out, uint32_t count) 
  { if(DRESULT res = disk_read (pdrv, (BYTE*)out, sector, count)) die("read_",res);
    6e22:	mov	r1, r0
    6e24:	ldr	r0, [pc, #4]	; (6e2c <zeroFS_class::Read(unsigned long, char*, unsigned long)+0x20>)
    6e26:	bl	65d8 <die(char const*, DRESULT)>
    6e2a:	nop
    6e2c:	.word	0x200002c0

00006e30 <MSC_disk_initialize>:
	}

	int MSC_ioctl(BYTE cmd, BYTE *buff) {return 0;}
#else
	int MSC_disk_status() {return STA_NOINIT;}
	int MSC_disk_initialize() {return STA_NOINIT;}
    6e30:	movs	r0, #1
    6e32:	bx	lr

00006e34 <MSC_disk_read>:
    6e34:	movs	r0, #1
    6e36:	bx	lr

00006e38 <MSC_disk_write>:
	int MSC_disk_read(BYTE *buff, DWORD sector, UINT count) {return STA_NOINIT;}
	int MSC_disk_write(const BYTE *buff, DWORD sector, UINT count) {return STA_NOINIT;}
    6e38:	movs	r0, #1
    6e3a:	bx	lr

00006e3c <disk_initialize>:
)
{
	DSTATUS stat=STA_NOINIT;
	int result;

	switch (pdrv) {
    6e3c:	cmp	r0, #1
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
    6e3e:	push	{r3, lr}
	DSTATUS stat=STA_NOINIT;
	int result;

	switch (pdrv) {
    6e40:	beq.n	6e64 <disk_initialize+0x28>
    6e42:	bcc.n	6e56 <disk_initialize+0x1a>
    6e44:	cmp	r0, #2
    6e46:	bne.n	6e52 <disk_initialize+0x16>
		if(result==RES_OK) stat=0; else stat=STA_NODISK;

		return stat;

	case DEV_MSC :
		result = MSC_disk_initialize();
    6e48:	bl	6e30 <MSC_disk_initialize>

		// translate the reslut code here
		if(result==RES_OK) stat=0; else stat=STA_NODISK;
    6e4c:	cbz	r0, 6e60 <disk_initialize+0x24>
	switch (pdrv) {
	case DEV_SPI :

		result = SPI_disk_initialize(pdrv);
		// translate the reslut code here
		if(result==RES_OK) stat=0; else stat=STA_NODISK;
    6e4e:	movs	r0, #2
    6e50:	pop	{r3, pc}
		// translate the reslut code here
		if(result==RES_OK) stat=0; else stat=STA_NODISK;

		return stat;
	}
	return STA_NOINIT;
    6e52:	movs	r0, #1
}
    6e54:	pop	{r3, pc}
	int result;

	switch (pdrv) {
	case DEV_SPI :

		result = SPI_disk_initialize(pdrv);
    6e56:	movs	r0, #0
    6e58:	bl	7f48 <SPI_disk_initialize>
		// translate the reslut code here
		if(result==RES_OK) stat=0; else stat=STA_NODISK;
    6e5c:	cmp	r0, #0
    6e5e:	bne.n	6e4e <disk_initialize+0x12>
    6e60:	movs	r0, #0
    6e62:	pop	{r3, pc}

		return stat;

	case DEV_SDHC :
		result = SDHC_disk_initialize();
    6e64:	bl	7474 <SDHC_disk_initialize>

		// translate the reslut code here
		if(result==RES_OK) stat=0; else stat=STA_NODISK;
    6e68:	cmp	r0, #0
    6e6a:	beq.n	6e60 <disk_initialize+0x24>
	switch (pdrv) {
	case DEV_SPI :

		result = SPI_disk_initialize(pdrv);
		// translate the reslut code here
		if(result==RES_OK) stat=0; else stat=STA_NODISK;
    6e6c:	movs	r0, #2
    6e6e:	pop	{r3, pc}

00006e70 <disk_read>:
	UINT count		/* Number of sectors to read */
)
{
	DRESULT res=RES_OK;
	int result=0;
	switch (pdrv) {
    6e70:	cmp	r0, #1
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Start sector in LBA */
	UINT count		/* Number of sectors to read */
)
{
    6e72:	push	{r4, lr}
    6e74:	mov	r4, r1
    6e76:	mov	r1, r2
	DRESULT res=RES_OK;
	int result=0;
	switch (pdrv) {
    6e78:	beq.n	6ea2 <disk_read+0x32>
    6e7a:	bcc.n	6e92 <disk_read+0x22>
    6e7c:	cmp	r0, #2
    6e7e:	bne.n	6e8e <disk_read+0x1e>
		return res;

	case DEV_MSC :
		// translate the arguments here

		result = MSC_disk_read(buff, sector, count);
    6e80:	mov	r2, r3
    6e82:	mov	r0, r4
    6e84:	bl	6e34 <MSC_disk_read>
		// translate the reslut code here
		if(result==0) res=RES_OK; else res=RES_READERROR;
    6e88:	cbz	r0, 6e9e <disk_read+0x2e>
	switch (pdrv) {
	case DEV_SPI :
  
		result = SPI_disk_read(buff, sector, count);
		// translate the reslut code here
 	    if(result==0) res=RES_OK; else res=RES_READERROR;
    6e8a:	movs	r0, #6
    6e8c:	pop	{r4, pc}

		return res;

	}

	return RES_PARERR;
    6e8e:	movs	r0, #4
}
    6e90:	pop	{r4, pc}
	DRESULT res=RES_OK;
	int result=0;
	switch (pdrv) {
	case DEV_SPI :
  
		result = SPI_disk_read(buff, sector, count);
    6e92:	mov	r2, r3
    6e94:	mov	r0, r4
    6e96:	bl	79ec <SPI_disk_read>
		// translate the reslut code here
 	    if(result==0) res=RES_OK; else res=RES_READERROR;
    6e9a:	cmp	r0, #0
    6e9c:	bne.n	6e8a <disk_read+0x1a>
    6e9e:	movs	r0, #0
    6ea0:	pop	{r4, pc}
		return res;

	case DEV_SDHC :
		// translate the arguments here

		result = SDHC_disk_read(buff, sector, count);
    6ea2:	mov	r2, r3
    6ea4:	mov	r0, r4
    6ea6:	bl	758c <SDHC_disk_read>
		// translate the reslut code here
		if(result==0) res=RES_OK; else res=RES_READERROR;
    6eaa:	cmp	r0, #0
    6eac:	beq.n	6e9e <disk_read+0x2e>
	switch (pdrv) {
	case DEV_SPI :
  
		result = SPI_disk_read(buff, sector, count);
		// translate the reslut code here
 	    if(result==0) res=RES_OK; else res=RES_READERROR;
    6eae:	movs	r0, #6
    6eb0:	pop	{r4, pc}
    6eb2:	nop

00006eb4 <disk_write>:
)
{
	DRESULT res=RES_OK;
	int result;

	switch (pdrv) {
    6eb4:	cmp	r0, #1
	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Start sector in LBA */
	UINT count			/* Number of sectors to write */
)
{
    6eb6:	push	{r4, lr}
    6eb8:	mov	r4, r1
    6eba:	mov	r1, r2
	DRESULT res=RES_OK;
	int result;

	switch (pdrv) {
    6ebc:	beq.n	6ee6 <disk_write+0x32>
    6ebe:	bcc.n	6ed6 <disk_write+0x22>
    6ec0:	cmp	r0, #2
    6ec2:	bne.n	6ed2 <disk_write+0x1e>
		return res;

	case DEV_MSC :
		// translate the arguments here

		result = MSC_disk_write(buff, sector, count);
    6ec4:	mov	r2, r3
    6ec6:	mov	r0, r4
    6ec8:	bl	6e38 <MSC_disk_write>
		// translate the reslut code here
		if(result==0) res=RES_OK; else res=RES_WRITEERROR;
    6ecc:	cbz	r0, 6ee2 <disk_write+0x2e>
	case DEV_SPI :
		// translate the arguments here

		result = SPI_disk_write(buff, sector, count);
		// translate the reslut code here
		if(result==0) res=RES_OK; else res=RES_WRITEERROR;
    6ece:	movs	r0, #7
    6ed0:	pop	{r4, pc}
		if(result==0) res=RES_OK; else res=RES_WRITEERROR;

		return res;
	}

	return RES_PARERR;
    6ed2:	movs	r0, #4
}
    6ed4:	pop	{r4, pc}

	switch (pdrv) {
	case DEV_SPI :
		// translate the arguments here

		result = SPI_disk_write(buff, sector, count);
    6ed6:	mov	r2, r3
    6ed8:	mov	r0, r4
    6eda:	bl	7c30 <SPI_disk_write>
		// translate the reslut code here
		if(result==0) res=RES_OK; else res=RES_WRITEERROR;
    6ede:	cmp	r0, #0
    6ee0:	bne.n	6ece <disk_write+0x1a>
    6ee2:	movs	r0, #0
    6ee4:	pop	{r4, pc}
		return res;

	case DEV_SDHC :
		// translate the arguments here

		result = SDHC_disk_write(buff, sector, count);
    6ee6:	mov	r2, r3
    6ee8:	mov	r0, r4
    6eea:	bl	76fc <SDHC_disk_write>
		// translate the reslut code here
		if(result==0) res=RES_OK; else res=RES_WRITEERROR;
    6eee:	cmp	r0, #0
    6ef0:	beq.n	6ee2 <disk_write+0x2e>
	case DEV_SPI :
		// translate the arguments here

		result = SPI_disk_write(buff, sector, count);
		// translate the reslut code here
		if(result==0) res=RES_OK; else res=RES_WRITEERROR;
    6ef2:	movs	r0, #7
    6ef4:	pop	{r4, pc}
    6ef6:	nop

00006ef8 <setSdclk>:
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05 = 6; //CCM_CLKO2 (0 is USDHC1_DAT3)
  }
  
  static uint32_t sdClock()
  {
    uint32_t divider = ((CCM_CSCDR1 >> 11) & 0x7) + 1;
    6ef8:	ldr	r2, [pc, #152]	; (6f94 <setSdclk+0x9c>)
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000 * kHzMax;
    6efa:	mov.w	r1, #1000	; 0x3e8
  }
  
  static uint32_t sdClock()
  {
    uint32_t divider = ((CCM_CSCDR1 >> 11) & 0x7) + 1;
    uint32_t PLL2PFD0 = (528000000U * 3) / ((CCM_ANALOG_PFD_528 & 0x3F) / 6) / divider;
    6efe:	ldr	r3, [pc, #152]	; (6f98 <setSdclk+0xa0>)
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05 = 6; //CCM_CLKO2 (0 is USDHC1_DAT3)
  }
  
  static uint32_t sdClock()
  {
    uint32_t divider = ((CCM_CSCDR1 >> 11) & 0x7) + 1;
    6f00:	ldr	r2, [r2, #36]	; 0x24
static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
  uint32_t maxSdclk = 1000 * kHzMax;
    6f02:	mul.w	r0, r1, r0
  }
  
  static uint32_t sdClock()
  {
    uint32_t divider = ((CCM_CSCDR1 >> 11) & 0x7) + 1;
    uint32_t PLL2PFD0 = (528000000U * 3) / ((CCM_ANALOG_PFD_528 & 0x3F) / 6) / divider;
    6f06:	ldr.w	r3, [r3, #256]	; 0x100
    6f0a:	ldr	r1, [pc, #144]	; (6f9c <setSdclk+0xa4>)
    6f0c:	and.w	r3, r3, #63	; 0x3f
    6f10:	umull	r1, r3, r1, r3
    return PLL2PFD0;
  }

#endif

static void setSdclk(uint32_t kHzMax) {
    6f14:	push	{r4, r5, r6, r7}
  }
  
  static uint32_t sdClock()
  {
    uint32_t divider = ((CCM_CSCDR1 >> 11) & 0x7) + 1;
    uint32_t PLL2PFD0 = (528000000U * 3) / ((CCM_ANALOG_PFD_528 & 0x3F) / 6) / divider;
    6f16:	lsrs	r3, r3, #2
    6f18:	ubfx	r4, r2, #11, #3
    6f1c:	ldr	r2, [pc, #128]	; (6fa0 <setSdclk+0xa8>)
    6f1e:	adds	r4, #1
    6f20:	udiv	r3, r2, r3
    6f24:	udiv	r4, r3, r4
  uint32_t maxSdclk = 1000 * kHzMax;

  //  uint32_t f_pll = F_CPU;
  uint32_t f_pll = sdClock();

  while ((f_pll / (sdclkfs * DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    6f28:	cmp.w	r0, r4, lsr #4
    6f2c:	bcs.n	6f8a <setSdclk+0x92>
    6f2e:	movs	r3, #1
    6f30:	b.n	6f36 <setSdclk+0x3e>
    6f32:	cmp	r3, #255	; 0xff
    6f34:	bhi.n	6f42 <setSdclk+0x4a>
    sdclkfs <<= 1;
    6f36:	lsls	r3, r3, #1
  uint32_t maxSdclk = 1000 * kHzMax;

  //  uint32_t f_pll = F_CPU;
  uint32_t f_pll = sdClock();

  while ((f_pll / (sdclkfs * DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    6f38:	lsls	r2, r3, #4
    6f3a:	udiv	r2, r4, r2
    6f3e:	cmp	r0, r2
    6f40:	bcc.n	6f32 <setSdclk+0x3a>
    6f42:	lsrs	r2, r3, #1
    6f44:	lsls	r7, r2, #8
    sdclkfs <<= 1;
  }
  while ((f_pll / (sdclkfs * dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    6f46:	udiv	r2, r4, r3
    6f4a:	cmp	r0, r2
    6f4c:	bcs.n	6f90 <setSdclk+0x98>
    6f4e:	lsls	r1, r3, #1
    6f50:	movs	r2, #1
    dvs++;
    6f52:	adds	r6, r2, #1
  uint32_t f_pll = sdClock();

  while ((f_pll / (sdclkfs * DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((f_pll / (sdclkfs * dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    6f54:	udiv	r5, r4, r1
    6f58:	cmp	r0, r5
    6f5a:	add	r1, r3
    6f5c:	bcs.n	6f86 <setSdclk+0x8e>
    6f5e:	cmp	r6, #16
    6f60:	mov	r2, r6
    6f62:	bne.n	6f52 <setSdclk+0x5a>
    6f64:	movs	r3, #240	; 0xf0
    // Disable SDHC clock.
    SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
  #endif

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    6f66:	ldr	r4, [pc, #60]	; (6fa4 <setSdclk+0xac>)
                                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    6f68:	ldr	r0, [pc, #60]	; (6fa8 <setSdclk+0xb0>)
    // Disable SDHC clock.
    SDHC_SYSCTL &= ~SDHC_SYSCTL_SDCLKEN;
  #endif

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
    6f6a:	ldr	r2, [r4, #44]	; 0x2c

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) { }
    6f6c:	mov	r1, r4
  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
                                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);
    6f6e:	ands	r0, r2
    6f70:	orr.w	r0, r0, #917504	; 0xe0000
    6f74:	orr.w	r2, r0, r7
    6f78:	orrs	r2, r3

  // Change dividers.
  uint32_t sysctl = SDHC_SYSCTL & ~(SDHC_SYSCTL_DTOCV_MASK
                                    | SDHC_SYSCTL_DVS_MASK | SDHC_SYSCTL_SDCLKFS_MASK);

  SDHC_SYSCTL = sysctl | SDHC_SYSCTL_DTOCV(0x0E) | SDHC_SYSCTL_DVS(dvs)
    6f7a:	str	r2, [r4, #44]	; 0x2c
                | SDHC_SYSCTL_SDCLKFS(sdclkfs);

  // Wait until the SDHC clock is stable.
  while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_SDSTB)) { }
    6f7c:	ldr	r3, [r1, #36]	; 0x24
    6f7e:	lsls	r3, r3, #28
    6f80:	bpl.n	6f7c <setSdclk+0x84>

  #if defined(__MK64FX512__) || defined(__MK66FX1M0__)
    // Enable the SDHC clock.
    SDHC_SYSCTL |= SDHC_SYSCTL_SDCLKEN;
  #endif
}
    6f82:	pop	{r4, r5, r6, r7}
    6f84:	bx	lr
    6f86:	lsls	r3, r2, #4
    6f88:	b.n	6f66 <setSdclk+0x6e>
  uint32_t maxSdclk = 1000 * kHzMax;

  //  uint32_t f_pll = F_CPU;
  uint32_t f_pll = sdClock();

  while ((f_pll / (sdclkfs * DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    6f8a:	movs	r7, #0

static void setSdclk(uint32_t kHzMax) {
  const uint32_t DVS_LIMIT = 0X10;
  const uint32_t SDCLKFS_LIMIT = 0X100;
  uint32_t dvs = 1;
  uint32_t sdclkfs = 1;
    6f8c:	movs	r3, #1
    6f8e:	b.n	6f46 <setSdclk+0x4e>
  uint32_t f_pll = sdClock();

  while ((f_pll / (sdclkfs * DVS_LIMIT) > maxSdclk) && (sdclkfs < SDCLKFS_LIMIT)) {
    sdclkfs <<= 1;
  }
  while ((f_pll / (sdclkfs * dvs) > maxSdclk) && (dvs < DVS_LIMIT)) {
    6f90:	movs	r3, #0
    6f92:	b.n	6f66 <setSdclk+0x6e>
    6f94:	.word	0x400fc000
    6f98:	.word	0x400d8000
    6f9c:	.word	0xaaaaaaab
    6fa0:	.word	0x5e69ec00
    6fa4:	.word	0x402c0000
    6fa8:	.word	0xfff0000f

00006fac <sd_isr>:

static volatile uint32_t dmaDone=0;
//

void sd_isr(void)
{ SDHC_IRQSIGEN &= ~SDHC_IRQSIGEN_DMA_MASK;
    6fac:	ldr	r3, [pc, #64]	; (6ff0 <sd_isr+0x44>)
    6fae:	ldr	r2, [pc, #68]	; (6ff4 <sd_isr+0x48>)
    6fb0:	ldr	r0, [r3, #56]	; 0x38
  //
  while(!(SDHC_IRQSTAT & SDHC_IRQSTAT_TC));//  SDHC_IRQSTAT &= ~SDHC_IRQSTAT_TC;
    6fb2:	mov	r1, r3

static volatile uint32_t dmaDone=0;
//

void sd_isr(void)
{ SDHC_IRQSIGEN &= ~SDHC_IRQSIGEN_DMA_MASK;
    6fb4:	ands	r2, r0
    6fb6:	str	r2, [r3, #56]	; 0x38
  //
  while(!(SDHC_IRQSTAT & SDHC_IRQSTAT_TC));//  SDHC_IRQSTAT &= ~SDHC_IRQSTAT_TC;
    6fb8:	ldr	r3, [r1, #48]	; 0x30
    6fba:	ldr	r2, [pc, #52]	; (6ff0 <sd_isr+0x44>)
    6fbc:	lsls	r0, r3, #30
    6fbe:	bpl.n	6fb8 <sd_isr+0xc>

  #if defined(__IMXRT1052__) || defined(__IMXRT1062__)
    SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN) ;  
    6fc0:	ldr	r3, [r2, #72]	; 0x48
    6fc2:	bic.w	r3, r3, #129	; 0x81
    6fc6:	str	r3, [r2, #72]	; 0x48
  #endif
  
  if(SDHC_SYSCTL & SDHC_SYSCTL_HCKEN) SDHC_SYSCTL &=  ~SDHC_SYSCTL_HCKEN;
    6fc8:	ldr	r3, [r2, #44]	; 0x2c
    6fca:	lsls	r3, r3, #30
    6fcc:	bpl.n	6fd6 <sd_isr+0x2a>
    6fce:	ldr	r3, [r2, #44]	; 0x2c
    6fd0:	bic.w	r3, r3, #2
    6fd4:	str	r3, [r2, #44]	; 0x2c
  SDHC_PROCTL &= ~SDHC_PROCTL_D3CD; SDHC_PROCTL |=  SDHC_PROCTL_D3CD;
    6fd6:	ldr	r3, [pc, #24]	; (6ff0 <sd_isr+0x44>)

  dmaDone=1;
    6fd8:	movs	r0, #1
    6fda:	ldr	r1, [pc, #28]	; (6ff8 <sd_isr+0x4c>)
  #if defined(__IMXRT1052__) || defined(__IMXRT1062__)
    SDHC_MIX_CTRL &= ~(SDHC_MIX_CTRL_AC23EN | SDHC_MIX_CTRL_DMAEN) ;  
  #endif
  
  if(SDHC_SYSCTL & SDHC_SYSCTL_HCKEN) SDHC_SYSCTL &=  ~SDHC_SYSCTL_HCKEN;
  SDHC_PROCTL &= ~SDHC_PROCTL_D3CD; SDHC_PROCTL |=  SDHC_PROCTL_D3CD;
    6fdc:	ldr	r2, [r3, #40]	; 0x28
    6fde:	bic.w	r2, r2, #8
    6fe2:	str	r2, [r3, #40]	; 0x28
    6fe4:	ldr	r2, [r3, #40]	; 0x28
    6fe6:	orr.w	r2, r2, #8
    6fea:	str	r2, [r3, #40]	; 0x28

  dmaDone=1;
    6fec:	str	r0, [r1, #0]
    6fee:	bx	lr
    6ff0:	.word	0x402c0000
    6ff4:	.word	0xeffffff5
    6ff8:	.word	0x2000af10

00006ffc <sd_CMD>:
/***************************** LOW Level SDHC interface ********************************/
// sends the command to SDcard
static int sd_CMD(uint32_t xfertyp, uint32_t arg)
{
  // Card removal check preparation
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM;
    6ffc:	ldr	r3, [pc, #80]	; (7050 <sd_CMD+0x54>)
    6ffe:	ldr	r2, [r3, #48]	; 0x30
}

/***************************** LOW Level SDHC interface ********************************/
// sends the command to SDcard
static int sd_CMD(uint32_t xfertyp, uint32_t arg)
{
    7000:	push	{r4, r5}
  // Card removal check preparation
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM;
    7002:	orr.w	r2, r2, #128	; 0x80

  // Wait for cmd line idle // to do timeout PRSSTAT[CDIHB] and the PRSSTAT[CIHB]
  while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB));
    7006:	mov	r4, r3
    7008:	mov	r5, r3
/***************************** LOW Level SDHC interface ********************************/
// sends the command to SDcard
static int sd_CMD(uint32_t xfertyp, uint32_t arg)
{
  // Card removal check preparation
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM;
    700a:	str	r2, [r3, #48]	; 0x30

  // Wait for cmd line idle // to do timeout PRSSTAT[CDIHB] and the PRSSTAT[CIHB]
  while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB));
    700c:	ldr	r3, [r4, #36]	; 0x24
    700e:	ldr	r2, [pc, #64]	; (7050 <sd_CMD+0x54>)
    7010:	lsls	r3, r3, #31
    7012:	bmi.n	700c <sd_CMD+0x10>
    7014:	ldr	r3, [r5, #36]	; 0x24
    7016:	lsls	r3, r3, #30
    7018:	bmi.n	700c <sd_CMD+0x10>

  // send command
  SDHC_CMDARG = arg;
    701a:	str	r1, [r2, #8]
static uint32_t sd_WaitStatus(uint32_t mask)
{
  uint32_t             result;
  uint32_t             timeout = 1 << 24;
  do
  { result = SDHC_IRQSTAT & mask;
    701c:	mov	r5, r2
******************************************************************************/
// waits for status bits sets
static uint32_t sd_WaitStatus(uint32_t mask)
{
  uint32_t             result;
  uint32_t             timeout = 1 << 24;
    701e:	mov.w	r4, #16777216	; 0x1000000
  // Wait for cmd line idle // to do timeout PRSSTAT[CDIHB] and the PRSSTAT[CIHB]
  while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB));

  // send command
  SDHC_CMDARG = arg;
  SDHC_XFERTYP = xfertyp;
    7022:	str	r0, [r2, #12]
    7024:	b.n	7028 <sd_CMD+0x2c>
  uint32_t             result;
  uint32_t             timeout = 1 << 24;
  do
  { result = SDHC_IRQSTAT & mask;
    timeout--;
  } while (!result && (timeout));
    7026:	cbz	r4, 7034 <sd_CMD+0x38>
static uint32_t sd_WaitStatus(uint32_t mask)
{
  uint32_t             result;
  uint32_t             timeout = 1 << 24;
  do
  { result = SDHC_IRQSTAT & mask;
    7028:	ldr	r2, [r5, #48]	; 0x30
    timeout--;
    702a:	subs	r4, #1
static uint32_t sd_WaitStatus(uint32_t mask)
{
  uint32_t             result;
  uint32_t             timeout = 1 << 24;
  do
  { result = SDHC_IRQSTAT & mask;
    702c:	ldr	r3, [pc, #36]	; (7054 <sd_CMD+0x58>)
    702e:	ands	r3, r2
    timeout--;
  } while (!result && (timeout));
    7030:	cmp	r3, #0
    7032:	beq.n	7026 <sd_CMD+0x2a>
  SDHC_CMDARG = arg;
  SDHC_XFERTYP = xfertyp;

  /* Wait for response */
  const uint32_t mask = SDHC_IRQSTAT_CIE | SDHC_IRQSTAT_CEBE | SDHC_IRQSTAT_CCE | SDHC_IRQSTAT_CC;
  if (sd_WaitStatus(mask) != SDHC_IRQSTAT_CC)
    7034:	cmp	r3, #1
    7036:	bne.n	7040 <sd_CMD+0x44>
    7038:	clz	r0, r4
    703c:	lsrs	r0, r0, #5
    703e:	cbz	r0, 704c <sd_CMD+0x50>
  { SDHC_IRQSTAT |= mask;
    7040:	ldr	r2, [pc, #12]	; (7050 <sd_CMD+0x54>)
    return SDHC_RESULT_ERROR;
    7042:	movs	r0, #1
  SDHC_XFERTYP = xfertyp;

  /* Wait for response */
  const uint32_t mask = SDHC_IRQSTAT_CIE | SDHC_IRQSTAT_CEBE | SDHC_IRQSTAT_CCE | SDHC_IRQSTAT_CC;
  if (sd_WaitStatus(mask) != SDHC_IRQSTAT_CC)
  { SDHC_IRQSTAT |= mask;
    7044:	ldr	r3, [pc, #12]	; (7054 <sd_CMD+0x58>)
    7046:	ldr	r1, [r2, #48]	; 0x30
    7048:	orrs	r3, r1
    704a:	str	r3, [r2, #48]	; 0x30
    return SDHC_RESULT_NO_RESPONSE;
  }
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CC;

  return SDHC_RESULT_OK;
}
    704c:	pop	{r4, r5}
    704e:	bx	lr
    7050:	.word	0x402c0000
    7054:	.word	0x000e0001

00007058 <sd_ACMD>:
// send CMD 55 Application specific command
#define SDHC_CMD55_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD55) | SDHC_XFERTYP_CICEN | \
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))

static int sd_ACMD(uint32_t xfertyp, uint32_t arg1, uint32_t arg2)
{
    7058:	push	{r3, r4, r5, lr}
    705a:	mov	r4, r0
  int result =sd_CMD(SDHC_CMD55_XFERTYP,arg1);
    705c:	ldr	r0, [pc, #20]	; (7074 <sd_ACMD+0x1c>)
// send CMD 55 Application specific command
#define SDHC_CMD55_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD55) | SDHC_XFERTYP_CICEN | \
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))

static int sd_ACMD(uint32_t xfertyp, uint32_t arg1, uint32_t arg2)
{
    705e:	mov	r5, r2
  int result =sd_CMD(SDHC_CMD55_XFERTYP,arg1);
    7060:	bl	6ffc <sd_CMD>
  if(!(result == SDHC_RESULT_OK)) return result;
    7064:	cbz	r0, 7068 <sd_ACMD+0x10>
  return sd_CMD(xfertyp,arg2);
}
    7066:	pop	{r3, r4, r5, pc}

static int sd_ACMD(uint32_t xfertyp, uint32_t arg1, uint32_t arg2)
{
  int result =sd_CMD(SDHC_CMD55_XFERTYP,arg1);
  if(!(result == SDHC_RESULT_OK)) return result;
  return sd_CMD(xfertyp,arg2);
    7068:	mov	r1, r5
    706a:	mov	r0, r4
}
    706c:	ldmia.w	sp!, {r3, r4, r5, lr}

static int sd_ACMD(uint32_t xfertyp, uint32_t arg1, uint32_t arg2)
{
  int result =sd_CMD(SDHC_CMD55_XFERTYP,arg1);
  if(!(result == SDHC_RESULT_OK)) return result;
  return sd_CMD(xfertyp,arg2);
    7070:	b.w	6ffc <sd_CMD>
    7074:	.word	0x371a0000

00007078 <sd_CMD12_StopTransferWaitForBusy>:
//
static int sd_CMD12_StopTransfer(void){  return sd_CMD(SDHC_CMD12_XFERTYP, 0);}

// ---------- sends CMD12 to stop transfer and first waits to ready SDCard
static int sd_CMD12_StopTransferWaitForBusy(void)
{
    7078:	push	{r3, r4, r5, lr}

// ---------- sends CMD12 to stop transfer
#define SDHC_CMD12_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) | \
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY))
//
static int sd_CMD12_StopTransfer(void){  return sd_CMD(SDHC_CMD12_XFERTYP, 0);}
    707a:	movs	r1, #0
    707c:	ldr	r0, [pc, #48]	; (70b0 <sd_CMD12_StopTransferWaitForBusy+0x38>)
    707e:	bl	6ffc <sd_CMD>
    7082:	movw	r4, #999	; 0x3e7
    7086:	mov	r3, r0
  uint32_t timeOut = 1000;
  int result;
  do 
  { result = sd_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
    7088:	ldr	r5, [pc, #40]	; (70b4 <sd_CMD12_StopTransferWaitForBusy+0x3c>)
    708a:	b.n	7098 <sd_CMD12_StopTransferWaitForBusy+0x20>
    708c:	cbnz	r3, 70a2 <sd_CMD12_StopTransferWaitForBusy+0x2a>

// ---------- sends CMD12 to stop transfer
#define SDHC_CMD12_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) | \
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY))
//
static int sd_CMD12_StopTransfer(void){  return sd_CMD(SDHC_CMD12_XFERTYP, 0);}
    708e:	bl	6ffc <sd_CMD>
  uint32_t timeOut = 1000;
  int result;
  do 
  { result = sd_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
    7092:	subs	r4, #1

// ---------- sends CMD12 to stop transfer
#define SDHC_CMD12_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) | \
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY))
//
static int sd_CMD12_StopTransfer(void){  return sd_CMD(SDHC_CMD12_XFERTYP, 0);}
    7094:	mov	r3, r0
  uint32_t timeOut = 1000;
  int result;
  do 
  { result = sd_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
    7096:	beq.n	70a6 <sd_CMD12_StopTransferWaitForBusy+0x2e>
    7098:	ldr	r2, [r5, #36]	; 0x24

// ---------- sends CMD12 to stop transfer
#define SDHC_CMD12_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) | \
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY))
//
static int sd_CMD12_StopTransfer(void){  return sd_CMD(SDHC_CMD12_XFERTYP, 0);}
    709a:	mov	r1, r3
    709c:	ldr	r0, [pc, #16]	; (70b0 <sd_CMD12_StopTransferWaitForBusy+0x38>)
  uint32_t timeOut = 1000;
  int result;
  do 
  { result = sd_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
    709e:	lsls	r2, r2, #29
    70a0:	bmi.n	708c <sd_CMD12_StopTransferWaitForBusy+0x14>
  
  if (result != SDHC_RESULT_OK)  return result;
  if (!timeOut)  return SDHC_RESULT_NO_RESPONSE;

  return SDHC_RESULT_OK;
}
    70a2:	mov	r0, r3
    70a4:	pop	{r3, r4, r5, pc}
  { result = sd_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
  
  if (result != SDHC_RESULT_OK)  return result;
  if (!timeOut)  return SDHC_RESULT_NO_RESPONSE;
    70a6:	cmp	r0, #0
    70a8:	it	eq
    70aa:	moveq	r3, #5

  return SDHC_RESULT_OK;
}
    70ac:	mov	r0, r3
    70ae:	pop	{r3, r4, r5, pc}
    70b0:	.word	0x0cdb0000
    70b4:	.word	0x402c0000

000070b8 <sd_CardInit>:
  }
  
  static void initClock()
  {
    /* set PDF_528 PLL2PFD0 */
    CCM_ANALOG_PFD_528 |= (1 << 7);
    70b8:	ldr	r2, [pc, #528]	; (72cc <sd_CardInit+0x214>)
    CCM_ANALOG_PFD_528 &= ~(0x3F << 0);
    CCM_ANALOG_PFD_528 |= ((24) & 0x3F << 0); // 12 - 35
    CCM_ANALOG_PFD_528 &= ~(1 << 7);
  
    /* Enable USDHC clock. */
    CCM_CCGR6 |= CCM_CCGR6_USDHC1(CCM_CCGR_ON);
    70ba:	ldr	r3, [pc, #532]	; (72d0 <sd_CardInit+0x218>)
  }
  
  static void initClock()
  {
    /* set PDF_528 PLL2PFD0 */
    CCM_ANALOG_PFD_528 |= (1 << 7);
    70bc:	ldr.w	r0, [r2, #256]	; 0x100
    CCM_CSCMR1 |= CCM_CSCMR1_USDHC1_CLK_SEL;          // PLL2PFD0
    CCM_CSCDR1 |= CCM_CSCDR1_USDHC1_CLK_PODF((7)); // &0x7
  
    // for testing
    CCM_CCOSR = CCM_CCOSR_CLKO1_EN | CCM_CCOSR_CLKO1_DIV(7) | CCM_CCOSR_CLKO1_SEL(1); //(1: SYS_PLL/2)
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 6; //CCM_CLKO1 (0 is USDHC1_DAT2)
    70c0:	ldr	r1, [pc, #528]	; (72d4 <sd_CardInit+0x21c>)
  }
  
  static void initClock()
  {
    /* set PDF_528 PLL2PFD0 */
    CCM_ANALOG_PFD_528 |= (1 << 7);
    70c2:	orr.w	r0, r0, #128	; 0x80

//-----------------------------------------------------------------------------
// initialize the SDHC Controller and SD Card
// returns status of initialization(OK, nonInit, noCard, CardProtected)
uint8_t sd_CardInit(void)
{
    70c6:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  }
  
  static void initClock()
  {
    /* set PDF_528 PLL2PFD0 */
    CCM_ANALOG_PFD_528 |= (1 << 7);
    70ca:	str.w	r0, [r2, #256]	; 0x100
    CCM_CSCMR1 |= CCM_CSCMR1_USDHC1_CLK_SEL;          // PLL2PFD0
    CCM_CSCDR1 |= CCM_CSCDR1_USDHC1_CLK_PODF((7)); // &0x7
  
    // for testing
    CCM_CCOSR = CCM_CCOSR_CLKO1_EN | CCM_CCOSR_CLKO1_DIV(7) | CCM_CCOSR_CLKO1_SEL(1); //(1: SYS_PLL/2)
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 6; //CCM_CLKO1 (0 is USDHC1_DAT2)
    70ce:	movs	r7, #6
  
  static void initClock()
  {
    /* set PDF_528 PLL2PFD0 */
    CCM_ANALOG_PFD_528 |= (1 << 7);
    CCM_ANALOG_PFD_528 &= ~(0x3F << 0);
    70d0:	ldr.w	r5, [r2, #256]	; 0x100
    //  CCM_CSCMR1 &= ~(CCM_CSCMR1_USDHC1_CLK_SEL);     // PLL2PFD2
    CCM_CSCMR1 |= CCM_CSCMR1_USDHC1_CLK_SEL;          // PLL2PFD0
    CCM_CSCDR1 |= CCM_CSCDR1_USDHC1_CLK_PODF((7)); // &0x7
  
    // for testing
    CCM_CCOSR = CCM_CCOSR_CLKO1_EN | CCM_CCOSR_CLKO1_DIV(7) | CCM_CCOSR_CLKO1_SEL(1); //(1: SYS_PLL/2)
    70d4:	mov.w	lr, #241	; 0xf1
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 6; //CCM_CLKO1 (0 is USDHC1_DAT2)
    // for testing
    CCM_CCOSR |= (CCM_CCOSR_CLKO2_EN | CCM_CCOSR_CLKO2_DIV(7) | CCM_CCOSR_CLKO2_SEL(3)); //(3: usdhc1_clk_root))
    70d8:	ldr	r6, [pc, #508]	; (72d8 <sd_CardInit+0x220>)
    }
  }
  
  static void sd_ReleaseGPIO(void)
  {
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 5; //GPIO3_IO16
    70da:	movs	r4, #5
  
  static void initClock()
  {
    /* set PDF_528 PLL2PFD0 */
    CCM_ANALOG_PFD_528 |= (1 << 7);
    CCM_ANALOG_PFD_528 &= ~(0x3F << 0);
    70dc:	bic.w	r5, r5, #63	; 0x3f
  initClock();

  // De-init GPIO - to prevent unwanted clocks on bus
  sd_ReleaseGPIO();
  #if defined (__IMXRT1052__) || defined (__IMXRT1062__)
    SDHC_SYSCTL   |= 0xF;
    70e0:	ldr	r0, [pc, #504]	; (72dc <sd_CardInit+0x224>)
  
  static void initClock()
  {
    /* set PDF_528 PLL2PFD0 */
    CCM_ANALOG_PFD_528 |= (1 << 7);
    CCM_ANALOG_PFD_528 &= ~(0x3F << 0);
    70e2:	str.w	r5, [r2, #256]	; 0x100
    CCM_ANALOG_PFD_528 |= ((24) & 0x3F << 0); // 12 - 35
    70e6:	ldr.w	r5, [r2, #256]	; 0x100
    70ea:	orr.w	r5, r5, #24
    70ee:	str.w	r5, [r2, #256]	; 0x100
    CCM_ANALOG_PFD_528 &= ~(1 << 7);
    70f2:	ldr.w	r5, [r2, #256]	; 0x100
    70f6:	bic.w	r5, r5, #128	; 0x80
    70fa:	str.w	r5, [r2, #256]	; 0x100
    SDHC_MIX_CTRL |= 0x80000000;
  #endif  

  /* Reset SDHC */
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) ; // wait
    70fe:	mov	r2, r0
    CCM_ANALOG_PFD_528 &= ~(0x3F << 0);
    CCM_ANALOG_PFD_528 |= ((24) & 0x3F << 0); // 12 - 35
    CCM_ANALOG_PFD_528 &= ~(1 << 7);
  
    /* Enable USDHC clock. */
    CCM_CCGR6 |= CCM_CCGR6_USDHC1(CCM_CCGR_ON);
    7100:	ldr.w	r5, [r3, #128]	; 0x80
    7104:	orr.w	r5, r5, #12
    7108:	str.w	r5, [r3, #128]	; 0x80
    CCM_CSCDR1 &= ~(CCM_CSCDR1_USDHC1_CLK_PODF_MASK);
    710c:	ldr	r5, [r3, #36]	; 0x24
    710e:	bic.w	r5, r5, #14336	; 0x3800
    7112:	str	r5, [r3, #36]	; 0x24
    //
    //  CCM_CSCMR1 &= ~(CCM_CSCMR1_USDHC1_CLK_SEL);     // PLL2PFD2
    CCM_CSCMR1 |= CCM_CSCMR1_USDHC1_CLK_SEL;          // PLL2PFD0
    7114:	ldr	r5, [r3, #28]
    7116:	orr.w	r5, r5, #65536	; 0x10000
    711a:	str	r5, [r3, #28]
    CCM_CSCDR1 |= CCM_CSCDR1_USDHC1_CLK_PODF((7)); // &0x7
    711c:	ldr	r5, [r3, #36]	; 0x24
    711e:	orr.w	r5, r5, #14336	; 0x3800
    7122:	str	r5, [r3, #36]	; 0x24
  
    // for testing
    CCM_CCOSR = CCM_CCOSR_CLKO1_EN | CCM_CCOSR_CLKO1_DIV(7) | CCM_CCOSR_CLKO1_SEL(1); //(1: SYS_PLL/2)
    7124:	str.w	lr, [r3, #96]	; 0x60
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 6; //CCM_CLKO1 (0 is USDHC1_DAT2)
    7128:	str.w	r7, [r1, #460]	; 0x1cc
    // for testing
    CCM_CCOSR |= (CCM_CCOSR_CLKO2_EN | CCM_CCOSR_CLKO2_DIV(7) | CCM_CCOSR_CLKO2_SEL(3)); //(3: usdhc1_clk_root))
    712c:	ldr	r5, [r3, #96]	; 0x60
    712e:	orrs	r6, r5
    SDHC_SYSCTL   |= 0xF;
    SDHC_MIX_CTRL |= 0x80000000;
  #endif  

  /* Reset SDHC */
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    7130:	ldr	r5, [pc, #428]	; (72e0 <sd_CardInit+0x228>)
  
    // for testing
    CCM_CCOSR = CCM_CCOSR_CLKO1_EN | CCM_CCOSR_CLKO1_DIV(7) | CCM_CCOSR_CLKO1_SEL(1); //(1: SYS_PLL/2)
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 6; //CCM_CLKO1 (0 is USDHC1_DAT2)
    // for testing
    CCM_CCOSR |= (CCM_CCOSR_CLKO2_EN | CCM_CCOSR_CLKO2_DIV(7) | CCM_CCOSR_CLKO2_SEL(3)); //(3: usdhc1_clk_root))
    7132:	str	r6, [r3, #96]	; 0x60
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05 = 6; //CCM_CLKO2 (0 is USDHC1_DAT3)
    7134:	str.w	r7, [r1, #464]	; 0x1d0
    }
  }
  
  static void sd_ReleaseGPIO(void)
  {
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 5; //GPIO3_IO16
    7138:	str.w	r4, [r1, #460]	; 0x1cc
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05 = 5; //GPIO3_IO17
    713c:	str.w	r4, [r1, #464]	; 0x1d0
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00 = 5; //GPIO3_IO12
    7140:	str.w	r4, [r1, #444]	; 0x1bc
    //3.3V
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01 = 5; //GPIO3_IO13
    7144:	str.w	r4, [r1, #448]	; 0x1c0
    //GND
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02 = 5; //GPIO3_IO14
    7148:	str.w	r4, [r1, #452]	; 0x1c4
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03 = 5; //GPIO3_IO15
    714c:	str.w	r4, [r1, #456]	; 0x1c8
  initClock();

  // De-init GPIO - to prevent unwanted clocks on bus
  sd_ReleaseGPIO();
  #if defined (__IMXRT1052__) || defined (__IMXRT1062__)
    SDHC_SYSCTL   |= 0xF;
    7150:	ldr	r3, [r0, #44]	; 0x2c
    7152:	orr.w	r3, r3, #15
    7156:	str	r3, [r0, #44]	; 0x2c
    SDHC_MIX_CTRL |= 0x80000000;
    7158:	ldr	r3, [r0, #72]	; 0x48
    715a:	orr.w	r3, r3, #2147483648	; 0x80000000
    715e:	str	r3, [r0, #72]	; 0x48
  #endif  

  /* Reset SDHC */
  SDHC_SYSCTL |= SDHC_SYSCTL_RSTA | SDHC_SYSCTL_SDCLKFS(0x80);
    7160:	ldr	r3, [r0, #44]	; 0x2c
    7162:	orrs	r5, r3
    7164:	str	r5, [r0, #44]	; 0x2c
  while (SDHC_SYSCTL & SDHC_SYSCTL_RSTA) ; // wait
    7166:	ldr	r3, [r2, #44]	; 0x2c
    7168:	lsls	r0, r3, #7
    716a:	bmi.n	7166 <sd_CardInit+0xae>

  /* Set the SDHC initial baud rate divider and start */
  setSdclk(400);
    716c:	mov.w	r0, #400	; 0x190
    7170:	bl	6ef8 <setSdclk>

  /* Poll inhibit bits */
  while (SDHC_PRSSTAT & (SDHC_PRSSTAT_CIHB | SDHC_PRSSTAT_CDIHB)) ;
    7174:	ldr	r1, [pc, #356]	; (72dc <sd_CardInit+0x224>)
    7176:	ldr	r3, [r1, #36]	; 0x24
    7178:	ldr	r2, [pc, #352]	; (72dc <sd_CardInit+0x224>)
    717a:	ands.w	r3, r3, #3
    717e:	bne.n	7176 <sd_CardInit+0xbe>
#else

  static void sd_InitGPIO(void)
  {
    { //T4                              // Inverted pins(T4)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 0; //DAT2  
    7180:	ldr	r1, [pc, #336]	; (72d4 <sd_CardInit+0x21c>)
                                  IOMUXC_SW_PAD_CTL_PAD_SPEED(2);
  
      const uint32_t DATA_MASK = CLOCK_MASK |
                                 (IOMUXC_SW_PAD_CTL_PAD_PUE | IOMUXC_SW_PAD_CTL_PAD_PUS(1));
  
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04 = DATA_MASK;
    7182:	movw	r0, #28808	; 0x7088
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05 = DATA_MASK;
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00 = DATA_MASK;
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01 = CLOCK_MASK;
    7186:	movw	r5, #4232	; 0x1088
  SDHC_PROCTL |=  SDHC_PROCTL_D3CD;
  // SDHC_PROCTL = SDHC_PROCTL_EMODE(SDHC_PROCTL_EMODE_INVARIANT) | SDHC_PROCTL_D3CD;
  //  SDHC_WML |= SDHC_WML_RDWML(SDHC_FIFO_BUFFER_SIZE) | SDHC_WML_WRWML(SDHC_FIFO_BUFFER_SIZE);

  #if defined(__IMXRT1052__) || defined (__IMXRT1062__)
    SDHC_VENDOR = 0x2000F801; // (1<<29 | 0x1F<<11 | 1);
    718a:	ldr	r4, [pc, #344]	; (72e4 <sd_CardInit+0x22c>)
#else

  static void sd_InitGPIO(void)
  {
    { //T4                              // Inverted pins(T4)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 0; //DAT2  
    718c:	str.w	r3, [r1, #460]	; 0x1cc
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05 = 0; //DAT3  
    7190:	str.w	r3, [r1, #464]	; 0x1d0
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00 = 0; //CMD   
    7194:	str.w	r3, [r1, #444]	; 0x1bc
      //3.3V                                           
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01 = 0; //CLK   
    7198:	str.w	r3, [r1, #448]	; 0x1c0
      //GND                                           
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02 = 0; //DAT0 
    719c:	str.w	r3, [r1, #452]	; 0x1c4
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03 = 0; //DAT1 
    71a0:	str.w	r3, [r1, #456]	; 0x1c8
                                  IOMUXC_SW_PAD_CTL_PAD_SPEED(2);
  
      const uint32_t DATA_MASK = CLOCK_MASK |
                                 (IOMUXC_SW_PAD_CTL_PAD_PUE | IOMUXC_SW_PAD_CTL_PAD_PUS(1));
  
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04 = DATA_MASK;
    71a4:	str.w	r0, [r1, #956]	; 0x3bc
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05 = DATA_MASK;
    71a8:	str.w	r0, [r1, #960]	; 0x3c0
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00 = DATA_MASK;
    71ac:	str.w	r0, [r1, #940]	; 0x3ac
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01 = CLOCK_MASK;
    71b0:	str.w	r5, [r1, #944]	; 0x3b0
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02 = DATA_MASK;
    71b4:	str.w	r0, [r1, #948]	; 0x3b4
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03 = DATA_MASK;
    71b8:	str.w	r0, [r1, #952]	; 0x3b8
  sd_InitGPIO();

  /* Initial values */ // to do - Check values
//  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(512);
  
  SDHC_PROCTL &= ~SDHC_PROCTL_DMAS(3); // clear ADMA
    71bc:	ldr	r3, [r2, #40]	; 0x28
#else
extern void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    71be:	ldr	r0, [pc, #296]	; (72e8 <sd_CardInit+0x230>)
    71c0:	bic.w	r3, r3, #768	; 0x300
    71c4:	ldr	r5, [pc, #292]	; (72ec <sd_CardInit+0x234>)
  
  // clear interrupt status
  SDHC_IRQSTAT = SDHC_IRQSTAT;

  /* Enable requests */
  SDHC_IRQSTATEN =  SDHC_IRQSTAT_CRM | SDHC_IRQSTATEN_CIESEN | 
    71c6:	ldr	r1, [pc, #296]	; (72f0 <sd_CardInit+0x238>)
  sd_InitGPIO();

  /* Initial values */ // to do - Check values
//  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | SDHC_BLKATTR_BLKSIZE(512);
  
  SDHC_PROCTL &= ~SDHC_PROCTL_DMAS(3); // clear ADMA
    71c8:	str	r3, [r2, #40]	; 0x28

  SDHC_PROCTL |=  SDHC_PROCTL_D3CD;
    71ca:	ldr	r3, [r2, #40]	; 0x28
    71cc:	str.w	r5, [r0, #504]	; 0x1f8
    71d0:	orr.w	r3, r3, #8
    71d4:	str	r3, [r2, #40]	; 0x28
  // SDHC_PROCTL = SDHC_PROCTL_EMODE(SDHC_PROCTL_EMODE_INVARIANT) | SDHC_PROCTL_D3CD;
  //  SDHC_WML |= SDHC_WML_RDWML(SDHC_FIFO_BUFFER_SIZE) | SDHC_WML_WRWML(SDHC_FIFO_BUFFER_SIZE);

  #if defined(__IMXRT1052__) || defined (__IMXRT1062__)
    SDHC_VENDOR = 0x2000F801; // (1<<29 | 0x1F<<11 | 1);
    71d6:	str.w	r4, [r2, #192]	; 0xc0
    SDHC_VENDOR2 &= ~(1<<12); //switch off ACMD23 sharing SDMA
    71da:	ldr.w	r3, [r2, #200]	; 0xc8
    71de:	bic.w	r3, r3, #4096	; 0x1000
    71e2:	str.w	r3, [r2, #200]	; 0xc8
  #endif
  
  // clear interrupt status
  SDHC_IRQSTAT = SDHC_IRQSTAT;
    71e6:	ldr	r3, [r2, #48]	; 0x30
    71e8:	str	r3, [r2, #48]	; 0x30

  /* Enable requests */
  SDHC_IRQSTATEN =  SDHC_IRQSTAT_CRM | SDHC_IRQSTATEN_CIESEN | 
    71ea:	str	r1, [r2, #52]	; 0x34
                    SDHC_IRQSTATEN_TCSEN | SDHC_IRQSTATEN_CCSEN;

  attachInterruptVector(IRQ_SDHC, sd_isr);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6 * 16);
    71ec:	ldr	r0, [pc, #260]	; (72f4 <sd_CardInit+0x23c>)
    71ee:	movs	r4, #96	; 0x60
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    71f0:	ldr	r3, [pc, #260]	; (72f8 <sd_CardInit+0x240>)
    71f2:	mov.w	r1, #16384	; 0x4000
    71f6:	mov.w	r5, #500	; 0x1f4
  /* Enable requests */
  SDHC_IRQSTATEN =  SDHC_IRQSTAT_CRM | SDHC_IRQSTATEN_CIESEN | 
                    SDHC_IRQSTATEN_TCSEN | SDHC_IRQSTATEN_CCSEN;

  attachInterruptVector(IRQ_SDHC, sd_isr);
  NVIC_SET_PRIORITY(IRQ_SDHC, 6 * 16);
    71fa:	strb	r4, [r0, #0]
  NVIC_ENABLE_IRQ(IRQ_SDHC);
    71fc:	str	r1, [r3, #0]

  // initial clocks... SD spec says only 74 clocks are needed, but if Teensy rebooted
  // while the card was in middle of an operation, thousands of clock cycles can be
  // needed to get the card to complete a prior command and return to a usable state.
  for (int ii = 0; ii < 500; ii++) {
    SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    71fe:	ldr	r3, [r2, #44]	; 0x2c
    7200:	orr.w	r3, r3, #134217728	; 0x8000000
    7204:	str	r3, [r2, #44]	; 0x2c
    while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) ;
    7206:	ldr	r3, [r2, #44]	; 0x2c
    7208:	ldr	r4, [pc, #208]	; (72dc <sd_CardInit+0x224>)
    720a:	lsls	r1, r3, #4
    720c:	bmi.n	7206 <sd_CardInit+0x14e>
  NVIC_ENABLE_IRQ(IRQ_SDHC);

  // initial clocks... SD spec says only 74 clocks are needed, but if Teensy rebooted
  // while the card was in middle of an operation, thousands of clock cycles can be
  // needed to get the card to complete a prior command and return to a usable state.
  for (int ii = 0; ii < 500; ii++) {
    720e:	subs	r5, #1
    7210:	bne.n	71fe <sd_CardInit+0x146>
    SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) ;
  }

  if(!(SDHC_PRSSTAT & SDHC_PRSSTAT_CINS)) return SDHC_STATUS_NODISK;
    7212:	ldr	r3, [r4, #36]	; 0x24
    7214:	lsls	r2, r3, #15
    7216:	bmi.n	722c <sd_CardInit+0x174>
  uint8_t resS;
  int resR;

  resS = sd_Init();

  sdCardDesc.status = resS;
    7218:	ldr	r3, [pc, #224]	; (72fc <sd_CardInit+0x244>)
    721a:	movs	r2, #2
  sdCardDesc.address = 0;
    721c:	str	r5, [r3, #4]
  for (int ii = 0; ii < 500; ii++) {
    SDHC_SYSCTL |= SDHC_SYSCTL_INITA;
    while (SDHC_SYSCTL & SDHC_SYSCTL_INITA) ;
  }

  if(!(SDHC_PRSSTAT & SDHC_PRSSTAT_CINS)) return SDHC_STATUS_NODISK;
    721e:	mov	r0, r2

  resS = sd_Init();

  sdCardDesc.status = resS;
  sdCardDesc.address = 0;
  sdCardDesc.highCapacity = 0;
    7220:	strb	r5, [r3, #1]
  sdCardDesc.version2 = 0;
    7222:	strb	r5, [r3, #2]
  sdCardDesc.numBlocks = 0;
    7224:	str	r5, [r3, #8]
  uint8_t resS;
  int resR;

  resS = sd_Init();

  sdCardDesc.status = resS;
    7226:	strb	r2, [r3, #0]
    7228:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    722c:	ldr	r6, [pc, #204]	; (72fc <sd_CardInit+0x244>)
    // mixCtrl |= SDHC_MIX_CTRL_BCEN; // does not hurt
    // mixCtrl |= SDHC_MIX_CTRL_DTDSEL; // write/read (will be set later
    // mixCtrl |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    // mixCtrl |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    // mixCtrl |= SDHC_MIX_CTRL_AC23EN;
    SDHC_MIX_CTRL = mixCtrl;
    722e:	mov.w	r3, #2147483648	; 0x80000000
 * Convenience interfaces
 */
// ---------- sends CMD0 to put SDCARD to idle
#define SDHC_CMD0_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD0) | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_NO))
//
static int sd_CMD0_GoToIdle(void){ return sd_CMD(SDHC_CMD0_XFERTYP,0); }
    7232:	mov	r1, r5
    7234:	mov	r0, r5
  uint8_t resS;
  int resR;

  resS = sd_Init();

  sdCardDesc.status = resS;
    7236:	strb	r5, [r6, #0]
  sdCardDesc.address = 0;
  sdCardDesc.highCapacity = 0;
    7238:	strb	r5, [r6, #1]
  sdCardDesc.version2 = 0;
    723a:	strb	r5, [r6, #2]
  sdCardDesc.numBlocks = 0;
  
  if (resS)  return resS;

  SDHC_IRQSIGEN = 0;
    723c:	str	r5, [r4, #56]	; 0x38
    // mixCtrl |= SDHC_MIX_CTRL_BCEN; // does not hurt
    // mixCtrl |= SDHC_MIX_CTRL_DTDSEL; // write/read (will be set later
    // mixCtrl |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    // mixCtrl |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    // mixCtrl |= SDHC_MIX_CTRL_AC23EN;
    SDHC_MIX_CTRL = mixCtrl;
    723e:	str	r3, [r4, #72]	; 0x48
  int resR;

  resS = sd_Init();

  sdCardDesc.status = resS;
  sdCardDesc.address = 0;
    7240:	str	r5, [r6, #4]
  sdCardDesc.highCapacity = 0;
  sdCardDesc.version2 = 0;
  sdCardDesc.numBlocks = 0;
    7242:	str	r5, [r6, #8]
 * Convenience interfaces
 */
// ---------- sends CMD0 to put SDCARD to idle
#define SDHC_CMD0_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD0) | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_NO))
//
static int sd_CMD0_GoToIdle(void){ return sd_CMD(SDHC_CMD0_XFERTYP,0); }
    7244:	bl	6ffc <sd_CMD>
    SDHC_MIX_CTRL = mixCtrl;
  #endif

  resR = sd_CMD0_GoToIdle();

  if (resR) { return sdCardDesc.status = SDHC_STATUS_NOINIT;}
    7248:	cbz	r0, 7252 <sd_CardInit+0x19a>
    724a:	movs	r0, #1
    724c:	strb	r0, [r6, #0]
    724e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
             
// ---------- CMD8 to send interface condition
#define SDHC_CMD8_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD8) | SDHC_XFERTYP_CICEN | \
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))
//
static int sd_CMD8_SetInterface(uint32_t cond){  return sd_CMD(SDHC_CMD8_XFERTYP, cond); }
    7252:	mov.w	r1, #426	; 0x1aa
    7256:	ldr	r0, [pc, #168]	; (7300 <sd_CardInit+0x248>)
    7258:	bl	6ffc <sd_CMD>

  resR = sd_CMD0_GoToIdle();

  if (resR) { return sdCardDesc.status = SDHC_STATUS_NOINIT;}
  resR = sd_CMD8_SetInterface(0x000001AA); // 3.3V and AA check pattern
  if (resR == SDHC_RESULT_OK) 
    725c:	cbnz	r0, 72be <sd_CardInit+0x206>
  { if (!((SDHC_CMDRSP0 & 0x000001AA)== 0x000001AA)) return sdCardDesc.status = SDHC_STATUS_NOINIT;
    725e:	ldr	r3, [r4, #16]
    7260:	and.w	r3, r3, #426	; 0x1aa
    7264:	cmp.w	r3, #426	; 0x1aa
    7268:	bne.n	724a <sd_CardInit+0x192>
    sdCardDesc.highCapacity = 1;
    726a:	movs	r3, #1
    726c:	strb	r3, [r6, #1]
static int sd_CMD16_SetBlockSize(uint32_t block_size){  return sd_CMD(SDHC_CMD16_XFERTYP, block_size);}

// ---------- ACMD 41 to send operation condition
#define SDHC_ACMD41_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_ACMD41) | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))
//
static int sd_ACMD41_SendOperationCond(uint32_t cond){  return sd_ACMD(SDHC_ACMD41_XFERTYP,0, cond);}
    726e:	movs	r2, #0
    7270:	ldr	r0, [pc, #144]	; (7304 <sd_CardInit+0x24c>)
    7272:	mov	r1, r2
    7274:	bl	7058 <sd_ACMD>
  else if (resR == SDHC_RESULT_NO_RESPONSE) 
  { // version 1 cards do not respond to CMD8
  } 
  else return sdCardDesc.status = SDHC_STATUS_NOINIT;

  if (sd_ACMD41_SendOperationCond(0))  return sdCardDesc.status = SDHC_STATUS_NOINIT;
    7278:	cmp	r0, #0
    727a:	bne.n	724a <sd_CardInit+0x192>

  if (SDHC_CMDRSP0 & 0x300000) {
    727c:	ldr	r3, [pc, #92]	; (72dc <sd_CardInit+0x224>)
    727e:	ldr	r2, [r3, #16]
    7280:	tst.w	r2, #3145728	; 0x300000
    7284:	beq.n	7320 <sd_CardInit+0x268>
    uint32_t condition = 0x00300000;
    if (sdCardDesc.highCapacity) condition |= 0x40000000;
    7286:	ldrb	r2, [r6, #1]
    //
    uint32_t ii = 0;
    7288:	mov	r4, r0
  else return sdCardDesc.status = SDHC_STATUS_NOINIT;

  if (sd_ACMD41_SendOperationCond(0))  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  if (SDHC_CMDRSP0 & 0x300000) {
    uint32_t condition = 0x00300000;
    728a:	ldr	r7, [pc, #124]	; (7308 <sd_CardInit+0x250>)
      ii++;
      if (sd_ACMD41_SendOperationCond(condition)) {
        resS = SDHC_STATUS_NOINIT;
        break;
      }
    } while ((!(SDHC_CMDRSP0 & 0x80000000)) && (ii < SDHC_INITIALIZATION_MAX_CNT));
    728c:	mov	r5, r3
  else return sdCardDesc.status = SDHC_STATUS_NOINIT;

  if (sd_ACMD41_SendOperationCond(0))  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  if (SDHC_CMDRSP0 & 0x300000) {
    uint32_t condition = 0x00300000;
    728e:	cmp	r2, #0
      ii++;
      if (sd_ACMD41_SendOperationCond(condition)) {
        resS = SDHC_STATUS_NOINIT;
        break;
      }
    } while ((!(SDHC_CMDRSP0 & 0x80000000)) && (ii < SDHC_INITIALIZATION_MAX_CNT));
    7290:	ldr.w	r8, [pc, #120]	; 730c <sd_CardInit+0x254>
  else return sdCardDesc.status = SDHC_STATUS_NOINIT;

  if (sd_ACMD41_SendOperationCond(0))  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  if (SDHC_CMDRSP0 & 0x300000) {
    uint32_t condition = 0x00300000;
    7294:	it	eq
    7296:	moveq.w	r7, #3145728	; 0x300000
    729a:	b.n	72a6 <sd_CardInit+0x1ee>
      ii++;
      if (sd_ACMD41_SendOperationCond(condition)) {
        resS = SDHC_STATUS_NOINIT;
        break;
      }
    } while ((!(SDHC_CMDRSP0 & 0x80000000)) && (ii < SDHC_INITIALIZATION_MAX_CNT));
    729c:	ldr	r2, [r5, #16]
    729e:	cmp	r2, #0
    72a0:	blt.n	7310 <sd_CardInit+0x258>
    72a2:	cmp	r4, r8
    72a4:	beq.n	731c <sd_CardInit+0x264>
static int sd_CMD16_SetBlockSize(uint32_t block_size){  return sd_CMD(SDHC_CMD16_XFERTYP, block_size);}

// ---------- ACMD 41 to send operation condition
#define SDHC_ACMD41_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_ACMD41) | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))
//
static int sd_ACMD41_SendOperationCond(uint32_t cond){  return sd_ACMD(SDHC_ACMD41_XFERTYP,0, cond);}
    72a6:	mov	r2, r7
    72a8:	movs	r1, #0
    72aa:	ldr	r0, [pc, #88]	; (7304 <sd_CardInit+0x24c>)
    uint32_t condition = 0x00300000;
    if (sdCardDesc.highCapacity) condition |= 0x40000000;
    //
    uint32_t ii = 0;
    do {
      ii++;
    72ac:	adds	r4, #1
static int sd_CMD16_SetBlockSize(uint32_t block_size){  return sd_CMD(SDHC_CMD16_XFERTYP, block_size);}

// ---------- ACMD 41 to send operation condition
#define SDHC_ACMD41_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_ACMD41) | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))
//
static int sd_ACMD41_SendOperationCond(uint32_t cond){  return sd_ACMD(SDHC_ACMD41_XFERTYP,0, cond);}
    72ae:	bl	7058 <sd_ACMD>
      ii++;
      if (sd_ACMD41_SendOperationCond(condition)) {
        resS = SDHC_STATUS_NOINIT;
        break;
      }
    } while ((!(SDHC_CMDRSP0 & 0x80000000)) && (ii < SDHC_INITIALIZATION_MAX_CNT));
    72b2:	ldr	r3, [pc, #40]	; (72dc <sd_CardInit+0x224>)
    if (sdCardDesc.highCapacity) condition |= 0x40000000;
    //
    uint32_t ii = 0;
    do {
      ii++;
      if (sd_ACMD41_SendOperationCond(condition)) {
    72b4:	cmp	r0, #0
    72b6:	beq.n	729c <sd_CardInit+0x1e4>
    72b8:	movs	r0, #1
    72ba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  resR = sd_CMD8_SetInterface(0x000001AA); // 3.3V and AA check pattern
  if (resR == SDHC_RESULT_OK) 
  { if (!((SDHC_CMDRSP0 & 0x000001AA)== 0x000001AA)) return sdCardDesc.status = SDHC_STATUS_NOINIT;
    sdCardDesc.highCapacity = 1;
  } 
  else if (resR == SDHC_RESULT_NO_RESPONSE) 
    72be:	cmp	r0, #5
    72c0:	beq.n	726e <sd_CardInit+0x1b6>
    SDHC_MIX_CTRL = mixCtrl;
  #endif

  resR = sd_CMD0_GoToIdle();

  if (resR) { return sdCardDesc.status = SDHC_STATUS_NOINIT;}
    72c2:	movs	r0, #1
    72c4:	strb	r0, [r6, #0]
    72c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    72ca:	nop
    72cc:	.word	0x400d8000
    72d0:	.word	0x400fc000
    72d4:	.word	0x401f8000
    72d8:	.word	0x01e30000
    72dc:	.word	0x402c0000
    72e0:	.word	0x01008000
    72e4:	.word	0x2000f801
    72e8:	.word	0x2000d800
    72ec:	.word	0x00006fad
    72f0:	.word	0x00080083
    72f4:	.word	0xe000e46e
    72f8:	.word	0xe000e10c
    72fc:	.word	0x2000af14
    7300:	.word	0x081a0000
    7304:	.word	0x29020000
    7308:	.word	0x40300000
    730c:	.word	0x000186a0
      }
    } while ((!(SDHC_CMDRSP0 & 0x80000000)) && (ii < SDHC_INITIALIZATION_MAX_CNT));

    if (resS) return resS;

    if ((ii >= SDHC_INITIALIZATION_MAX_CNT) || (!(SDHC_CMDRSP0 & 0x40000000)))
    7310:	ldr	r2, [pc, #308]	; (7448 <sd_CardInit+0x390>)
    7312:	cmp	r4, r2
    7314:	beq.n	731c <sd_CardInit+0x264>
    7316:	ldr	r3, [r3, #16]
    7318:	lsls	r3, r3, #1
    731a:	bmi.n	7320 <sd_CardInit+0x268>
      sdCardDesc.highCapacity = 0;
    731c:	movs	r3, #0
    731e:	strb	r3, [r6, #1]
  }

  // Card identify
  SDHC_CMDRSP0=SDHC_CMDRSP1=SDHC_CMDRSP2=SDHC_CMDRSP3=0;
    7320:	movs	r3, #0
    7322:	ldr	r7, [pc, #296]	; (744c <sd_CardInit+0x394>)

// ---------- sends CMD2 to identify card
#define SDHC_CMD2_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD2) | SDHC_XFERTYP_CCCEN \
                          | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_136))
//
static int sd_CMD2_Identify(void){  return sd_CMD(SDHC_CMD2_XFERTYP,0); }
    7324:	ldr	r0, [pc, #296]	; (7450 <sd_CardInit+0x398>)
    if ((ii >= SDHC_INITIALIZATION_MAX_CNT) || (!(SDHC_CMDRSP0 & 0x40000000)))
      sdCardDesc.highCapacity = 0;
  }

  // Card identify
  SDHC_CMDRSP0=SDHC_CMDRSP1=SDHC_CMDRSP2=SDHC_CMDRSP3=0;
    7326:	str	r3, [r7, #28]

// ---------- sends CMD2 to identify card
#define SDHC_CMD2_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD2) | SDHC_XFERTYP_CCCEN \
                          | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_136))
//
static int sd_CMD2_Identify(void){  return sd_CMD(SDHC_CMD2_XFERTYP,0); }
    7328:	mov	r1, r3
    if ((ii >= SDHC_INITIALIZATION_MAX_CNT) || (!(SDHC_CMDRSP0 & 0x40000000)))
      sdCardDesc.highCapacity = 0;
  }

  // Card identify
  SDHC_CMDRSP0=SDHC_CMDRSP1=SDHC_CMDRSP2=SDHC_CMDRSP3=0;
    732a:	str	r3, [r7, #24]
    732c:	str	r3, [r7, #20]
    732e:	str	r3, [r7, #16]

// ---------- sends CMD2 to identify card
#define SDHC_CMD2_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD2) | SDHC_XFERTYP_CCCEN \
                          | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_136))
//
static int sd_CMD2_Identify(void){  return sd_CMD(SDHC_CMD2_XFERTYP,0); }
    7330:	bl	6ffc <sd_CMD>
      sdCardDesc.highCapacity = 0;
  }

  // Card identify
  SDHC_CMDRSP0=SDHC_CMDRSP1=SDHC_CMDRSP2=SDHC_CMDRSP3=0;
  if (sd_CMD2_Identify())  return sdCardDesc.status = SDHC_STATUS_NOINIT;
    7334:	mov	r1, r0
    7336:	cmp	r0, #0
    7338:	bne.n	724a <sd_CardInit+0x192>

// ---------- sends CMD 3 to get address
#define SDHC_CMD3_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD3) | SDHC_XFERTYP_CICEN | \
                         SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))
//
static int sd_CMD3_GetAddress(void){  return sd_CMD(SDHC_CMD3_XFERTYP,0); }
    733a:	ldr	r0, [pc, #280]	; (7454 <sd_CardInit+0x39c>)
    733c:	bl	6ffc <sd_CMD>
  // Card identify
  SDHC_CMDRSP0=SDHC_CMDRSP1=SDHC_CMDRSP2=SDHC_CMDRSP3=0;
  if (sd_CMD2_Identify())  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  // Get card address
  if (sd_CMD3_GetAddress())  return sdCardDesc.status = SDHC_STATUS_NOINIT;
    7340:	cmp	r0, #0
    7342:	bne.n	724a <sd_CardInit+0x192>

  sdCardDesc.address = SDHC_CMDRSP0 & 0xFFFF0000;
    7344:	ldr	r3, [r7, #16]
    7346:	ldr	r4, [pc, #272]	; (7458 <sd_CardInit+0x3a0>)
#define SDHC_CMD9_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD9) | SDHC_XFERTYP_CCCEN | \
             SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_136))
//
static int sd_CMD9_GetParameters(uint32_t address)
{
  int result = sd_CMD(SDHC_CMD9_XFERTYP, address);
    7348:	ldr	r0, [pc, #272]	; (745c <sd_CardInit+0x3a4>)
  if (sd_CMD2_Identify())  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  // Get card address
  if (sd_CMD3_GetAddress())  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  sdCardDesc.address = SDHC_CMDRSP0 & 0xFFFF0000;
    734a:	ands	r4, r3
    734c:	ldr	r5, [pc, #272]	; (7460 <sd_CardInit+0x3a8>)
#define SDHC_CMD9_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD9) | SDHC_XFERTYP_CCCEN | \
             SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_136))
//
static int sd_CMD9_GetParameters(uint32_t address)
{
  int result = sd_CMD(SDHC_CMD9_XFERTYP, address);
    734e:	mov	r1, r4
  if (sd_CMD2_Identify())  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  // Get card address
  if (sd_CMD3_GetAddress())  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  sdCardDesc.address = SDHC_CMDRSP0 & 0xFFFF0000;
    7350:	str	r4, [r6, #4]
#define SDHC_CMD9_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD9) | SDHC_XFERTYP_CCCEN | \
             SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_136))
//
static int sd_CMD9_GetParameters(uint32_t address)
{
  int result = sd_CMD(SDHC_CMD9_XFERTYP, address);
    7352:	bl	6ffc <sd_CMD>
  if (result == SDHC_RESULT_OK) { sdCardDesc.tranSpeed = SDHC_CMDRSP2 >> 24;}
    7356:	cmp	r0, #0
    7358:	bne.w	724a <sd_CardInit+0x192>
    735c:	ldr	r3, [r7, #24]
    735e:	lsrs	r3, r3, #24
    7360:	strb	r3, [r5, #3]
  sdCardDesc.address = SDHC_CMDRSP0 & 0xFFFF0000;

  // Get card parameters
  if (sd_CMD9_GetParameters(sdCardDesc.address))  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  if (!(SDHC_CMDRSP3 & 0x00C00000)) {
    7362:	ldr	r3, [r7, #28]
    7364:	tst.w	r3, #12582912	; 0xc00000
    7368:	bne.n	7436 <sd_CardInit+0x37e>
    uint32_t read_bl_len, c_size, c_size_mult;

    read_bl_len = (SDHC_CMDRSP2 >> 8) & 0x0F;
    736a:	ldr	r1, [r7, #24]
    c_size = SDHC_CMDRSP2 & 0x03;
    736c:	ldr	r3, [r7, #24]
    c_size = (c_size << 10) | (SDHC_CMDRSP1 >> 22);
    736e:	ldr	r0, [r7, #20]
    c_size_mult = (SDHC_CMDRSP1 >> 7) & 0x07;
    sdCardDesc.numBlocks = (c_size + 1) * (1 << (c_size_mult + 2)) * (1 << (read_bl_len - 9));
    7370:	ubfx	r1, r1, #8, #4
    7374:	lsls	r2, r3, #10
    uint32_t read_bl_len, c_size, c_size_mult;

    read_bl_len = (SDHC_CMDRSP2 >> 8) & 0x0F;
    c_size = SDHC_CMDRSP2 & 0x03;
    c_size = (c_size << 10) | (SDHC_CMDRSP1 >> 22);
    c_size_mult = (SDHC_CMDRSP1 >> 7) & 0x07;
    7376:	ldr	r3, [r7, #20]
    sdCardDesc.numBlocks = (c_size + 1) * (1 << (c_size_mult + 2)) * (1 << (read_bl_len - 9));
    7378:	subs	r1, #9
    737a:	and.w	r2, r2, #3072	; 0xc00
    737e:	ubfx	r3, r3, #7, #3
    7382:	orr.w	r2, r2, r0, lsr #22
    7386:	adds	r3, #2
    7388:	adds	r2, #1
    738a:	lsl.w	r3, r2, r3
    738e:	lsls	r3, r1
    7390:	str	r3, [r5, #8]
             
// ---------- sends CMD 7 to select card
#define SDHC_CMD7_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD7) | SDHC_XFERTYP_CICEN | \
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY))
//
static int sd_CMD7_SelectCard(uint32_t address){  return sd_CMD(SDHC_CMD7_XFERTYP, address);}
    7392:	mov	r1, r4
    7394:	ldr	r0, [pc, #204]	; (7464 <sd_CardInit+0x3ac>)
    7396:	bl	6ffc <sd_CMD>
    c_size = (SDHC_CMDRSP1 >> 8) & 0x003FFFFF;
    sdCardDesc.numBlocks = (c_size + 1) << 10;
  }

  // Select card
  if (sd_CMD7_SelectCard(sdCardDesc.address)) return sdCardDesc.status = SDHC_STATUS_NOINIT;
    739a:	cmp	r0, #0
    739c:	bne.w	724a <sd_CardInit+0x192>

// ---------- sends CMD16 to set block size
#define SDHC_CMD16_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD16) | SDHC_XFERTYP_CICEN | \
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))
//
static int sd_CMD16_SetBlockSize(uint32_t block_size){  return sd_CMD(SDHC_CMD16_XFERTYP, block_size);}
    73a0:	mov.w	r1, #512	; 0x200
    73a4:	ldr	r0, [pc, #192]	; (7468 <sd_CardInit+0x3b0>)
    73a6:	bl	6ffc <sd_CMD>

  // Select card
  if (sd_CMD7_SelectCard(sdCardDesc.address)) return sdCardDesc.status = SDHC_STATUS_NOINIT;

  // Set 512 Block size in SD card
  if (sd_CMD16_SetBlockSize(SDHC_BLOCK_SIZE))  return sdCardDesc.status = SDHC_STATUS_NOINIT;
    73aa:	cmp	r0, #0
    73ac:	bne.w	724a <sd_CardInit+0x192>
// ---------- sends ACMD6 to set bus width
#define SDHC_ACMD6_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_ACMD6) | SDHC_XFERTYP_CICEN | \
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))
//
static int sd_ACMD6_SetBusWidth(uint32_t address, uint32_t width) 
{ return sd_ACMD(SDHC_ACMD6_XFERTYP,address, width); }
    73b0:	mov	r1, r4
    73b2:	movs	r2, #2
    73b4:	ldr	r0, [pc, #180]	; (746c <sd_CardInit+0x3b4>)
    73b6:	bl	7058 <sd_ACMD>

  // Set 512 Block size in SD card
  if (sd_CMD16_SetBlockSize(SDHC_BLOCK_SIZE))  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  // Set 4 bit data bus width
  if (sd_ACMD6_SetBusWidth(sdCardDesc.address, 2))  return sdCardDesc.status = SDHC_STATUS_NOINIT;
    73ba:	mov	r5, r0
    73bc:	cmp	r0, #0
    73be:	bne.w	724a <sd_CardInit+0x192>

  // Set Data bus width also in SDHC controller
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    73c2:	ldr	r2, [pc, #136]	; (744c <sd_CardInit+0x394>)
    }
  }
  
  static void sd_ReleaseGPIO(void)
  {
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 5; //GPIO3_IO16
    73c4:	movs	r3, #5
    73c6:	ldr	r4, [pc, #168]	; (7470 <sd_CardInit+0x3b8>)
  
  // De-Init GPIO
  sd_ReleaseGPIO();

  // Set the SDHC default baud rate
  setSdclk(60000);
    73c8:	movw	r0, #60000	; 0xea60

  // Set 4 bit data bus width
  if (sd_ACMD6_SetBusWidth(sdCardDesc.address, 2))  return sdCardDesc.status = SDHC_STATUS_NOINIT;

  // Set Data bus width also in SDHC controller
  SDHC_PROCTL &= ~SDHC_PROCTL_DTW_MASK;
    73cc:	ldr	r1, [r2, #40]	; 0x28
    73ce:	bic.w	r1, r1, #6
    73d2:	str	r1, [r2, #40]	; 0x28
  SDHC_PROCTL |= SDHC_PROCTL_DTW(SDHC_PROCTL_DTW_4BIT);
    73d4:	ldr	r1, [r2, #40]	; 0x28
    73d6:	orr.w	r1, r1, #2
    73da:	str	r1, [r2, #40]	; 0x28
    }
  }
  
  static void sd_ReleaseGPIO(void)
  {
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 5; //GPIO3_IO16
    73dc:	str.w	r3, [r4, #460]	; 0x1cc
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05 = 5; //GPIO3_IO17
    73e0:	str.w	r3, [r4, #464]	; 0x1d0
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00 = 5; //GPIO3_IO12
    73e4:	str.w	r3, [r4, #444]	; 0x1bc
    //3.3V
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01 = 5; //GPIO3_IO13
    73e8:	str.w	r3, [r4, #448]	; 0x1c0
    //GND
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02 = 5; //GPIO3_IO14
    73ec:	str.w	r3, [r4, #452]	; 0x1c4
    IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03 = 5; //GPIO3_IO15
    73f0:	str.w	r3, [r4, #456]	; 0x1c8
  
  // De-Init GPIO
  sd_ReleaseGPIO();

  // Set the SDHC default baud rate
  setSdclk(60000);
    73f4:	bl	6ef8 <setSdclk>
                                  IOMUXC_SW_PAD_CTL_PAD_SPEED(2);
  
      const uint32_t DATA_MASK = CLOCK_MASK |
                                 (IOMUXC_SW_PAD_CTL_PAD_PUE | IOMUXC_SW_PAD_CTL_PAD_PUS(1));
  
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04 = DATA_MASK;
    73f8:	movw	r3, #28808	; 0x7088
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05 = DATA_MASK;
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00 = DATA_MASK;
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01 = CLOCK_MASK;
    73fc:	movw	r2, #4232	; 0x1088
#else

  static void sd_InitGPIO(void)
  {
    { //T4                              // Inverted pins(T4)
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_04 = 0; //DAT2  
    7400:	str.w	r5, [r4, #460]	; 0x1cc
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_05 = 0; //DAT3  
    7404:	str.w	r5, [r4, #464]	; 0x1d0
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_00 = 0; //CMD   
    7408:	str.w	r5, [r4, #444]	; 0x1bc
      //3.3V                                           
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_01 = 0; //CLK   
    740c:	str.w	r5, [r4, #448]	; 0x1c0
      //GND                                           
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_02 = 0; //DAT0 
    7410:	str.w	r5, [r4, #452]	; 0x1c4
      IOMUXC_SW_MUX_CTL_PAD_GPIO_SD_B0_03 = 0; //DAT1 
    7414:	str.w	r5, [r4, #456]	; 0x1c8
                                  IOMUXC_SW_PAD_CTL_PAD_SPEED(2);
  
      const uint32_t DATA_MASK = CLOCK_MASK |
                                 (IOMUXC_SW_PAD_CTL_PAD_PUE | IOMUXC_SW_PAD_CTL_PAD_PUS(1));
  
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_04 = DATA_MASK;
    7418:	str.w	r3, [r4, #956]	; 0x3bc
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_05 = DATA_MASK;
    741c:	str.w	r3, [r4, #960]	; 0x3c0
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_00 = DATA_MASK;
    7420:	str.w	r3, [r4, #940]	; 0x3ac
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_01 = CLOCK_MASK;
    7424:	str.w	r2, [r4, #944]	; 0x3b0
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_02 = DATA_MASK;
    7428:	str.w	r3, [r4, #948]	; 0x3b4
      IOMUXC_SW_PAD_CTL_PAD_GPIO_SD_B0_03 = DATA_MASK;
    742c:	str.w	r3, [r4, #952]	; 0x3b8
  // and SDHC_SetClock() for 50 MHz config

  // Init GPIO
  sd_InitGPIO();

  return sdCardDesc.status;
    7430:	ldrb	r0, [r6, #0]
    7432:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c_size = (c_size << 10) | (SDHC_CMDRSP1 >> 22);
    c_size_mult = (SDHC_CMDRSP1 >> 7) & 0x07;
    sdCardDesc.numBlocks = (c_size + 1) * (1 << (c_size_mult + 2)) * (1 << (read_bl_len - 9));
  } else {
    uint32_t c_size;
    sdCardDesc.version2 = 1;
    7436:	movs	r3, #1
    7438:	strb	r3, [r5, #2]
    c_size = (SDHC_CMDRSP1 >> 8) & 0x003FFFFF;
    743a:	ldr	r3, [r7, #20]
    sdCardDesc.numBlocks = (c_size + 1) << 10;
    743c:	ubfx	r3, r3, #8, #22
    7440:	adds	r3, #1
    7442:	lsls	r3, r3, #10
    7444:	str	r3, [r5, #8]
    7446:	b.n	7392 <sd_CardInit+0x2da>
    7448:	.word	0x000186a0
    744c:	.word	0x402c0000
    7450:	.word	0x02090000
    7454:	.word	0x031a0000
    7458:	.word	0xffff0000
    745c:	.word	0x09090000
    7460:	.word	0x2000af14
    7464:	.word	0x071b0000
    7468:	.word	0x101a0000
    746c:	.word	0x061a0000
    7470:	.word	0x401f8000

00007474 <SDHC_disk_initialize>:
DSTATUS SDHC_disk_status()
{	return (DSTATUS) sdCardDesc.status;
}

DSTATUS SDHC_disk_initialize()
{	return (DSTATUS) sd_CardInit();
    7474:	b.w	70b8 <sd_CardInit>

00007478 <sd_CardReadBlocks>:
  int result=0;
  // unused // uint32_t* pData = (uint32_t*)buff;

  
  // Convert LBA to BYTE address if needed
  if (!sdCardDesc.highCapacity)  sector *= 512;
    7478:	ldr	r3, [pc, #240]	; (756c <sd_CardReadBlocks+0xf4>)
#define SDHC_CMD18_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD18) | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) \
                            | SDHC_XFERTYP_DPSEL | SDHC_XFERTYP_DMAEN | SDHC_XFERTYP_DTDSEL \
                            | SDHC_XFERTYP_AC12EN| SDHC_XFERTYP_BCEN | SDHC_XFERTYP_MSBSEL )
//
int sd_CardReadBlocks(void * buff, uint32_t sector, uint32_t count)
{
    747a:	push	{r4, r5, r6, r7, lr}
  int result=0;
  // unused // uint32_t* pData = (uint32_t*)buff;

  
  // Convert LBA to BYTE address if needed
  if (!sdCardDesc.highCapacity)  sector *= 512;
    747c:	ldrb	r4, [r3, #1]
    747e:	cbnz	r4, 7482 <sd_CardReadBlocks+0xa>
    7480:	lsls	r1, r1, #9

  // Check if this is ready
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;
    7482:	ldrb	r3, [r3, #0]
    7484:	cbz	r3, 748a <sd_CardReadBlocks+0x12>
    7486:	movs	r0, #3
    7488:	pop	{r4, r5, r6, r7, pc}

	while(SDHC_PRSSTAT & (SDHC_PRSSTAT_CIHB | SDHC_PRSSTAT_CDIHB | SDHC_PRSSTAT_DLA)) ;
    748a:	ldr	r5, [pc, #228]	; (7570 <sd_CardReadBlocks+0xf8>)
    748c:	ldr	r3, [r5, #36]	; 0x24
    748e:	ldr	r4, [pc, #224]	; (7570 <sd_CardReadBlocks+0xf8>)
    7490:	ands.w	r3, r3, #7
    7494:	bne.n	748c <sd_CardReadBlocks+0x14>

  // clear status
  SDHC_IRQSTAT = SDHC_IRQSTAT;
    7496:	ldr	r5, [r4, #48]	; 0x30
    SDHC_MIX_CTRL |= SDHC_MIX_CTRL_DTDSEL ; // read
    SDHC_MIX_CTRL |= SDHC_MIX_CTRL_DMAEN ; // DMA
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_BCEN; // Block Count
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    7498:	cmp	r2, #1
  SDHC_IRQSTAT = SDHC_IRQSTAT;
  
  // use dma: disabling polling
  uint32_t irqstat = SDHC_IRQSTATEN;
  irqstat &= ~(SDHC_IRQSTATEN_BRRSEN | SDHC_IRQSTATEN_BWRSEN | SDHC_IRQSTATEN_CCSEN) ;
  irqstat &= ~(SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN) ;
    749a:	ldr	r7, [pc, #216]	; (7574 <sd_CardReadBlocks+0xfc>)
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;

	while(SDHC_PRSSTAT & (SDHC_PRSSTAT_CIHB | SDHC_PRSSTAT_CDIHB | SDHC_PRSSTAT_DLA)) ;

  // clear status
  SDHC_IRQSTAT = SDHC_IRQSTAT;
    749c:	str	r5, [r4, #48]	; 0x30
  
  // use dma: disabling polling
  uint32_t irqstat = SDHC_IRQSTATEN;
    749e:	ldr	r5, [r4, #52]	; 0x34
  irqstat &= ~(SDHC_IRQSTATEN_BRRSEN | SDHC_IRQSTATEN_BWRSEN | SDHC_IRQSTATEN_CCSEN) ;
  irqstat &= ~(SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN) ;
  // enable status
  irqstat |= /*SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN |*/ SDHC_IRQSTATEN_DMAESEN ; 
  irqstat |= SDHC_IRQSTATEN_DINTSEN | SDHC_IRQSTATEN_TCSEN ;//| SDHC_IRQSTATEN_CCSEN ; 
    74a0:	ldr	r6, [pc, #212]	; (7578 <sd_CardReadBlocks+0x100>)
  SDHC_IRQSTAT = SDHC_IRQSTAT;
  
  // use dma: disabling polling
  uint32_t irqstat = SDHC_IRQSTATEN;
  irqstat &= ~(SDHC_IRQSTATEN_BRRSEN | SDHC_IRQSTATEN_BWRSEN | SDHC_IRQSTATEN_CCSEN) ;
  irqstat &= ~(SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN) ;
    74a2:	and.w	r7, r7, r5
  irqstat |= /*SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN |*/ SDHC_IRQSTATEN_DMAESEN ; 
  irqstat |= SDHC_IRQSTATEN_DINTSEN | SDHC_IRQSTATEN_TCSEN ;//| SDHC_IRQSTATEN_CCSEN ; 
  SDHC_IRQSTATEN = irqstat;
  
  uint32_t sigen = SDHC_IRQSIGEN;
  sigen |= SDHC_IRQSIGEN_DMA_MASK ;
    74a6:	mov	r5, r6
  uint32_t irqstat = SDHC_IRQSTATEN;
  irqstat &= ~(SDHC_IRQSTATEN_BRRSEN | SDHC_IRQSTATEN_BWRSEN | SDHC_IRQSTATEN_CCSEN) ;
  irqstat &= ~(SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN) ;
  // enable status
  irqstat |= /*SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN |*/ SDHC_IRQSTATEN_DMAESEN ; 
  irqstat |= SDHC_IRQSTATEN_DINTSEN | SDHC_IRQSTATEN_TCSEN ;//| SDHC_IRQSTATEN_CCSEN ; 
    74a8:	orr.w	r6, r6, r7
  SDHC_IRQSTATEN = irqstat;
    74ac:	str	r6, [r4, #52]	; 0x34
  
  uint32_t sigen = SDHC_IRQSIGEN;
    74ae:	ldr	r6, [r4, #56]	; 0x38
  sigen |= SDHC_IRQSIGEN_DMA_MASK ;
    74b0:	orr.w	r5, r5, r6
  SDHC_IRQSIGEN = sigen;
    74b4:	str	r5, [r4, #56]	; 0x38
  
  SDHC_SYSCTL |= SDHC_SYSCTL_HCKEN;
    74b6:	ldr	r5, [r4, #44]	; 0x2c
    74b8:	orr.w	r5, r5, #2
    74bc:	str	r5, [r4, #44]	; 0x2c
  #if defined(__IMXRT1052__) || defined(__IMXRT1062__)
    
    SDHC_MIX_CTRL |= SDHC_MIX_CTRL_DTDSEL ; // read
    74be:	ldr	r5, [r4, #72]	; 0x48
    74c0:	orr.w	r5, r5, #16
    74c4:	str	r5, [r4, #72]	; 0x48
    SDHC_MIX_CTRL |= SDHC_MIX_CTRL_DMAEN ; // DMA
    74c6:	ldr	r5, [r4, #72]	; 0x48
    74c8:	orr.w	r5, r5, #1
    74cc:	str	r5, [r4, #72]	; 0x48
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_BCEN; // Block Count
    74ce:	ldr	r5, [r4, #72]	; 0x48
    74d0:	bic.w	r5, r5, #2
    74d4:	str	r5, [r4, #72]	; 0x48
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    74d6:	ldr	r5, [r4, #72]	; 0x48
    74d8:	bic.w	r5, r5, #32
    74dc:	str	r5, [r4, #72]	; 0x48
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    74de:	ldr	r5, [r4, #72]	; 0x48
    74e0:	bic.w	r5, r5, #4
    74e4:	str	r5, [r4, #72]	; 0x48
    if(count>1)
    74e6:	bls.n	7548 <sd_CardReadBlocks+0xd0>
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
    74e8:	ldr	r7, [r4, #72]	; 0x48
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    74ea:	lsls	r5, r2, #16
    74ec:	ldr	r6, [pc, #140]	; (757c <sd_CardReadBlocks+0x104>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_BCEN; // Block Count
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
    74ee:	orr.w	r7, r7, #2
  dmaDone=0;
  SDHC_DSADDR  = (uint32_t)buff;

  // send command
    SDHC_CMDARG = sector;
    SDHC_XFERTYP = count==1 ? SDHC_CMD17_XFERTYP: SDHC_CMD18_XFERTYP; 
    74f2:	ldr.w	lr, [pc, #144]	; 7584 <sd_CardReadBlocks+0x10c>
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    74f6:	ands	r6, r5

  // enable DMA
  dmaDone=0;
    74f8:	ldr	r5, [pc, #132]	; (7580 <sd_CardReadBlocks+0x108>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_BCEN; // Block Count
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
    74fa:	str	r7, [r4, #72]	; 0x48
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    74fc:	ldr	r7, [r4, #72]	; 0x48
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    74fe:	orr.w	r6, r6, #512	; 0x200
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    7502:	orr.w	r7, r7, #32
    7506:	str	r7, [r4, #72]	; 0x48
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    7508:	ldr	r7, [r4, #72]	; 0x48
    750a:	orr.w	r7, r7, #4
    750e:	str	r7, [r4, #72]	; 0x48
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    7510:	str	r6, [r4, #4]

  // enable DMA
  dmaDone=0;
    7512:	str	r3, [r5, #0]
  SDHC_DSADDR  = (uint32_t)buff;
    7514:	str	r0, [r4, #0]

  // send command
    SDHC_CMDARG = sector;
    7516:	str	r1, [r4, #8]
    SDHC_XFERTYP = count==1 ? SDHC_CMD17_XFERTYP: SDHC_CMD18_XFERTYP; 
    7518:	ldr	r3, [pc, #84]	; (7570 <sd_CardReadBlocks+0xf8>)
    751a:	str.w	lr, [r3, #12]

  // wait for DMA
  while(!dmaDone);
    751e:	ldr	r3, [r5, #0]
    7520:	cmp	r3, #0
    7522:	beq.n	751e <sd_CardReadBlocks+0xa6>
  SDHC_IRQSTAT &= (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_TC);
    7524:	ldr	r3, [pc, #72]	; (7570 <sd_CardReadBlocks+0xf8>)

	// Auto CMD12 is enabled for DMA so call it if DMA error
	if((SDHC_DSADDR < (uint32_t)(buff+(count*512))) && (count>1))
    7526:	add.w	r0, r0, r2, lsl #9
    SDHC_CMDARG = sector;
    SDHC_XFERTYP = count==1 ? SDHC_CMD17_XFERTYP: SDHC_CMD18_XFERTYP; 

  // wait for DMA
  while(!dmaDone);
  SDHC_IRQSTAT &= (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_TC);
    752a:	ldr	r1, [r3, #48]	; 0x30
    752c:	and.w	r1, r1, #3
    7530:	str	r1, [r3, #48]	; 0x30

	// Auto CMD12 is enabled for DMA so call it if DMA error
	if((SDHC_DSADDR < (uint32_t)(buff+(count*512))) && (count>1))
    7532:	ldr	r3, [r3, #0]
    7534:	cmp	r3, r0
    7536:	bcs.n	7544 <sd_CardReadBlocks+0xcc>
    7538:	cmp	r2, #1
    753a:	bls.n	7544 <sd_CardReadBlocks+0xcc>
		result=sd_CMD12_StopTransferWaitForBusy();

  return result;
}
    753c:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  while(!dmaDone);
  SDHC_IRQSTAT &= (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_TC);

	// Auto CMD12 is enabled for DMA so call it if DMA error
	if((SDHC_DSADDR < (uint32_t)(buff+(count*512))) && (count>1))
		result=sd_CMD12_StopTransferWaitForBusy();
    7540:	b.w	7078 <sd_CMD12_StopTransferWaitForBusy>
                            | SDHC_XFERTYP_DPSEL | SDHC_XFERTYP_DMAEN | SDHC_XFERTYP_DTDSEL \
                            | SDHC_XFERTYP_AC12EN| SDHC_XFERTYP_BCEN | SDHC_XFERTYP_MSBSEL )
//
int sd_CardReadBlocks(void * buff, uint32_t sector, uint32_t count)
{
  int result=0;
    7544:	movs	r0, #0
	// Auto CMD12 is enabled for DMA so call it if DMA error
	if((SDHC_DSADDR < (uint32_t)(buff+(count*512))) && (count>1))
		result=sd_CMD12_StopTransferWaitForBusy();

  return result;
}
    7546:	pop	{r4, r5, r6, r7, pc}
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    7548:	mov.w	r7, r2, lsl #16
    754c:	ldr	r6, [pc, #44]	; (757c <sd_CardReadBlocks+0x104>)

  // enable DMA
  dmaDone=0;
    754e:	ldr	r5, [pc, #48]	; (7580 <sd_CardReadBlocks+0x108>)
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    7550:	and.w	r6, r6, r7
  dmaDone=0;
  SDHC_DSADDR  = (uint32_t)buff;

  // send command
    SDHC_CMDARG = sector;
    SDHC_XFERTYP = count==1 ? SDHC_CMD17_XFERTYP: SDHC_CMD18_XFERTYP; 
    7554:	ite	ne
    7556:	ldrne.w	lr, [pc, #44]	; 7584 <sd_CardReadBlocks+0x10c>
    755a:	ldreq.w	lr, [pc, #44]	; 7588 <sd_CardReadBlocks+0x110>
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    755e:	orr.w	r6, r6, #512	; 0x200
    7562:	str	r6, [r4, #4]

  // enable DMA
  dmaDone=0;
    7564:	str	r3, [r5, #0]
  SDHC_DSADDR  = (uint32_t)buff;
    7566:	str	r0, [r4, #0]

  // send command
    SDHC_CMDARG = sector;
    7568:	str	r1, [r4, #8]
    756a:	b.n	7518 <sd_CardReadBlocks+0xa0>
    756c:	.word	0x2000af14
    7570:	.word	0x402c0000
    7574:	.word	0xffddffce
    7578:	.word	0x1000000a
    757c:	.word	0x1fff0000
    7580:	.word	0x2000af10
    7584:	.word	0x12220037
    7588:	.word	0x11220013

0000758c <SDHC_disk_read>:
DSTATUS SDHC_disk_initialize()
{	return (DSTATUS) sd_CardInit();
}

DRESULT SDHC_disk_read(BYTE *buff, DWORD sector, UINT count)
{	return (DRESULT) sd_CardReadBlocks((void *) buff, (uint32_t) sector, (uint32_t) count);
    758c:	push	{r3, lr}
    758e:	bl	7478 <sd_CardReadBlocks>
}
    7592:	uxtb	r0, r0
    7594:	pop	{r3, pc}
    7596:	nop

00007598 <sd_CardWriteBlocks>:
#define SDHC_CMD25_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD25) |SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) \
                            | SDHC_XFERTYP_DPSEL | SDHC_XFERTYP_DMAEN \
                            | SDHC_XFERTYP_AC12EN| SDHC_XFERTYP_BCEN | SDHC_XFERTYP_MSBSEL )
//
int sd_CardWriteBlocks(const void * buff, uint32_t sector, uint32_t count)
{
    7598:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  int result=0;
  // unused // const uint32_t *pData = (const uint32_t *)buff;

  // Convert LBA to uint8_t address if needed
  if (!sdCardDesc.highCapacity) sector *= 512;
    759c:	ldr	r5, [pc, #308]	; (76d4 <sd_CardWriteBlocks+0x13c>)
#define SDHC_CMD25_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD25) |SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) \
                            | SDHC_XFERTYP_DPSEL | SDHC_XFERTYP_DMAEN \
                            | SDHC_XFERTYP_AC12EN| SDHC_XFERTYP_BCEN | SDHC_XFERTYP_MSBSEL )
//
int sd_CardWriteBlocks(const void * buff, uint32_t sector, uint32_t count)
{
    759e:	mov	r7, r2
  int result=0;
  // unused // const uint32_t *pData = (const uint32_t *)buff;

  // Convert LBA to uint8_t address if needed
  if (!sdCardDesc.highCapacity) sector *= 512;
    75a0:	ldrb	r3, [r5, #1]
    75a2:	cbnz	r3, 75a6 <sd_CardWriteBlocks+0xe>
    75a4:	lsls	r1, r1, #9

  // Check if this is ready
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;
    75a6:	ldrb	r3, [r5, #0]
    75a8:	cbz	r3, 75b0 <sd_CardWriteBlocks+0x18>
    75aa:	movs	r0, #3
	// Auto CMD12 is enabled for DMA so call it when transfer error
	if((result != SDHC_RESULT_OK) && (count>1))
		result=sd_CMD12_StopTransferWaitForBusy();
  
  return result;
}
    75ac:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (!sdCardDesc.highCapacity) sector *= 512;

  // Check if this is ready
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;

	while(SDHC_PRSSTAT & (SDHC_PRSSTAT_CIHB | SDHC_PRSSTAT_CDIHB | SDHC_PRSSTAT_DLA)) ;
    75b0:	ldr	r4, [pc, #292]	; (76d8 <sd_CardWriteBlocks+0x140>)
    75b2:	ldr	r2, [r4, #36]	; 0x24
    75b4:	ldr	r3, [pc, #288]	; (76d8 <sd_CardWriteBlocks+0x140>)
    75b6:	ands.w	r2, r2, #7
    75ba:	bne.n	75b2 <sd_CardWriteBlocks+0x1a>

  // clear status
  SDHC_IRQSTAT = SDHC_IRQSTAT;
    75bc:	ldr	r4, [r3, #48]	; 0x30
    SDHC_MIX_CTRL &= ~ SDHC_MIX_CTRL_DTDSEL;  // write
    SDHC_MIX_CTRL |=  SDHC_MIX_CTRL_DMAEN ;   //DMA
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_BCEN; // Block Count
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    75be:	cmp	r7, #1
  SDHC_IRQSTAT = SDHC_IRQSTAT;

  uint32_t irqstat = SDHC_IRQSTATEN;
  // use dma: disabling polling
  irqstat &= ~(SDHC_IRQSTATEN_BRRSEN | SDHC_IRQSTATEN_BWRSEN | SDHC_IRQSTATEN_CCSEN) ;
  irqstat &= ~(SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN) ;
    75c0:	ldr.w	lr, [pc, #300]	; 76f0 <sd_CardWriteBlocks+0x158>
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;

	while(SDHC_PRSSTAT & (SDHC_PRSSTAT_CIHB | SDHC_PRSSTAT_CDIHB | SDHC_PRSSTAT_DLA)) ;

  // clear status
  SDHC_IRQSTAT = SDHC_IRQSTAT;
    75c4:	str	r4, [r3, #48]	; 0x30

  uint32_t irqstat = SDHC_IRQSTATEN;
    75c6:	ldr	r4, [r3, #52]	; 0x34
  // use dma: disabling polling
  irqstat &= ~(SDHC_IRQSTATEN_BRRSEN | SDHC_IRQSTATEN_BWRSEN | SDHC_IRQSTATEN_CCSEN) ;
  irqstat &= ~(SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN) ;
  // enable status
  irqstat |= SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN | SDHC_IRQSTATEN_DMAESEN ; 
  irqstat |= SDHC_IRQSTATEN_DINTSEN | SDHC_IRQSTATEN_TCSEN ;//| SDHC_IRQSTATEN_CCSEN ; 
    75c8:	ldr	r6, [pc, #272]	; (76dc <sd_CardWriteBlocks+0x144>)
  SDHC_IRQSTAT = SDHC_IRQSTAT;

  uint32_t irqstat = SDHC_IRQSTATEN;
  // use dma: disabling polling
  irqstat &= ~(SDHC_IRQSTATEN_BRRSEN | SDHC_IRQSTATEN_BWRSEN | SDHC_IRQSTATEN_CCSEN) ;
  irqstat &= ~(SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN) ;
    75ca:	and.w	lr, r4, lr
  irqstat |= SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN | SDHC_IRQSTATEN_DMAESEN ; 
  irqstat |= SDHC_IRQSTATEN_DINTSEN | SDHC_IRQSTATEN_TCSEN ;//| SDHC_IRQSTATEN_CCSEN ; 
  SDHC_IRQSTATEN = irqstat;
  
  uint32_t sigen = SDHC_IRQSIGEN;
  sigen |= SDHC_IRQSIGEN_DMA_MASK ;
    75ce:	ldr	r4, [pc, #272]	; (76e0 <sd_CardWriteBlocks+0x148>)
  // use dma: disabling polling
  irqstat &= ~(SDHC_IRQSTATEN_BRRSEN | SDHC_IRQSTATEN_BWRSEN | SDHC_IRQSTATEN_CCSEN) ;
  irqstat &= ~(SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN) ;
  // enable status
  irqstat |= SDHC_IRQSTATEN_DCESEN | SDHC_IRQSTATEN_CCESEN | SDHC_IRQSTATEN_DMAESEN ; 
  irqstat |= SDHC_IRQSTATEN_DINTSEN | SDHC_IRQSTATEN_TCSEN ;//| SDHC_IRQSTATEN_CCSEN ; 
    75d0:	orr.w	r6, lr, r6
  SDHC_IRQSTATEN = irqstat;
    75d4:	str	r6, [r3, #52]	; 0x34
  
  uint32_t sigen = SDHC_IRQSIGEN;
    75d6:	ldr	r6, [r3, #56]	; 0x38
  sigen |= SDHC_IRQSIGEN_DMA_MASK ;
    75d8:	orr.w	r4, r4, r6
  SDHC_IRQSIGEN = sigen;
    75dc:	str	r4, [r3, #56]	; 0x38
  
  SDHC_SYSCTL |= SDHC_SYSCTL_HCKEN;
    75de:	ldr	r4, [r3, #44]	; 0x2c
    75e0:	orr.w	r4, r4, #2
    75e4:	str	r4, [r3, #44]	; 0x2c
  #if defined(__IMXRT1052__) || defined(__IMXRT1062__)
    SDHC_MIX_CTRL &= ~ SDHC_MIX_CTRL_DTDSEL;  // write
    75e6:	ldr	r4, [r3, #72]	; 0x48
    75e8:	bic.w	r4, r4, #16
    75ec:	str	r4, [r3, #72]	; 0x48
    SDHC_MIX_CTRL |=  SDHC_MIX_CTRL_DMAEN ;   //DMA
    75ee:	ldr	r4, [r3, #72]	; 0x48
    75f0:	orr.w	r4, r4, #1
    75f4:	str	r4, [r3, #72]	; 0x48
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_BCEN; // Block Count
    75f6:	ldr	r4, [r3, #72]	; 0x48
    75f8:	bic.w	r4, r4, #2
    75fc:	str	r4, [r3, #72]	; 0x48
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    75fe:	ldr	r4, [r3, #72]	; 0x48
    7600:	bic.w	r4, r4, #32
    7604:	str	r4, [r3, #72]	; 0x48
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    7606:	ldr	r4, [r3, #72]	; 0x48
    7608:	bic.w	r4, r4, #4
    760c:	str	r4, [r3, #72]	; 0x48
    if(count>1)
    760e:	bls.n	76ae <sd_CardWriteBlocks+0x116>
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
    7610:	ldr	r4, [r3, #72]	; 0x48
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    7612:	mov.w	ip, r7, lsl #16
    7616:	ldr	r6, [pc, #204]	; (76e4 <sd_CardWriteBlocks+0x14c>)
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_BCEN; // Block Count
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
    7618:	orr.w	lr, r4, #2
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    761c:	mov	r4, ip
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_BCEN; // Block Count
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
    761e:	str.w	lr, [r3, #72]	; 0x48
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    7622:	ands	r6, r4
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    7624:	ldr.w	ip, [r3, #72]	; 0x48
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);

  // enable DMA
  dmaDone=0;
    7628:	ldr	r4, [pc, #188]	; (76e8 <sd_CardWriteBlocks+0x150>)
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    762a:	orr.w	r6, r6, #512	; 0x200
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    762e:	orr.w	ip, ip, #32
  dmaDone=0;
  SDHC_DSADDR  = (uint32_t)buff;
  //
  // send write command
  SDHC_CMDARG = sector;
  SDHC_XFERTYP = count==1 ? SDHC_CMD24_XFERTYP: SDHC_CMD25_XFERTYP; 
    7632:	ldr.w	lr, [pc, #192]	; 76f4 <sd_CardWriteBlocks+0x15c>
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    if(count>1)
    {
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
    7636:	str.w	ip, [r3, #72]	; 0x48
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    763a:	ldr.w	ip, [r3, #72]	; 0x48
    763e:	orr.w	ip, ip, #4
    7642:	str.w	ip, [r3, #72]	; 0x48
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    7646:	str	r6, [r3, #4]

  // enable DMA
  dmaDone=0;
    7648:	str	r2, [r4, #0]
  SDHC_DSADDR  = (uint32_t)buff;
    764a:	str	r0, [r3, #0]
  //
  // send write command
  SDHC_CMDARG = sector;
    764c:	str	r1, [r3, #8]
  SDHC_XFERTYP = count==1 ? SDHC_CMD24_XFERTYP: SDHC_CMD25_XFERTYP; 
    764e:	ldr	r3, [pc, #136]	; (76d8 <sd_CardWriteBlocks+0x140>)
    7650:	str.w	lr, [r3, #12]
  //
  // wait for  DMA to finish
  while(!dmaDone);
    7654:	ldr	r3, [r4, #0]
    7656:	cmp	r3, #0
    7658:	beq.n	7654 <sd_CardWriteBlocks+0xbc>

  SDHC_IRQSTAT &= (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_TC);
    765a:	ldr	r3, [pc, #124]	; (76d8 <sd_CardWriteBlocks+0x140>)
    765c:	ldr	r1, [r3, #48]	; 0x30
  while(SDHC_PRSSTAT & SDHC_PRSSTAT_DLA);
    765e:	mov	r2, r3
  SDHC_XFERTYP = count==1 ? SDHC_CMD24_XFERTYP: SDHC_CMD25_XFERTYP; 
  //
  // wait for  DMA to finish
  while(!dmaDone);

  SDHC_IRQSTAT &= (SDHC_IRQSTAT_CC | SDHC_IRQSTAT_TC);
    7660:	and.w	r1, r1, #3
    7664:	str	r1, [r3, #48]	; 0x30
  while(SDHC_PRSSTAT & SDHC_PRSSTAT_DLA);
    7666:	ldr	r3, [r2, #36]	; 0x24
    7668:	lsls	r0, r3, #29
    766a:	bmi.n	7666 <sd_CardWriteBlocks+0xce>
#define CARD_STATUS_READY_FOR_DATA	(1UL << 8)
// ---------- sends CMD13 to check uSD status and wait for ready
static int sd_CMD13_WaitForReady(uint32_t address)
{ int result;
  do
  { while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB)) ;
    766c:	ldr	r4, [pc, #104]	; (76d8 <sd_CardWriteBlocks+0x140>)
    766e:	ldr.w	r8, [r5, #4]
    7672:	mov	r6, r4
    7674:	mov	r5, r4
    7676:	ldr	r3, [r4, #36]	; 0x24
    7678:	lsls	r1, r3, #31
    767a:	bmi.n	7676 <sd_CardWriteBlocks+0xde>
    767c:	ldr	r3, [r5, #36]	; 0x24
    767e:	lsls	r2, r3, #30
    7680:	bmi.n	7676 <sd_CardWriteBlocks+0xde>
    SDHC_IRQSTATEN |= SDHC_IRQSTATEN_CCSEN;
    7682:	ldr	r3, [r6, #52]	; 0x34
}

// ---------- sends CMD13 to check uSD status
#define SDHC_CMD13_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD13) | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))
//
static int sd_CMD13_Check_Status(uint32_t address){  return sd_CMD(SDHC_CMD13_XFERTYP, address);}
    7684:	mov	r1, r8
    7686:	ldr	r0, [pc, #100]	; (76ec <sd_CardWriteBlocks+0x154>)
// ---------- sends CMD13 to check uSD status and wait for ready
static int sd_CMD13_WaitForReady(uint32_t address)
{ int result;
  do
  { while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB)) ;
    SDHC_IRQSTATEN |= SDHC_IRQSTATEN_CCSEN;
    7688:	orr.w	r3, r3, #1
    768c:	str	r3, [r6, #52]	; 0x34
    SDHC_IRQSTAT=SDHC_IRQSTAT;
    768e:	ldr	r3, [r6, #48]	; 0x30
    7690:	str	r3, [r6, #48]	; 0x30
}

// ---------- sends CMD13 to check uSD status
#define SDHC_CMD13_XFERTYP (SDHC_XFERTYP_CMDINX(SDHC_CMD13) | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48))
//
static int sd_CMD13_Check_Status(uint32_t address){  return sd_CMD(SDHC_CMD13_XFERTYP, address);}
    7692:	bl	6ffc <sd_CMD>
  { while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB)) ;
    SDHC_IRQSTATEN |= SDHC_IRQSTATEN_CCSEN;
    SDHC_IRQSTAT=SDHC_IRQSTAT;
    // CMD13 to check uSD status
    result = sd_CMD13_Check_Status(sdCardDesc.address);
    if (result != SDHC_RESULT_OK)  return result;
    7696:	cbnz	r0, 76a2 <sd_CardWriteBlocks+0x10a>
  } while(!((SDHC_CMDRSP0 & CARD_STATUS_READY_FOR_DATA)==CARD_STATUS_READY_FOR_DATA)); // while data?
    7698:	ldr	r3, [r6, #16]
    769a:	lsls	r3, r3, #23
    769c:	bpl.n	7676 <sd_CardWriteBlocks+0xde>
    769e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

  //check for SD status (if data are written?)
  result = sd_CMD13_WaitForReady(sdCardDesc.address);

	// Auto CMD12 is enabled for DMA so call it when transfer error
	if((result != SDHC_RESULT_OK) && (count>1))
    76a2:	cmp	r7, #1
    76a4:	bls.n	75ac <sd_CardWriteBlocks+0x14>
		result=sd_CMD12_StopTransferWaitForBusy();
  
  return result;
}
    76a6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  //check for SD status (if data are written?)
  result = sd_CMD13_WaitForReady(sdCardDesc.address);

	// Auto CMD12 is enabled for DMA so call it when transfer error
	if((result != SDHC_RESULT_OK) && (count>1))
		result=sd_CMD12_StopTransferWaitForBusy();
    76aa:	b.w	7078 <sd_CMD12_StopTransferWaitForBusy>
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    76ae:	mov.w	lr, r7, lsl #16
    76b2:	ldr	r6, [pc, #48]	; (76e4 <sd_CardWriteBlocks+0x14c>)

  // enable DMA
  dmaDone=0;
    76b4:	ldr	r4, [pc, #48]	; (76e8 <sd_CardWriteBlocks+0x150>)
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    76b6:	and.w	r6, lr, r6
  dmaDone=0;
  SDHC_DSADDR  = (uint32_t)buff;
  //
  // send write command
  SDHC_CMDARG = sector;
  SDHC_XFERTYP = count==1 ? SDHC_CMD24_XFERTYP: SDHC_CMD25_XFERTYP; 
    76ba:	ite	eq
    76bc:	ldreq.w	lr, [pc, #56]	; 76f8 <sd_CardWriteBlocks+0x160>
    76c0:	ldrne.w	lr, [pc, #48]	; 76f4 <sd_CardWriteBlocks+0x15c>
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_BCEN; // Block Count
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_MSBSEL; //for multi block transfer
      SDHC_MIX_CTRL |= SDHC_MIX_CTRL_AC12EN; //for multi block transfer
    }
  #endif
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(count) | SDHC_BLKATTR_BLKSIZE(512);
    76c4:	orr.w	r6, r6, #512	; 0x200
    76c8:	str	r6, [r3, #4]

  // enable DMA
  dmaDone=0;
    76ca:	str	r2, [r4, #0]
  SDHC_DSADDR  = (uint32_t)buff;
    76cc:	str	r0, [r3, #0]
  //
  // send write command
  SDHC_CMDARG = sector;
    76ce:	str	r1, [r3, #8]
    76d0:	b.n	764e <sd_CardWriteBlocks+0xb6>
    76d2:	nop
    76d4:	.word	0x2000af14
    76d8:	.word	0x402c0000
    76dc:	.word	0x1022000a
    76e0:	.word	0x1000000a
    76e4:	.word	0x1fff0000
    76e8:	.word	0x2000af10
    76ec:	.word	0x0d020000
    76f0:	.word	0xffddffce
    76f4:	.word	0x19220027
    76f8:	.word	0x18220003

000076fc <SDHC_disk_write>:
DRESULT SDHC_disk_read(BYTE *buff, DWORD sector, UINT count)
{	return (DRESULT) sd_CardReadBlocks((void *) buff, (uint32_t) sector, (uint32_t) count);
}

DRESULT SDHC_disk_write(const BYTE *buff, DWORD sector, UINT count)
{	return (DRESULT) sd_CardWriteBlocks((void *) buff, (uint32_t) sector, (uint32_t) count);
    76fc:	push	{r3, lr}
    76fe:	bl	7598 <sd_CardWriteBlocks>
}
    7702:	uxtb	r0, r0
    7704:	pop	{r3, pc}
    7706:	nop

00007708 <sd_chipSelect.part.0>:
  return TRUE;
}

//------------------------------------------------------------------------------

void sd_chipSelect(uint16_t high_low) 
    7708:	push	{r3, lr}
{ if(m_chipSelectPin<0) return;
//
  if(high_low==HIGH)
  {
    digitalWrite(m_chipSelectPin, HIGH);
    770a:	ldr	r3, [pc, #32]	; (772c <sd_chipSelect.part.0+0x24>)
    770c:	movs	r1, #1
    770e:	ldrb	r0, [r3, #0]
    7710:	bl	9820 <digitalWrite>
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7714:	ldr	r3, [pc, #24]	; (7730 <sd_chipSelect.part.0+0x28>)
    7716:	movs	r2, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7718:	mov	r1, r3
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    771a:	str	r2, [r3, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    771c:	ldr	r3, [r1, #92]	; 0x5c
    771e:	ldr	r2, [pc, #16]	; (7730 <sd_chipSelect.part.0+0x28>)
		if (fifo > 0) return spi->RDR; 
    7720:	tst.w	r3, #2031616	; 0x1f0000
    7724:	beq.n	771c <sd_chipSelect.part.0+0x14>
    7726:	ldr	r3, [r2, #116]	; 0x74
    7728:	pop	{r3, pc}
    772a:	nop
    772c:	.word	0x20000b78
    7730:	.word	0x403a0000

00007734 <spi_transfer.part.2>:
	  //spi->PUSHR = data; 
	  //while (!(spi->SR & SPI_SR_TCF)) ; // wait 
	  //return spi->POPR; 
	} 

	void spi_transfer(const void * buf, void * retbuf, size_t count)
    7734:	push	{r4, r5}
		uint8_t *p_read = (uint8_t*)retbuf;
		size_t count_read = count;

	  // Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	  // Lets clear the reader queue
	  spi->CR = LPSPI_CR_RRF | LPSPI_CR_MEN;  // clear the queue and make sure still enabled. 
    7736:	ldr	r3, [pc, #80]	; (7788 <spi_transfer.part.2+0x54>)
    7738:	movw	r4, #513	; 0x201
    773c:	str	r4, [r3, #16]

	  while (count > 0) {
    773e:	cbz	r2, 7784 <spi_transfer.part.2+0x50>
    7740:	mov	r5, r2
		// Push out the next byte; 
		spi->TDR = p_write? *p_write++ : 0xff;
    7742:	cbz	r0, 7780 <spi_transfer.part.2+0x4c>
    7744:	ldrb	r4, [r0, #0]
    7746:	adds	r0, #1
		count--; // how many bytes left to output.
    7748:	subs	r2, #1
	  // Lets clear the reader queue
	  spi->CR = LPSPI_CR_RRF | LPSPI_CR_MEN;  // clear the queue and make sure still enabled. 

	  while (count > 0) {
		// Push out the next byte; 
		spi->TDR = p_write? *p_write++ : 0xff;
    774a:	str	r4, [r3, #100]	; 0x64
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
		  if ((spi->RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    774c:	ldr	r4, [r3, #112]	; 0x70
    774e:	lsls	r4, r4, #30
    7750:	bmi.n	775e <spi_transfer.part.2+0x2a>
			uint8_t b = spi->RDR;  // Read any pending RX bytes in
    7752:	ldr	r4, [r3, #116]	; 0x74
			if (p_read) *p_read++ = b; 
			count_read--;
    7754:	subs	r5, #1
		spi->TDR = p_write? *p_write++ : 0xff;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
		  if ((spi->RSR & LPSPI_RSR_RXEMPTY) == 0)  {
			uint8_t b = spi->RDR;  // Read any pending RX bytes in
    7756:	uxtb	r4, r4
			if (p_read) *p_read++ = b; 
    7758:	cbz	r1, 775e <spi_transfer.part.2+0x2a>
    775a:	strb	r4, [r1, #0]
    775c:	adds	r1, #1
			count_read--;
		  }
		} while ((spi->SR & LPSPI_SR_TDF) == 0) ;
    775e:	ldr	r4, [r3, #20]
    7760:	lsls	r4, r4, #31
    7762:	bpl.n	774c <spi_transfer.part.2+0x18>

	  // Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	  // Lets clear the reader queue
	  spi->CR = LPSPI_CR_RRF | LPSPI_CR_MEN;  // clear the queue and make sure still enabled. 

	  while (count > 0) {
    7764:	cmp	r2, #0
    7766:	bne.n	7742 <spi_transfer.part.2+0xe>

	  }

	  // now lets wait for all of the read bytes to be returned...
	  while (count_read) {
		if ((spi->RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    7768:	ldr	r2, [pc, #28]	; (7788 <spi_transfer.part.2+0x54>)
		} while ((spi->SR & LPSPI_SR_TDF) == 0) ;

	  }

	  // now lets wait for all of the read bytes to be returned...
	  while (count_read) {
    776a:	cbz	r5, 7784 <spi_transfer.part.2+0x50>
		if ((spi->RSR & LPSPI_RSR_RXEMPTY) == 0)  {
    776c:	ldr	r3, [r2, #112]	; 0x70
    776e:	lsls	r3, r3, #30
    7770:	bmi.n	776c <spi_transfer.part.2+0x38>
		  uint8_t b = spi->RDR;  // Read any pending RX bytes in
    7772:	ldr	r3, [r2, #116]	; 0x74
    7774:	uxtb	r3, r3
		  if (p_read) *p_read++ = b; 
    7776:	cbz	r1, 777c <spi_transfer.part.2+0x48>
    7778:	strb	r3, [r1, #0]
    777a:	adds	r1, #1
		  count_read--;
    777c:	subs	r5, #1
    777e:	b.n	776a <spi_transfer.part.2+0x36>
	  // Lets clear the reader queue
	  spi->CR = LPSPI_CR_RRF | LPSPI_CR_MEN;  // clear the queue and make sure still enabled. 

	  while (count > 0) {
		// Push out the next byte; 
		spi->TDR = p_write? *p_write++ : 0xff;
    7780:	movs	r4, #255	; 0xff
    7782:	b.n	7748 <spi_transfer.part.2+0x14>
		  uint8_t b = spi->RDR;  // Read any pending RX bytes in
		  if (p_read) *p_read++ = b; 
		  count_read--;
		}
	  }
	}
    7784:	pop	{r4, r5}
    7786:	bx	lr
    7788:	.word	0x403a0000

0000778c <sd_cardCommand>:
  }
}

// send command and return error code.  Return zero for OK
uint8_t sd_cardCommand(uint8_t cmd, uint32_t arg) 
{ uint8_t d[6], *pa, kk;
    778c:	push	{r4, r5, r6, r7, lr}
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    778e:	ldr	r3, [pc, #220]	; (786c <sd_cardCommand+0xe0>)
  }
}

// send command and return error code.  Return zero for OK
uint8_t sd_cardCommand(uint8_t cmd, uint32_t arg) 
{ uint8_t d[6], *pa, kk;
    7790:	sub	sp, #20
    7792:	mov	r4, r0
    7794:	str	r1, [sp, #4]
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    7796:	movs	r1, #0
    7798:	ldrb	r0, [r3, #0]
    779a:	add	r6, sp, #8
    779c:	bl	9820 <digitalWrite>
  sd_chipSelect(LOW);

  // wait if busy
 // unused // uint16_t ret=sd_waitNotBusy(SD_WRITE_TIMEOUT);
// form message
  d[0]=cmd | 0x40;
    77a0:	orr.w	lr, r4, #64	; 0x40
  for(kk=1;kk<5;kk++) d[kk]=pa[4-kk];
    77a4:	ldrb.w	r3, [sp, #7]
    77a8:	mov	r7, r6
    77aa:	ldrb.w	r2, [sp, #5]
    77ae:	mov	r1, lr
    77b0:	ldrb.w	r0, [sp, #6]
    77b4:	add.w	ip, sp, #12
    77b8:	strb.w	r3, [sp, #9]
    77bc:	movs	r3, #0
    77be:	strb.w	r2, [sp, #11]
    77c2:	ldrb.w	r2, [sp, #4]
  sd_chipSelect(LOW);

  // wait if busy
 // unused // uint16_t ret=sd_waitNotBusy(SD_WRITE_TIMEOUT);
// form message
  d[0]=cmd | 0x40;
    77c6:	strb.w	lr, [sp, #8]
  for(kk=1;kk<5;kk++) d[kk]=pa[4-kk];
    77ca:	strb.w	r0, [sp, #10]
    77ce:	strb.w	r2, [sp, #12]
    77d2:	movs	r2, #8
    uint8_t ii,jj;
    for (ii = 0; ii < n; ii++) 
    {
    uint8_t d = data[ii];
    for (jj = 0; jj < 8; jj++) {
      crc <<= 1;
    77d4:	lsls	r3, r3, #1
    77d6:	subs	r2, #1
      if ((d & 0x80) ^ (crc & 0x80)) crc ^= 0x09;
      d <<= 1;
    77d8:	lsls	r5, r1, #1
    uint8_t ii,jj;
    for (ii = 0; ii < n; ii++) 
    {
    uint8_t d = data[ii];
    for (jj = 0; jj < 8; jj++) {
      crc <<= 1;
    77da:	uxtb	r3, r3
      if ((d & 0x80) ^ (crc & 0x80)) crc ^= 0x09;
    77dc:	eor.w	r0, r3, r1
      d <<= 1;
    77e0:	uxtb	r1, r5
    for (ii = 0; ii < n; ii++) 
    {
    uint8_t d = data[ii];
    for (jj = 0; jj < 8; jj++) {
      crc <<= 1;
      if ((d & 0x80) ^ (crc & 0x80)) crc ^= 0x09;
    77e2:	lsls	r0, r0, #24
    77e4:	it	mi
    77e6:	eormi.w	r3, r3, #9
    uint8_t crc = 0;
    uint8_t ii,jj;
    for (ii = 0; ii < n; ii++) 
    {
    uint8_t d = data[ii];
    for (jj = 0; jj < 8; jj++) {
    77ea:	ands.w	r2, r2, #255	; 0xff
    77ee:	bne.n	77d4 <sd_cardCommand+0x48>
  //------------------------------------------------------------------------------
  // CRC functions
  static uint8_t CRC7(const uint8_t* data, uint8_t n) {
    uint8_t crc = 0;
    uint8_t ii,jj;
    for (ii = 0; ii < n; ii++) 
    77f0:	cmp	ip, r7
    77f2:	beq.n	77fa <sd_cardCommand+0x6e>
    77f4:	ldrb.w	r1, [r7, #1]!
    77f8:	b.n	77d2 <sd_cardCommand+0x46>
// form message
  d[0]=cmd | 0x40;
  for(kk=1;kk<5;kk++) d[kk]=pa[4-kk];
  
#ifdef USE_SD_CRC  // add crc
  d[5] = CRC7(d, 5);
    77fa:	lsls	r3, r3, #1
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    77fc:	ldr	r2, [pc, #112]	; (7870 <sd_cardCommand+0xe4>)
// form message
  d[0]=cmd | 0x40;
  for(kk=1;kk<5;kk++) d[kk]=pa[4-kk];
  
#ifdef USE_SD_CRC  // add crc
  d[5] = CRC7(d, 5);
    77fe:	add	r0, sp, #16
    7800:	orr.w	r3, r3, #1
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7804:	mov	r5, r2
// form message
  d[0]=cmd | 0x40;
  for(kk=1;kk<5;kk++) d[kk]=pa[4-kk];
  
#ifdef USE_SD_CRC  // add crc
  d[5] = CRC7(d, 5);
    7806:	strb.w	r3, [r0, #-3]!
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    780a:	str.w	lr, [r2, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    780e:	ldr	r3, [r2, #92]	; 0x5c
    7810:	ldr	r1, [pc, #92]	; (7870 <sd_cardCommand+0xe4>)
		if (fifo > 0) return spi->RDR; 
    7812:	tst.w	r3, #2031616	; 0x1f0000
    7816:	beq.n	780e <sd_cardCommand+0x82>
#else
  d[5]=((cmd == CMD0) ? 0X95 : 0X87);
#endif  // USE_SD_CRC

  // send message
  for (kk = 0; kk < 6; kk++) spi_send(d[kk]);
    7818:	cmp	r6, r0
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
		if (fifo > 0) return spi->RDR; 
    781a:	ldr	r3, [r5, #116]	; 0x74
#else
  d[5]=((cmd == CMD0) ? 0X95 : 0X87);
#endif  // USE_SD_CRC

  // send message
  for (kk = 0; kk < 6; kk++) spi_send(d[kk]);
    781c:	beq.n	7824 <sd_cardCommand+0x98>
    781e:	ldrb.w	lr, [r6, #1]!
    7822:	b.n	780a <sd_cardCommand+0x7e>

  // skip stuff byte for stop read
  if (cmd == CMD12) spi_receive();
    7824:	cmp	r4, #12
    7826:	beq.n	7858 <sd_cardCommand+0xcc>
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7828:	ldr	r2, [pc, #68]	; (7870 <sd_cardCommand+0xe4>)

  // wait if busy
 // unused // uint16_t ret=sd_waitNotBusy(SD_WRITE_TIMEOUT);
// form message
  d[0]=cmd | 0x40;
  for(kk=1;kk<5;kk++) d[kk]=pa[4-kk];
    782a:	movs	r1, #0
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    782c:	movs	r6, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    782e:	mov	r5, r2
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7830:	str	r6, [r2, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7832:	ldr	r3, [r2, #92]	; 0x5c
		if (fifo > 0) return spi->RDR; 
    7834:	tst.w	r3, #2031616	; 0x1f0000
    7838:	beq.n	7832 <sd_cardCommand+0xa6>

  // skip stuff byte for stop read
  if (cmd == CMD12) spi_receive();

  // wait for response
  for (kk = 0; ((m_sd_status = spi_receive()) & 0X80) && kk != 0XFF; kk++);
    783a:	uxtb	r3, r1
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
		if (fifo > 0) return spi->RDR; 
    783c:	ldr	r0, [r5, #116]	; 0x74

  // skip stuff byte for stop read
  if (cmd == CMD12) spi_receive();

  // wait for response
  for (kk = 0; ((m_sd_status = spi_receive()) & 0X80) && kk != 0XFF; kk++);
    783e:	adds	r1, #1
    7840:	subs	r3, #255	; 0xff
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
		if (fifo > 0) return spi->RDR; 
    7842:	uxtb	r0, r0

  // skip stuff byte for stop read
  if (cmd == CMD12) spi_receive();

  // wait for response
  for (kk = 0; ((m_sd_status = spi_receive()) & 0X80) && kk != 0XFF; kk++);
    7844:	it	ne
    7846:	movne	r3, #1
    7848:	uxth	r4, r0
    784a:	ands.w	r3, r3, r0, lsr #7
    784e:	bne.n	7830 <sd_cardCommand+0xa4>
    7850:	ldr	r3, [pc, #32]	; (7874 <sd_cardCommand+0xe8>)
    7852:	strh	r4, [r3, #0]
  return m_sd_status;
} 
    7854:	add	sp, #20
    7856:	pop	{r4, r5, r6, r7, pc}
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7858:	movs	r3, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    785a:	mov	r0, r1
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    785c:	str	r3, [r1, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    785e:	ldr	r3, [r0, #92]	; 0x5c
    7860:	ldr	r2, [pc, #12]	; (7870 <sd_cardCommand+0xe4>)
		if (fifo > 0) return spi->RDR; 
    7862:	tst.w	r3, #2031616	; 0x1f0000
    7866:	beq.n	785e <sd_cardCommand+0xd2>
    7868:	ldr	r3, [r2, #116]	; 0x74
    786a:	b.n	7828 <sd_cardCommand+0x9c>
    786c:	.word	0x20000b78
    7870:	.word	0x403a0000
    7874:	.word	0x2000b2f0

00007878 <sd_readData>:
  return m_sd_status;
} 

//typedef long size_t;

uint16_t sd_readData(uint8_t* dst, size_t count) {
    7878:	push	{r3, r4, r5, r6, r7, lr}
    787a:	ldr	r6, [pc, #224]	; (795c <sd_readData+0xe4>)
    787c:	mov	r5, r1
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    787e:	ldr	r2, [pc, #224]	; (7960 <sd_readData+0xe8>)
  return m_sd_status;
} 

//typedef long size_t;

uint16_t sd_readData(uint8_t* dst, size_t count) {
    7880:	mov	r4, r0
    7882:	ldr	r1, [r6, #0]
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7884:	movs	r7, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7886:	mov	r0, r2
  uint16_t crc;
#endif  // USE_SD_CRC
  // wait for start block token
  uint16_t t0 = millis();
  while ((m_sd_status = spi_receive()) == 0XFF) {
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
    7888:	uxth	r1, r1
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    788a:	str	r7, [r2, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    788c:	ldr	r3, [r2, #92]	; 0x5c
		if (fifo > 0) return spi->RDR; 
    788e:	tst.w	r3, #2031616	; 0x1f0000
    7892:	beq.n	788c <sd_readData+0x14>
    7894:	ldr	r3, [r0, #116]	; 0x74
    7896:	uxtb	r3, r3
#ifdef USE_SD_CRC
  uint16_t crc;
#endif  // USE_SD_CRC
  // wait for start block token
  uint16_t t0 = millis();
  while ((m_sd_status = spi_receive()) == 0XFF) {
    7898:	cmp	r3, #255	; 0xff
    789a:	uxth.w	lr, r3
    789e:	bne.n	78c0 <sd_readData+0x48>
    78a0:	ldr	r3, [r6, #0]
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
    78a2:	uxth	r3, r3
    78a4:	subs	r3, r3, r1
    78a6:	cmp.w	r3, #300	; 0x12c
    78aa:	ble.n	788a <sd_readData+0x12>
    78ac:	ldr	r1, [pc, #180]	; (7964 <sd_readData+0xec>)
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    78ae:	movs	r2, #17
    78b0:	ldr	r3, [pc, #180]	; (7968 <sd_readData+0xf0>)
    78b2:	strh.w	lr, [r1]
    78b6:	strh	r2, [r3, #0]
    78b8:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
    78bc:	movs	r0, #0
}
    78be:	pop	{r3, r4, r5, r6, r7, pc}
    78c0:	ldr	r6, [pc, #160]	; (7964 <sd_readData+0xec>)
    if (((uint16_t)millis() - t0) > SD_READ_TIMEOUT) {
      sd_setError(SD_CARD_ERROR_READ_TIMEOUT);
      goto fail;
    }
  }
  if (m_sd_status != DATA_START_BLOCK) {
    78c2:	cmp.w	lr, #254	; 0xfe
    78c6:	strh.w	lr, [r6]
    78ca:	beq.n	78da <sd_readData+0x62>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    78cc:	ldr	r3, [pc, #152]	; (7968 <sd_readData+0xf0>)
    78ce:	movs	r2, #15
    78d0:	strh	r2, [r3, #0]
    78d2:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
    78d6:	movs	r0, #0
}
    78d8:	pop	{r3, r4, r5, r6, r7, pc}
	} 

	void spi_transfer(const void * buf, void * retbuf, size_t count)
	{

	  if (count == 0) return;
    78da:	cmp	r5, #0
    78dc:	bne.n	7944 <sd_readData+0xcc>
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    78de:	ldr	r3, [pc, #128]	; (7960 <sd_readData+0xe8>)
  if (m_sd_status != DATA_START_BLOCK) {
    sd_setError(SD_CARD_ERROR_READ);
    goto fail;
  }
  // transfer data
  if ((m_sd_status = spi_receiveBulk(dst, count))) {
    78e0:	movs	r0, #0
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    78e2:	movs	r2, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    78e4:	mov	r1, r3
  if (m_sd_status != DATA_START_BLOCK) {
    sd_setError(SD_CARD_ERROR_READ);
    goto fail;
  }
  // transfer data
  if ((m_sd_status = spi_receiveBulk(dst, count))) {
    78e6:	strh	r0, [r6, #0]
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    78e8:	str	r2, [r3, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    78ea:	ldr	r3, [r1, #92]	; 0x5c
    78ec:	ldr	r2, [pc, #112]	; (7960 <sd_readData+0xe8>)
		if (fifo > 0) return spi->RDR; 
    78ee:	tst.w	r3, #2031616	; 0x1f0000
    78f2:	beq.n	78ea <sd_readData+0x72>
    78f4:	ldr	r6, [r2, #116]	; 0x74
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    78f6:	movs	r3, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    78f8:	mov	r1, r2
    goto fail;
  }

#ifdef USE_SD_CRC
  // get crc
  crc = (spi_receive() << 8) | spi_receive();
    78fa:	lsls	r6, r6, #8
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    78fc:	str	r3, [r2, #100]	; 0x64
    goto fail;
  }

#ifdef USE_SD_CRC
  // get crc
  crc = (spi_receive() << 8) | spi_receive();
    78fe:	sxth	r6, r6
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7900:	ldr	r3, [r1, #92]	; 0x5c
    7902:	ldr	r2, [pc, #92]	; (7960 <sd_readData+0xe8>)
		if (fifo > 0) return spi->RDR; 
    7904:	tst.w	r3, #2031616	; 0x1f0000
    7908:	beq.n	7900 <sd_readData+0x88>
    790a:	ldr	r3, [r2, #116]	; 0x74
    goto fail;
  }

#ifdef USE_SD_CRC
  // get crc
  crc = (spi_receive() << 8) | spi_receive();
    790c:	uxtb	r3, r3
    790e:	orrs	r6, r3
    7910:	uxth	r6, r6
    };

    static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
      uint16_t crc = 0;
      size_t ii;
      for (ii = 0; ii < n; ii++) {
    7912:	cbz	r5, 7950 <sd_readData+0xd8>
    7914:	movs	r3, #0
    7916:	ldr	r0, [pc, #84]	; (796c <sd_readData+0xf4>)
    7918:	add	r5, r4
      crc = crctab[(crc >> 8 ^ data[ii]) & 0XFF] ^ (crc << 8);
    791a:	ldrb.w	r2, [r4], #1
    791e:	ubfx	r1, r3, #8, #16
    7922:	eors	r2, r1
    };

    static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
      uint16_t crc = 0;
      size_t ii;
      for (ii = 0; ii < n; ii++) {
    7924:	cmp	r4, r5
      crc = crctab[(crc >> 8 ^ data[ii]) & 0XFF] ^ (crc << 8);
    7926:	ldrh.w	r2, [r0, r2, lsl #1]
    792a:	eor.w	r3, r2, r3, lsl #8
    792e:	uxth	r3, r3
    };

    static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
      uint16_t crc = 0;
      size_t ii;
      for (ii = 0; ii < n; ii++) {
    7930:	bne.n	791a <sd_readData+0xa2>
  }

#ifdef USE_SD_CRC
  // get crc
  crc = (spi_receive() << 8) | spi_receive();
  if (crc != CRC_CCITT(dst, count)) {
    7932:	cmp	r6, r3
    7934:	beq.n	7954 <sd_readData+0xdc>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7936:	ldr	r3, [pc, #48]	; (7968 <sd_readData+0xf0>)
    7938:	movs	r2, #27
    793a:	strh	r2, [r3, #0]
    793c:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
    7940:	movs	r0, #0
}
    7942:	pop	{r3, r4, r5, r6, r7, pc}
    7944:	mov	r2, r5
    7946:	mov	r1, r4
    7948:	movs	r0, #0
    794a:	bl	7734 <spi_transfer.part.2>
    794e:	b.n	78de <sd_readData+0x66>
      0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
      0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
    };

    static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
      uint16_t crc = 0;
    7950:	mov	r3, r5
    7952:	b.n	7932 <sd_readData+0xba>
    7954:	bl	7708 <sd_chipSelect.part.0>
  spi_receive();
  spi_receive();
#endif  // USE_SD_CRC

  sd_chipSelect(HIGH);
  return TRUE;
    7958:	movs	r0, #1
    795a:	pop	{r3, r4, r5, r6, r7, pc}
    795c:	.word	0x2000b144
    7960:	.word	0x403a0000
    7964:	.word	0x2000b2f0
    7968:	.word	0x2000b2f2
    796c:	.word	0x200002d8

00007970 <sd_readData2>:
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    7970:	ldr	r3, [pc, #24]	; (798c <sd_readData2+0x1c>)
    7972:	movs	r1, #0
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint16_t sd_readData2(uint8_t *dst) 
{
    7974:	push	{r4, lr}
    7976:	mov	r4, r0
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    7978:	ldrb	r0, [r3, #0]
    797a:	bl	9820 <digitalWrite>
 * the value zero, false, is returned for failure.
 */
uint16_t sd_readData2(uint8_t *dst) 
{
  sd_chipSelect(LOW);
  return sd_readData(dst, 512);
    797e:	mov.w	r1, #512	; 0x200
    7982:	mov	r0, r4
}
    7984:	ldmia.w	sp!, {r4, lr}
 * the value zero, false, is returned for failure.
 */
uint16_t sd_readData2(uint8_t *dst) 
{
  sd_chipSelect(LOW);
  return sd_readData(dst, 512);
    7988:	b.w	7878 <sd_readData>
    798c:	.word	0x20000b78

00007990 <sd_readStart>:
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint16_t sd_readStart(uint32_t blockNumber) 
{
    7990:	push	{r3, lr}
// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
uint16_t sd_getError(void) {return m_sd_errorCode;}

void sd_setType(uint16_t type) {m_sd_type=type;}
uint16_t sd_getType(void) {return m_sd_type;}
    7992:	ldr	r3, [pc, #40]	; (79bc <sd_readStart+0x2c>)
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint16_t sd_readStart(uint32_t blockNumber) 
{
    7994:	mov	r1, r0
  //SD_TRACE("RS", blockNumber);
  if (sd_getType()!= SD_CARD_TYPE_SDHC) blockNumber <<= 9;
    7996:	ldrh	r3, [r3, #0]
    7998:	cmp	r3, #3
    799a:	it	ne
    799c:	lslne	r1, r0, #9
  if (sd_cardCommand(CMD18, blockNumber)) {
    799e:	movs	r0, #18
    79a0:	bl	778c <sd_cardCommand>
    79a4:	cbnz	r0, 79ae <sd_readStart+0x1e>
    79a6:	bl	7708 <sd_chipSelect.part.0>
    sd_setError(SD_CARD_ERROR_CMD18);
    goto fail;
  }
  sd_chipSelect(HIGH);
  return TRUE;
    79aa:	movs	r0, #1

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
}
    79ac:	pop	{r3, pc}
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    79ae:	ldr	r3, [pc, #16]	; (79c0 <sd_readStart+0x30>)
    79b0:	movs	r2, #5
    79b2:	strh	r2, [r3, #0]
    79b4:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
    79b8:	movs	r0, #0
    79ba:	pop	{r3, pc}
    79bc:	.word	0x2000b2f4
    79c0:	.word	0x2000b2f2

000079c4 <sd_readStop>:
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */

uint16_t sd_readStop() 
{
    79c4:	push	{r3, lr}
  if (sd_cardCommand(CMD12, 0)) {
    79c6:	movs	r1, #0
    79c8:	movs	r0, #12
    79ca:	bl	778c <sd_cardCommand>
    79ce:	cbnz	r0, 79d8 <sd_readStop+0x14>
    79d0:	bl	7708 <sd_chipSelect.part.0>
    sd_setError(SD_CARD_ERROR_CMD12);
    goto fail;
  }
  sd_chipSelect(HIGH);
  return TRUE;
    79d4:	movs	r0, #1

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
}
    79d6:	pop	{r3, pc}
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    79d8:	ldr	r3, [pc, #12]	; (79e8 <sd_readStop+0x24>)
    79da:	movs	r2, #3
    79dc:	strh	r2, [r3, #0]
    79de:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
    79e2:	movs	r0, #0
    79e4:	pop	{r3, pc}
    79e6:	nop
    79e8:	.word	0x2000b2f2

000079ec <SPI_disk_read>:
    
    return 0;
}

DRESULT SPI_disk_read(BYTE *buff, DWORD sector, UINT count)
{	
    79ec:	push	{r3, r4, r5, r6, r7, lr}
    79ee:	mov	r4, r0
	DRESULT res = RES_OK;
    if(!sd_readStart(sector)) res = RES_READERROR;
    79f0:	mov	r0, r1
    
    return 0;
}

DRESULT SPI_disk_read(BYTE *buff, DWORD sector, UINT count)
{	
    79f2:	mov	r7, r2
	DRESULT res = RES_OK;
    if(!sd_readStart(sector)) res = RES_READERROR;
    79f4:	bl	7990 <sd_readStart>
    79f8:	cmp	r0, #0
    79fa:	ite	ne
    79fc:	movne	r6, #0
    79fe:	moveq	r6, #6
    for(int ii=0; ii<count;ii++)
    7a00:	cbz	r7, 7a1a <SPI_disk_read+0x2e>
    7a02:	movs	r5, #0
    {
      if(!sd_readData2(buff)) res = RES_READERROR;
    7a04:	mov	r0, r4

DRESULT SPI_disk_read(BYTE *buff, DWORD sector, UINT count)
{	
	DRESULT res = RES_OK;
    if(!sd_readStart(sector)) res = RES_READERROR;
    for(int ii=0; ii<count;ii++)
    7a06:	adds	r5, #1
    {
      if(!sd_readData2(buff)) res = RES_READERROR;
    7a08:	bl	7970 <sd_readData2>
    7a0c:	cmp	r0, #0
      sector++;
      buff += 512;    
    7a0e:	add.w	r4, r4, #512	; 0x200
{	
	DRESULT res = RES_OK;
    if(!sd_readStart(sector)) res = RES_READERROR;
    for(int ii=0; ii<count;ii++)
    {
      if(!sd_readData2(buff)) res = RES_READERROR;
    7a12:	it	eq
    7a14:	moveq	r6, #6

DRESULT SPI_disk_read(BYTE *buff, DWORD sector, UINT count)
{	
	DRESULT res = RES_OK;
    if(!sd_readStart(sector)) res = RES_READERROR;
    for(int ii=0; ii<count;ii++)
    7a16:	cmp	r7, r5
    7a18:	bne.n	7a04 <SPI_disk_read+0x18>
    {
      if(!sd_readData2(buff)) res = RES_READERROR;
      sector++;
      buff += 512;    
    }
    if(!sd_readStop()) res = RES_READERROR;
    7a1a:	bl	79c4 <sd_readStop>
    7a1e:	cmp	r0, #0

    return res;
}
    7a20:	ite	ne
    7a22:	movne	r0, r6
    7a24:	moveq	r0, #6
    7a26:	pop	{r3, r4, r5, r6, r7, pc}

00007a28 <sd_writeData>:
}

//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint16_t sd_writeData(uint8_t token, const uint8_t* src) 
{
    7a28:	push	{r3, r4, r5, r6, r7, lr}
    7a2a:	subs	r2, r1, #1
      0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
      0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
    };

    static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
      uint16_t crc = 0;
    7a2c:	movs	r5, #0
    7a2e:	ldr	r7, [pc, #144]	; (7ac0 <sd_writeData+0x98>)
    7a30:	addw	r6, r1, #511	; 0x1ff
      size_t ii;
      for (ii = 0; ii < n; ii++) {
      crc = crctab[(crc >> 8 ^ data[ii]) & 0XFF] ^ (crc << 8);
    7a34:	ldrb.w	r3, [r2, #1]!
    7a38:	eor.w	r3, r3, r5, lsr #8
    };

    static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
      uint16_t crc = 0;
      size_t ii;
      for (ii = 0; ii < n; ii++) {
    7a3c:	cmp	r6, r2
      crc = crctab[(crc >> 8 ^ data[ii]) & 0XFF] ^ (crc << 8);
    7a3e:	ldrh.w	r3, [r7, r3, lsl #1]
    7a42:	eor.w	r4, r3, r5, lsl #8
    7a46:	sxth	r4, r4
    7a48:	uxth	r5, r4
    };

    static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {
      uint16_t crc = 0;
      size_t ii;
      for (ii = 0; ii < n; ii++) {
    7a4a:	bne.n	7a34 <sd_writeData+0xc>
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7a4c:	ldr	r3, [pc, #116]	; (7ac4 <sd_writeData+0x9c>)
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7a4e:	mov	r2, r3
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7a50:	str	r0, [r3, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7a52:	ldr	r3, [r2, #92]	; 0x5c
    7a54:	ldr	r6, [pc, #108]	; (7ac4 <sd_writeData+0x9c>)
		if (fifo > 0) return spi->RDR; 
    7a56:	tst.w	r3, #2031616	; 0x1f0000
    7a5a:	beq.n	7a52 <sd_writeData+0x2a>
    7a5c:	mov	r0, r1
    7a5e:	mov.w	r2, #512	; 0x200
    7a62:	movs	r1, #0
    7a64:	ldr	r3, [r6, #116]	; 0x74
    7a66:	bl	7734 <spi_transfer.part.2>
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7a6a:	mov	r1, r6
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7a6c:	lsrs	r3, r5, #8
    7a6e:	str	r3, [r6, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7a70:	ldr	r3, [r1, #92]	; 0x5c
    7a72:	ldr	r2, [pc, #80]	; (7ac4 <sd_writeData+0x9c>)
		if (fifo > 0) return spi->RDR; 
    7a74:	tst.w	r3, #2031616	; 0x1f0000
    7a78:	beq.n	7a70 <sd_writeData+0x48>
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7a7a:	uxtb	r4, r4
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7a7c:	mov	r1, r2
		if (fifo > 0) return spi->RDR; 
    7a7e:	ldr	r3, [r2, #116]	; 0x74
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7a80:	str	r4, [r2, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7a82:	ldr	r3, [r1, #92]	; 0x5c
    7a84:	ldr	r2, [pc, #60]	; (7ac4 <sd_writeData+0x9c>)
		if (fifo > 0) return spi->RDR; 
    7a86:	tst.w	r3, #2031616	; 0x1f0000
    7a8a:	beq.n	7a82 <sd_writeData+0x5a>
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7a8c:	movs	r3, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7a8e:	mov	r1, r2
		if (fifo > 0) return spi->RDR; 
    7a90:	ldr	r0, [r2, #116]	; 0x74
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7a92:	str	r3, [r2, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7a94:	ldr	r3, [r1, #92]	; 0x5c
    7a96:	ldr	r2, [pc, #44]	; (7ac4 <sd_writeData+0x9c>)
		if (fifo > 0) return spi->RDR; 
    7a98:	tst.w	r3, #2031616	; 0x1f0000
    7a9c:	beq.n	7a94 <sd_writeData+0x6c>
    7a9e:	ldr	r3, [r2, #116]	; 0x74

  spi_send(token);
  spi_sendBulk(src, 512);
  spi_send(crc >> 8);
  spi_send(crc & 0XFF);
  m_sd_status=spi_receive();
    7aa0:	ldr	r1, [pc, #36]	; (7ac8 <sd_writeData+0xa0>)
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
		if (fifo > 0) return spi->RDR; 
    7aa2:	uxtb	r3, r3
  spi_sendBulk(src, 512);
  spi_send(crc >> 8);
  spi_send(crc & 0XFF);
  m_sd_status=spi_receive();

  if ((m_sd_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    7aa4:	and.w	r2, r3, #31

  spi_send(token);
  spi_sendBulk(src, 512);
  spi_send(crc >> 8);
  spi_send(crc & 0XFF);
  m_sd_status=spi_receive();
    7aa8:	strh	r3, [r1, #0]

  if ((m_sd_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    7aaa:	cmp	r2, #5
    7aac:	beq.n	7abc <sd_writeData+0x94>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7aae:	ldr	r3, [pc, #28]	; (7acc <sd_writeData+0xa4>)
    7ab0:	movs	r2, #19
    7ab2:	strh	r2, [r3, #0]
    7ab4:	bl	7708 <sd_chipSelect.part.0>
  }
  return TRUE;

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
    7ab8:	movs	r0, #0
    7aba:	pop	{r3, r4, r5, r6, r7, pc}
  if ((m_sd_status & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    sd_setError(SD_CARD_ERROR_WRITE);
//  fprintf(stderr,"write error %x\r\n",m_sd_status & DATA_RES_MASK);
    goto fail;
  }
  return TRUE;
    7abc:	movs	r0, #1

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
}
    7abe:	pop	{r3, r4, r5, r6, r7, pc}
    7ac0:	.word	0x200002d8
    7ac4:	.word	0x403a0000
    7ac8:	.word	0x2000b2f0
    7acc:	.word	0x2000b2f2

00007ad0 <sd_writeData2>:
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    7ad0:	ldr	r3, [pc, #88]	; (7b2c <sd_writeData2+0x5c>)
    7ad2:	movs	r1, #0
 * \param[in] src Pointer to the location of the data to be written.
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint16_t sd_writeData2(const uint8_t* src) 
{
    7ad4:	push	{r4, r5, r6, lr}
    7ad6:	mov	r4, r0
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    7ad8:	ldrb	r0, [r3, #0]
    7ada:	bl	9820 <digitalWrite>
    7ade:	ldr	r0, [pc, #80]	; (7b30 <sd_writeData2+0x60>)
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7ae0:	ldr	r2, [pc, #80]	; (7b34 <sd_writeData2+0x64>)
    7ae2:	movs	r6, #255	; 0xff
    7ae4:	ldr	r1, [r0, #0]
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7ae6:	mov	r5, r2
{
  uint16_t t0;
  uint16_t ret;
  t0  = millis();
  while ((ret=spi_receive()) != 0XFF) 
  { if (((uint16_t)millis() - t0) >= timeoutMillis) return FALSE;
    7ae8:	uxth	r1, r1
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7aea:	str	r6, [r2, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7aec:	ldr	r3, [r2, #92]	; 0x5c
		if (fifo > 0) return spi->RDR; 
    7aee:	tst.w	r3, #2031616	; 0x1f0000
    7af2:	beq.n	7aec <sd_writeData2+0x1c>
    7af4:	ldr	r3, [r5, #116]	; 0x74
uint16_t sd_waitNotBusy(uint16_t timeoutMillis) 
{
  uint16_t t0;
  uint16_t ret;
  t0  = millis();
  while ((ret=spi_receive()) != 0XFF) 
    7af6:	uxtb	r3, r3
    7af8:	cmp	r3, #255	; 0xff
    7afa:	beq.n	7b16 <sd_writeData2+0x46>
    7afc:	ldr	r3, [r0, #0]
  { if (((uint16_t)millis() - t0) >= timeoutMillis) return FALSE;
    7afe:	uxth	r3, r3
    7b00:	subs	r3, r3, r1
    7b02:	cmp.w	r3, #600	; 0x258
    7b06:	blt.n	7aea <sd_writeData2+0x1a>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7b08:	ldr	r3, [pc, #44]	; (7b38 <sd_writeData2+0x68>)
    7b0a:	movs	r2, #21
    7b0c:	strh	r2, [r3, #0]
    7b0e:	bl	7708 <sd_chipSelect.part.0>
  return TRUE;

 fail:
  sd_setError(SD_CARD_ERROR_WRITE_MULTIPLE);
  sd_chipSelect(HIGH);
  return FALSE;
    7b12:	movs	r0, #0
    7b14:	pop	{r4, r5, r6, pc}
uint16_t sd_writeData2(const uint8_t* src) 
{
// unused // static long cnt=0;
  sd_chipSelect(LOW);
  if (!sd_waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  if (!sd_writeData(WRITE_MULTIPLE_TOKEN, src)) goto fail;
    7b16:	mov	r1, r4
    7b18:	movs	r0, #252	; 0xfc
    7b1a:	bl	7a28 <sd_writeData>
    7b1e:	cmp	r0, #0
    7b20:	beq.n	7b08 <sd_writeData2+0x38>
    7b22:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;
    7b26:	movs	r0, #1
    7b28:	pop	{r4, r5, r6, pc}
    7b2a:	nop
    7b2c:	.word	0x20000b78
    7b30:	.word	0x2000b144
    7b34:	.word	0x403a0000
    7b38:	.word	0x2000b2f2

00007b3c <sd_writeStart>:
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint16_t sd_writeStart(uint32_t blockNumber, uint32_t eraseCount) 
{
    7b3c:	push	{r3, r4, r5, lr}
    7b3e:	mov	r4, r0
  // send pre-erase count
  if(eraseCount)
    7b40:	cbnz	r1, 7b64 <sd_writeStart+0x28>
// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
uint16_t sd_getError(void) {return m_sd_errorCode;}

void sd_setType(uint16_t type) {m_sd_type=type;}
uint16_t sd_getType(void) {return m_sd_type;}
    7b42:	ldr	r3, [pc, #76]	; (7b90 <sd_writeStart+0x54>)
    goto fail;
    }
  }
  // use address if not SDHC card
  if (sd_getType() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
  if (sd_cardCommand(CMD25, blockNumber)) {
    7b44:	movs	r0, #25
    sd_setError(SD_CARD_ERROR_ACMD23);
    goto fail;
    }
  }
  // use address if not SDHC card
  if (sd_getType() != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
    7b46:	ldrh	r3, [r3, #0]
    7b48:	cmp	r3, #3
    7b4a:	it	ne
    7b4c:	lslne	r4, r4, #9
  if (sd_cardCommand(CMD25, blockNumber)) {
    7b4e:	mov	r1, r4
    7b50:	bl	778c <sd_cardCommand>
    7b54:	cbz	r0, 7b88 <sd_writeStart+0x4c>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7b56:	ldr	r3, [pc, #60]	; (7b94 <sd_writeStart+0x58>)
    7b58:	movs	r2, #7
    7b5a:	strh	r2, [r3, #0]
    7b5c:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
    7b60:	movs	r0, #0
}
    7b62:	pop	{r3, r4, r5, pc}
    7b64:	mov	r5, r1
  uint16_t sd_readCID(cid_t* cid) {  return sd_readRegister(CMD10, cid); }
  uint16_t sd_readCSD(csd_t* csd) {  return sd_readRegister(CMD9, csd); }

 
uint8_t sd_cardAcmd(uint8_t cmd, uint32_t arg) 
{   sd_cardCommand(CMD55, 0);
    7b66:	movs	r0, #55	; 0x37
    7b68:	movs	r1, #0
    7b6a:	bl	778c <sd_cardCommand>
    return sd_cardCommand(cmd, arg);
    7b6e:	mov	r1, r5
    7b70:	movs	r0, #23
    7b72:	bl	778c <sd_cardCommand>
uint16_t sd_writeStart(uint32_t blockNumber, uint32_t eraseCount) 
{
  // send pre-erase count
  if(eraseCount)
  {
    if (sd_cardAcmd(ACMD23, eraseCount)) {
    7b76:	cmp	r0, #0
    7b78:	beq.n	7b42 <sd_writeStart+0x6>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7b7a:	ldr	r3, [pc, #24]	; (7b94 <sd_writeStart+0x58>)
    7b7c:	movs	r2, #9
    7b7e:	strh	r2, [r3, #0]
    7b80:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;

 fail:
  sd_chipSelect(HIGH);
  return FALSE;
    7b84:	movs	r0, #0
}
    7b86:	pop	{r3, r4, r5, pc}
    7b88:	bl	7708 <sd_chipSelect.part.0>
  if (sd_cardCommand(CMD25, blockNumber)) {
    sd_setError(SD_CARD_ERROR_CMD25);
    goto fail;
  }
  sd_chipSelect(HIGH);
  return TRUE;
    7b8c:	movs	r0, #1
    7b8e:	pop	{r3, r4, r5, pc}
    7b90:	.word	0x2000b2f4
    7b94:	.word	0x2000b2f2

00007b98 <sd_writeStop>:
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    7b98:	ldr	r3, [pc, #132]	; (7c20 <sd_writeStop+0x88>)
    7b9a:	movs	r1, #0
 *
* \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint16_t sd_writeStop(void) 
{
    7b9c:	push	{r4, r5, r6, lr}
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    7b9e:	ldrb	r0, [r3, #0]
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7ba0:	movs	r6, #255	; 0xff
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    7ba2:	bl	9820 <digitalWrite>
    7ba6:	ldr	r0, [pc, #124]	; (7c24 <sd_writeStop+0x8c>)
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7ba8:	ldr	r2, [pc, #124]	; (7c28 <sd_writeStop+0x90>)
    7baa:	ldr	r4, [r0, #0]
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7bac:	mov	r5, r2
{
  uint16_t t0;
  uint16_t ret;
  t0  = millis();
  while ((ret=spi_receive()) != 0XFF) 
  { if (((uint16_t)millis() - t0) >= timeoutMillis) return FALSE;
    7bae:	uxth	r4, r4
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7bb0:	str	r6, [r2, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7bb2:	ldr	r3, [r2, #92]	; 0x5c
    7bb4:	ldr	r1, [pc, #112]	; (7c28 <sd_writeStop+0x90>)
		if (fifo > 0) return spi->RDR; 
    7bb6:	tst.w	r3, #2031616	; 0x1f0000
    7bba:	beq.n	7bb2 <sd_writeStop+0x1a>
    7bbc:	ldr	r3, [r5, #116]	; 0x74
uint16_t sd_waitNotBusy(uint16_t timeoutMillis) 
{
  uint16_t t0;
  uint16_t ret;
  t0  = millis();
  while ((ret=spi_receive()) != 0XFF) 
    7bbe:	uxtb	r3, r3
    7bc0:	cmp	r3, #255	; 0xff
    7bc2:	beq.n	7bde <sd_writeStop+0x46>
    7bc4:	ldr	r3, [r0, #0]
  { if (((uint16_t)millis() - t0) >= timeoutMillis) return FALSE;
    7bc6:	uxth	r3, r3
    7bc8:	subs	r3, r3, r4
    7bca:	cmp.w	r3, #600	; 0x258
    7bce:	blt.n	7bb0 <sd_writeStop+0x18>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7bd0:	ldr	r3, [pc, #88]	; (7c2c <sd_writeStop+0x94>)
    7bd2:	movs	r2, #18
    7bd4:	strh	r2, [r3, #0]
    7bd6:	bl	7708 <sd_chipSelect.part.0>
  return TRUE;

 fail:
  sd_setError(SD_CARD_ERROR_STOP_TRAN);
  sd_chipSelect(HIGH);
  return FALSE;
    7bda:	movs	r0, #0
    7bdc:	pop	{r4, r5, r6, pc}
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7bde:	movs	r3, #253	; 0xfd
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7be0:	mov	r4, r1
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7be2:	str	r3, [r1, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7be4:	ldr	r3, [r4, #92]	; 0x5c
    7be6:	ldr	r2, [pc, #64]	; (7c28 <sd_writeStop+0x90>)
		if (fifo > 0) return spi->RDR; 
    7be8:	tst.w	r3, #2031616	; 0x1f0000
    7bec:	beq.n	7be4 <sd_writeStop+0x4c>
    7bee:	ldr	r3, [r2, #116]	; 0x74
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7bf0:	movs	r5, #255	; 0xff
    7bf2:	ldr	r1, [r0, #0]
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7bf4:	mov	r4, r2
{
  uint16_t t0;
  uint16_t ret;
  t0  = millis();
  while ((ret=spi_receive()) != 0XFF) 
  { if (((uint16_t)millis() - t0) >= timeoutMillis) return FALSE;
    7bf6:	uxth	r1, r1
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7bf8:	str	r5, [r2, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7bfa:	ldr	r3, [r2, #92]	; 0x5c
		if (fifo > 0) return spi->RDR; 
    7bfc:	tst.w	r3, #2031616	; 0x1f0000
    7c00:	beq.n	7bfa <sd_writeStop+0x62>
    7c02:	ldr	r3, [r4, #116]	; 0x74
uint16_t sd_waitNotBusy(uint16_t timeoutMillis) 
{
  uint16_t t0;
  uint16_t ret;
  t0  = millis();
  while ((ret=spi_receive()) != 0XFF) 
    7c04:	uxtb	r3, r3
    7c06:	cmp	r3, #255	; 0xff
    7c08:	beq.n	7c18 <sd_writeStop+0x80>
    7c0a:	ldr	r3, [r0, #0]
  { if (((uint16_t)millis() - t0) >= timeoutMillis) return FALSE;
    7c0c:	uxth	r3, r3
    7c0e:	subs	r3, r3, r1
    7c10:	cmp.w	r3, #600	; 0x258
    7c14:	blt.n	7bf8 <sd_writeStop+0x60>
    7c16:	b.n	7bd0 <sd_writeStop+0x38>
    7c18:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(LOW);
  if (!sd_waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  spi_send(STOP_TRAN_TOKEN);
  if (!sd_waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;
  sd_chipSelect(HIGH);
  return TRUE;
    7c1c:	movs	r0, #1

 fail:
  sd_setError(SD_CARD_ERROR_STOP_TRAN);
  sd_chipSelect(HIGH);
  return FALSE;
}
    7c1e:	pop	{r4, r5, r6, pc}
    7c20:	.word	0x20000b78
    7c24:	.word	0x2000b144
    7c28:	.word	0x403a0000
    7c2c:	.word	0x2000b2f2

00007c30 <SPI_disk_write>:
    if(!sd_readStop()) res = RES_READERROR;

    return res;
}
DRESULT SPI_disk_write(const BYTE *buff, DWORD sector, UINT count)
{
    7c30:	push	{r3, r4, r5, r6, r7, lr}
    7c32:	mov	r3, r1
    7c34:	mov	r4, r0
    DRESULT res = RES_OK;
    if(!sd_writeStart(sector,count)) res = RES_WRITEERROR;
    7c36:	mov	r1, r2
    if(!sd_readStop()) res = RES_READERROR;

    return res;
}
DRESULT SPI_disk_write(const BYTE *buff, DWORD sector, UINT count)
{
    7c38:	mov	r7, r2
    DRESULT res = RES_OK;
    if(!sd_writeStart(sector,count)) res = RES_WRITEERROR;
    7c3a:	mov	r0, r3
    7c3c:	bl	7b3c <sd_writeStart>
    7c40:	cmp	r0, #0
    7c42:	ite	ne
    7c44:	movne	r6, #0
    7c46:	moveq	r6, #7
    for(int ii=0; ii<count;ii++)
    7c48:	cbz	r7, 7c62 <SPI_disk_write+0x32>
    7c4a:	movs	r5, #0
    {
      if(!sd_writeData2(buff)) res = RES_WRITEERROR;
    7c4c:	mov	r0, r4
}
DRESULT SPI_disk_write(const BYTE *buff, DWORD sector, UINT count)
{
    DRESULT res = RES_OK;
    if(!sd_writeStart(sector,count)) res = RES_WRITEERROR;
    for(int ii=0; ii<count;ii++)
    7c4e:	adds	r5, #1
    {
      if(!sd_writeData2(buff)) res = RES_WRITEERROR;
    7c50:	bl	7ad0 <sd_writeData2>
    7c54:	cmp	r0, #0
      sector++;
      buff += 512;    
    7c56:	add.w	r4, r4, #512	; 0x200
{
    DRESULT res = RES_OK;
    if(!sd_writeStart(sector,count)) res = RES_WRITEERROR;
    for(int ii=0; ii<count;ii++)
    {
      if(!sd_writeData2(buff)) res = RES_WRITEERROR;
    7c5a:	it	eq
    7c5c:	moveq	r6, #7
}
DRESULT SPI_disk_write(const BYTE *buff, DWORD sector, UINT count)
{
    DRESULT res = RES_OK;
    if(!sd_writeStart(sector,count)) res = RES_WRITEERROR;
    for(int ii=0; ii<count;ii++)
    7c5e:	cmp	r7, r5
    7c60:	bne.n	7c4c <SPI_disk_write+0x1c>
    {
      if(!sd_writeData2(buff)) res = RES_WRITEERROR;
      sector++;
      buff += 512;    
    }
    if(!sd_writeStop()) res = RES_WRITEERROR;
    7c62:	bl	7b98 <sd_writeStop>
    7c66:	cmp	r0, #0

    return res;
}
    7c68:	ite	ne
    7c6a:	movne	r0, r6
    7c6c:	moveq	r0, #7
    7c6e:	pop	{r3, r4, r5, r6, r7, pc}

00007c70 <spi_receive>:
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7c70:	ldr	r3, [pc, #20]	; (7c88 <spi_receive+0x18>)
    7c72:	movs	r2, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7c74:	mov	r1, r3
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7c76:	str	r2, [r3, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7c78:	ldr	r3, [r1, #92]	; 0x5c
    7c7a:	ldr	r2, [pc, #12]	; (7c88 <spi_receive+0x18>)
		if (fifo > 0) return spi->RDR; 
    7c7c:	tst.w	r3, #2031616	; 0x1f0000
    7c80:	beq.n	7c78 <spi_receive+0x8>
    7c82:	ldr	r0, [r2, #116]	; 0x74
		return 0;
	}

	uint8_t spi_receive(void)
	{ return spi_transfer8(0xff) ;
	}
    7c84:	uxtb	r0, r0
    7c86:	bx	lr
    7c88:	.word	0x403a0000

00007c8c <sd_connect>:
 * can be determined by calling errorCode() and errorData().
 */
 uint8_t sdCommandAndResponse(uint8_t cmd, uint32_t param);
 
int sd_connect()
{ int kk;
    7c8c:	push	{r3, r4, r5, r6, r7, lr}
    spi_send(0XFF); 
  }
  else
  {
//    spi_init(m_sckDivisor); 
    digitalWrite(m_chipSelectPin, LOW);
    7c8e:	ldr	r3, [pc, #312]	; (7dc8 <sd_connect+0x13c>)
    7c90:	movs	r1, #0
    7c92:	ldr	r5, [pc, #312]	; (7dcc <sd_connect+0x140>)
    7c94:	ldrb	r0, [r3, #0]
    7c96:	ldr	r6, [r5, #0]
    7c98:	bl	9820 <digitalWrite>
  uint32_t arg;
  // uint8_t ret;
  // command to go idle in SPI mode
  sd_chipSelect(LOW);

  while (sd_cardCommand(CMD0, 0) != R1_IDLE_STATE) 
    7c9c:	movs	r1, #0
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7c9e:	ldr	r4, [pc, #304]	; (7dd0 <sd_connect+0x144>)
  uint32_t arg;
  // uint8_t ret;
  // command to go idle in SPI mode
  sd_chipSelect(LOW);

  while (sd_cardCommand(CMD0, 0) != R1_IDLE_STATE) 
    7ca0:	mov	r0, r1
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7ca2:	mov	r7, r4
  uint32_t arg;
  // uint8_t ret;
  // command to go idle in SPI mode
  sd_chipSelect(LOW);

  while (sd_cardCommand(CMD0, 0) != R1_IDLE_STATE) 
    7ca4:	bl	778c <sd_cardCommand>
    7ca8:	cmp	r0, #1
    7caa:	beq.n	7cd4 <sd_connect+0x48>
    7cac:	ldr	r2, [r5, #0]
  {
    t1=(uint16_t)millis();
    if ((t1- t0) > SD_INIT_TIMEOUT) {
    7cae:	uxth	r3, r6
    7cb0:	uxth	r2, r2
    7cb2:	subs	r3, r2, r3
    7cb4:	cmp.w	r3, #2000	; 0x7d0
    7cb8:	bgt.n	7cee <sd_connect+0x62>
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7cba:	movs	r3, #255	; 0xff
    7cbc:	str	r3, [r4, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7cbe:	ldr	r3, [r4, #92]	; 0x5c
		if (fifo > 0) return spi->RDR; 
    7cc0:	tst.w	r3, #2031616	; 0x1f0000
    7cc4:	beq.n	7cbe <sd_connect+0x32>
  uint32_t arg;
  // uint8_t ret;
  // command to go idle in SPI mode
  sd_chipSelect(LOW);

  while (sd_cardCommand(CMD0, 0) != R1_IDLE_STATE) 
    7cc6:	movs	r1, #0
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
		if (fifo > 0) return spi->RDR; 
    7cc8:	ldr	r3, [r7, #116]	; 0x74
  uint32_t arg;
  // uint8_t ret;
  // command to go idle in SPI mode
  sd_chipSelect(LOW);

  while (sd_cardCommand(CMD0, 0) != R1_IDLE_STATE) 
    7cca:	mov	r0, r1
    7ccc:	bl	778c <sd_cardCommand>
    7cd0:	cmp	r0, #1
    7cd2:	bne.n	7cac <sd_connect+0x20>
    }
   spi_send(0XFF);
  }
  
#ifdef USE_SD_CRC
  if (sd_cardCommand(CMD59, 1) != R1_IDLE_STATE) {
    7cd4:	mov	r1, r0
    7cd6:	movs	r0, #59	; 0x3b
    7cd8:	bl	778c <sd_cardCommand>
    7cdc:	cmp	r0, #1
    7cde:	beq.n	7cfc <sd_connect+0x70>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7ce0:	ldr	r3, [pc, #240]	; (7dd4 <sd_connect+0x148>)
    7ce2:	movs	r2, #26
    7ce4:	strh	r2, [r3, #0]
    7ce6:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;

  fail:
  sd_chipSelect(HIGH);
  return FALSE;
    7cea:	movs	r0, #0
}
    7cec:	pop	{r3, r4, r5, r6, r7, pc}
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7cee:	ldr	r3, [pc, #228]	; (7dd4 <sd_connect+0x148>)
    7cf0:	movs	r2, #1
    7cf2:	strh	r2, [r3, #0]
    7cf4:	bl	7708 <sd_chipSelect.part.0>
  sd_chipSelect(HIGH);
  return TRUE;

  fail:
  sd_chipSelect(HIGH);
  return FALSE;
    7cf8:	movs	r0, #0
}
    7cfa:	pop	{r3, r4, r5, r6, r7, pc}
    7cfc:	ldr	r7, [r5, #0]
    7cfe:	ldr	r6, [pc, #216]	; (7dd8 <sd_connect+0x14c>)

  // check SD version
  t0  = (uint16_t)millis();
  while (1) 
  {
    if (sd_cardCommand(CMD8, 0x1AA) == (R1_ILLEGAL_COMMAND | R1_IDLE_STATE)) 
    7d00:	mov.w	r1, #426	; 0x1aa
    7d04:	movs	r0, #8
    7d06:	bl	778c <sd_cardCommand>
    7d0a:	cmp	r0, #5
    7d0c:	beq.n	7d78 <sd_connect+0xec>
    7d0e:	movs	r4, #4
  {
      sd_setType(SD_CARD_TYPE_SD1);
      break;
    }
    for (kk = 0; kk < 4; kk++) m_sd_status = spi_receive(0);
    7d10:	movs	r0, #0
    7d12:	bl	7c70 <spi_receive>
    7d16:	subs	r4, #1
    7d18:	uxth	r0, r0
    7d1a:	strh	r0, [r6, #0]
    7d1c:	bne.n	7d10 <sd_connect+0x84>
    if (m_sd_status == 0XAA) 
    7d1e:	cmp	r0, #170	; 0xaa
    7d20:	beq.n	7d38 <sd_connect+0xac>
    7d22:	ldr	r2, [r5, #0]
  {
      sd_setType(SD_CARD_TYPE_SD2);
      break;
    }
    if (((uint16_t)millis() - t0) > SD_INIT_TIMEOUT) 
    7d24:	uxth	r3, r7
    7d26:	uxth	r2, r2
    7d28:	subs	r3, r2, r3
    7d2a:	cmp.w	r3, #2000	; 0x7d0
    7d2e:	ble.n	7d00 <sd_connect+0x74>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7d30:	ldr	r3, [pc, #160]	; (7dd4 <sd_connect+0x148>)
    7d32:	movs	r2, #2
    7d34:	strh	r2, [r3, #0]
    7d36:	b.n	7ce6 <sd_connect+0x5a>
uint16_t sd_getError(void) {return m_sd_errorCode;}

void sd_setType(uint16_t type) {m_sd_type=type;}
    7d38:	ldr	r7, [pc, #160]	; (7ddc <sd_connect+0x150>)
    7d3a:	movs	r3, #2
      goto fail;
    }
  }
  
  // initialize card and send host supports SDHC if SD2
  arg = (sd_getType() == SD_CARD_TYPE_SD2) ? 0X40000000 : 0;
    7d3c:	mov.w	r4, #1073741824	; 0x40000000

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
uint16_t sd_getError(void) {return m_sd_errorCode;}

void sd_setType(uint16_t type) {m_sd_type=type;}
    7d40:	strh	r3, [r7, #0]
    7d42:	ldr	r6, [r5, #0]
  
  // initialize card and send host supports SDHC if SD2
  arg = (sd_getType() == SD_CARD_TYPE_SD2) ? 0X40000000 : 0;

  t0  = (uint16_t)millis();
  while (sd_cardAcmd(ACMD41, arg) != R1_READY_STATE) 
    7d44:	b.n	7d52 <sd_connect+0xc6>
    7d46:	ldr	r3, [r5, #0]
  {
    // check for timeout
  t1  = (uint16_t)millis();
    if ((t1 - t0) > SD_INIT_TIMEOUT) 
    7d48:	uxth	r3, r3
    7d4a:	subs	r3, r3, r2
    7d4c:	cmp.w	r3, #2000	; 0x7d0
    7d50:	bgt.n	7d82 <sd_connect+0xf6>
  uint16_t sd_readCID(cid_t* cid) {  return sd_readRegister(CMD10, cid); }
  uint16_t sd_readCSD(csd_t* csd) {  return sd_readRegister(CMD9, csd); }

 
uint8_t sd_cardAcmd(uint8_t cmd, uint32_t arg) 
{   sd_cardCommand(CMD55, 0);
    7d52:	movs	r1, #0
    7d54:	movs	r0, #55	; 0x37
    7d56:	bl	778c <sd_cardCommand>
    return sd_cardCommand(cmd, arg);
    7d5a:	mov	r1, r4
    7d5c:	movs	r0, #41	; 0x29
    7d5e:	bl	778c <sd_cardCommand>
  t0  = (uint16_t)millis();
  while (sd_cardAcmd(ACMD41, arg) != R1_READY_STATE) 
  {
    // check for timeout
  t1  = (uint16_t)millis();
    if ((t1 - t0) > SD_INIT_TIMEOUT) 
    7d62:	uxth	r2, r6
  
  // initialize card and send host supports SDHC if SD2
  arg = (sd_getType() == SD_CARD_TYPE_SD2) ? 0X40000000 : 0;

  t0  = (uint16_t)millis();
  while (sd_cardAcmd(ACMD41, arg) != R1_READY_STATE) 
    7d64:	cmp	r0, #0
    7d66:	bne.n	7d46 <sd_connect+0xba>
  { sd_setError(SD_CARD_ERROR_ACMD41);
      goto fail;
    }
  }
  // if SD2 read OCR register to check for SDHC card
  if (sd_getType() == SD_CARD_TYPE_SD2) {
    7d68:	ldrh	r3, [r7, #0]
// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
uint16_t sd_getError(void) {return m_sd_errorCode;}

void sd_setType(uint16_t type) {m_sd_type=type;}
uint16_t sd_getType(void) {return m_sd_type;}
    7d6a:	ldr	r4, [pc, #112]	; (7ddc <sd_connect+0x150>)
  { sd_setError(SD_CARD_ERROR_ACMD41);
      goto fail;
    }
  }
  // if SD2 read OCR register to check for SDHC card
  if (sd_getType() == SD_CARD_TYPE_SD2) {
    7d6c:	cmp	r3, #2
    7d6e:	beq.n	7d8a <sd_connect+0xfe>
    7d70:	bl	7708 <sd_chipSelect.part.0>
    // Discard rest of ocr - contains allowed voltage range.
    for (kk = 0; kk < 3; kk++) spi_receive();
  }
  
  sd_chipSelect(HIGH);
  return TRUE;
    7d74:	movs	r0, #1
    7d76:	pop	{r3, r4, r5, r6, r7, pc}

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
uint16_t sd_getError(void) {return m_sd_errorCode;}

void sd_setType(uint16_t type) {m_sd_type=type;}
    7d78:	ldr	r7, [pc, #96]	; (7ddc <sd_connect+0x150>)
    7d7a:	movs	r3, #1
      goto fail;
    }
  }
  
  // initialize card and send host supports SDHC if SD2
  arg = (sd_getType() == SD_CARD_TYPE_SD2) ? 0X40000000 : 0;
    7d7c:	movs	r4, #0

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
uint16_t sd_getError(void) {return m_sd_errorCode;}

void sd_setType(uint16_t type) {m_sd_type=type;}
    7d7e:	strh	r3, [r7, #0]
    7d80:	b.n	7d42 <sd_connect+0xb6>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7d82:	ldr	r3, [pc, #80]	; (7dd4 <sd_connect+0x148>)
    7d84:	movs	r2, #10
    7d86:	strh	r2, [r3, #0]
    7d88:	b.n	7ce6 <sd_connect+0x5a>
      goto fail;
    }
  }
  // if SD2 read OCR register to check for SDHC card
  if (sd_getType() == SD_CARD_TYPE_SD2) {
    if (sd_cardCommand(CMD58, 0)) {
    7d8a:	mov	r1, r0
    7d8c:	movs	r0, #58	; 0x3a
    7d8e:	bl	778c <sd_cardCommand>
    7d92:	cbz	r0, 7d9c <sd_connect+0x110>
  uint16_t m_sckDivisor;
  uint16_t m_sd_status;
  uint16_t m_sd_type;

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
    7d94:	ldr	r3, [pc, #60]	; (7dd4 <sd_connect+0x148>)
    7d96:	movs	r2, #8
    7d98:	strh	r2, [r3, #0]
    7d9a:	b.n	7ce6 <sd_connect+0x5a>
  if (sd_getType() == SD_CARD_TYPE_SD2) {
    if (sd_cardCommand(CMD58, 0)) {
      sd_setError(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spi_receive(0) & 0XC0) == 0XC0) sd_setType(SD_CARD_TYPE_SDHC);
    7d9c:	bl	7c70 <spi_receive>
    7da0:	and.w	r0, r0, #192	; 0xc0
    7da4:	cmp	r0, #192	; 0xc0
    7da6:	bne.n	7dac <sd_connect+0x120>

// some short functions 
void sd_setError(uint8_t error) {m_sd_errorCode=error;}
uint16_t sd_getError(void) {return m_sd_errorCode;}

void sd_setType(uint16_t type) {m_sd_type=type;}
    7da8:	movs	r3, #3
    7daa:	strh	r3, [r4, #0]
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7dac:	ldr	r3, [pc, #32]	; (7dd0 <sd_connect+0x144>)
      goto fail;
    }
  }
  
  // initialize card and send host supports SDHC if SD2
  arg = (sd_getType() == SD_CARD_TYPE_SD2) ? 0X40000000 : 0;
    7dae:	movs	r2, #3
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7db0:	movs	r0, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7db2:	mov	r1, r3
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7db4:	str	r0, [r3, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7db6:	ldr	r4, [r3, #92]	; 0x5c
		if (fifo > 0) return spi->RDR; 
    7db8:	tst.w	r4, #2031616	; 0x1f0000
    7dbc:	beq.n	7db6 <sd_connect+0x12a>
      sd_setError(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spi_receive(0) & 0XC0) == 0XC0) sd_setType(SD_CARD_TYPE_SDHC);
    // Discard rest of ocr - contains allowed voltage range.
    for (kk = 0; kk < 3; kk++) spi_receive();
    7dbe:	subs	r2, #1
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
		if (fifo > 0) return spi->RDR; 
    7dc0:	ldr	r4, [r1, #116]	; 0x74
      sd_setError(SD_CARD_ERROR_CMD58);
      goto fail;
    }
    if ((spi_receive(0) & 0XC0) == 0XC0) sd_setType(SD_CARD_TYPE_SDHC);
    // Discard rest of ocr - contains allowed voltage range.
    for (kk = 0; kk < 3; kk++) spi_receive();
    7dc2:	bne.n	7db4 <sd_connect+0x128>
    7dc4:	b.n	7d70 <sd_connect+0xe4>
    7dc6:	nop
    7dc8:	.word	0x20000b78
    7dcc:	.word	0x2000b144
    7dd0:	.word	0x403a0000
    7dd4:	.word	0x2000b2f2
    7dd8:	.word	0x2000b2f0
    7ddc:	.word	0x2000b2f4

00007de0 <spi_init>:
	void spi_init(void) 
	{ 
	  // CBCMR[LPSPI_CLK_SEL] - PLL2 = 528 MHz 
	  // CBCMR[LPSPI_PODF] - div4 = 132 MHz 

	  CCM_CCGR1 &= ~CCM_CCGR1_LPSPIx(ISPI,CCM_CCGR_ON); 
    7de0:	ldr	r2, [pc, #68]	; (7e28 <spi_init+0x48>)

	  CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_LPSPI_PODF_MASK | CCM_CBCMR_LPSPI_CLK_SEL_MASK)) | 
								 CCM_CBCMR_LPSPI_PODF(6) | CCM_CBCMR_LPSPI_CLK_SEL(2); // pg 714 

	  uint32_t fastio = IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3); 
	  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01 = fastio; 
    7de2:	movs	r0, #217	; 0xd9
    7de4:	ldr	r3, [pc, #68]	; (7e2c <spi_init+0x4c>)
	  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02 = fastio; 
	  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = fastio; 

	  CCM_CCGR1 |= CCM_CCGR1_LPSPIx(ISPI, CCM_CCGR_ON); 
	  
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01 = 3 | 0x10; // SDI  //Pin12
    7de6:	movs	r1, #19
//	static IMXRT_LPSPI_t * spi = (const IMXRT_LPSPI_t *)SPIX[ISPI];

	#define CCM_CCGR1_LPSPIx(m,n)     ((uint32_t)(((n) & 0x03) << (2*m)))
	
	void spi_init(void) 
	{ 
    7de8:	push	{r4, r5, r6, r7}
	  // CBCMR[LPSPI_CLK_SEL] - PLL2 = 528 MHz 
	  // CBCMR[LPSPI_PODF] - div4 = 132 MHz 

	  CCM_CCGR1 &= ~CCM_CCGR1_LPSPIx(ISPI,CCM_CCGR_ON); 
    7dea:	ldr	r6, [r2, #108]	; 0x6c
	  
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01 = 3 | 0x10; // SDI  //Pin12
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02 = 3 | 0x10; // SDO  //Pin11
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 3 | 0x10; // SCK  //Pin13

	  spi->CR = LPSPI_CR_RST; 
    7dec:	movs	r7, #2
	  // CBCMR[LPSPI_PODF] - div4 = 132 MHz 

	  CCM_CCGR1 &= ~CCM_CCGR1_LPSPIx(ISPI,CCM_CCGR_ON); 

	  CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_LPSPI_PODF_MASK | CCM_CBCMR_LPSPI_CLK_SEL_MASK)) | 
								 CCM_CBCMR_LPSPI_PODF(6) | CCM_CBCMR_LPSPI_CLK_SEL(2); // pg 714 
    7dee:	ldr	r5, [pc, #64]	; (7e30 <spi_init+0x50>)
	void spi_init(void) 
	{ 
	  // CBCMR[LPSPI_CLK_SEL] - PLL2 = 528 MHz 
	  // CBCMR[LPSPI_PODF] - div4 = 132 MHz 

	  CCM_CCGR1 &= ~CCM_CCGR1_LPSPIx(ISPI,CCM_CCGR_ON); 
    7df0:	bic.w	r6, r6, #192	; 0xc0

	  CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_LPSPI_PODF_MASK | CCM_CBCMR_LPSPI_CLK_SEL_MASK)) | 
								 CCM_CBCMR_LPSPI_PODF(6) | CCM_CBCMR_LPSPI_CLK_SEL(2); // pg 714 
    7df4:	ldr	r4, [pc, #60]	; (7e34 <spi_init+0x54>)
	void spi_init(void) 
	{ 
	  // CBCMR[LPSPI_CLK_SEL] - PLL2 = 528 MHz 
	  // CBCMR[LPSPI_PODF] - div4 = 132 MHz 

	  CCM_CCGR1 &= ~CCM_CCGR1_LPSPIx(ISPI,CCM_CCGR_ON); 
    7df6:	str	r6, [r2, #108]	; 0x6c

	  CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_LPSPI_PODF_MASK | CCM_CBCMR_LPSPI_CLK_SEL_MASK)) | 
    7df8:	ldr	r6, [r2, #24]
								 CCM_CBCMR_LPSPI_PODF(6) | CCM_CBCMR_LPSPI_CLK_SEL(2); // pg 714 
    7dfa:	ands	r5, r6
	  
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01 = 3 | 0x10; // SDI  //Pin12
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02 = 3 | 0x10; // SDO  //Pin11
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 3 | 0x10; // SCK  //Pin13

	  spi->CR = LPSPI_CR_RST; 
    7dfc:	ldr	r6, [pc, #56]	; (7e38 <spi_init+0x58>)
	  // CBCMR[LPSPI_PODF] - div4 = 132 MHz 

	  CCM_CCGR1 &= ~CCM_CCGR1_LPSPIx(ISPI,CCM_CCGR_ON); 

	  CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_LPSPI_PODF_MASK | CCM_CBCMR_LPSPI_CLK_SEL_MASK)) | 
								 CCM_CBCMR_LPSPI_PODF(6) | CCM_CBCMR_LPSPI_CLK_SEL(2); // pg 714 
    7dfe:	orrs	r4, r5
	  // CBCMR[LPSPI_CLK_SEL] - PLL2 = 528 MHz 
	  // CBCMR[LPSPI_PODF] - div4 = 132 MHz 

	  CCM_CCGR1 &= ~CCM_CCGR1_LPSPIx(ISPI,CCM_CCGR_ON); 

	  CCM_CBCMR = (CCM_CBCMR & ~(CCM_CBCMR_LPSPI_PODF_MASK | CCM_CBCMR_LPSPI_CLK_SEL_MASK)) | 
    7e00:	str	r4, [r2, #24]
								 CCM_CBCMR_LPSPI_PODF(6) | CCM_CBCMR_LPSPI_CLK_SEL(2); // pg 714 

	  uint32_t fastio = IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(3) | IOMUXC_PAD_SPEED(3); 
	  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_01 = fastio; 
    7e02:	str.w	r0, [r3, #816]	; 0x330
	  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_02 = fastio; 
    7e06:	str.w	r0, [r3, #820]	; 0x334
	  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = fastio; 
    7e0a:	str.w	r0, [r3, #824]	; 0x338

	  CCM_CCGR1 |= CCM_CCGR1_LPSPIx(ISPI, CCM_CCGR_ON); 
    7e0e:	ldr	r0, [r2, #108]	; 0x6c
    7e10:	orr.w	r0, r0, #192	; 0xc0
    7e14:	str	r0, [r2, #108]	; 0x6c
	  
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_01 = 3 | 0x10; // SDI  //Pin12
    7e16:	str.w	r1, [r3, #320]	; 0x140
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_02 = 3 | 0x10; // SDO  //Pin11
    7e1a:	str.w	r1, [r3, #324]	; 0x144
	  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 3 | 0x10; // SCK  //Pin13
    7e1e:	str.w	r1, [r3, #328]	; 0x148

	  spi->CR = LPSPI_CR_RST; 
    7e22:	str	r7, [r6, #16]
	} 
    7e24:	pop	{r4, r5, r6, r7}
    7e26:	bx	lr
    7e28:	.word	0x400fc000
    7e2c:	.word	0x401f8000
    7e30:	.word	0xe3ffffcf
    7e34:	.word	0x18000020
    7e38:	.word	0x403a0000

00007e3c <spi_begin>:

	void spi_begin(uint32_t clck, uint8_t bitOrder, uint8_t dataMode)
	{
    7e3c:	push	{r4, r5, r6, r7, lr}
		const uint32_t clk_sel[4] = {664615384,  // PLL3 PFD1
    7e3e:	ldr	r3, [pc, #148]	; (7ed4 <spi_begin+0x98>)

	  spi->CR = LPSPI_CR_RST; 
	} 

	void spi_begin(uint32_t clck, uint8_t bitOrder, uint8_t dataMode)
	{
    7e40:	sub	sp, #20
    7e42:	mov	r6, r0
				   396000000}; // PLL2 PFD2       
		uint32_t cbcmr = CCM_CBCMR;
		uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
		
		uint32_t d, div;    
		if (clck == 0) clck =1;
    7e44:	cmp	r0, #0
	  spi->CR = LPSPI_CR_RST; 
	} 

	void spi_begin(uint32_t clck, uint8_t bitOrder, uint8_t dataMode)
	{
		const uint32_t clk_sel[4] = {664615384,  // PLL3 PFD1
    7e46:	add.w	lr, sp, #16

	  spi->CR = LPSPI_CR_RST; 
	} 

	void spi_begin(uint32_t clck, uint8_t bitOrder, uint8_t dataMode)
	{
    7e4a:	mov	r5, r1
    7e4c:	mov	r4, r2
		const uint32_t clk_sel[4] = {664615384,  // PLL3 PFD1
				   720000000,  // PLL3 PFD0
				   528000000,  // PLL2
				   396000000}; // PLL2 PFD2       
		uint32_t cbcmr = CCM_CBCMR;
    7e4e:	ldr	r7, [pc, #136]	; (7ed8 <spi_begin+0x9c>)
		uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
		
		uint32_t d, div;    
		if (clck == 0) clck =1;
    7e50:	it	eq
    7e52:	moveq	r6, #1
	  spi->CR = LPSPI_CR_RST; 
	} 

	void spi_begin(uint32_t clck, uint8_t bitOrder, uint8_t dataMode)
	{
		const uint32_t clk_sel[4] = {664615384,  // PLL3 PFD1
    7e54:	ldmia	r3, {r0, r1, r2, r3}
    7e56:	stmdb	lr, {r0, r1, r2, r3}
				   720000000,  // PLL3 PFD0
				   528000000,  // PLL2
				   396000000}; // PLL2 PFD2       
		uint32_t cbcmr = CCM_CBCMR;
    7e5a:	ldr	r3, [r7, #24]
		uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
    7e5c:	ubfx	r2, r3, #4, #2
    7e60:	ubfx	r3, r3, #26, #3
    7e64:	add.w	r2, lr, r2, lsl #2
    7e68:	adds	r3, #1
    7e6a:	ldr.w	r2, [r2, #-16]
    7e6e:	udiv	r3, r2, r3
		
		uint32_t d, div;    
		if (clck == 0) clck =1;
		d= clkhz/clck;
    7e72:	udiv	r2, r3, r6
		if (d && clkhz/d > clck) d++;
    7e76:	cbz	r2, 7e8c <spi_begin+0x50>
    7e78:	udiv	r3, r3, r2
    7e7c:	cmp	r6, r3
    7e7e:	it	cc
    7e80:	addcc	r2, #1
		if (d > 257) d= 257;  // max div
    7e82:	cmp.w	r2, #258	; 0x102
    7e86:	bcc.n	7ec0 <spi_begin+0x84>
    7e88:	movw	r2, #32767	; 0x7fff
		  div = d-2;
		} else {
		  div =0;
		}
		uint32_t ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2);
		uint32_t tcr = LPSPI_TCR_FRAMESZ(7);    // TCR has polarity and bit order too
    7e8c:	cmp	r5, #0
    7e8e:	ldr	r3, [pc, #76]	; (7edc <spi_begin+0xa0>)

		// PCS to SCK Delay Prescaler into the After SCK Delay Prescaler  
		if (dataMode & 0x04) tcr |= LPSPI_TCR_CPHA; 


	  spi->CR = 0; 
    7e90:	mov.w	r5, #0
		  div = d-2;
		} else {
		  div =0;
		}
		uint32_t ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2);
		uint32_t tcr = LPSPI_TCR_FRAMESZ(7);    // TCR has polarity and bit order too
    7e94:	it	ne
    7e96:	movne	r3, #7

		// handle LSB setup 
		if (bitOrder == LSBFIRST) tcr |= LPSPI_TCR_LSBF;

		// Handle Data Mode
		if (dataMode & 0x08) tcr |= LPSPI_TCR_CPOL;
    7e98:	lsls	r0, r4, #28
	  spi->CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE; 
	//  spi->CCR = LPSPI_CCR_SCKDIV(4); 
	//  spi->TCR = LPSPI_TCR_FRAMESZ(7); 
	  spi->CCR = ccr; 
	  spi->TCR = tcr; 
	  spi->CR = LPSPI_CR_MEN; 
    7e9a:	mov.w	r0, #1

		// handle LSB setup 
		if (bitOrder == LSBFIRST) tcr |= LPSPI_TCR_LSBF;

		// Handle Data Mode
		if (dataMode & 0x08) tcr |= LPSPI_TCR_CPOL;
    7e9e:	it	mi
    7ea0:	orrmi.w	r3, r3, #2147483648	; 0x80000000

		// PCS to SCK Delay Prescaler into the After SCK Delay Prescaler  
		if (dataMode & 0x04) tcr |= LPSPI_TCR_CPHA; 
    7ea4:	lsls	r1, r4, #29


	  spi->CR = 0; 
    7ea6:	ldr	r1, [pc, #56]	; (7ee0 <spi_begin+0xa4>)
	  spi->CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE; 
    7ea8:	mov.w	r4, #3

		// Handle Data Mode
		if (dataMode & 0x08) tcr |= LPSPI_TCR_CPOL;

		// PCS to SCK Delay Prescaler into the After SCK Delay Prescaler  
		if (dataMode & 0x04) tcr |= LPSPI_TCR_CPHA; 
    7eac:	it	mi
    7eae:	orrmi.w	r3, r3, #1073741824	; 0x40000000


	  spi->CR = 0; 
    7eb2:	str	r5, [r1, #16]
	  spi->CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE; 
    7eb4:	str	r4, [r1, #36]	; 0x24
	//  spi->CCR = LPSPI_CCR_SCKDIV(4); 
	//  spi->TCR = LPSPI_TCR_FRAMESZ(7); 
	  spi->CCR = ccr; 
    7eb6:	str	r2, [r1, #64]	; 0x40
	  spi->TCR = tcr; 
    7eb8:	str	r3, [r1, #96]	; 0x60
	  spi->CR = LPSPI_CR_MEN; 
    7eba:	str	r0, [r1, #16]
	}
    7ebc:	add	sp, #20
    7ebe:	pop	{r4, r5, r6, r7, pc}
		uint32_t d, div;    
		if (clck == 0) clck =1;
		d= clkhz/clck;
		if (d && clkhz/d > clck) d++;
		if (d > 257) d= 257;  // max div
		if (d > 2) {
    7ec0:	cmp	r2, #2
    7ec2:	it	ls
    7ec4:	movls	r2, #0
    7ec6:	bls.n	7e8c <spi_begin+0x50>
    7ec8:	subs	r2, #2
    7eca:	lsrs	r3, r2, #1
    7ecc:	orr.w	r2, r2, r3, lsl #8
    7ed0:	b.n	7e8c <spi_begin+0x50>
    7ed2:	nop
    7ed4:	.word	0x200002c8
    7ed8:	.word	0x400fc000
    7edc:	.word	0x00800007
    7ee0:	.word	0x403a0000

00007ee4 <sd_init>:
  #endif  // USE_SD_CCITT
#endif  // USE_SD_SRC

//***************************************************************************/
uint16_t sd_init(uint16_t cs_pin)
{  int ii;
    7ee4:	push	{r3, r4, r5, lr}
  pinMode(cs_pin, OUTPUT);
    7ee6:	movs	r1, #1
  #endif  // USE_SD_CCITT
#endif  // USE_SD_SRC

//***************************************************************************/
uint16_t sd_init(uint16_t cs_pin)
{  int ii;
    7ee8:	mov	r5, r0
  pinMode(cs_pin, OUTPUT);
    7eea:	uxtb	r0, r0
    7eec:	movs	r4, #10
    7eee:	bl	982c <pinMode>
	void spi_configPorts(int iconf) 
	{ return;
	}

	uint32_t spi_setup(uint32_t clk)
	{	spi_init() ;
    7ef2:	bl	7de0 <spi_init>
		spi_begin(clk, MSBFIRST, SPI_MODE0);
    7ef6:	movs	r2, #0
    7ef8:	movs	r1, #1
    7efa:	movs	r0, #100	; 0x64
    7efc:	bl	7e3c <spi_begin>
uint16_t sd_getError(void) {return m_sd_errorCode;}

void sd_setType(uint16_t type) {m_sd_type=type;}
uint16_t sd_getType(void) {return m_sd_type;}

void sd_setChipSelect(uint16_t pin) {m_chipSelectPin=pin;}
    7f00:	ldr	r3, [pc, #56]	; (7f3c <sd_init+0x58>)
    7f02:	strh	r5, [r3, #0]
    7f04:	bl	7708 <sd_chipSelect.part.0>
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7f08:	ldr	r2, [pc, #52]	; (7f40 <sd_init+0x5c>)
    7f0a:	movs	r0, #255	; 0xff
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7f0c:	mov	r1, r2
	}

	uint8_t spi_transfer8(uint8_t data) 
	{ 
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
    7f0e:	str	r0, [r2, #100]	; 0x64
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
    7f10:	ldr	r3, [r2, #92]	; 0x5c
		if (fifo > 0) return spi->RDR; 
    7f12:	tst.w	r3, #2031616	; 0x1f0000
    7f16:	beq.n	7f10 <sd_init+0x2c>
  spi_setup(100);

  sd_setChipSelect(cs_pin);
  sd_chipSelect(HIGH);
  // must supply min of 74 clock cycles with CS high.
  for (ii = 0; ii < 10; ii++) spi_send(0XFF);
    7f18:	subs	r4, #1
	  // TODO: check for space in fifo? 
	  spi->TDR = data; 
	  while (1) 
	  { 
		uint32_t fifo = (spi->FSR >> 16) & 0x1F; 
		if (fifo > 0) return spi->RDR; 
    7f1a:	ldr	r3, [r1, #116]	; 0x74
  spi_setup(100);

  sd_setChipSelect(cs_pin);
  sd_chipSelect(HIGH);
  // must supply min of 74 clock cycles with CS high.
  for (ii = 0; ii < 10; ii++) spi_send(0XFF);
    7f1c:	bne.n	7f0e <sd_init+0x2a>

  if(!sd_connect())
    7f1e:	bl	7c8c <sd_connect>
    7f22:	cbnz	r0, 7f28 <sd_init+0x44>
  {  // uint32_t errorcode=sd_getError();
//     printDebug("connect:", errorcode);
    return false;
    7f24:	mov	r0, r4
//    printDebug("F_BUS:",F_BUS);
//    printDebug("divide:",divide);
  spi_setup(24*MEG);

  return true;
}
    7f26:	pop	{r3, r4, r5, pc}
	void spi_configPorts(int iconf) 
	{ return;
	}

	uint32_t spi_setup(uint32_t clk)
	{	spi_init() ;
    7f28:	bl	7de0 <spi_init>
		spi_begin(clk, MSBFIRST, SPI_MODE0);
    7f2c:	mov	r2, r4
    7f2e:	movs	r1, #1
    7f30:	ldr	r0, [pc, #16]	; (7f44 <sd_init+0x60>)
    7f32:	bl	7e3c <spi_begin>
    7f36:	movs	r0, #1
    7f38:	pop	{r3, r4, r5, pc}
    7f3a:	nop
    7f3c:	.word	0x20000b78
    7f40:	.word	0x403a0000
    7f44:	.word	0x016e3600

00007f48 <SPI_disk_initialize>:
DSTATUS SPI_disk_status()
{
    return 0;
}
DSTATUS SPI_disk_initialize(int cs)
{
    7f48:	push	{r3, lr}
    if(!sd_init(cs)) return STA_NOINIT;
    7f4a:	uxth	r0, r0
    7f4c:	bl	7ee4 <sd_init>
    
    return 0;
}
    7f50:	clz	r0, r0
    7f54:	lsrs	r0, r0, #5
    7f56:	pop	{r3, pc}

00007f58 <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    7f58:	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    7f5a:	orr.w	r3, r1, r0
	ands	r3, r3, #3
    7f5e:	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    7f62:	bne.n	8040 <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    7f64:	subs	r2, #64	; 0x40
	blo	.Lmid_block
    7f66:	bcc.n	7fec <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    7f68:	ldr.w	r3, [r1], #4
    7f6c:	str.w	r3, [r0], #4
    7f70:	ldr.w	r3, [r1], #4
    7f74:	str.w	r3, [r0], #4
    7f78:	ldr.w	r3, [r1], #4
    7f7c:	str.w	r3, [r0], #4
    7f80:	ldr.w	r3, [r1], #4
    7f84:	str.w	r3, [r0], #4
    7f88:	ldr.w	r3, [r1], #4
    7f8c:	str.w	r3, [r0], #4
    7f90:	ldr.w	r3, [r1], #4
    7f94:	str.w	r3, [r0], #4
    7f98:	ldr.w	r3, [r1], #4
    7f9c:	str.w	r3, [r0], #4
    7fa0:	ldr.w	r3, [r1], #4
    7fa4:	str.w	r3, [r0], #4
    7fa8:	ldr.w	r3, [r1], #4
    7fac:	str.w	r3, [r0], #4
    7fb0:	ldr.w	r3, [r1], #4
    7fb4:	str.w	r3, [r0], #4
    7fb8:	ldr.w	r3, [r1], #4
    7fbc:	str.w	r3, [r0], #4
    7fc0:	ldr.w	r3, [r1], #4
    7fc4:	str.w	r3, [r0], #4
    7fc8:	ldr.w	r3, [r1], #4
    7fcc:	str.w	r3, [r0], #4
    7fd0:	ldr.w	r3, [r1], #4
    7fd4:	str.w	r3, [r0], #4
    7fd8:	ldr.w	r3, [r1], #4
    7fdc:	str.w	r3, [r0], #4
    7fe0:	ldr.w	r3, [r1], #4
    7fe4:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    7fe8:	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    7fea:	bcs.n	7f68 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    7fec:	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    7fee:	bcc.n	8014 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    7ff0:	ldr.w	r3, [r1], #4
    7ff4:	str.w	r3, [r0], #4
    7ff8:	ldr.w	r3, [r1], #4
    7ffc:	str.w	r3, [r0], #4
    8000:	ldr.w	r3, [r1], #4
    8004:	str.w	r3, [r0], #4
    8008:	ldr.w	r3, [r1], #4
    800c:	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    8010:	subs	r2, #16
	bhs	.Lmid_block_loop
    8012:	bcs.n	7ff0 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    8014:	adds	r2, #12
	blo	.Lcopy_less_than_4
    8016:	bcc.n	8024 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    8018:	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    801c:	str.w	r3, [r0], #4
	subs	r2, #4
    8020:	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    8022:	bcs.n	8018 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    8024:	adds	r2, #4
	beq	.Ldone
    8026:	beq.n	803a <memcpy+0xe2>

	lsls	r2, r2, #31
    8028:	lsls	r2, r2, #31
	itt ne
    802a:	itt	ne
	ldrbne  r3, [r1], #1
    802c:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    8030:	strbne.w	r3, [r0], #1

	bcc	.Ldone
    8034:	bcc.n	803a <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    8036:	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    8038:	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    803a:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    803c:	bx	lr
    803e:	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    8040:	cmp	r2, #8
	blo	.Lbyte_copy
    8042:	bcc.n	806c <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    8044:	lsls	r3, r1, #30
	beq	.Ldst_aligned
    8046:	beq.n	7f64 <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    8048:	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    804c:	beq.n	7f64 <memcpy+0xc>

	rsb	r3, #4
    804e:	rsb	r3, r3, #4
	subs	r2, r3
    8052:	subs	r2, r2, r3

	lsls    r3, r3, #31
    8054:	lsls	r3, r3, #31
	itt ne
    8056:	itt	ne
	ldrbne  r3, [r1], #1
    8058:	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    805c:	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    8060:	bcc.n	7f64 <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    8062:	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    8066:	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    806a:	b.n	7f64 <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    806c:	subs	r2, #4
	blo	.Lcopy_less_than_4
    806e:	bcc.n	8024 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    8070:	subs	r2, #1
	ldrb    r3, [r1], #1
    8072:	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    8076:	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    807a:	bcs.n	8070 <memcpy+0x118>

	ldrb	r3, [r1]
    807c:	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    807e:	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    8080:	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    8082:	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    8084:	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    8086:	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    8088:	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    808a:	bx	lr

0000808c <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    808c:	push	{r3, r4, r5, r6, r7, lr}
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    808e:	ldr	r1, [pc, #80]	; (80e0 <rx_queue_transfer+0x54>)
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    8090:	mov.w	r7, #131072	; 0x20000
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    8094:	ldr	r5, [pc, #76]	; (80e4 <rx_queue_transfer+0x58>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    8096:	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    8098:	add.w	r4, r1, r0, lsl #9
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    809c:	ldr	r6, [pc, #72]	; (80e8 <rx_queue_transfer+0x5c>)
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    809e:	ldr	r2, [pc, #76]	; (80ec <rx_queue_transfer+0x60>)
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    80a0:	add.w	r5, r5, r0, lsl #5
    80a4:	mov	r1, r4
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	NVIC_DISABLE_IRQ(IRQ_USB1);
    80a6:	str	r7, [r2, #0]
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    80a8:	mov	r0, r5
    80aa:	ldrh	r2, [r6, #0]
    80ac:	bl	9050 <usb_prepare_transfer>
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
    80b0:	ldrh	r1, [r6, #0]
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    80b2:	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    80b6:	add	r1, r4
	asm volatile("": : :"memory");
	asm("dsb");
    80b8:	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    80bc:	ldr	r2, [pc, #48]	; (80f0 <rx_queue_transfer+0x64>)
    80be:	str	r3, [r2, #0]
		location += 32;
    80c0:	adds	r3, #32
	} while (location < end_addr);
    80c2:	cmp	r1, r3
    80c4:	bhi.n	80be <rx_queue_transfer+0x32>
	asm("dsb");
    80c6:	dsb	sy
	asm("isb");
    80ca:	isb	sy
	arm_dcache_delete(buffer, rx_packet_size);
	usb_receive(CDC_RX_ENDPOINT, rx_transfer + i);
    80ce:	movs	r0, #3
    80d0:	mov	r1, r5
    80d2:	bl	90a8 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    80d6:	ldr	r3, [pc, #28]	; (80f4 <rx_queue_transfer+0x68>)
    80d8:	mov.w	r2, #131072	; 0x20000
    80dc:	str	r2, [r3, #0]
    80de:	pop	{r3, r4, r5, r6, r7, pc}
    80e0:	.word	0x20200000
    80e4:	.word	0x2000af40
    80e8:	.word	0x2000b04e
    80ec:	.word	0xe000e18c
    80f0:	.word	0xe000ef5c
    80f4:	.word	0xe000e10c

000080f8 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    80f8:	ldr	r2, [pc, #144]	; (818c <rx_event+0x94>)
    80fa:	ldr	r3, [r0, #4]
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
    80fc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    8100:	ubfx	r3, r3, #16, #15
    8104:	ldrh	r4, [r2, #0]
	int i = t->callback_param;
    8106:	ldr	r5, [r0, #28]
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    8108:	subs	r4, r4, r3
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
    810a:	cmp	r4, #0
    810c:	ble.n	8180 <rx_event+0x88>
		// received a packet with data
		uint32_t head = rx_head;
    810e:	ldr	r1, [pc, #128]	; (8190 <rx_event+0x98>)
		if (head != rx_tail) {
    8110:	ldr	r2, [pc, #128]	; (8194 <rx_event+0x9c>)
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		// received a packet with data
		uint32_t head = rx_head;
    8112:	ldrb	r3, [r1, #0]
		if (head != rx_tail) {
    8114:	ldrb	r2, [r2, #0]
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		// received a packet with data
		uint32_t head = rx_head;
    8116:	uxtb	r3, r3
		if (head != rx_tail) {
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
    8118:	ldr	r0, [pc, #124]	; (8198 <rx_event+0xa0>)
			uint32_t count = rx_count[ii];
    811a:	ldr	r6, [pc, #128]	; (819c <rx_event+0xa4>)
	int i = t->callback_param;
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
		// received a packet with data
		uint32_t head = rx_head;
		if (head != rx_tail) {
    811c:	cmp	r3, r2
    811e:	beq.n	8130 <rx_event+0x38>
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
    8120:	ldrb.w	r8, [r0, r3]
			uint32_t count = rx_count[ii];
    8124:	ldrh.w	r7, [r6, r8, lsl #1]
			if (len <= CDC_RX_SIZE_480 - count) {
    8128:	rsb	r2, r7, #512	; 0x200
    812c:	cmp	r4, r2
    812e:	bls.n	8156 <rx_event+0x5e>
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    8130:	adds	r3, #1
				return;
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
    8132:	movs	r2, #0
    8134:	ldr	r7, [pc, #104]	; (81a0 <rx_event+0xa8>)
		if (++head > RX_NUM) head = 0;
    8136:	cmp	r3, #8
				// TODO: trigger serialEvent
				return;
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
    8138:	strh.w	r4, [r6, r5, lsl #1]
		rx_index[i] = 0;
    813c:	strh.w	r2, [r7, r5, lsl #1]
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
		rx_head = head;
		rx_available += len;
    8140:	ldr	r6, [pc, #96]	; (81a4 <rx_event+0xac>)
    8142:	ite	ls
    8144:	uxtbls	r2, r3
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
    8146:	movhi	r3, r2
		rx_list[head] = i;
		rx_head = head;
    8148:	strb	r2, [r1, #0]
		rx_available += len;
    814a:	ldr	r2, [r6, #0]
		}
		// add this packet to rx_list
		rx_count[i] = len;
		rx_index[i] = 0;
		if (++head > RX_NUM) head = 0;
		rx_list[head] = i;
    814c:	strb	r5, [r0, r3]
		rx_head = head;
		rx_available += len;
    814e:	add	r4, r2
    8150:	str	r4, [r6, #0]
    8152:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
			if (len <= CDC_RX_SIZE_480 - count) {
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    8156:	ldr	r3, [pc, #80]	; (81a8 <rx_event+0xb0>)
    8158:	add.w	r0, r7, r8, lsl #9
    815c:	mov	r2, r4
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
    815e:	add	r7, r4
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
			uint32_t count = rx_count[ii];
			if (len <= CDC_RX_SIZE_480 - count) {
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    8160:	add.w	r1, r3, r5, lsl #9
    8164:	add	r0, r3
    8166:	bl	7f58 <memcpy>
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
				rx_available += len;
    816a:	ldr	r2, [pc, #56]	; (81a4 <rx_event+0xac>)
				rx_queue_transfer(i);
    816c:	mov	r0, r5
			uint32_t count = rx_count[ii];
			if (len <= CDC_RX_SIZE_480 - count) {
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
    816e:	strh.w	r7, [r6, r8, lsl #1]
				rx_available += len;
    8172:	ldr	r3, [r2, #0]
    8174:	add	r4, r3
    8176:	str	r4, [r2, #0]
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
	}
}
    8178:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
				rx_available += len;
				rx_queue_transfer(i);
    817c:	b.w	808c <rx_queue_transfer>
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
    8180:	mov	r0, r5
	}
}
    8182:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		rx_head = head;
		rx_available += len;
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
    8186:	b.w	808c <rx_queue_transfer>
    818a:	nop
    818c:	.word	0x2000b04e
    8190:	.word	0x2000b064
    8194:	.word	0x2000b040
    8198:	.word	0x2000b044
    819c:	.word	0x2000b050
    81a0:	.word	0x2000af24
    81a4:	.word	0x2000b060
    81a8:	.word	0x20200000

000081ac <usb_serial_flush_callback>:
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
	if (tx_noautoflush) return;
    81ac:	ldr	r3, [pc, #120]	; (8228 <usb_serial_flush_callback+0x7c>)
    81ae:	ldrb	r2, [r3, #0]
    81b0:	cbnz	r2, 81ca <usb_serial_flush_callback+0x1e>
    81b2:	and.w	r3, r2, #255	; 0xff
	if (!usb_configuration) return;
    81b6:	ldr	r2, [pc, #116]	; (822c <usb_serial_flush_callback+0x80>)
    81b8:	ldrb	r2, [r2, #0]
    81ba:	cbz	r2, 81ca <usb_serial_flush_callback+0x1e>
	tx_available = 0;
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
    81bc:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
    81c0:	ldr	r5, [pc, #108]	; (8230 <usb_serial_flush_callback+0x84>)
    81c2:	ldrh	r2, [r5, #0]
    81c4:	cbnz	r2, 81cc <usb_serial_flush_callback+0x20>
    81c6:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    81ca:	bx	lr
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    81cc:	ldr	r6, [pc, #100]	; (8234 <usb_serial_flush_callback+0x88>)
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
    81ce:	rsb	r8, r2, #2048	; 0x800
{
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    81d2:	ldr	r7, [pc, #100]	; (8238 <usb_serial_flush_callback+0x8c>)
    81d4:	ldrb	r1, [r6, #0]
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    81d6:	mov	r2, r8
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    81d8:	ldr	r4, [pc, #96]	; (823c <usb_serial_flush_callback+0x90>)
{
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    81da:	add.w	r7, r7, r1, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    81de:	add.w	r4, r4, r1, lsl #11
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    81e2:	mov	r0, r7
    81e4:	mov	r1, r4
    81e6:	bl	9050 <usb_prepare_transfer>
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
    81ea:	add.w	r2, r8, r4
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    81ee:	bic.w	r1, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    81f2:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    81f6:	ldr	r3, [pc, #72]	; (8240 <usb_serial_flush_callback+0x94>)
    81f8:	str	r1, [r3, #0]
		location += 32;
    81fa:	adds	r1, #32
	} while (location < end_addr);
    81fc:	cmp	r2, r1
    81fe:	bhi.n	81f8 <usb_serial_flush_callback+0x4c>
	asm("dsb");
    8200:	dsb	sy
	asm("isb");
    8204:	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    8208:	movs	r0, #3
    820a:	mov	r1, r7
    820c:	bl	9080 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    8210:	ldrb	r3, [r6, #0]
    8212:	ldr	r2, [pc, #32]	; (8234 <usb_serial_flush_callback+0x88>)
    8214:	adds	r3, #1
    8216:	uxtb	r3, r3
    8218:	cmp	r3, #3
    821a:	it	hi
    821c:	movhi	r3, #0
    821e:	strb	r3, [r2, #0]
	tx_available = 0;
    8220:	movs	r3, #0
    8222:	strh	r3, [r5, #0]
    8224:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8228:	.word	0x2000af36
    822c:	.word	0x2000b138
    8230:	.word	0x2000b066
    8234:	.word	0x2000af37
    8238:	.word	0x2000b080
    823c:	.word	0x20201000
    8240:	.word	0xe000ef70

00008244 <usb_serial_write.part.1>:
{
	USB1_GPTIMER0CTRL = 0;
}


int usb_serial_write(const void *buffer, uint32_t size)
    8244:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8248:	sub	sp, #20
    824a:	str	r0, [sp, #8]
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    824c:	str	r1, [sp, #4]
    824e:	cmp	r1, #0
    8250:	beq.w	8398 <usb_serial_write.part.1+0x154>
    8254:	movs	r3, #0
    8256:	ldr.w	r8, [pc, #348]	; 83b4 <usb_serial_write.part.1+0x170>
    825a:	ldr.w	r9, [pc, #332]	; 83a8 <usb_serial_write.part.1+0x164>
    825e:	str	r3, [sp, #0]
				tx_available = TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			if (!waiting) {
				wait_begin_at = systick_millis_count;
    8260:	ldr	r6, [pc, #312]	; (839c <usb_serial_write.part.1+0x158>)
    8262:	ldrh.w	r3, [r8]
				//printf("tx head=%d\n", tx_head);
				//printf("TXFILLTUNING=%08lX\n", USB1_TXFILLTUNING);
				//usb_print_transfer_log();
				//while (1) ;
			}
			if (!usb_configuration) return sent;
    8266:	ldr.w	sl, [pc, #336]	; 83b8 <usb_serial_write.part.1+0x174>
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
	do {
		SCB_CACHE_DCCIMVAC = location;
    826a:	ldr.w	fp, [pc, #336]	; 83bc <usb_serial_write.part.1+0x178>
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		transfer_t *xfer = tx_transfer + tx_head;
    826e:	ldr	r2, [pc, #304]	; (83a0 <usb_serial_write.part.1+0x15c>)
    8270:	ldrb	r4, [r2, #0]
    8272:	ldr	r2, [pc, #304]	; (83a4 <usb_serial_write.part.1+0x160>)
    8274:	add.w	r7, r2, r4, lsl #5
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    8278:	cmp	r3, #0
    827a:	bne.n	835a <usb_serial_write.part.1+0x116>
    827c:	mov	r5, r3
    827e:	mov	r4, r3
    8280:	b.n	82ac <usb_serial_write.part.1+0x68>
			}
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    8282:	ldrb.w	r3, [r9]
				}
				tx_available = TX_SIZE;
				transmit_previous_timeout = 0;
				break;
			}
			if (!waiting) {
    8286:	cbnz	r4, 828a <usb_serial_write.part.1+0x46>
				wait_begin_at = systick_millis_count;
    8288:	ldr	r5, [r6, #0]
    828a:	movs	r4, #1
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    828c:	cmp	r3, #0
    828e:	bne.n	834e <usb_serial_write.part.1+0x10a>
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    8290:	ldr	r3, [r6, #0]
    8292:	subs	r3, r3, r5
    8294:	cmp	r3, #120	; 0x78
    8296:	bhi.n	838c <usb_serial_write.part.1+0x148>
				//printf("tx head=%d\n", tx_head);
				//printf("TXFILLTUNING=%08lX\n", USB1_TXFILLTUNING);
				//usb_print_transfer_log();
				//while (1) ;
			}
			if (!usb_configuration) return sent;
    8298:	ldrb.w	r3, [sl]
    829c:	cmp	r3, #0
    829e:	beq.n	834e <usb_serial_write.part.1+0x10a>
			yield();
    82a0:	bl	9ea4 <yield>
	if (!usb_configuration) return 0;
	while (size > 0) {
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    82a4:	ldrh.w	r3, [r8]
    82a8:	cmp	r3, #0
    82aa:	bne.n	8356 <usb_serial_write.part.1+0x112>
			//digitalWriteFast(3, HIGH);
			uint32_t status = usb_transfer_status(xfer);
    82ac:	mov	r0, r7
    82ae:	bl	90cc <usb_transfer_status>
			if (!(status & 0x80)) {
    82b2:	ands.w	r0, r0, #128	; 0x80
			}
			if (!waiting) {
				wait_begin_at = systick_millis_count;
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
    82b6:	ldr	r2, [pc, #240]	; (83a8 <usb_serial_write.part.1+0x164>)
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
			//digitalWriteFast(3, HIGH);
			uint32_t status = usb_transfer_status(xfer);
			if (!(status & 0x80)) {
    82b8:	bne.n	8282 <usb_serial_write.part.1+0x3e>
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = TX_SIZE;
    82ba:	mov.w	r3, #2048	; 0x800
    82be:	ldr	r2, [pc, #224]	; (83a0 <usb_serial_write.part.1+0x15c>)
				transmit_previous_timeout = 0;
    82c0:	strb.w	r0, [r9]
    82c4:	ldrb	r4, [r2, #0]
    82c6:	mov	r2, r3
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = TX_SIZE;
    82c8:	strh.w	r3, [r8]
			}
			if (!usb_configuration) return sent;
			yield();
		}
		//digitalWriteFast(3, LOW);
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    82cc:	lsls	r4, r4, #11
		if (size >= tx_available) {
    82ce:	ldr	r5, [sp, #4]
			}
			if (!usb_configuration) return sent;
			yield();
		}
		//digitalWriteFast(3, LOW);
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    82d0:	ldr	r1, [pc, #216]	; (83ac <usb_serial_write.part.1+0x168>)
    82d2:	add	r0, r4
		if (size >= tx_available) {
    82d4:	cmp	r5, r2
			}
			if (!usb_configuration) return sent;
			yield();
		}
		//digitalWriteFast(3, LOW);
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    82d6:	add	r0, r1
		if (size >= tx_available) {
    82d8:	bcc.n	8362 <usb_serial_write.part.1+0x11e>
			memcpy(txdata, data, tx_available);
			//*(txbuffer + (tx_head * TX_SIZE)) = 'A' + tx_head; // to see which buffer
			//*(txbuffer + (tx_head * TX_SIZE) + 1) = ' '; // really see it
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    82da:	add	r4, r1
			yield();
		}
		//digitalWriteFast(3, LOW);
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
		if (size >= tx_available) {
			memcpy(txdata, data, tx_available);
    82dc:	ldr	r1, [sp, #8]
    82de:	bl	7f58 <memcpy>
			//*(txbuffer + (tx_head * TX_SIZE)) = 'A' + tx_head; // to see which buffer
			//*(txbuffer + (tx_head * TX_SIZE) + 1) = ' '; // really see it
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
    82e2:	movs	r3, #0
    82e4:	mov	r1, r4
    82e6:	mov.w	r2, #2048	; 0x800
    82ea:	mov	r0, r7
    82ec:	bl	9050 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    82f0:	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    82f4:	add.w	r4, r4, #2048	; 0x800
	asm volatile("": : :"memory");
	asm("dsb");
    82f8:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    82fc:	str.w	r3, [fp]
		location += 32;
    8300:	adds	r3, #32
	} while (location < end_addr);
    8302:	cmp	r4, r3
    8304:	bhi.n	82fc <usb_serial_write.part.1+0xb8>
	asm("dsb");
    8306:	dsb	sy
	asm("isb");
    830a:	isb	sy
			arm_dcache_flush_delete(txbuf, TX_SIZE);
			usb_transmit(CDC_TX_ENDPOINT, xfer);
    830e:	movs	r0, #3
    8310:	mov	r1, r7
    8312:	bl	9080 <usb_transmit>
			if (++tx_head >= TX_NUM) tx_head = 0;
    8316:	ldr	r3, [pc, #136]	; (83a0 <usb_serial_write.part.1+0x15c>)
    8318:	ldr	r2, [pc, #132]	; (83a0 <usb_serial_write.part.1+0x15c>)
			size -= tx_available;
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
    831a:	movs	r1, #0
			//*(txbuffer + (tx_head * TX_SIZE) + 1) = ' '; // really see it
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
			arm_dcache_flush_delete(txbuf, TX_SIZE);
			usb_transmit(CDC_TX_ENDPOINT, xfer);
			if (++tx_head >= TX_NUM) tx_head = 0;
    831c:	ldrb	r3, [r3, #0]
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    831e:	ldr	r0, [pc, #144]	; (83b0 <usb_serial_write.part.1+0x16c>)
			//*(txbuffer + (tx_head * TX_SIZE) + 1) = ' '; // really see it
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
			arm_dcache_flush_delete(txbuf, TX_SIZE);
			usb_transmit(CDC_TX_ENDPOINT, xfer);
			if (++tx_head >= TX_NUM) tx_head = 0;
    8320:	adds	r3, #1
    8322:	uxtb	r3, r3
    8324:	cmp	r3, #3
    8326:	it	hi
    8328:	movhi	r3, #0
    832a:	strb	r3, [r2, #0]
			size -= tx_available;
    832c:	ldrh.w	r2, [r8]
			sent += tx_available;
    8330:	ldr	r3, [sp, #0]
			data += tx_available;
			tx_available = 0;
    8332:	strh.w	r1, [r8]
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
			arm_dcache_flush_delete(txbuf, TX_SIZE);
			usb_transmit(CDC_TX_ENDPOINT, xfer);
			if (++tx_head >= TX_NUM) tx_head = 0;
			size -= tx_available;
			sent += tx_available;
    8336:	add	r3, r2
    8338:	str	r3, [sp, #0]
			data += tx_available;
    833a:	ldr	r3, [sp, #8]
    833c:	add	r3, r2
    833e:	str	r3, [sp, #8]
    8340:	mov	r3, r1
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    8342:	str.w	r1, [r0, #132]	; 0x84
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    8346:	ldr	r1, [sp, #4]
    8348:	subs	r2, r1, r2
    834a:	str	r2, [sp, #4]
    834c:	bne.n	826e <usb_serial_write.part.1+0x2a>
    834e:	ldr	r0, [sp, #0]
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
    8350:	add	sp, #20
    8352:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8356:	ldr	r2, [pc, #72]	; (83a0 <usb_serial_write.part.1+0x15c>)
    8358:	ldrb	r4, [r2, #0]
    835a:	mov	r2, r3
    835c:	rsb	r0, r3, #2048	; 0x800
    8360:	b.n	82cc <usb_serial_write.part.1+0x88>
			sent += tx_available;
			data += tx_available;
			tx_available = 0;
			timer_stop();
		} else {
			memcpy(txdata, data, size);
    8362:	ldr	r4, [sp, #4]
    8364:	ldr	r1, [sp, #8]
    8366:	mov	r2, r4
    8368:	str	r3, [sp, #12]
    836a:	bl	7f58 <memcpy>
			tx_available -= size;
    836e:	ldr	r3, [sp, #12]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    8370:	ldr	r2, [pc, #60]	; (83b0 <usb_serial_write.part.1+0x16c>)
    8372:	mov.w	r1, #3221225472	; 0xc0000000
			data += tx_available;
			tx_available = 0;
			timer_stop();
		} else {
			memcpy(txdata, data, size);
			tx_available -= size;
    8376:	subs	r3, r3, r4
    8378:	strh.w	r3, [r8]
    837c:	ldr	r3, [sp, #0]
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    837e:	str.w	r1, [r2, #132]	; 0x84
    8382:	mov	r0, r3
    8384:	add	r0, r4
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
    8386:	add	sp, #20
    8388:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    838c:	movs	r3, #1
				return sent;
    838e:	ldr	r0, [sp, #0]
				waiting = 1;
			}
			if (transmit_previous_timeout) return sent;
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    8390:	strb	r3, [r2, #0]
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
    8392:	add	sp, #20
    8394:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    8398:	ldr	r0, [sp, #4]
    839a:	b.n	8350 <usb_serial_write.part.1+0x10c>
    839c:	.word	0x2000b144
    83a0:	.word	0x2000af37
    83a4:	.word	0x2000b080
    83a8:	.word	0x2000b065
    83ac:	.word	0x20201000
    83b0:	.word	0x402e0000
    83b4:	.word	0x2000b066
    83b8:	.word	0x2000b138
    83bc:	.word	0xe000ef70

000083c0 <usb_serial_reset>:
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_serial_reset(void)
{
    83c0:	bx	lr
    83c2:	nop

000083c4 <usb_serial_configure>:
void usb_serial_configure(void)
{
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    83c4:	ldr	r3, [pc, #196]	; (848c <usb_serial_configure+0xc8>)
	printf("usb_serial_reset\n");
	// deallocate all transfer descriptors
}

void usb_serial_configure(void)
{
    83c6:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    83ca:	ldrb	r3, [r3, #0]
		tx_packet_size = CDC_TX_SIZE_480;
    83cc:	ldr	r7, [pc, #192]	; (8490 <usb_serial_configure+0xcc>)
void usb_serial_configure(void)
{
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    83ce:	cmp	r3, #0
    83d0:	beq.n	847c <usb_serial_configure+0xb8>
		tx_packet_size = CDC_TX_SIZE_480;
    83d2:	mov.w	r3, #512	; 0x200
		rx_packet_size = CDC_RX_SIZE_480;
    83d6:	ldr.w	r8, [pc, #236]	; 84c4 <usb_serial_configure+0x100>
{
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
		tx_packet_size = CDC_TX_SIZE_480;
    83da:	strh	r3, [r7, #0]
		rx_packet_size = CDC_RX_SIZE_480;
    83dc:	strh.w	r3, [r8]
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
    83e0:	movs	r1, #0
    83e2:	movs	r2, #128	; 0x80
    83e4:	ldr	r0, [pc, #172]	; (8494 <usb_serial_configure+0xd0>)
	tx_head = 0;
    83e6:	mov	r5, r1
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
    83e8:	ldr	r6, [pc, #172]	; (8498 <usb_serial_configure+0xd4>)
		rx_packet_size = CDC_RX_SIZE_480;
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
    83ea:	bl	b73c <memset>
	tx_head = 0;
    83ee:	ldr	r4, [pc, #172]	; (849c <usb_serial_configure+0xd8>)
	tx_available = 0;
    83f0:	ldr	r3, [pc, #172]	; (84a0 <usb_serial_configure+0xdc>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
    83f2:	mov	r1, r5
    83f4:	mov.w	r2, #256	; 0x100
    83f8:	ldr	r0, [pc, #168]	; (84a4 <usb_serial_configure+0xe0>)
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
    83fa:	strb	r5, [r4, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    83fc:	mov	r4, r5
		tx_packet_size = CDC_TX_SIZE_12;
		rx_packet_size = CDC_RX_SIZE_12;
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
    83fe:	strh	r5, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    8400:	bl	b73c <memset>
	memset(rx_count, 0, sizeof(rx_count));
    8404:	str	r5, [r6, #0]
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    8406:	mov	r3, r5
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
    8408:	str	r5, [r6, #4]
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    840a:	mov	r2, r5
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
    840c:	str	r5, [r6, #8]
    840e:	str	r5, [r6, #12]
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    8410:	ldr	r1, [pc, #148]	; (84a8 <usb_serial_configure+0xe4>)
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
    8412:	ldr	r6, [pc, #152]	; (84ac <usb_serial_configure+0xe8>)
	rx_head = 0;
	rx_tail = 0;
    8414:	ldr	r0, [pc, #152]	; (84b0 <usb_serial_configure+0xec>)
	rx_available = 0;
    8416:	ldr.w	lr, [pc, #176]	; 84c8 <usb_serial_configure+0x104>
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
    841a:	strb	r5, [r1, #0]
	rx_tail = 0;
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    841c:	movs	r1, #16
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
	rx_head = 0;
	rx_tail = 0;
    841e:	strb	r5, [r0, #0]
	rx_available = 0;
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    8420:	movs	r0, #2
	memset(tx_transfer, 0, sizeof(tx_transfer));
	tx_head = 0;
	tx_available = 0;
	memset(rx_transfer, 0, sizeof(rx_transfer));
	memset(rx_count, 0, sizeof(rx_count));
	memset(rx_index, 0, sizeof(rx_index));
    8422:	str	r5, [r6, #0]
    8424:	str	r5, [r6, #4]
    8426:	str	r5, [r6, #8]
    8428:	str	r5, [r6, #12]
	rx_head = 0;
	rx_tail = 0;
	rx_available = 0;
    842a:	str.w	r5, [lr]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    842e:	bl	8fe8 <usb_config_tx>
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
    8432:	ldrh.w	r1, [r8]
    8436:	mov	r2, r5
    8438:	ldr	r3, [pc, #120]	; (84b4 <usb_serial_configure+0xf0>)
    843a:	movs	r0, #3
    843c:	bl	8f84 <usb_config_rx>
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
    8440:	mov	r3, r5
    8442:	ldrh	r1, [r7, #0]
    8444:	movs	r2, #1
    8446:	movs	r0, #3
    8448:	bl	8fe8 <usb_config_tx>
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    844c:	mov	r0, r4
    844e:	adds	r4, #1
    8450:	bl	808c <rx_queue_transfer>
    8454:	cmp	r4, #8
    8456:	bne.n	844c <usb_serial_configure+0x88>
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
	USB1_GPTIMER0CTRL = 0;
    8458:	ldr	r3, [pc, #92]	; (84b8 <usb_serial_configure+0xf4>)
	USB1_GPTIMER0LD = microseconds - 1;
    845a:	movs	r2, #74	; 0x4a
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    845c:	ldr	r0, [pc, #92]	; (84bc <usb_serial_configure+0xf8>)
	USB1_GPTIMER0CTRL = 0;
    845e:	movs	r1, #0
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    8460:	ldr	r4, [pc, #92]	; (84c0 <usb_serial_configure+0xfc>)
    8462:	str	r4, [r0, #0]
	USB1_GPTIMER0CTRL = 0;
    8464:	str.w	r1, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    8468:	str.w	r2, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    846c:	ldr.w	r2, [r3, #328]	; 0x148
    8470:	orr.w	r2, r2, #16777216	; 0x1000000
    8474:	str.w	r2, [r3, #328]	; 0x148
    8478:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	printf("usb_serial_configure\n");
	if (usb_high_speed) {
		tx_packet_size = CDC_TX_SIZE_480;
		rx_packet_size = CDC_RX_SIZE_480;
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
    847c:	movs	r3, #64	; 0x40
		rx_packet_size = CDC_RX_SIZE_12;
    847e:	ldr.w	r8, [pc, #68]	; 84c4 <usb_serial_configure+0x100>
	printf("usb_serial_configure\n");
	if (usb_high_speed) {
		tx_packet_size = CDC_TX_SIZE_480;
		rx_packet_size = CDC_RX_SIZE_480;
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
    8482:	strh	r3, [r7, #0]
		rx_packet_size = CDC_RX_SIZE_12;
    8484:	strh.w	r3, [r8]
    8488:	b.n	83e0 <usb_serial_configure+0x1c>
    848a:	nop
    848c:	.word	0x2000b110
    8490:	.word	0x2000af34
    8494:	.word	0x2000b080
    8498:	.word	0x2000b050
    849c:	.word	0x2000af37
    84a0:	.word	0x2000b066
    84a4:	.word	0x2000af40
    84a8:	.word	0x2000b064
    84ac:	.word	0x2000af24
    84b0:	.word	0x2000b040
    84b4:	.word	0x000080f9
    84b8:	.word	0x402e0000
    84bc:	.word	0x2000b100
    84c0:	.word	0x000081ad
    84c4:	.word	0x2000b04e
    84c8:	.word	0x2000b060

000084cc <usb_serial_read>:
int usb_serial_read(void *buffer, uint32_t size)
{
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;

	NVIC_DISABLE_IRQ(IRQ_USB1);
    84cc:	ldr	r3, [pc, #196]	; (8594 <usb_serial_read+0xc8>)
    84ce:	mov.w	r2, #131072	; 0x20000

//static int maxtimes=0;

// read a block of bytes to a buffer
int usb_serial_read(void *buffer, uint32_t size)
{
    84d2:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;

	NVIC_DISABLE_IRQ(IRQ_USB1);
    84d6:	str	r2, [r3, #0]

//static int maxtimes=0;

// read a block of bytes to a buffer
int usb_serial_read(void *buffer, uint32_t size)
{
    84d8:	sub	sp, #12
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;

	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
    84da:	ldr	r3, [pc, #188]	; (8598 <usb_serial_read+0xcc>)
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
    84dc:	mov	r9, r1
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;

	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
    84de:	ldrb	r4, [r3, #0]
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
    84e0:	cmp	r1, #0
    84e2:	beq.n	858c <usb_serial_read+0xc0>
    84e4:	ldr	r3, [pc, #180]	; (859c <usb_serial_read+0xd0>)
    84e6:	uxtb	r4, r4
    84e8:	ldrb	r3, [r3, #0]
    84ea:	cmp	r4, r3
    84ec:	beq.n	8590 <usb_serial_read+0xc4>
    84ee:	mov	sl, r0
    84f0:	movs	r7, #0
    84f2:	ldr.w	fp, [pc, #192]	; 85b4 <usb_serial_read+0xe8>
		if (++tail > RX_NUM) tail = 0;
    84f6:	adds	r4, #1
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    84f8:	ldr	r3, [pc, #164]	; (85a0 <usb_serial_read+0xd4>)
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
    84fa:	rsb	r8, r7, r9
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    84fe:	mov	r0, sl
	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
    8500:	cmp	r4, #9
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    8502:	str	r3, [sp, #4]
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
    8504:	ldr	r3, [pc, #156]	; (85a4 <usb_serial_read+0xd8>)
	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
    8506:	it	cs
    8508:	movcs	r4, #0
		uint32_t i = rx_list[tail];
    850a:	ldrb	r5, [r3, r4]
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    850c:	ldr	r3, [pc, #144]	; (85a0 <usb_serial_read+0xd4>)
    850e:	ldrh.w	lr, [r3, r5, lsl #1]
    8512:	ldr	r3, [pc, #148]	; (85a8 <usb_serial_read+0xdc>)
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    8514:	add.w	r1, lr, r5, lsl #9
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    8518:	ldrh.w	r6, [r3, r5, lsl #1]
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    851c:	ldr	r3, [pc, #140]	; (85ac <usb_serial_read+0xe0>)
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
    851e:	rsb	r6, lr, r6
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    8522:	add	r1, r3
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
    8524:	cmp	r8, r6
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    8526:	mov	r2, r6
			p += avail;
			rx_available -= avail;
			count += avail;
    8528:	add	r7, r6
		uint32_t i = rx_list[tail];
		uint32_t len = size - count;
		uint32_t avail = rx_count[i] - rx_index[i];
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
    852a:	bcs.n	8560 <usb_serial_read+0x94>
			// partially consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    852c:	add.w	r1, lr, r5, lsl #9
    8530:	mov	r2, r8
    8532:	add	r1, r3
    8534:	bl	7f58 <memcpy>
			rx_available -= len;
			rx_index[i] += len;
    8538:	ldr	r3, [sp, #4]
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
			// partially consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
			rx_available -= len;
    853a:	ldr.w	r1, [fp]
    853e:	mov	r0, r9
			rx_index[i] += len;
    8540:	ldrh.w	r2, [r3, r5, lsl #1]
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
			// partially consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
			rx_available -= len;
    8544:	rsb	r1, r8, r1
			rx_index[i] += len;
    8548:	add	r8, r2
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
			// partially consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
			rx_available -= len;
    854a:	str.w	r1, [fp]
			rx_index[i] += len;
    854e:	strh.w	r8, [r3, r5, lsl #1]
			count += avail;
			rx_tail = tail;
			rx_queue_transfer(i);
		}
	}
	NVIC_ENABLE_IRQ(IRQ_USB1);
    8552:	ldr	r3, [pc, #92]	; (85b0 <usb_serial_read+0xe4>)
    8554:	mov.w	r2, #131072	; 0x20000
    8558:	str	r2, [r3, #0]
	return count;
}
    855a:	add	sp, #12
    855c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			rx_available -= len;
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    8560:	bl	7f58 <memcpy>
			p += avail;
			rx_available -= avail;
    8564:	ldr.w	r2, [fp]
			count += avail;
			rx_tail = tail;
    8568:	uxtb	r3, r4
			rx_queue_transfer(i);
    856a:	mov	r0, r5
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
			p += avail;
			rx_available -= avail;
    856c:	subs	r2, r2, r6
			rx_index[i] += len;
			count += len;
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
			p += avail;
    856e:	add	sl, r6
			rx_available -= avail;
    8570:	str.w	r2, [fp]
			count += avail;
			rx_tail = tail;
    8574:	ldr	r2, [pc, #32]	; (8598 <usb_serial_read+0xcc>)
    8576:	strb	r3, [r2, #0]
			rx_queue_transfer(i);
    8578:	bl	808c <rx_queue_transfer>

	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
    857c:	cmp	r9, r7
    857e:	bls.n	8588 <usb_serial_read+0xbc>
    8580:	ldr	r3, [pc, #24]	; (859c <usb_serial_read+0xd0>)
    8582:	ldrb	r3, [r3, #0]
    8584:	cmp	r4, r3
    8586:	bne.n	84f6 <usb_serial_read+0x2a>
    8588:	mov	r0, r7
    858a:	b.n	8552 <usb_serial_read+0x86>
    858c:	mov	r0, r1
    858e:	b.n	8552 <usb_serial_read+0x86>
    8590:	movs	r0, #0
    8592:	b.n	8552 <usb_serial_read+0x86>
    8594:	.word	0xe000e18c
    8598:	.word	0x2000b040
    859c:	.word	0x2000b064
    85a0:	.word	0x2000af24
    85a4:	.word	0x2000b044
    85a8:	.word	0x2000b050
    85ac:	.word	0x20200000
    85b0:	.word	0xe000e10c
    85b4:	.word	0x2000b060

000085b8 <usb_serial_peekchar>:
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
    85b8:	ldr	r3, [pc, #44]	; (85e8 <usb_serial_peekchar+0x30>)
	if (tail == rx_head) return -1;
    85ba:	ldr	r2, [pc, #48]	; (85ec <usb_serial_peekchar+0x34>)
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
    85bc:	ldrb	r3, [r3, #0]
	if (tail == rx_head) return -1;
    85be:	ldrb	r2, [r2, #0]
}

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
    85c0:	uxtb	r3, r3
	if (tail == rx_head) return -1;
    85c2:	cmp	r3, r2
    85c4:	beq.n	85e2 <usb_serial_peekchar+0x2a>
	if (++tail > RX_NUM) tail = 0;
    85c6:	adds	r3, #1
	uint32_t i = rx_list[tail];
    85c8:	ldr	r0, [pc, #36]	; (85f0 <usb_serial_peekchar+0x38>)
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    85ca:	ldr	r2, [pc, #40]	; (85f4 <usb_serial_peekchar+0x3c>)
// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    85cc:	cmp	r3, #9
	uint32_t i = rx_list[tail];
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    85ce:	ldr	r1, [pc, #40]	; (85f8 <usb_serial_peekchar+0x40>)
// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
	if (++tail > RX_NUM) tail = 0;
    85d0:	it	cs
    85d2:	movcs	r3, #0
	uint32_t i = rx_list[tail];
    85d4:	ldrb	r3, [r0, r3]
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    85d6:	ldrh.w	r1, [r1, r3, lsl #1]
    85da:	add.w	r3, r2, r3, lsl #9
    85de:	ldrb	r0, [r3, r1]
    85e0:	bx	lr

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
    85e2:	mov.w	r0, #4294967295
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
}
    85e6:	bx	lr
    85e8:	.word	0x2000b040
    85ec:	.word	0x2000b064
    85f0:	.word	0x2000b044
    85f4:	.word	0x20200000
    85f8:	.word	0x2000af24

000085fc <usb_serial_available>:

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	return rx_available;
    85fc:	ldr	r3, [pc, #4]	; (8604 <usb_serial_available+0x8>)
    85fe:	ldr	r0, [r3, #0]
}
    8600:	bx	lr
    8602:	nop
    8604:	.word	0x2000b060

00008608 <usb_serial_flush_input>:

// discard any buffered input
void usb_serial_flush_input(void)
{
    8608:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t tail = rx_tail;
    860c:	ldr	r6, [pc, #84]	; (8664 <usb_serial_flush_input+0x5c>)
	while (tail != rx_head) {
    860e:	ldr	r5, [pc, #88]	; (8668 <usb_serial_flush_input+0x60>)
}

// discard any buffered input
void usb_serial_flush_input(void)
{
	uint32_t tail = rx_tail;
    8610:	ldrb	r4, [r6, #0]
	while (tail != rx_head) {
    8612:	ldrb	r3, [r5, #0]
}

// discard any buffered input
void usb_serial_flush_input(void)
{
	uint32_t tail = rx_tail;
    8614:	uxtb	r4, r4
	while (tail != rx_head) {
    8616:	cmp	r4, r3
    8618:	beq.n	865e <usb_serial_flush_input+0x56>
    861a:	ldr.w	r9, [pc, #84]	; 8670 <usb_serial_flush_input+0x68>
    861e:	ldr.w	fp, [pc, #84]	; 8674 <usb_serial_flush_input+0x6c>
    8622:	ldr.w	r8, [pc, #84]	; 8678 <usb_serial_flush_input+0x70>
    8626:	ldr	r7, [pc, #68]	; (866c <usb_serial_flush_input+0x64>)
		if (++tail > RX_NUM) tail = 0;
    8628:	adds	r4, #1
    862a:	cmp	r4, #8
    862c:	uxtb.w	sl, r4
    8630:	bls.n	8636 <usb_serial_flush_input+0x2e>
    8632:	movs	r4, #0
    8634:	mov	sl, r4
		uint32_t i = rx_list[tail];
    8636:	ldrb.w	r1, [r9, r4]
		rx_available -= rx_count[i] - rx_index[i];
    863a:	ldr.w	r2, [fp]
    863e:	ldrh.w	r3, [r8, r1, lsl #1]
		rx_queue_transfer(i);
    8642:	mov	r0, r1
{
	uint32_t tail = rx_tail;
	while (tail != rx_head) {
		if (++tail > RX_NUM) tail = 0;
		uint32_t i = rx_list[tail];
		rx_available -= rx_count[i] - rx_index[i];
    8644:	ldrh.w	r1, [r7, r1, lsl #1]
    8648:	subs	r3, r3, r1
    864a:	subs	r3, r2, r3
    864c:	str.w	r3, [fp]
		rx_queue_transfer(i);
    8650:	bl	808c <rx_queue_transfer>
		rx_tail = tail;
    8654:	strb.w	sl, [r6]

// discard any buffered input
void usb_serial_flush_input(void)
{
	uint32_t tail = rx_tail;
	while (tail != rx_head) {
    8658:	ldrb	r3, [r5, #0]
    865a:	cmp	r4, r3
    865c:	bne.n	8628 <usb_serial_flush_input+0x20>
    865e:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    8662:	nop
    8664:	.word	0x2000b040
    8668:	.word	0x2000b064
    866c:	.word	0x2000af24
    8670:	.word	0x2000b044
    8674:	.word	0x2000b060
    8678:	.word	0x2000b050

0000867c <usb_serial_getchar>:
}


// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    867c:	push	{lr}
    867e:	sub	sp, #12
	uint8_t c;
	if (usb_serial_read(&c, 1)) return c;
    8680:	movs	r1, #1
    8682:	add.w	r0, sp, #7
    8686:	bl	84cc <usb_serial_read>
    868a:	cbz	r0, 8696 <usb_serial_getchar+0x1a>
    868c:	ldrb.w	r0, [sp, #7]
	return -1;
}
    8690:	add	sp, #12
    8692:	ldr.w	pc, [sp], #4
// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
	uint8_t c;
	if (usb_serial_read(&c, 1)) return c;
	return -1;
    8696:	mov.w	r0, #4294967295
    869a:	b.n	8690 <usb_serial_getchar+0x14>

0000869c <usb_serial_putchar>:
int usb_serial_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    869c:	ldr	r3, [pc, #36]	; (86c4 <usb_serial_putchar+0x28>)
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    869e:	push	{lr}
    86a0:	sub	sp, #12
int usb_serial_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    86a2:	ldrb	r3, [r3, #0]
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    86a4:	strb.w	r0, [sp, #7]
int usb_serial_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    86a8:	cbnz	r3, 86b4 <usb_serial_putchar+0x18>
    86aa:	and.w	r0, r3, #255	; 0xff

// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
	return usb_serial_write(&c, 1);
}
    86ae:	add	sp, #12
    86b0:	ldr.w	pc, [sp], #4
    86b4:	movs	r1, #1
    86b6:	add.w	r0, sp, #7
    86ba:	bl	8244 <usb_serial_write.part.1>
    86be:	add	sp, #12
    86c0:	ldr.w	pc, [sp], #4
    86c4:	.word	0x2000b138

000086c8 <usb_serial_write>:
int usb_serial_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    86c8:	ldr	r3, [pc, #16]	; (86dc <usb_serial_write+0x14>)
    86ca:	ldrb	r3, [r3, #0]
    86cc:	and.w	r2, r3, #255	; 0xff
    86d0:	cbz	r3, 86d6 <usb_serial_write+0xe>
    86d2:	b.w	8244 <usb_serial_write.part.1>
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
    86d6:	mov	r0, r2
    86d8:	bx	lr
    86da:	nop
    86dc:	.word	0x2000b138

000086e0 <usb_serial_write_buffer_free>:

int usb_serial_write_buffer_free(void)
{
    86e0:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t sum = 0;
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
    86e4:	movs	r4, #0
}

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
	tx_noautoflush = 1;
    86e6:	ldr.w	r8, [pc, #64]	; 8728 <usb_serial_write_buffer_free+0x48>
    86ea:	movs	r3, #1
    86ec:	ldr	r5, [pc, #48]	; (8720 <usb_serial_write_buffer_free+0x40>)
	return sent;
}

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
    86ee:	mov	r7, r4
    86f0:	ldr	r6, [pc, #48]	; (8724 <usb_serial_write_buffer_free+0x44>)
	tx_noautoflush = 1;
    86f2:	strb.w	r3, [r8]
	for (uint32_t i=0; i < TX_NUM; i++) {
		if (i == tx_head) continue;
    86f6:	ldrb	r3, [r6, #0]
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    86f8:	mov	r0, r5
    86fa:	adds	r5, #32
int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
		if (i == tx_head) continue;
    86fc:	cmp	r3, r4

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
    86fe:	add.w	r4, r4, #1
		if (i == tx_head) continue;
    8702:	beq.n	8710 <usb_serial_write_buffer_free+0x30>
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    8704:	bl	90cc <usb_transfer_status>
    8708:	lsls	r3, r0, #24
    870a:	it	pl
    870c:	addpl.w	r7, r7, #2048	; 0x800

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
    8710:	cmp	r4, #4
    8712:	bne.n	86f6 <usb_serial_write_buffer_free+0x16>
		if (i == tx_head) continue;
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
	}
	tx_noautoflush = 0;
    8714:	movs	r3, #0
	return sum;
}
    8716:	mov	r0, r7
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
		if (i == tx_head) continue;
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
	}
	tx_noautoflush = 0;
    8718:	strb.w	r3, [r8]
	return sum;
}
    871c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    8720:	.word	0x2000b080
    8724:	.word	0x2000af37
    8728:	.word	0x2000af36

0000872c <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{
    872c:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

	if (!usb_configuration) return;
    8730:	ldr	r3, [pc, #124]	; (87b0 <usb_serial_flush_output+0x84>)
    8732:	ldrb	r3, [r3, #0]
    8734:	cbz	r3, 873c <usb_serial_flush_output+0x10>
	if (tx_available == 0) return;
    8736:	ldr	r5, [pc, #124]	; (87b4 <usb_serial_flush_output+0x88>)
    8738:	ldrh	r2, [r5, #0]
    873a:	cbnz	r2, 8740 <usb_serial_flush_output+0x14>
    873c:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	tx_noautoflush = 1;
	transfer_t *xfer = tx_transfer + tx_head;
    8740:	ldr.w	r8, [pc, #132]	; 87c8 <usb_serial_flush_output+0x9c>
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
    8744:	rsb	r9, r2, #2048	; 0x800
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	transfer_t *xfer = tx_transfer + tx_head;
    8748:	ldr	r6, [pc, #108]	; (87b8 <usb_serial_flush_output+0x8c>)
void usb_serial_flush_output(void)
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    874a:	mov.w	lr, #1
	transfer_t *xfer = tx_transfer + tx_head;
    874e:	ldrb.w	r1, [r8]
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    8752:	mov	r2, r9

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	transfer_t *xfer = tx_transfer + tx_head;
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    8754:	ldr	r4, [pc, #100]	; (87bc <usb_serial_flush_output+0x90>)
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    8756:	movs	r3, #0
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
	transfer_t *xfer = tx_transfer + tx_head;
    8758:	add.w	r6, r6, r1, lsl #5
void usb_serial_flush_output(void)
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    875c:	ldr	r7, [pc, #96]	; (87c0 <usb_serial_flush_output+0x94>)
	transfer_t *xfer = tx_transfer + tx_head;
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    875e:	add.w	r4, r4, r1, lsl #11
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    8762:	mov	r0, r6
void usb_serial_flush_output(void)
{

	if (!usb_configuration) return;
	if (tx_available == 0) return;
	tx_noautoflush = 1;
    8764:	strb.w	lr, [r7]
	transfer_t *xfer = tx_transfer + tx_head;
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
	uint32_t txnum = TX_SIZE - tx_available;
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    8768:	mov	r1, r4
    876a:	bl	9050 <usb_prepare_transfer>
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
    876e:	add.w	r2, r9, r4
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    8772:	bic.w	r1, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
    8776:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    877a:	ldr	r3, [pc, #72]	; (87c4 <usb_serial_flush_output+0x98>)
    877c:	str	r1, [r3, #0]
		location += 32;
    877e:	adds	r1, #32
	} while (location < end_addr);
    8780:	cmp	r2, r1
    8782:	bhi.n	877c <usb_serial_flush_output+0x50>
	asm("dsb");
    8784:	dsb	sy
	asm("isb");
    8788:	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    878c:	movs	r0, #3
    878e:	mov	r1, r6
    8790:	bl	9080 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    8794:	ldrb.w	r3, [r8]
    8798:	ldr	r2, [pc, #44]	; (87c8 <usb_serial_flush_output+0x9c>)
    879a:	adds	r3, #1
    879c:	uxtb	r3, r3
    879e:	cmp	r3, #3
    87a0:	it	hi
    87a2:	movhi	r3, #0
    87a4:	strb	r3, [r2, #0]
	tx_available = 0;
    87a6:	movs	r3, #0
    87a8:	strh	r3, [r5, #0]
	tx_noautoflush = 0;
    87aa:	strb	r3, [r7, #0]
    87ac:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    87b0:	.word	0x2000b138
    87b4:	.word	0x2000b066
    87b8:	.word	0x2000b080
    87bc:	.word	0x20201000
    87c0:	.word	0x2000af36
    87c4:	.word	0xe000ef70
    87c8:	.word	0x2000af37

000087cc <schedule_transfer>:
{
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    87cc:	ldr	r3, [r0, #56]	; 0x38
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
    87ce:	push	{r4, r5, r6, r7}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    87d0:	cbz	r3, 87da <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    87d2:	ldr	r3, [r2, #4]
    87d4:	orr.w	r3, r3, #32768	; 0x8000
    87d8:	str	r3, [r2, #4]
	}
	__disable_irq();
    87da:	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    87dc:	ldr	r4, [r0, #52]	; 0x34
	if (last) {
    87de:	cbz	r4, 8818 <schedule_transfer+0x4c>
		last->next = (uint32_t)transfer;
		if (USB1_ENDPTPRIME & epmask) goto end;
    87e0:	ldr	r3, [pc, #80]	; (8834 <schedule_transfer+0x68>)
	__disable_irq();
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
	if (last) {
		last->next = (uint32_t)transfer;
    87e2:	str	r2, [r4, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    87e4:	ldr.w	r4, [r3, #432]	; 0x1b0
    87e8:	tst	r4, r1
    87ea:	bne.n	882c <schedule_transfer+0x60>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    87ec:	ldr	r5, [pc, #72]	; (8838 <schedule_transfer+0x6c>)
    87ee:	ldr	r7, [r5, #0]
    87f0:	b.n	87fc <schedule_transfer+0x30>
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
			status = USB1_ENDPTSTATUS;
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    87f2:	ldr	r4, [r5, #0]
    87f4:	subs	r4, r4, r7
    87f6:	cmp.w	r4, #2400	; 0x960
    87fa:	bcs.n	8814 <schedule_transfer+0x48>
		if (USB1_ENDPTPRIME & epmask) goto end;
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    87fc:	ldr.w	r4, [r3, #320]	; 0x140
    8800:	orr.w	r4, r4, #16384	; 0x4000
    8804:	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    8808:	ldr.w	r6, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    880c:	ldr.w	r4, [r3, #320]	; 0x140
    8810:	lsls	r4, r4, #17
    8812:	bpl.n	87f2 <schedule_transfer+0x26>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    8814:	tst	r1, r6
    8816:	bne.n	882c <schedule_transfer+0x60>
		//ret |= 0x02;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
	endpoint->status = 0;
    8818:	movs	r3, #0
	USB1_ENDPTPRIME |= epmask;
    881a:	ldr	r4, [pc, #24]	; (8834 <schedule_transfer+0x68>)
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
		//ret |= 0x02;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
    881c:	str	r2, [r0, #8]
	endpoint->status = 0;
    881e:	str	r3, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
    8820:	ldr.w	r3, [r4, #432]	; 0x1b0
    8824:	orrs	r1, r3
    8826:	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    882a:	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
    882c:	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    882e:	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    8830:	pop	{r4, r5, r6, r7}
    8832:	bx	lr
    8834:	.word	0x402e0000
    8838:	.word	0xe0001004

0000883c <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    883c:	push	{r4, r5, r6, lr}
    883e:	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    8840:	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
    8842:	cbz	r0, 886a <run_callbacks+0x2e>
    8844:	mov	r2, r0
    8846:	movs	r4, #0
    8848:	b.n	8852 <run_callbacks+0x16>
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
		t = (transfer_t *)t->next;
    884a:	ldr	r2, [r2, #0]
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
			break;
		}
		count++;
    884c:	adds	r4, #1
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
    884e:	cmp	r2, #1
    8850:	beq.n	886c <run_callbacks+0x30>

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
    8852:	ldr	r3, [r2, #4]
    8854:	ands.w	r3, r3, #128	; 0x80
    8858:	beq.n	884a <run_callbacks+0xe>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
    885a:	str	r2, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    885c:	cbz	r4, 886a <run_callbacks+0x2e>
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
    885e:	ldr	r3, [r6, #56]	; 0x38
			break;
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
    8860:	ldr	r5, [r0, #0]
		ep->callback_function(first);
    8862:	blx	r3
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    8864:	subs	r4, #1
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
    8866:	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    8868:	bne.n	885e <run_callbacks+0x22>
    886a:	pop	{r4, r5, r6, pc}
		count++;
		t = (transfer_t *)t->next;
		if ((uint32_t)t == 1) {
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
    886c:	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
    886e:	str	r3, [r6, #52]	; 0x34
			break;
    8870:	b.n	885c <run_callbacks+0x20>
    8872:	nop

00008874 <endpoint0_transmit.constprop.1>:
#endif
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
    8874:	push	{r4, r5, r6, r7, lr}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
    8876:	cbnz	r1, 88b2 <endpoint0_transmit.constprop.1+0x3e>
    8878:	ldr	r4, [pc, #132]	; (8900 <endpoint0_transmit.constprop.1+0x8c>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    887a:	ldr	r1, [pc, #136]	; (8904 <endpoint0_transmit.constprop.1+0x90>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    887c:	movs	r0, #0
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    887e:	ldr	r3, [pc, #136]	; (8908 <endpoint0_transmit.constprop.1+0x94>)
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8880:	movs	r2, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    8882:	mov.w	r5, #65537	; 0x10001
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8886:	movs	r6, #128	; 0x80
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8888:	str	r2, [r1, #0]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
	while (USB1_ENDPTPRIME) ;
    888a:	mov	r2, r3
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
    888c:	str	r1, [r4, #8]
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    888e:	str	r6, [r1, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
    8890:	str	r0, [r4, #12]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    8892:	str.w	r5, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    8896:	ldr.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    889a:	ldr	r5, [pc, #112]	; (890c <endpoint0_transmit.constprop.1+0x98>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    889c:	orr.w	r4, r4, #1
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    88a0:	str	r0, [r1, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[0].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<0);
    88a2:	str.w	r4, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    88a6:	str	r0, [r5, #0]
	while (USB1_ENDPTPRIME) ;
    88a8:	ldr.w	r3, [r2, #432]	; 0x1b0
    88ac:	cmp	r3, #0
    88ae:	bne.n	88a8 <endpoint0_transmit.constprop.1+0x34>
}
    88b0:	pop	{r4, r5, r6, r7, pc}
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    88b2:	lsls	r1, r1, #16
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    88b4:	ldr	r3, [pc, #88]	; (8910 <endpoint0_transmit.constprop.1+0x9c>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    88b6:	ldr	r5, [pc, #80]	; (8908 <endpoint0_transmit.constprop.1+0x94>)
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    88b8:	movs	r6, #1
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    88ba:	ldr	r4, [pc, #68]	; (8900 <endpoint0_transmit.constprop.1+0x8c>)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    88bc:	orr.w	r1, r1, #128	; 0x80
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    88c0:	movs	r2, #0
static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
	//printf("tx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    88c2:	str	r6, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    88c4:	str	r1, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    88c6:	add.w	ip, r0, #4096	; 0x1000
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
    88ca:	str	r2, [r4, #76]	; 0x4c
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    88cc:	add.w	lr, r0, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    88d0:	str	r3, [r4, #72]	; 0x48
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
    88d2:	add.w	r7, r0, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    88d6:	ldr.w	r1, [r5, #432]	; 0x1b0
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
    88da:	add.w	r6, r0, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
		while (USB1_ENDPTPRIME) ;
    88de:	mov	r2, r5
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    88e0:	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    88e2:	orr.w	r1, r1, #65536	; 0x10000
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    88e6:	str.w	ip, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    88ea:	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    88ee:	str	r7, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    88f0:	str	r6, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[1].status = 0;
		USB1_ENDPTPRIME |= (1<<16);
    88f2:	str.w	r1, [r5, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    88f6:	ldr.w	r3, [r2, #432]	; 0x1b0
    88fa:	cmp	r3, #0
    88fc:	bne.n	88f6 <endpoint0_transmit.constprop.1+0x82>
    88fe:	b.n	887a <endpoint0_transmit.constprop.1+0x6>
    8900:	.word	0x2000d000
    8904:	.word	0x2000c020
    8908:	.word	0x402e0000
    890c:	.word	0x2000b114
    8910:	.word	0x2000c000

00008914 <isr>:
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


static void isr(void)
{
    8914:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    8918:	ldr	r4, [pc, #700]	; (8bd8 <isr+0x2c4>)
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


static void isr(void)
{
    891a:	sub	sp, #12
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    891c:	ldr.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    8920:	tst.w	r8, #1
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
	USB1_USBSTS = status;
    8924:	str.w	r8, [r4, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    8928:	beq.n	89e8 <isr+0xd4>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    892a:	ldr.w	r3, [r4, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    892e:	cmp	r3, #0
    8930:	beq.n	89de <isr+0xca>
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    8932:	mov.w	fp, #65537	; 0x10001
    8936:	ldr.w	r9, [pc, #712]	; 8c00 <isr+0x2ec>
    893a:	ldr	r6, [pc, #672]	; (8bdc <isr+0x2c8>)
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    893c:	mov	r5, r4
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    893e:	mov	sl, fp
	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
			USB1_ENDPTSETUPSTAT = setupstatus;
    8940:	str.w	r3, [r4, #428]	; 0x1ac
    8944:	ldr	r0, [r6, #40]	; 0x28
    8946:	ldr	r2, [r6, #44]	; 0x2c
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    8948:	ldr.w	r3, [r4, #320]	; 0x140
    894c:	orr.w	r3, r3, #8192	; 0x2000
    8950:	str.w	r3, [r4, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
				s.word2 = endpoint_queue_head[0].setup1;
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    8954:	ldr.w	r3, [r4, #320]	; 0x140
    8958:	lsls	r7, r3, #18
    895a:	bpl.n	8948 <isr+0x34>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    895c:	ldr.w	r3, [r5, #320]	; 0x140
    8960:	bic.w	r3, r3, #8192	; 0x2000
    8964:	str.w	r3, [r5, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    8968:	str.w	sl, [r5, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    896c:	ldr.w	r3, [r4, #436]	; 0x1b4
    8970:	ands.w	r3, r3, #65537	; 0x10001
    8974:	bne.n	896c <isr+0x58>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    8976:	uxth	r1, r0
    8978:	movw	r7, #1665	; 0x681
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
    897c:	str.w	r3, [r9]
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    8980:	cmp	r1, r7
    8982:	bhi.w	8aee <isr+0x1da>
    8986:	cmp.w	r1, #1664	; 0x680
    898a:	bcs.w	8d64 <isr+0x450>
    898e:	cmp.w	r1, #258	; 0x102
    8992:	beq.w	8c70 <isr+0x35c>
    8996:	bhi.w	8b86 <isr+0x272>
    899a:	cmp	r1, #128	; 0x80
    899c:	beq.w	8c56 <isr+0x342>
    89a0:	cmp	r1, #130	; 0x82
    89a2:	bne.w	8b76 <isr+0x262>
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
    89a6:	uxth	r2, r2
    89a8:	and.w	r1, r2, #127	; 0x7f
		if (endpoint > 7) break;
    89ac:	cmp	r1, #7
    89ae:	bhi.w	8b76 <isr+0x262>
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    89b2:	lsls	r1, r1, #2
    89b4:	ldr	r0, [pc, #552]	; (8be0 <isr+0x2cc>)
		reply_buffer[0] = 0;
    89b6:	ldr	r7, [pc, #556]	; (8be4 <isr+0x2d0>)
		return;
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    89b8:	add	r0, r1
    89ba:	ldr	r1, [r0, #0]
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    89bc:	lsls	r0, r2, #24
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
    89be:	strb	r3, [r7, #0]
		reply_buffer[1] = 0;
    89c0:	strb	r3, [r7, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    89c2:	bpl.w	8de2 <isr+0x4ce>
    89c6:	lsls	r2, r1, #15
    89c8:	bpl.n	89ce <isr+0xba>
			reply_buffer[0] = 1;
    89ca:	movs	r3, #1
    89cc:	strb	r3, [r7, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
    89ce:	movs	r1, #2
    89d0:	ldr	r0, [pc, #528]	; (8be4 <isr+0x2d0>)
    89d2:	bl	8874 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    89d6:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    89da:	cmp	r3, #0
    89dc:	bne.n	8940 <isr+0x2c>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    89de:	ldr	r2, [pc, #504]	; (8bd8 <isr+0x2c4>)
    89e0:	ldr.w	r3, [r2, #444]	; 0x1bc
		if (completestatus) {
    89e4:	cmp	r3, #0
    89e6:	bne.n	8a8a <isr+0x176>
			}
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
    89e8:	tst.w	r8, #64	; 0x40
    89ec:	beq.n	8a20 <isr+0x10c>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    89ee:	ldr	r3, [pc, #488]	; (8bd8 <isr+0x2c4>)
    89f0:	ldr.w	r1, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    89f4:	mov	r2, r3
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    89f6:	str.w	r1, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    89fa:	ldr.w	r1, [r3, #444]	; 0x1bc
    89fe:	str.w	r1, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    8a02:	ldr.w	r4, [r2, #432]	; 0x1b0
    8a06:	ldr	r3, [pc, #464]	; (8bd8 <isr+0x2c4>)
    8a08:	cmp	r4, #0
    8a0a:	bne.n	8a02 <isr+0xee>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    8a0c:	mov.w	r2, #4294967295
    8a10:	str.w	r2, [r3, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    8a14:	ldr.w	r3, [r3, #388]	; 0x184
			// we took too long to respond :(
			// TODO; is this ever really a problem?
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
    8a18:	bl	83c0 <usb_serial_reset>
		#endif
		endpointN_notify_mask = 0;
    8a1c:	ldr	r3, [pc, #456]	; (8be8 <isr+0x2d4>)
    8a1e:	str	r4, [r3, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
    8a20:	tst.w	r8, #16777216	; 0x1000000
    8a24:	beq.n	8a2e <isr+0x11a>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    8a26:	ldr	r3, [pc, #452]	; (8bec <isr+0x2d8>)
    8a28:	ldr	r3, [r3, #0]
    8a2a:	cbz	r3, 8a2e <isr+0x11a>
    8a2c:	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
    8a2e:	tst.w	r8, #33554432	; 0x2000000
    8a32:	beq.n	8a3c <isr+0x128>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    8a34:	ldr	r3, [pc, #440]	; (8bf0 <isr+0x2dc>)
    8a36:	ldr	r3, [r3, #0]
    8a38:	cbz	r3, 8a3c <isr+0x128>
    8a3a:	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
    8a3c:	tst.w	r8, #4
    8a40:	beq.n	8a54 <isr+0x140>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    8a42:	ldr	r3, [pc, #404]	; (8bd8 <isr+0x2c4>)
    8a44:	ldr.w	r3, [r3, #388]	; 0x184
    8a48:	ands.w	r3, r3, #512	; 0x200
    8a4c:	beq.n	8ae8 <isr+0x1d4>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
    8a4e:	ldr	r3, [pc, #420]	; (8bf4 <isr+0x2e0>)
    8a50:	movs	r2, #1
    8a52:	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    8a54:	ldr	r3, [pc, #384]	; (8bd8 <isr+0x2c4>)
    8a56:	ldr.w	r2, [r3, #328]	; 0x148
    8a5a:	lsls	r2, r2, #24
    8a5c:	bpl.n	8a84 <isr+0x170>
    8a5e:	tst.w	r8, #128	; 0x80
    8a62:	beq.n	8a84 <isr+0x170>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
    8a64:	ldr	r1, [pc, #400]	; (8bf8 <isr+0x2e4>)
    8a66:	ldrb	r2, [r1, #0]
    8a68:	cbz	r2, 8a84 <isr+0x170>
			if (--usb_reboot_timer == 0) {
    8a6a:	subs	r2, #1
    8a6c:	uxtb	r2, r2
    8a6e:	strb	r2, [r1, #0]
    8a70:	cbnz	r2, 8a84 <isr+0x170>
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
    8a72:	ldr	r1, [pc, #392]	; (8bfc <isr+0x2e8>)
    8a74:	ldrb	r2, [r1, #0]
    8a76:	and.w	r2, r2, #247	; 0xf7
    8a7a:	strb	r2, [r1, #0]
	if (sof_usage == 0) {
    8a7c:	cmp	r2, #0
    8a7e:	beq.w	8eea <isr+0x5d6>
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
			if (--usb_reboot_timer == 0) {
				usb_stop_sof_interrupts(NUM_INTERFACE);
				asm("bkpt #251"); // run bootloader
    8a82:	bkpt	0x00fb
		#endif
		#ifdef FLIGHTSIM_INTERFACE
		usb_flightsim_flush_output();
		#endif
	}
}
    8a84:	add	sp, #12
    8a86:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    8a8a:	ldr	r1, [pc, #372]	; (8c00 <isr+0x2ec>)
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
    8a8c:	str.w	r3, [r2, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    8a90:	ldr	r0, [r1, #0]
    8a92:	tst	r3, r0
    8a94:	bne.w	8e68 <isr+0x554>
				endpoint0_notify_mask = 0;
				endpoint0_complete();
			}
			completestatus &= endpointN_notify_mask;
    8a98:	ldr	r2, [pc, #332]	; (8be8 <isr+0x2d4>)
    8a9a:	ldr	r5, [r2, #0]
#if 1
			if (completestatus) {
    8a9c:	ands	r5, r3
    8a9e:	beq.n	89e8 <isr+0xd4>

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    8aa0:	lsrs	r7, r5, #16
    8aa2:	beq.n	8ac4 <isr+0x1b0>
    8aa4:	ldr	r6, [pc, #308]	; (8bdc <isr+0x2c8>)
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
    8aa6:	mov.w	r9, #1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
    8aaa:	rbit	r4, r7
    8aae:	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    8ab2:	add.w	r0, r6, r4, lsl #7
					tx &= ~(1<<p);
    8ab6:	lsl.w	r4, r9, r4

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
					int p=__builtin_ctz(tx);
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    8aba:	adds	r0, #64	; 0x40
    8abc:	bl	883c <run_callbacks>
#if 1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    8ac0:	bics	r7, r4
    8ac2:	bne.n	8aaa <isr+0x196>
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
    8ac4:	uxth	r5, r5
				while(rx) {
    8ac6:	cmp	r5, #0
    8ac8:	beq.n	89e8 <isr+0xd4>
    8aca:	ldr	r6, [pc, #272]	; (8bdc <isr+0x2c8>)
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
					rx &= ~(1<<p);
    8acc:	movs	r7, #1
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
    8ace:	rbit	r4, r5
    8ad2:	clz	r4, r4
					run_callbacks(endpoint_queue_head + p * 2);
    8ad6:	add.w	r0, r6, r4, lsl #7
					rx &= ~(1<<p);
    8ada:	lsl.w	r4, r7, r4

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
					int p=__builtin_ctz(rx);
					run_callbacks(endpoint_queue_head + p * 2);
    8ade:	bl	883c <run_callbacks>
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
    8ae2:	bics	r5, r4
    8ae4:	bne.n	8ace <isr+0x1ba>
    8ae6:	b.n	89e8 <isr+0xd4>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
    8ae8:	ldr	r2, [pc, #264]	; (8bf4 <isr+0x2e0>)
    8aea:	strb	r3, [r2, #0]
    8aec:	b.n	8a54 <isr+0x140>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    8aee:	movw	r7, #8225	; 0x2021
    8af2:	cmp	r1, r7
    8af4:	beq.n	8b6e <isr+0x25a>
    8af6:	bhi.w	8c10 <isr+0x2fc>
    8afa:	cmp.w	r1, #2176	; 0x880
    8afe:	beq.w	8d48 <isr+0x434>
    8b02:	cmp.w	r1, #2304	; 0x900
    8b06:	bne.n	8b76 <isr+0x262>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    8b08:	ubfx	r0, r0, #16, #8
    8b0c:	ldr	r1, [pc, #244]	; (8c04 <isr+0x2f0>)
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    8b0e:	mov.w	r2, #13107400	; 0xc800c8
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    8b12:	ldr	r7, [pc, #244]	; (8c08 <isr+0x2f4>)
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    8b14:	strb	r0, [r1, #0]
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
		#endif
		#if defined(ENDPOINT5_CONFIG)
		USB1_ENDPTCTRL5 = ENDPOINT5_CONFIG;
    8b16:	mov.w	r1, #13369548	; 0xcc00cc
    8b1a:	str	r3, [sp, #4]
		return;
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    8b1c:	str.w	r7, [r5, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    8b20:	str.w	r2, [r5, #460]	; 0x1cc
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    8b24:	str.w	r2, [r5, #464]	; 0x1d0
		#endif
		#if defined(ENDPOINT5_CONFIG)
		USB1_ENDPTCTRL5 = ENDPOINT5_CONFIG;
    8b28:	str.w	r1, [r5, #468]	; 0x1d4
		#endif
		#if defined(ENDPOINT7_CONFIG)
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
    8b2c:	bl	83c4 <usb_serial_configure>
		#endif
		#if defined(AUDIO_INTERFACE)
		usb_audio_configure();
		#endif
		#if defined(MTP_INTERFACE)
		usb_mtp_configure();
    8b30:	bl	9c00 <usb_mtp_configure>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8b34:	ldr	r2, [pc, #212]	; (8c0c <isr+0x2f8>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    8b36:	ldr	r3, [sp, #4]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8b38:	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8b3a:	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    8b3c:	str	r2, [r6, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8b3e:	str	r1, [r2, #4]
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8b40:	str	r0, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    8b42:	str	r3, [r6, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    8b44:	str.w	fp, [r5, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    8b48:	ldr.w	r1, [r5, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    8b4c:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    8b4e:	orr.w	r2, r1, #65536	; 0x10000
    8b52:	str.w	r2, [r5, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    8b56:	ldr	r2, [pc, #168]	; (8c00 <isr+0x2ec>)
    8b58:	str	r3, [r2, #0]
	while (USB1_ENDPTPRIME) ;
    8b5a:	ldr.w	r3, [r4, #432]	; 0x1b0
    8b5e:	cmp	r3, #0
    8b60:	bne.n	8b5a <isr+0x246>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    8b62:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    8b66:	cmp	r3, #0
    8b68:	bne.w	8940 <isr+0x2c>
    8b6c:	b.n	89de <isr+0xca>
		// fall through to next case, to always send ZLP ACK
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
    8b6e:	lsrs	r1, r2, #16
    8b70:	cmp	r1, #7
    8b72:	beq.w	8dea <isr+0x4d6>
			return;
		}
		break;
#endif
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    8b76:	str.w	fp, [r4, #448]	; 0x1c0
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    8b7a:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    8b7e:	cmp	r3, #0
    8b80:	bne.w	8940 <isr+0x2c>
    8b84:	b.n	89de <isr+0xca>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    8b86:	movw	r7, #770	; 0x302
    8b8a:	cmp	r1, r7
    8b8c:	beq.w	8ce8 <isr+0x3d4>
    8b90:	cmp.w	r1, #1280	; 0x500
    8b94:	bne.n	8b76 <isr+0x262>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8b96:	ldr	r2, [pc, #116]	; (8c0c <isr+0x2f8>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8b98:	movs	r1, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8b9a:	movs	r7, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    8b9c:	str	r3, [r6, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    8b9e:	str	r2, [r6, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8ba0:	str	r7, [r2, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8ba2:	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    8ba4:	str.w	fp, [r5, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    8ba8:	ldr.w	r1, [r5, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    8bac:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    8bae:	orr.w	r3, r1, #65536	; 0x10000
    8bb2:	str.w	r3, [r5, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    8bb6:	ldr.w	r3, [r4, #432]	; 0x1b0
    8bba:	cmp	r3, #0
    8bbc:	bne.n	8bb6 <isr+0x2a2>

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    8bbe:	lsrs	r3, r0, #16
    8bc0:	lsls	r3, r3, #25
    8bc2:	orr.w	r3, r3, #16777216	; 0x1000000
    8bc6:	str.w	r3, [r5, #340]	; 0x154
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    8bca:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    8bce:	cmp	r3, #0
    8bd0:	bne.w	8940 <isr+0x2c>
    8bd4:	b.n	89de <isr+0xca>
    8bd6:	nop
    8bd8:	.word	0x402e0000
    8bdc:	.word	0x2000d000
    8be0:	.word	0x402e01c0
    8be4:	.word	0x2000b128
    8be8:	.word	0x2000b104
    8bec:	.word	0x2000b100
    8bf0:	.word	0x2000b10c
    8bf4:	.word	0x2000b110
    8bf8:	.word	0x2000b118
    8bfc:	.word	0x2000b108
    8c00:	.word	0x2000b114
    8c04:	.word	0x2000b138
    8c08:	.word	0x00cc0002
    8c0c:	.word	0x2000c020
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    8c10:	movw	r3, #8737	; 0x2221
    8c14:	cmp	r1, r3
    8c16:	beq.n	8cd0 <isr+0x3bc>
    8c18:	movw	r3, #8993	; 0x2321
    8c1c:	cmp	r1, r3
    8c1e:	bne.n	8b76 <isr+0x262>
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8c20:	ldr	r3, [pc, #724]	; (8ef8 <isr+0x5e4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8c22:	movs	r2, #128	; 0x80
	endpoint0_transfer_ack.pointer0 = 0;
    8c24:	movs	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8c26:	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    8c28:	str	r3, [r6, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8c2a:	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8c2c:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    8c2e:	str	r1, [r6, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    8c30:	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    8c34:	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    8c38:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    8c3a:	orr.w	r3, r2, #65536	; 0x10000
    8c3e:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    8c42:	ldr.w	r3, [r4, #432]	; 0x1b0
    8c46:	cmp	r3, #0
    8c48:	bne.n	8c42 <isr+0x32e>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    8c4a:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    8c4e:	cmp	r3, #0
    8c50:	bne.w	8940 <isr+0x2c>
    8c54:	b.n	89de <isr+0xca>
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    8c56:	ldr	r2, [pc, #676]	; (8efc <isr+0x5e8>)
		reply_buffer[1] = 0;
		endpoint0_transmit(reply_buffer, 2, 0);
    8c58:	movs	r1, #2
    8c5a:	mov	r0, r2
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
		endpoint0_transmit(reply_buffer, 1, 0);
		return;
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    8c5c:	strb	r3, [r2, #0]
		reply_buffer[1] = 0;
    8c5e:	strb	r3, [r2, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
    8c60:	bl	8874 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    8c64:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    8c68:	cmp	r3, #0
    8c6a:	bne.w	8940 <isr+0x2c>
    8c6e:	b.n	89de <isr+0xca>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    8c70:	uxth	r2, r2
    8c72:	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    8c76:	cmp	r3, #7
    8c78:	bhi.w	8b76 <isr+0x262>
		dir = setup.wIndex & 0x80;
		if (dir) {
    8c7c:	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    8c80:	mov.w	r3, r3, lsl #2
    8c84:	ldr	r2, [pc, #632]	; (8f00 <isr+0x5ec>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    8c86:	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8c8a:	mov.w	r0, #1
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    8c8e:	add	r2, r3
    8c90:	ldr	r3, [r2, #0]
    8c92:	ite	ne
    8c94:	bicne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    8c98:	biceq.w	r3, r3, #1
    8c9c:	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8c9e:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8ca0:	ldr	r3, [pc, #596]	; (8ef8 <isr+0x5e4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    8ca2:	str	r1, [r6, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    8ca4:	str	r3, [r6, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8ca6:	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8ca8:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    8caa:	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    8cae:	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    8cb2:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    8cb4:	orr.w	r3, r2, #65536	; 0x10000
    8cb8:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    8cbc:	ldr.w	r3, [r4, #432]	; 0x1b0
    8cc0:	cmp	r3, #0
    8cc2:	bne.n	8cbc <isr+0x3a8>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    8cc4:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    8cc8:	cmp	r3, #0
    8cca:	bne.w	8940 <isr+0x2c>
    8cce:	b.n	89de <isr+0xca>
		}
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		#ifdef CDC_STATUS_INTERFACE
		if (setup.wIndex == CDC_STATUS_INTERFACE) {
    8cd0:	uxth	r2, r2
    8cd2:	cmp	r2, #1
    8cd4:	bne.n	8c20 <isr+0x30c>
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    8cd6:	ldr	r3, [pc, #556]	; (8f04 <isr+0x5f0>)
			usb_cdc_line_rtsdtr = setup.wValue;
    8cd8:	ubfx	r0, r0, #16, #8
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		#ifdef CDC_STATUS_INTERFACE
		if (setup.wIndex == CDC_STATUS_INTERFACE) {
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    8cdc:	ldr	r2, [pc, #552]	; (8f08 <isr+0x5f4>)
    8cde:	ldr	r1, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    8ce0:	ldr	r3, [pc, #552]	; (8f0c <isr+0x5f8>)
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		#ifdef CDC_STATUS_INTERFACE
		if (setup.wIndex == CDC_STATUS_INTERFACE) {
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    8ce2:	str	r1, [r2, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    8ce4:	strb	r0, [r3, #0]
    8ce6:	b.n	8c20 <isr+0x30c>
			reply_buffer[0] = 1;
		}
		endpoint0_transmit(reply_buffer, 2, 0);
		return;
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    8ce8:	uxth	r2, r2
    8cea:	and.w	r3, r2, #127	; 0x7f
		if (endpoint > 7) break;
    8cee:	cmp	r3, #7
    8cf0:	bhi.w	8b76 <isr+0x262>
		dir = setup.wIndex & 0x80;
		if (dir) {
    8cf4:	tst.w	r2, #128	; 0x80
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    8cf8:	mov.w	r3, r3, lsl #2
    8cfc:	ldr	r2, [pc, #512]	; (8f00 <isr+0x5ec>)
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    8cfe:	mov.w	r1, #0
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8d02:	mov.w	r0, #1
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		if (dir) {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    8d06:	add	r2, r3
    8d08:	ldr	r3, [r2, #0]
    8d0a:	ite	ne
    8d0c:	orrne.w	r3, r3, #65536	; 0x10000
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    8d10:	orreq.w	r3, r3, #1
    8d14:	str	r3, [r2, #0]
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8d16:	movs	r2, #128	; 0x80
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8d18:	ldr	r3, [pc, #476]	; (8ef8 <isr+0x5e4>)
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    8d1a:	str	r1, [r6, #76]	; 0x4c
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    8d1c:	str	r3, [r6, #72]	; 0x48
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8d1e:	str	r0, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8d20:	str	r2, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    8d22:	str.w	fp, [r4, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    8d26:	ldr.w	r2, [r4, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    8d2a:	str	r1, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    8d2c:	orr.w	r3, r2, #65536	; 0x10000
    8d30:	str.w	r3, [r4, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
	while (USB1_ENDPTPRIME) ;
    8d34:	ldr.w	r3, [r4, #432]	; 0x1b0
    8d38:	cmp	r3, #0
    8d3a:	bne.n	8d34 <isr+0x420>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    8d3c:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    8d40:	cmp	r3, #0
    8d42:	bne.w	8940 <isr+0x2c>
    8d46:	b.n	89de <isr+0xca>
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    8d48:	ldr	r2, [pc, #452]	; (8f10 <isr+0x5fc>)
		endpoint0_transmit(reply_buffer, 1, 0);
    8d4a:	movs	r1, #1
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    8d4c:	ldr	r3, [pc, #428]	; (8efc <isr+0x5e8>)
    8d4e:	ldrb	r2, [r2, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    8d50:	mov	r0, r3
		endpoint_queue_head[2].unused1 = (uint32_t)experimental_buffer;
		#endif
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    8d52:	strb	r2, [r3, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    8d54:	bl	8874 <endpoint0_transmit.constprop.1>
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    8d58:	ldr.w	r3, [r4, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    8d5c:	cmp	r3, #0
    8d5e:	bne.w	8940 <isr+0x2c>
    8d62:	b.n	89de <isr+0xca>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    8d64:	ldr	r3, [pc, #428]	; (8f14 <isr+0x600>)
    8d66:	ldr	r1, [r3, #4]
    8d68:	cmp	r1, #0
    8d6a:	beq.w	8b76 <isr+0x262>
    8d6e:	lsrs	r0, r0, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    8d70:	uxth.w	lr, r2
    8d74:	b.n	8d80 <isr+0x46c>
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    8d76:	adds	r3, #12
    8d78:	ldr	r1, [r3, #4]
    8d7a:	cmp	r1, #0
    8d7c:	beq.w	8b76 <isr+0x262>
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    8d80:	ldrh	r7, [r3, #0]
    8d82:	cmp	r7, r0
    8d84:	bne.n	8d76 <isr+0x462>
    8d86:	ldrh	r7, [r3, #2]
    8d88:	cmp	r7, lr
    8d8a:	bne.n	8d76 <isr+0x462>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
    8d8c:	lsrs	r7, r0, #8
    8d8e:	cmp	r7, #3
    8d90:	beq.w	8f66 <isr+0x652>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
    8d94:	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    8d96:	lsrs	r2, r2, #16
    8d98:	cmp	r3, r2
    8d9a:	it	cs
    8d9c:	movcs	r3, r2

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
    8d9e:	cmp.w	r0, #512	; 0x200
    8da2:	beq.w	8f48 <isr+0x634>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
    8da6:	cmp.w	r0, #1792	; 0x700
    8daa:	beq.w	8ec4 <isr+0x5b0>
    8dae:	ldr	r7, [pc, #360]	; (8f18 <isr+0x604>)
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
					usb_descriptor_buffer[1] = 7;
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    8db0:	mov	r2, r3
    8db2:	str	r3, [sp, #4]
    8db4:	mov	r0, r7
    8db6:	bl	7f58 <memcpy>
    8dba:	ldr	r3, [sp, #4]
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    8dbc:	bic.w	r2, r7, #31
	uint32_t end_addr = (uint32_t)addr + size;
    8dc0:	add	r7, r3
	asm volatile("": : :"memory");
	asm("dsb");
    8dc2:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    8dc6:	ldr	r1, [pc, #340]	; (8f1c <isr+0x608>)
    8dc8:	str	r2, [r1, #0]
		location += 32;
    8dca:	adds	r2, #32
	} while (location < end_addr);
    8dcc:	cmp	r7, r2
    8dce:	bhi.n	8dc6 <isr+0x4b2>
	asm("dsb");
    8dd0:	dsb	sy
	asm("isb");
    8dd4:	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    8dd8:	ldr	r0, [pc, #316]	; (8f18 <isr+0x604>)
    8dda:	mov	r1, r3
    8ddc:	bl	8874 <endpoint0_transmit.constprop.1>
    8de0:	b.n	89d6 <isr+0xc2>
		if (endpoint > 7) break;
		dir = setup.wIndex & 0x80;
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
		reply_buffer[0] = 0;
		reply_buffer[1] = 0;
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    8de2:	lsls	r3, r1, #31
    8de4:	bpl.w	89ce <isr+0xba>
    8de8:	b.n	89ca <isr+0xb6>
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
		endpoint0_setupdata.bothwords = setupdata;
    8dea:	ldr	r7, [pc, #308]	; (8f20 <isr+0x60c>)
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    8dec:	mov.w	lr, #1
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
    8df0:	str	r3, [r6, #12]
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    8df2:	ldr	r1, [pc, #304]	; (8f24 <isr+0x610>)
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    8df4:	ldr	r3, [pc, #304]	; (8f28 <isr+0x614>)
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
		endpoint0_setupdata.bothwords = setupdata;
    8df6:	str	r0, [r7, #0]
static void endpoint0_receive(void *data, uint32_t len, int notify)
{
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    8df8:	str.w	lr, [r3]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    8dfc:	str	r1, [r3, #4]
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    8dfe:	str	r3, [r6, #8]
	//printf("rx %lu\n", len);
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
    8e00:	ldr	r1, [pc, #296]	; (8f2c <isr+0x618>)
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    8e02:	ldr.w	r0, [r5, #432]	; 0x1b0
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
		endpoint0_setupdata.bothwords = setupdata;
    8e06:	str	r2, [r7, #4]
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    8e08:	add.w	r7, r1, #4096	; 0x1000
		endpoint0_transfer_data.pointer3 = addr + 12288;
		endpoint0_transfer_data.pointer4 = addr + 16384;
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    8e0c:	orr.w	r2, r0, lr
	if (len > 0) {
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    8e10:	str	r1, [r3, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
		endpoint0_transfer_data.pointer2 = addr + 8192;
    8e12:	add.w	lr, r1, #8192	; 0x2000
		endpoint0_transfer_data.pointer3 = addr + 12288;
    8e16:	add.w	r0, r1, #12288	; 0x3000
		endpoint0_transfer_data.pointer4 = addr + 16384;
    8e1a:	add.w	r1, r1, #16384	; 0x4000
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
    8e1e:	str.w	r2, [r5, #432]	; 0x1b0
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
		endpoint0_transfer_data.pointer1 = addr + 4096;
    8e22:	str	r7, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    8e24:	str.w	lr, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    8e28:	str	r0, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    8e2a:	str	r1, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
    8e2c:	ldr.w	r3, [r4, #432]	; 0x1b0
    8e30:	cmp	r3, #0
    8e32:	bne.n	8e2c <isr+0x518>
	}
	endpoint0_transfer_ack.next = 1;
    8e34:	ldr	r2, [pc, #192]	; (8ef8 <isr+0x5e4>)
    8e36:	movs	r0, #1
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8e38:	movw	r1, #32896	; 0x8080
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
    8e3c:	str	r3, [r6, #76]	; 0x4c
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
    8e3e:	str	r0, [r2, #0]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    8e40:	mov.w	r0, #65536	; 0x10000
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    8e44:	str	r2, [r6, #72]	; 0x48
		endpoint_queue_head[0].status = 0;
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    8e46:	str	r1, [r2, #4]
	endpoint0_transfer_ack.pointer0 = 0;
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    8e48:	str.w	fp, [r5, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    8e4c:	ldr.w	r1, [r5, #432]	; 0x1b0
		USB1_ENDPTPRIME |= (1<<0);
		while (USB1_ENDPTPRIME) ;
	}
	endpoint0_transfer_ack.next = 1;
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
	endpoint0_transfer_ack.pointer0 = 0;
    8e50:	str	r3, [r2, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
	endpoint_queue_head[1].status = 0;
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
	USB1_ENDPTPRIME |= (1<<16);
    8e52:	orr.w	r3, r1, r0
    8e56:	str.w	r3, [r5, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    8e5a:	str.w	r0, [r9]
	while (USB1_ENDPTPRIME) ;
    8e5e:	ldr.w	r3, [r4, #432]	; 0x1b0
    8e62:	cmp	r3, #0
    8e64:	bne.n	8e5e <isr+0x54a>
    8e66:	b.n	89d6 <isr+0xc2>

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    8e68:	ldr	r0, [pc, #180]	; (8f20 <isr+0x60c>)
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	// 0x2021 is CDC_SET_LINE_CODING
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    8e6a:	movw	r4, #8225	; 0x2021
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    8e6e:	movs	r6, #0

	setup.bothwords = endpoint0_setupdata.bothwords;
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	// 0x2021 is CDC_SET_LINE_CODING
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    8e70:	ldrh	r5, [r0, #0]
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
		if (completestatus) {
			USB1_ENDPTCOMPLETE = completestatus;
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
				endpoint0_notify_mask = 0;
    8e72:	str	r6, [r1, #0]

	setup.bothwords = endpoint0_setupdata.bothwords;
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	// 0x2021 is CDC_SET_LINE_CODING
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    8e74:	cmp	r5, r4

static void endpoint0_complete(void)
{
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    8e76:	ldr	r0, [r0, #4]
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	// 0x2021 is CDC_SET_LINE_CODING
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    8e78:	bne.w	8a98 <isr+0x184>
    8e7c:	uxth	r1, r0
    8e7e:	cmp	r1, #1
    8e80:	bne.w	8a98 <isr+0x184>
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    8e84:	ldr	r1, [pc, #164]	; (8f2c <isr+0x618>)
    8e86:	ldr	r4, [pc, #168]	; (8f30 <isr+0x61c>)
    8e88:	ldmia	r1, {r0, r1}
    8e8a:	lsrs	r5, r1, #16
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
    8e8c:	cmp	r0, #134	; 0x86
	setup.bothwords = endpoint0_setupdata.bothwords;
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	// 0x2021 is CDC_SET_LINE_CODING
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    8e8e:	str	r0, [r4, #0]
    8e90:	strh	r1, [r4, #4]
    8e92:	strb	r5, [r4, #6]
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
    8e94:	bne.w	8a98 <isr+0x184>
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
    8e98:	cpsid	i
	sof_usage |= (1 << interface);
    8e9a:	ldr	r0, [pc, #152]	; (8f34 <isr+0x620>)
    8e9c:	ldrb	r1, [r0, #0]
    8e9e:	orr.w	r1, r1, #8
    8ea2:	strb	r1, [r0, #0]
	uint32_t intr = USB1_USBINTR;
    8ea4:	ldr.w	r1, [r2, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    8ea8:	lsls	r0, r1, #24
    8eaa:	bmi.n	8eba <isr+0x5a6>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    8eac:	orr.w	r1, r1, #128	; 0x80
{
	__disable_irq();
	sof_usage |= (1 << interface);
	uint32_t intr = USB1_USBINTR;
	if (!(intr & USB_USBINTR_SRE)) {
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    8eb0:	movs	r0, #128	; 0x80
    8eb2:	str.w	r0, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    8eb6:	str.w	r1, [r2, #328]	; 0x148
	}
	__enable_irq();
    8eba:	cpsie	i
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
			usb_start_sof_interrupts(NUM_INTERFACE);
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    8ebc:	ldr	r2, [pc, #120]	; (8f38 <isr+0x624>)
    8ebe:	movs	r1, #80	; 0x50
    8ec0:	strb	r1, [r2, #0]
    8ec2:	b.n	8a98 <isr+0x184>
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    8ec4:	ldr	r0, [pc, #116]	; (8f3c <isr+0x628>)
					memcpy(usb_descriptor_buffer, src, datalen);
    8ec6:	mov	r2, r3
    8ec8:	ldr	r7, [pc, #76]	; (8f18 <isr+0x604>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    8eca:	ldrb.w	lr, [r0]
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
    8ece:	ldr	r1, [pc, #112]	; (8f40 <isr+0x62c>)
    8ed0:	ldr	r0, [pc, #112]	; (8f44 <isr+0x630>)
					if (usb_high_speed) src = usb_config_descriptor_12;
					memcpy(usb_descriptor_buffer, src, datalen);
    8ed2:	str	r3, [sp, #4]
    8ed4:	cmp.w	lr, #0
    8ed8:	it	eq
    8eda:	moveq	r1, r0
    8edc:	mov	r0, r7
    8ede:	bl	7f58 <memcpy>
					usb_descriptor_buffer[1] = 7;
    8ee2:	movs	r2, #7
    8ee4:	ldr	r3, [sp, #4]
    8ee6:	strb	r2, [r7, #1]
    8ee8:	b.n	8dbc <isr+0x4a8>

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
	if (sof_usage == 0) {
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    8eea:	ldr.w	r2, [r3, #328]	; 0x148
    8eee:	bic.w	r2, r2, #128	; 0x80
    8ef2:	str.w	r2, [r3, #328]	; 0x148
    8ef6:	b.n	8a82 <isr+0x16e>
    8ef8:	.word	0x2000c020
    8efc:	.word	0x2000b128
    8f00:	.word	0x402e01c0
    8f04:	.word	0x2000b144
    8f08:	.word	0x2000b300
    8f0c:	.word	0x2000b068
    8f10:	.word	0x2000b138
    8f14:	.word	0x2000084c
    8f18:	.word	0x20204000
    8f1c:	.word	0xe000ef70
    8f20:	.word	0x2000b120
    8f24:	.word	0x00070080
    8f28:	.word	0x2000c000
    8f2c:	.word	0x2000b130
    8f30:	.word	0x2000b2f8
    8f34:	.word	0x2000b108
    8f38:	.word	0x2000b118
    8f3c:	.word	0x2000b110
    8f40:	.word	0x60001a68
    8f44:	.word	0x60001ad4

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
    8f48:	ldr	r0, [pc, #40]	; (8f74 <isr+0x660>)
					memcpy(usb_descriptor_buffer, src, datalen);
    8f4a:	mov	r2, r3
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    8f4c:	ldr	r1, [pc, #40]	; (8f78 <isr+0x664>)
					if (usb_high_speed) src = usb_config_descriptor_480;
    8f4e:	ldrb	r7, [r0, #0]
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    8f50:	ldr	r0, [pc, #40]	; (8f7c <isr+0x668>)
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
    8f52:	str	r3, [sp, #4]
    8f54:	cmp	r7, #0
    8f56:	it	eq
    8f58:	moveq	r1, r0
    8f5a:	ldr	r0, [pc, #36]	; (8f80 <isr+0x66c>)
    8f5c:	bl	7f58 <memcpy>
    8f60:	ldr	r7, [pc, #28]	; (8f80 <isr+0x66c>)
    8f62:	ldr	r3, [sp, #4]
    8f64:	b.n	8dbc <isr+0x4a8>
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
				} else {
					datalen = list->length;
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    8f66:	lsrs	r2, r2, #16
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
    8f68:	ldrb	r3, [r1, #0]
    8f6a:	cmp	r3, r2
    8f6c:	it	cs
    8f6e:	movcs	r3, r2
    8f70:	b.n	8da6 <isr+0x492>
    8f72:	nop
    8f74:	.word	0x2000b110
    8f78:	.word	0x60001ad4
    8f7c:	.word	0x60001a68
    8f80:	.word	0x20204000

00008f84 <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    8f84:	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    8f86:	sub.w	r2, r0, #2
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    8f8a:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    8f8e:	ite	ne
    8f90:	movne	r7, #0
    8f92:	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    8f96:	cmp	r2, #3
    8f98:	bls.n	8f9e <usb_config_rx+0x1a>
    8f9a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    8f9e:	mov.w	sl, r0, lsl #7
    8fa2:	ldr.w	r9, [pc, #64]	; 8fe4 <usb_config_rx+0x60>
    8fa6:	mov	r5, r1
    8fa8:	mov	r4, r0
    8faa:	add.w	r6, sl, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    8fae:	movs	r1, #0
    8fb0:	movs	r2, #64	; 0x40
    8fb2:	mov	r8, r3
    8fb4:	mov	r0, r6
    8fb6:	bl	b73c <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    8fba:	movs	r0, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    8fbc:	orr.w	r1, r7, r5, lsl #16
    8fc0:	str.w	r1, [sl, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    8fc4:	str.w	r8, [r6, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    8fc8:	str	r0, [r6, #8]
void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
    8fca:	cmp.w	r8, #0
    8fce:	beq.n	8f9a <usb_config_rx+0x16>
    8fd0:	ldr	r3, [pc, #12]	; (8fe0 <usb_config_rx+0x5c>)
    8fd2:	lsls	r0, r4
    8fd4:	ldr	r4, [r3, #0]
    8fd6:	orrs	r0, r4
    8fd8:	str	r0, [r3, #0]
    8fda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    8fde:	nop
    8fe0:	.word	0x2000b104
    8fe4:	.word	0x2000d000

00008fe8 <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    8fe8:	cmp	r2, #0
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    8fea:	sub.w	r2, r0, #2
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    8fee:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    8ff2:	ite	ne
    8ff4:	movne	r7, #0
    8ff6:	moveq.w	r7, #536870912	; 0x20000000
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    8ffa:	cmp	r2, #3
    8ffc:	bls.n	9002 <usb_config_tx+0x1a>
    8ffe:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    9002:	movs	r2, #64	; 0x40

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    9004:	lsls	r5, r0, #7
    9006:	ldr.w	r9, [pc, #68]	; 904c <usb_config_tx+0x64>
    900a:	mov	r8, r1
    900c:	add	r5, r2
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    900e:	movs	r1, #0
    9010:	mov	r4, r0
    9012:	mov	r6, r3

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    9014:	add.w	sl, r5, r9
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
    9018:	mov	r0, sl
    901a:	bl	b73c <memset>
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    901e:	movs	r2, #1
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
    9020:	orr.w	r1, r7, r8, lsl #16
    9024:	str.w	r1, [r5, r9]
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
    9028:	str.w	r6, [sl, #56]	; 0x38

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
	memset(qh, 0, sizeof(endpoint_t));
	qh->config = config;
	qh->next = 1; // Terminate bit = 1
    902c:	str.w	r2, [sl, #8]
void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    9030:	cmp	r6, #0
    9032:	beq.n	8ffe <usb_config_tx+0x16>
    9034:	add.w	r0, r4, #16
    9038:	ldr	r3, [pc, #12]	; (9048 <usb_config_tx+0x60>)
    903a:	lsls	r2, r0
    903c:	ldr	r0, [r3, #0]
    903e:	orrs	r2, r0
    9040:	str	r2, [r3, #0]
    9042:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    9046:	nop
    9048:	.word	0x2000b104
    904c:	.word	0x2000d000

00009050 <usb_prepare_transfer>:


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    9050:	lsls	r2, r2, #16
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
    9052:	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
	transfer->pointer2 = addr + 8192;
	transfer->pointer3 = addr + 12288;
	transfer->pointer4 = addr + 16384;
	transfer->callback_param = param;
    9054:	str	r3, [r0, #28]


void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    9056:	orr.w	r2, r2, #128	; 0x80
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
    905a:	push	{r4, r5, r6, r7}
	transfer->next = 1;
	transfer->status = (len << 16) | (1<<7);
    905c:	str	r2, [r0, #4]



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    905e:	movs	r7, #1
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    9060:	add.w	r6, r1, #4096	; 0x1000
	transfer->pointer2 = addr + 8192;
    9064:	add.w	r5, r1, #8192	; 0x2000
	transfer->pointer3 = addr + 12288;
    9068:	add.w	r4, r1, #12288	; 0x3000
	transfer->pointer4 = addr + 16384;
    906c:	add.w	r2, r1, #16384	; 0x4000



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
	transfer->next = 1;
    9070:	str	r7, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
	transfer->pointer1 = addr + 4096;
    9072:	str	r6, [r0, #12]
	transfer->pointer2 = addr + 8192;
    9074:	str	r5, [r0, #16]
	transfer->pointer3 = addr + 12288;
    9076:	str	r4, [r0, #20]
	transfer->pointer4 = addr + 16384;
    9078:	str	r2, [r0, #24]
	transfer->callback_param = param;
}
    907a:	pop	{r4, r5, r6, r7}
    907c:	bx	lr
    907e:	nop

00009080 <usb_transmit>:
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    9080:	subs	r3, r0, #2
    9082:	cmp	r3, #3
    9084:	bls.n	9088 <usb_transmit+0x8>
    9086:	bx	lr
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
    9088:	push	{r4, r5}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    908a:	ldr	r3, [pc, #24]	; (90a4 <usb_transmit+0x24>)
    908c:	add.w	r4, r0, #16
    9090:	movs	r5, #1
    9092:	mov	r2, r1
    9094:	add.w	r0, r3, r0, lsl #7
    9098:	lsl.w	r1, r5, r4
}
    909c:	pop	{r4, r5}
void usb_transmit(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
    909e:	b.w	87cc <schedule_transfer>
    90a2:	nop
    90a4:	.word	0x2000d040

000090a8 <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    90a8:	subs	r3, r0, #2
    90aa:	cmp	r3, #3
    90ac:	bls.n	90b0 <usb_receive+0x8>
    90ae:	bx	lr
	uint32_t mask = 1 << (endpoint_number + 16);
	schedule_transfer(endpoint, mask, transfer);
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
    90b0:	push	{r4}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    90b2:	ldr	r3, [pc, #20]	; (90c8 <usb_receive+0x20>)
    90b4:	movs	r4, #1
    90b6:	mov	r2, r1
    90b8:	lsl.w	r1, r4, r0
    90bc:	add.w	r0, r3, r0, lsl #7
}
    90c0:	ldr.w	r4, [sp], #4
void usb_receive(int endpoint_number, transfer_t *transfer)
{
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    90c4:	b.w	87cc <schedule_transfer>
    90c8:	.word	0x2000d000

000090cc <usb_transfer_status>:
uint32_t usb_transfer_status(const transfer_t *transfer)
{
#if defined(USB_MTPDISK) || defined(USB_MTPDISK_SERIAL)
	uint32_t status, cmd;
	//int count=0;
	cmd = USB1_USBCMD;
    90cc:	ldr	r2, [pc, #32]	; (90f0 <usb_transfer_status+0x24>)
    90ce:	ldr.w	r3, [r2, #320]	; 0x140
	while (1) {
		__disable_irq();
    90d2:	cpsid	i
		USB1_USBCMD = cmd | USB_USBCMD_ATDTW;
    90d4:	orr.w	r3, r3, #16384	; 0x4000
    90d8:	str.w	r3, [r2, #320]	; 0x140
		status = transfer->status;
    90dc:	ldr	r1, [r0, #4]
		cmd = USB1_USBCMD;
    90de:	ldr.w	r3, [r2, #320]	; 0x140
		__enable_irq();
    90e2:	cpsie	i
		if (cmd & USB_USBCMD_ATDTW) return status;
    90e4:	tst.w	r3, #16384	; 0x4000
    90e8:	beq.n	90d2 <usb_transfer_status+0x6>
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
#endif
}
    90ea:	mov	r0, r1
    90ec:	bx	lr
    90ee:	nop
    90f0:	.word	0x402e0000

000090f4 <delay>:

void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
    90f4:	cmp	r0, #0
    90f6:	beq.n	91a8 <delay+0xb4>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    90f8:	movs	r2, #1
{

}*/

void delay(uint32_t msec)
{
    90fa:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    90fe:	sub	sp, #20
    9100:	mov	fp, r0
    9102:	ldr	r4, [pc, #168]	; (91ac <delay+0xb8>)
    9104:	ldr	r5, [pc, #168]	; (91b0 <delay+0xbc>)
    9106:	ldr	r6, [pc, #172]	; (91b4 <delay+0xc0>)
    9108:	ldrd	r8, r9, [sp, #8]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    910c:	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    9110:	ldr	r0, [r5, #0]
		scc = systick_cycle_count;
    9112:	ldr	r3, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    9114:	strex	r1, r2, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    9118:	cmp	r1, #0
    911a:	bne.n	910c <delay+0x18>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    911c:	ldr	r7, [pc, #152]	; (91b8 <delay+0xc4>)
    911e:	strd	r8, r9, [sp, #8]
    9122:	ldr	r2, [r7, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    9124:	subs	r3, r2, r3
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    9126:	ldr	r2, [pc, #148]	; (91bc <delay+0xc8>)
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    9128:	mov.w	lr, #1000	; 0x3e8
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    912c:	str	r7, [sp, #4]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    912e:	ldr	r2, [r2, #0]
    9130:	movs	r7, #1
    9132:	umull	r2, r3, r3, r2
	if (frac > 1000) frac = 1000;
    9136:	mov.w	r2, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    913a:	mov	r8, r3
	if (frac > 1000) frac = 1000;
    913c:	movs	r3, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    913e:	cmp	r3, r1
    9140:	it	eq
    9142:	cmpeq	r2, r8
    9144:	ite	cs
    9146:	movcs	sl, r8
    9148:	movcc	sl, lr
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
    914a:	mla	sl, lr, r0, sl
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    914e:	ldrex	r3, [r4]
uint32_t micros(void)
{
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    9152:	ldr	r2, [r5, #0]
		scc = systick_cycle_count;
    9154:	ldr	r1, [r6, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    9156:	strex	r3, r7, [r4]
	} while ( __STREXW(1, &systick_safe_read));
    915a:	cmp	r3, #0
    915c:	bne.n	914e <delay+0x5a>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    915e:	ldr	r0, [sp, #4]
    9160:	ldr	r0, [r0, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    9162:	subs	r1, r0, r1
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    9164:	ldr	r0, [pc, #84]	; (91bc <delay+0xc8>)
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    9166:	mov.w	lr, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    916a:	ldr	r0, [r0, #0]
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    916c:	mul.w	r2, lr, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    9170:	umull	r0, r1, r1, r0
	if (frac > 1000) frac = 1000;
    9174:	mov.w	r0, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    9178:	rsb	r2, sl, r2
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    917c:	mov	r8, r1
	if (frac > 1000) frac = 1000;
    917e:	movs	r1, #0
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    9180:	cmp	r1, r3
    9182:	it	eq
    9184:	cmpeq	r0, r8
    9186:	ite	cs
    9188:	movcs	r3, r8
    918a:	movcc	r3, lr
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    918c:	add	r2, r3
    918e:	cmp	r2, lr
    9190:	bcc.n	91a2 <delay+0xae>
			if (--msec == 0) return;
    9192:	subs.w	fp, fp, #1
			start += 1000;
    9196:	add.w	sl, sl, #1000	; 0x3e8

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
    919a:	bne.n	914e <delay+0x5a>
			start += 1000;
		}
		yield();
	}
	// TODO...
}
    919c:	add	sp, #20
    919e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
    91a2:	bl	9ea4 <yield>
	}
    91a6:	b.n	914e <delay+0x5a>
    91a8:	bx	lr
    91aa:	nop
    91ac:	.word	0x2000d300
    91b0:	.word	0x2000b144
    91b4:	.word	0x2000b13c
    91b8:	.word	0xe0001004
    91bc:	.word	0x2000b140

000091c0 <micros>:
	// TODO...
}

uint32_t micros(void)
{
    91c0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
    91c4:	ldr	r2, [pc, #72]	; (9210 <micros+0x50>)
    91c6:	movs	r6, #1
    91c8:	ldr	r5, [pc, #72]	; (9214 <micros+0x54>)
    91ca:	ldr	r4, [pc, #76]	; (9218 <micros+0x58>)
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    91cc:	ldrex	r3, [r2]
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    91d0:	ldr	r1, [r5, #0]
		scc = systick_cycle_count;
    91d2:	ldr	r0, [r4, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    91d4:	strex	r3, r6, [r2]
	} while ( __STREXW(1, &systick_safe_read));
    91d8:	cmp	r3, #0
    91da:	bne.n	91cc <micros+0xc>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    91dc:	ldr	r2, [pc, #60]	; (921c <micros+0x5c>)
    91de:	ldr	r6, [r2, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    91e0:	ldr	r7, [pc, #60]	; (9220 <micros+0x60>)
		smc = systick_millis_count;
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    91e2:	subs	r2, r6, r0
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
	if (frac > 1000) frac = 1000;
    91e4:	mov.w	r9, #0
    91e8:	mov.w	r8, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    91ec:	ldr	r6, [r7, #0]
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
	return usec;
    91ee:	mov.w	r0, #1000	; 0x3e8
		scc = systick_cycle_count;
	} while ( __STREXW(1, &systick_safe_read));
	uint32_t cyccnt = ARM_DWT_CYCCNT;
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    91f2:	cmp	r9, r3
    91f4:	umull	r6, r7, r2, r6
    91f8:	it	eq
    91fa:	cmpeq	r8, r7
    91fc:	mov	r4, r7
    91fe:	ite	cs
    9200:	movcs	r4, r7
    9202:	movcc	r4, r0
	if (frac > 1000) frac = 1000;
	uint32_t usec = 1000*smc + frac;
	return usec;
}
    9204:	mla	r0, r0, r1, r4
    9208:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
    920c:	bx	lr
    920e:	nop
    9210:	.word	0x2000d300
    9214:	.word	0x2000b144
    9218:	.word	0x2000b13c
    921c:	.word	0xe0001004
    9220:	.word	0x2000b140

00009224 <unused_interrupt_vector>:
//  R0
// Code from :: https://community.nxp.com/thread/389002
__attribute__((naked))
void unused_interrupt_vector(void)
{
  __asm( ".syntax unified\n"
    9224:	movs	r0, #4
    9226:	mov	r1, lr
    9228:	tst	r0, r1
    922a:	beq.n	9234 <_MSP>
    922c:	mrs	r0, PSP
    9230:	b.w	9244 <HardFault_HandlerC>

00009234 <_MSP>:
    9234:	mrs	r0, MSP
    9238:	b.w	9244 <HardFault_HandlerC>

0000923c <startup_default_early_hook>:
         "B HardFault_HandlerC \n"
         "_MSP: \n"
         "MRS R0, MSP \n"
         "B HardFault_HandlerC \n"
         ".syntax divided\n") ;
}
    923c:	bx	lr
    923e:	nop

00009240 <startup_default_late_hook>:
#endif

extern int main (void);
void startup_default_early_hook(void) {}
void startup_early_hook(void)		__attribute__ ((weak, alias("startup_default_early_hook")));
void startup_default_late_hook(void) {}
    9240:	bx	lr
    9242:	nop

00009244 <HardFault_HandlerC>:
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    9244:	ldr	r3, [pc, #108]	; (92b4 <HardFault_HandlerC+0x70>)
  printf(" _AFSR ::  %x\n", _AFSR);
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
    9246:	movs	r1, #5
    9248:	ldr	r2, [pc, #108]	; (92b8 <HardFault_HandlerC+0x74>)
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
    924a:	movs	r0, #56	; 0x38
         ".syntax divided\n") ;
}

__attribute__((weak))
void HardFault_HandlerC(unsigned int *hardfault_args)
{
    924c:	push	{r4, r5, lr}
  printf(" _AFSR ::  %x\n", _AFSR);
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
    924e:	str.w	r1, [r2, #328]	; 0x148
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
  GPIO2_DR_SET = (1 << 3);
    9252:	movs	r1, #8
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
    9254:	str.w	r0, [r2, #824]	; 0x338
         ".syntax divided\n") ;
}

__attribute__((weak))
void HardFault_HandlerC(unsigned int *hardfault_args)
{
    9258:	sub	sp, #12
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    925a:	ldr	r2, [r3, #4]
  GPIO2_DR_SET = (1 << 3);
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);

  if ( F_CPU_ACTUAL >= 600000000 )
    925c:	ldr	r4, [pc, #92]	; (92bc <HardFault_HandlerC+0x78>)
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    925e:	orrs	r2, r1
  GPIO2_DR_SET = (1 << 3);
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);

  if ( F_CPU_ACTUAL >= 600000000 )
    9260:	ldr	r0, [pc, #92]	; (92c0 <HardFault_HandlerC+0x7c>)
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
  GPIO2_GDIR |= (1 << 3);
    9262:	str	r2, [r3, #4]
  GPIO2_DR_SET = (1 << 3);
    9264:	str.w	r1, [r3, #132]	; 0x84
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    9268:	str.w	r1, [r3, #136]	; 0x88

  if ( F_CPU_ACTUAL >= 600000000 )
    926c:	ldr	r3, [r4, #0]
    926e:	cmp	r3, r0
    9270:	bls.n	9278 <HardFault_HandlerC+0x34>
    set_arm_clock(300000000);
    9272:	ldr	r0, [pc, #80]	; (92c4 <HardFault_HandlerC+0x80>)
    9274:	bl	a1ac <set_arm_clock>

  while (1)
  {
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
    9278:	ldr	r5, [pc, #56]	; (92b4 <HardFault_HandlerC+0x70>)
    927a:	movs	r4, #8
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 2000000/2; nn++) ;
    927c:	movs	r0, #0
    927e:	ldr	r2, [pc, #72]	; (92c8 <HardFault_HandlerC+0x84>)
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    // digitalWrite(13, LOW);
    for (nn = 0; nn < 18000000/2; nn++) ;
    9280:	ldr	r1, [pc, #72]	; (92cc <HardFault_HandlerC+0x88>)
  if ( F_CPU_ACTUAL >= 600000000 )
    set_arm_clock(300000000);

  while (1)
  {
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
    9282:	str.w	r4, [r5, #132]	; 0x84
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 2000000/2; nn++) ;
    9286:	str	r0, [sp, #4]
    9288:	ldr	r3, [sp, #4]
    928a:	cmp	r3, r2
    928c:	bhi.n	929a <HardFault_HandlerC+0x56>
    928e:	ldr	r3, [sp, #4]
    9290:	adds	r3, #1
    9292:	str	r3, [sp, #4]
    9294:	ldr	r3, [sp, #4]
    9296:	cmp	r3, r2
    9298:	bls.n	928e <HardFault_HandlerC+0x4a>
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    929a:	str.w	r4, [r5, #136]	; 0x88
    // digitalWrite(13, LOW);
    for (nn = 0; nn < 18000000/2; nn++) ;
    929e:	str	r0, [sp, #4]
    92a0:	ldr	r3, [sp, #4]
    92a2:	cmp	r3, r1
    92a4:	bhi.n	9282 <HardFault_HandlerC+0x3e>
    92a6:	ldr	r3, [sp, #4]
    92a8:	adds	r3, #1
    92aa:	str	r3, [sp, #4]
    92ac:	ldr	r3, [sp, #4]
    92ae:	cmp	r3, r1
    92b0:	bls.n	92a6 <HardFault_HandlerC+0x62>
    92b2:	b.n	9282 <HardFault_HandlerC+0x3e>
    92b4:	.word	0x401bc000
    92b8:	.word	0x401f8000
    92bc:	.word	0x20000bc0
    92c0:	.word	0x23c345ff
    92c4:	.word	0x11e1a300
    92c8:	.word	0x000f423f
    92cc:	.word	0x0089543f

000092d0 <_sbrk>:

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
        char *prev = __brkval;
    92d0:	ldr	r2, [pc, #36]	; (92f8 <_sbrk+0x28>)
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
    92d2:	push	{r3, lr}
        char *prev = __brkval;
    92d4:	ldr	r3, [r2, #0]
        if (incr != 0) {
    92d6:	cbz	r0, 92e2 <_sbrk+0x12>
                if (prev + incr > (char *)&_heap_end) {
    92d8:	add	r0, r3
    92da:	ldr	r1, [pc, #32]	; (92fc <_sbrk+0x2c>)
    92dc:	cmp	r0, r1
    92de:	bhi.n	92e6 <_sbrk+0x16>
                        errno = ENOMEM;
                        return (void *)-1;
                }
                __brkval = prev + incr;
    92e0:	str	r0, [r2, #0]
        }
        return prev;
}
    92e2:	mov	r0, r3
    92e4:	pop	{r3, pc}
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    92e6:	bl	b07c <__errno>
    92ea:	movs	r2, #12
                        return (void *)-1;
    92ec:	mov.w	r3, #4294967295
void * _sbrk(int incr)
{
        char *prev = __brkval;
        if (incr != 0) {
                if (prev + incr > (char *)&_heap_end) {
                        errno = ENOMEM;
    92f0:	str	r2, [r0, #0]
                        return (void *)-1;
                }
                __brkval = prev + incr;
        }
        return prev;
}
    92f2:	mov	r0, r3
    92f4:	pop	{r3, pc}
    92f6:	nop
    92f8:	.word	0x20000b7c
    92fc:	.word	0x20280000

00009300 <rtc_get>:
#include "debug/printf.h"


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
    9300:	ldr	r3, [pc, #40]	; (932c <rtc_get+0x2c>)
#include "imxrt.h"
#include "debug/printf.h"


unsigned long rtc_get(void)
{
    9302:	push	{r4, r5}
	uint32_t hi1 = SNVS_HPRTCMR;
    9304:	ldr	r0, [r3, #36]	; 0x24
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    9306:	mov	r4, r3


unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
    9308:	ldr	r1, [r3, #40]	; 0x28
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    930a:	ldr	r2, [r4, #36]	; 0x24
		uint32_t lo2 = SNVS_HPRTCLR;
    930c:	ldr	r3, [r4, #40]	; 0x28
		if (lo1 == lo2 && hi1 == hi2) {
    930e:	cmp	r1, r3
    9310:	it	eq
    9312:	cmpeq	r0, r2
unsigned long rtc_get(void)
{
	uint32_t hi1 = SNVS_HPRTCMR;
	uint32_t lo1 = SNVS_HPRTCLR;
	while (1) {
		uint32_t hi2 = SNVS_HPRTCMR;
    9314:	mov	r0, r2
		uint32_t lo2 = SNVS_HPRTCLR;
    9316:	mov	r1, r3
		if (lo1 == lo2 && hi1 == hi2) {
    9318:	ite	eq
    931a:	moveq	r5, #1
    931c:	movne	r5, #0
    931e:	cmp	r5, #0
    9320:	beq.n	930a <rtc_get+0xa>
			return (hi2 << 17) | (lo2 >> 15);
    9322:	lsrs	r1, r3, #15
		}
		hi1 = hi2;
		lo1 = lo2;
	}
}
    9324:	pop	{r4, r5}
    9326:	orr.w	r0, r1, r2, lsl #17
    932a:	bx	lr
    932c:	.word	0x400d4000

00009330 <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    9330:	push	{r4, r5, r6, r7}
    9332:	subs	r6, r1, #1
	unsigned digit;
	int i=0, j;
    9334:	movs	r5, #0
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    9336:	mov	r7, r6
    9338:	b.n	933c <ultoa+0xc>
	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
		val /= radix;
		if (val == 0) break;
		i++;
    933a:	adds	r5, #1
	unsigned digit;
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
    933c:	udiv	r3, r0, r2
    9340:	mls	r0, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9344:	add.w	r4, r0, #55	; 0x37
    9348:	cmp	r0, #9
    934a:	add.w	r0, r0, #48	; 0x30
    934e:	uxtb	r4, r4
    9350:	it	ls
    9352:	uxtbls	r4, r0
		val /= radix;
		if (val == 0) break;
    9354:	mov	r0, r3
	int i=0, j;
	char t;

	while (1) {
		digit = val % radix;
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    9356:	strb.w	r4, [r7, #1]!
		val /= radix;
		if (val == 0) break;
    935a:	cmp	r3, #0
    935c:	bne.n	933a <ultoa+0xa>
		i++;
	}
	buf[i + 1] = 0;
    935e:	adds	r2, r1, r5
    9360:	strb	r3, [r2, #1]
	for (j=0; j < i; j++, i--) {
    9362:	cbz	r5, 9378 <ultoa+0x48>
    9364:	adds	r3, #1
		t = buf[j];
    9366:	ldrb.w	r4, [r6, #1]!
		buf[j] = buf[i];
    936a:	ldrb	r7, [r2, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    936c:	subs	r0, r5, r3
		t = buf[j];
		buf[j] = buf[i];
    936e:	strb	r7, [r6, #0]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    9370:	cmp	r3, r0
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
    9372:	strb.w	r4, [r2], #-1
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    9376:	blt.n	9364 <ultoa+0x34>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    9378:	mov	r0, r1
    937a:	pop	{r4, r5, r6, r7}
    937c:	bx	lr
    937e:	nop

00009380 <dtostrf>:
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
    9380:	vcmp.f32	s0, s0
{
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    9384:	eor.w	r3, r0, r0, asr #31
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    9388:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
    938c:	vmrs	APSR_nzcv, fpscr
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    9390:	mov	r5, r0
    9392:	mov	r4, r2
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
    9394:	sub.w	r3, r3, r0, asr #31
char * fcvtf(float, int, int *, int *);
int isnanf (float x);
int isinff (float x);

char * dtostrf(float val, int width, unsigned int precision, char *buf)
{
    9398:	vpush	{d8}
    939c:	vmov.f32	s16, s0
    93a0:	sub	sp, #16
	int decpt, sign, reqd, pad;
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
    93a2:	bvs.w	95ec <dtostrf+0x26c>
			awidth--;
		}
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
    93a6:	vabs.f32	s15, s0
    93aa:	vldr	s14, [pc, #792]	; 96c4 <dtostrf+0x344>
    93ae:	vcmp.f32	s15, s14
    93b2:	vmrs	APSR_nzcv, fpscr
    93b6:	ble.n	943e <dtostrf+0xbe>
		int ndigs = (val<0) ? 4 : 3;
    93b8:	vcmpe.f32	s0, #0.0
    93bc:	vmrs	APSR_nzcv, fpscr
    93c0:	ite	mi
    93c2:	movmi	r2, #4
    93c4:	movpl	r2, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    93c6:	cmp	r2, r3
    93c8:	blt.n	940e <dtostrf+0x8e>
		if (width<0) {
    93ca:	cmp	r0, #0
    93cc:	blt.w	96b0 <dtostrf+0x330>
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    93d0:	movs	r2, #0
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    93d2:	vcmpe.f32	s16, #0.0
    93d6:	vmrs	APSR_nzcv, fpscr
    93da:	bmi.w	9672 <dtostrf+0x2f2>
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    93de:	movs	r5, #73	; 0x49
    93e0:	movs	r0, #78	; 0x4e
    93e2:	movs	r1, #70	; 0x46
    93e4:	adds	r3, r4, #3
    93e6:	strb	r5, [r4, #0]
    93e8:	strb	r0, [r4, #1]
    93ea:	strb	r1, [r4, #2]
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    93ec:	cmp	r2, #0
    93ee:	beq.w	96c0 <dtostrf+0x340>
    93f2:	add	r2, r3
			*buf++ = ' ';
    93f4:	movs	r1, #32
    93f6:	strb.w	r1, [r3], #1
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
		} else {
			*buf++ = 'i';  *buf++ = 'n';  *buf++ = 'f';
		}
		while (awidth) {
    93fa:	cmp	r2, r3
    93fc:	bne.n	93f6 <dtostrf+0x76>
			*buf++ = ' ';
			awidth--;
		}
		*buf = 0;
    93fe:	movs	r3, #0
		return buf;
    9400:	mov	r0, r2
		}
		while (awidth) {
			*buf++ = ' ';
			awidth--;
		}
		*buf = 0;
    9402:	strb	r3, [r2, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    9404:	add	sp, #16
    9406:	vpop	{d8}
    940a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    940e:	cmp	r0, #0
		*buf = 0;
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    9410:	sub.w	r2, r3, r2
		if (width<0) {
    9414:	bge.n	93d2 <dtostrf+0x52>
			while (awidth) {
    9416:	cmp	r2, #0
    9418:	beq.w	96b0 <dtostrf+0x330>
    941c:	adds	r3, r4, r2
				*buf++ = ' ';
    941e:	movs	r2, #32
    9420:	strb.w	r2, [r4], #1
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    9424:	cmp	r4, r3
    9426:	bne.n	9420 <dtostrf+0xa0>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
    9428:	vcmpe.f32	s16, #0.0
    942c:	vmrs	APSR_nzcv, fpscr
    9430:	bpl.w	9662 <dtostrf+0x2e2>
    9434:	movs	r2, #0
    9436:	movs	r1, #45	; 0x2d
    9438:	adds	r4, r3, #1
    943a:	strb	r1, [r3, #0]
    943c:	b.n	93de <dtostrf+0x5e>
    943e:	mov	r7, r1
		}
		*buf = 0;
		return buf;
	}

	s = fcvtf(val, precision, &decpt, &sign);
    9440:	add	r2, sp, #8
    9442:	add	r1, sp, #4
    9444:	mov	r0, r7
    9446:	mov	sl, r7
    9448:	bl	b058 <fcvtf>

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    944c:	ldr.w	r9, [sp, #4]
		}
		*buf = 0;
		return buf;
	}

	s = fcvtf(val, precision, &decpt, &sign);
    9450:	mov	r8, r0

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    9452:	cmp	r7, #0
    9454:	beq.w	9566 <dtostrf+0x1e6>
    9458:	rsb	r3, r9, #0
		s = (*s < '5') ? "0" : "1";
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
    945c:	cmp	r3, r7
    945e:	bgt.w	95da <dtostrf+0x25a>
    9462:	mov	r0, r8
    9464:	bl	c080 <strlen>
    9468:	mov	r6, r0
	}

	reqd = strlen(s);

	// add 1 for decimal point
	if (reqd > decpt) reqd++;
    946a:	cmp	r9, r6
    946c:	it	lt
    946e:	addlt	r6, #1

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    9470:	cmp.w	r9, #0
    9474:	beq.w	95d6 <dtostrf+0x256>

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
    9478:	cmp.w	r9, #0
    947c:	bge.n	94c4 <dtostrf+0x144>
    947e:	cbz	r7, 94c4 <dtostrf+0x144>
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;

		if (strlen(s) > precision + decpt) {
    9480:	add.w	r3, r9, r7
	if (decpt == 0) reqd++;

	// if leading zeros after decimal point
	if (decpt < 0 && precision > 0) {
		// ensure enough trailing zeros, add 2 for '0.'
		reqd = precision + 2;
    9484:	adds	r6, r7, #2

		if (strlen(s) > precision + decpt) {
    9486:	cmp	r3, r0
    9488:	bcs.n	94c4 <dtostrf+0x144>

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    948a:	cmp	r7, #0
    948c:	ble.n	949c <dtostrf+0x11c>
				val *= 10.0f;
    948e:	vmov.f32	s15, #36	; 0x41200000  10.0

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    9492:	subs.w	sl, sl, #1
				val *= 10.0f;
    9496:	vmul.f32	s16, s16, s15

			int newPrecision = precision;
			int newDecimalPoint;

			// shift decimal point
			while (newPrecision > 0) {
    949a:	bne.n	9492 <dtostrf+0x112>
				val *= 10.0f;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    949c:	add	r2, sp, #8
    949e:	mov	r0, sl
    94a0:	vmov.f32	s0, s16
    94a4:	add	r1, sp, #12
    94a6:	bl	b058 <fcvtf>

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    94aa:	ldr.w	r9, [sp, #4]
    94ae:	ldr	r2, [sp, #12]
    94b0:	adds	r3, r7, #1
				val *= 10.0f;
				newPrecision--;
			}

			// round after accounting for leading 0's
			s = fcvtf(val, newPrecision, &newDecimalPoint, &sign);
    94b2:	mov	r8, r0

			// if rounded up to new digit (e.g. 0.09 to 0.1), move decimal point
			if (newDecimalPoint - decpt == precision + 1) decpt++;
    94b4:	rsb	r2, r9, r2
    94b8:	cmp	r2, r3
    94ba:	bne.n	94c4 <dtostrf+0x144>
    94bc:	add.w	r9, r9, #1
    94c0:	str.w	r9, [sp, #4]
		}
	}

	// add 1 for sign if negative
	if (sign) reqd++;
    94c4:	ldr.w	lr, [sp, #8]
    94c8:	cmp.w	lr, #0
    94cc:	beq.n	958c <dtostrf+0x20c>
    94ce:	adds	r6, #1

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    94d0:	subs	r0, r5, r6

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    94d2:	adds	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    94d4:	cmp	r0, #0
    94d6:	bgt.n	9596 <dtostrf+0x216>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    94d8:	mov	r2, r4
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
	}
	if (sign) *p++ = '-';
    94da:	movs	r0, #45	; 0x2d
    94dc:	adds	r3, r2, #1
    94de:	strb	r0, [r2, #0]
	if (decpt == 0 && precision > 0) {
    94e0:	cmp.w	r9, #0
    94e4:	beq.n	95c2 <dtostrf+0x242>
		*p++ = '0';
		*p++ = '.';
	}
	else if (decpt < 0 && precision > 0) {
    94e6:	cbz	r7, 950a <dtostrf+0x18a>
    94e8:	cmp.w	r9, #0
    94ec:	bge.n	950a <dtostrf+0x18a>
		*p++ = '0';
    94ee:	mov	r2, r3
    94f0:	movs	r0, #48	; 0x30
		*p++ = '.';
    94f2:	movs	r7, #46	; 0x2e
	if (decpt == 0 && precision > 0) {
		*p++ = '0';
		*p++ = '.';
	}
	else if (decpt < 0 && precision > 0) {
		*p++ = '0';
    94f4:	strb.w	r0, [r2], #2
		*p++ = '.';
    94f8:	strb	r7, [r3, #1]
    94fa:	rsb	r3, r9, r2
		// print leading zeros
		while ( decpt < 0 ) {
			decpt++;
			*p++ = '0';
    94fe:	strb.w	r0, [r2], #1
	}
	else if (decpt < 0 && precision > 0) {
		*p++ = '0';
		*p++ = '.';
		// print leading zeros
		while ( decpt < 0 ) {
    9502:	cmp	r2, r3
    9504:	bne.n	94fe <dtostrf+0x17e>
    9506:	movs	r2, #0
    9508:	str	r2, [sp, #4]
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    950a:	cmp	r3, r1
    950c:	bcs.n	9550 <dtostrf+0x1d0>
		*p++ = *s++;
    950e:	adds	r7, r3, #1
    9510:	ldrb.w	r2, [r8]
    9514:	add.w	r8, r8, #1
		if (p == e) break;
    9518:	cmp	r7, r1
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
		*p++ = *s++;
    951a:	strb	r2, [r3, #0]
		if (p == e) break;
    951c:	beq.n	9552 <dtostrf+0x1d2>
    951e:	ldr	r2, [sp, #4]
		if (--decpt == 0) *p++ = '.';
    9520:	mov.w	lr, #46	; 0x2e
    9524:	b.n	953e <dtostrf+0x1be>
    9526:	strb.w	lr, [r3, #1]
    952a:	adds	r3, #2
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    952c:	cmp	r3, r1
		*p++ = *s++;
    952e:	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    9532:	bcs.n	9550 <dtostrf+0x1d0>
		*p++ = *s++;
    9534:	ldrb.w	r0, [r8], #1
		if (p == e) break;
    9538:	cmp	r7, r1
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
		*p++ = *s++;
    953a:	strb	r0, [r3, #0]
		if (p == e) break;
    953c:	beq.n	9552 <dtostrf+0x1d2>
		if (--decpt == 0) *p++ = '.';
    953e:	subs	r2, #1
    9540:	str	r2, [sp, #4]
    9542:	cmp	r2, #0
    9544:	beq.n	9526 <dtostrf+0x1a6>
    9546:	mov	r3, r7
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    9548:	cmp	r3, r1
		*p++ = *s++;
    954a:	add.w	r7, r3, #1
			decpt++;
			*p++ = '0';
		}
	}
	// print digits
	while (p < e) {
    954e:	bcc.n	9534 <dtostrf+0x1b4>
    9550:	mov	r1, r3
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
    9552:	cmp	r5, #0
    9554:	blt.n	963a <dtostrf+0x2ba>
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    9556:	movs	r3, #0

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
    9558:	mov	r0, r4
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
		while (pad-- > 0) *p++ = ' ';
	}
	*p = 0;
    955a:	strb	r3, [r1, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    955c:	add	sp, #16
    955e:	vpop	{d8}
    9562:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	}

	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
    9566:	cmp.w	r9, #0
    956a:	bne.w	9458 <dtostrf+0xd8>
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
		decpt++;
    956e:	movs	r3, #1
	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    9570:	ldrb.w	r8, [r0]
    9574:	ldr	r1, [pc, #336]	; (96c8 <dtostrf+0x348>)
    9576:	ldr	r2, [pc, #340]	; (96cc <dtostrf+0x34c>)
		decpt++;
    9578:	mov	r9, r3
    957a:	str	r3, [sp, #4]
    957c:	mov.w	r3, #4294967295
	s = fcvtf(val, precision, &decpt, &sign);

	// if only 1 digit in output
	if (precision == 0 && decpt == 0) {
		// round and move decimal point
		s = (*s < '5') ? "0" : "1";
    9580:	cmp.w	r8, #52	; 0x34
    9584:	ite	hi
    9586:	movhi	r8, r1
    9588:	movls	r8, r2
    958a:	b.n	945c <dtostrf+0xdc>
	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
	pad = width - reqd;
    958c:	subs	r0, r5, r6

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
	e = p + reqd;
    958e:	adds	r1, r4, r6
	pad = width - reqd;
	if (pad > 0) {
    9590:	cmp	r0, #0
    9592:	ble.w	96bc <dtostrf+0x33c>
		e += pad;
    9596:	add	r1, r0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    9598:	mov	r2, r4
	p = buf;
	e = p + reqd;
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
    959a:	subs	r0, #1
    959c:	mov.w	ip, #32
    95a0:	strb.w	ip, [r2], #1
    95a4:	rsb	r3, r2, #1
    95a8:	add	r3, r0
    95aa:	add	r3, r4
    95ac:	cmp	r3, #0
    95ae:	bgt.n	95a0 <dtostrf+0x220>
    95b0:	bic.w	r3, r0, r0, asr #31
    95b4:	adds	r3, #1
    95b6:	add	r3, r4
	}
	if (sign) *p++ = '-';
    95b8:	cmp.w	lr, #0
    95bc:	beq.n	94e0 <dtostrf+0x160>
	p = buf;
	e = p + reqd;
	pad = width - reqd;
	if (pad > 0) {
		e += pad;
		while (pad-- > 0) *p++ = ' ';
    95be:	mov	r2, r3
    95c0:	b.n	94da <dtostrf+0x15a>
	}
	if (sign) *p++ = '-';
	if (decpt == 0 && precision > 0) {
    95c2:	cmp	r7, #0
    95c4:	beq.n	950a <dtostrf+0x18a>
		*p++ = '0';
    95c6:	mov	r2, r3
    95c8:	movs	r7, #48	; 0x30
		*p++ = '.';
    95ca:	movs	r0, #46	; 0x2e
		e += pad;
		while (pad-- > 0) *p++ = ' ';
	}
	if (sign) *p++ = '-';
	if (decpt == 0 && precision > 0) {
		*p++ = '0';
    95cc:	strb.w	r7, [r2], #2
		*p++ = '.';
    95d0:	strb	r0, [r3, #1]
    95d2:	mov	r3, r2
    95d4:	b.n	950a <dtostrf+0x18a>

	// add 1 for decimal point
	if (reqd > decpt) reqd++;

	// add 1 for zero in front of decimal point
	if (decpt == 0) reqd++;
    95d6:	adds	r6, #1
    95d8:	b.n	94c4 <dtostrf+0x144>
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
		decpt = -precision;
    95da:	movs	r6, #1
    95dc:	rsb	r9, r7, #0
		decpt++;
	}

	// if all zeros, limit to precision
	if (-decpt  > (int)precision) {
		s = "0";
    95e0:	ldr.w	r8, [pc, #232]	; 96cc <dtostrf+0x34c>
		decpt = -precision;
    95e4:	mov	r0, r6
    95e6:	str.w	r9, [sp, #4]
    95ea:	b.n	946a <dtostrf+0xea>
	const char *s, *e;
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
    95ec:	vcmpe.f32	s0, #0.0
    95f0:	vmrs	APSR_nzcv, fpscr
    95f4:	ite	mi
    95f6:	movmi	r2, #4
    95f8:	movpl	r2, #3
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    95fa:	cmp	r2, r3
    95fc:	bge.n	9676 <dtostrf+0x2f6>
		if (width<0) {
    95fe:	cmp	r0, #0
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    9600:	sub.w	r3, r3, r2
		if (width<0) {
    9604:	blt.n	9688 <dtostrf+0x308>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    9606:	vmov	r2, s16
    960a:	cmp	r2, #0
    960c:	blt.n	967e <dtostrf+0x2fe>
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    960e:	movs	r1, #78	; 0x4e
    9610:	movs	r0, #65	; 0x41
    9612:	adds	r2, r4, #3
    9614:	strb	r1, [r4, #0]
    9616:	strb	r1, [r4, #2]
    9618:	strb	r0, [r4, #1]
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    961a:	cmp	r3, #0
    961c:	beq.n	96b8 <dtostrf+0x338>
    961e:	add	r3, r2
			*buf++ = ' ';
    9620:	movs	r1, #32
    9622:	strb.w	r1, [r2], #1
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
		} else {
			*buf++ = 'n';  *buf++ = 'a';  *buf++ = 'n';
		}
		while (awidth) {
    9626:	cmp	r2, r3
    9628:	bne.n	9622 <dtostrf+0x2a2>
			*buf++ = ' ';
			awidth--;
		}
		*buf = 0;
    962a:	movs	r2, #0
		return buf;
    962c:	mov	r0, r3
		}
		while (awidth) {
			*buf++ = ' ';
			awidth--;
		}
		*buf = 0;
    962e:	strb	r2, [r3, #0]

	//char format[20];
	//sprintf(format, "%%%d.%df", width, precision);
	//sprintf(buf, format, val);
	return buf;
}
    9630:	add	sp, #16
    9632:	vpop	{d8}
    9636:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		*p++ = *s++;
		if (p == e) break;
		if (--decpt == 0) *p++ = '.';
	}
	if (width < 0) {
		pad = (reqd + width) * -1;
    963a:	adds	r0, r5, r6
		while (pad-- > 0) *p++ = ' ';
    963c:	negs	r3, r0
    963e:	mvns	r0, r0
    9640:	cmp	r3, #0
    9642:	ble.n	9556 <dtostrf+0x1d6>
    9644:	mov	r2, r1
    9646:	movs	r5, #32
    9648:	strb.w	r5, [r2], #1
    964c:	rsb	r3, r2, #1
    9650:	add	r3, r0
    9652:	add	r3, r1
    9654:	cmp	r3, #0
    9656:	bgt.n	9648 <dtostrf+0x2c8>
    9658:	bic.w	r3, r0, r0, asr #31
    965c:	adds	r3, #1
    965e:	add	r1, r3
    9660:	b.n	9556 <dtostrf+0x1d6>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    9662:	movs	r4, #73	; 0x49
    9664:	movs	r0, #78	; 0x4e
    9666:	movs	r1, #70	; 0x46
    9668:	adds	r2, r3, #3
    966a:	strb	r4, [r3, #0]
    966c:	strb	r0, [r3, #1]
    966e:	strb	r1, [r3, #2]
    9670:	b.n	93fe <dtostrf+0x7e>
    9672:	mov	r3, r4
    9674:	b.n	9436 <dtostrf+0xb6>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    9676:	cmp	r0, #0
    9678:	blt.n	96ac <dtostrf+0x32c>
	char *p;

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
    967a:	movs	r3, #0
    967c:	b.n	9606 <dtostrf+0x286>
    967e:	mov	r2, r4
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    9680:	movs	r1, #45	; 0x2d
    9682:	adds	r4, r2, #1
    9684:	strb	r1, [r2, #0]
    9686:	b.n	960e <dtostrf+0x28e>
	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    9688:	cbz	r3, 96ac <dtostrf+0x32c>
    968a:	adds	r2, r4, r3
				*buf++ = ' ';
    968c:	movs	r3, #32
    968e:	strb.w	r3, [r4], #1
	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
			while (awidth) {
    9692:	cmp	r4, r2
    9694:	bne.n	968e <dtostrf+0x30e>
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    9696:	vmov	r3, s16
    969a:	cmp	r3, #0
    969c:	blt.n	96b4 <dtostrf+0x334>
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    969e:	movs	r1, #78	; 0x4e
    96a0:	movs	r0, #65	; 0x41
    96a2:	adds	r3, r2, #3
    96a4:	strb	r1, [r2, #0]
    96a6:	strb	r1, [r2, #2]
    96a8:	strb	r0, [r2, #1]
    96aa:	b.n	962a <dtostrf+0x2aa>

	int awidth = abs(width);
	if (isnanf(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    96ac:	mov	r2, r4
    96ae:	b.n	9696 <dtostrf+0x316>
		return buf;
	}
	if (isinff(val)) {
		int ndigs = (val<0) ? 4 : 3;
		awidth = (awidth > ndigs) ? awidth - ndigs : 0;
		if (width<0) {
    96b0:	mov	r3, r4
    96b2:	b.n	9428 <dtostrf+0xa8>
			while (awidth) {
				*buf++ = ' ';
				awidth--;
			}
		}
		if (copysignf(1.0f, val)<0) *buf++ = '-';
    96b4:	movs	r3, #0
    96b6:	b.n	9680 <dtostrf+0x300>
		if (DTOA_UPPER) {
			*buf++ = 'N';  *buf++ = 'A';  *buf++ = 'N';
    96b8:	mov	r3, r2
    96ba:	b.n	962a <dtostrf+0x2aa>
	}

	// add 1 for sign if negative
	if (sign) reqd++;

	p = buf;
    96bc:	mov	r3, r4
    96be:	b.n	94e0 <dtostrf+0x160>
				awidth--;
			}
		}
		if (val<0) *buf++ = '-';
		if (DTOA_UPPER) {
			*buf++ = 'I';  *buf++ = 'N';  *buf++ = 'F';
    96c0:	mov	r2, r3
    96c2:	b.n	93fe <dtostrf+0x7e>
    96c4:	.word	0x7f7fffff
    96c8:	.word	0x20000134
    96cc:	.word	0x200004d8

000096d0 <sm_align_pool>:
	if (spool->pool_size % HEADER_SZ) return 0;
	return 1;
}

int sm_align_pool(struct smalloc_pool *spool)
{
    96d0:	push	{r3, lr}

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    96d2:	ldr	r3, [r0, #0]
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    96d4:	ldr	r2, [r0, #4]

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    96d6:	cbz	r3, 9708 <sm_align_pool+0x38>
    96d8:	cbz	r2, 96fa <sm_align_pool+0x2a>
	if (spool->pool_size % HEADER_SZ) return 0;
    96da:	ldr	r3, [pc, #64]	; (971c <sm_align_pool+0x4c>)
    96dc:	umull	r1, r3, r3, r2
    96e0:	lsrs	r3, r3, #3
    96e2:	add.w	r3, r3, r3, lsl #1
    96e6:	subs.w	r3, r2, r3, lsl #2
    96ea:	beq.n	96f4 <sm_align_pool+0x24>
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
    96ec:	subs	r2, r2, r3
    96ee:	str	r2, [r0, #4]
	if (spool->pool_size <= MIN_POOL_SZ) {
    96f0:	cmp	r2, #240	; 0xf0
    96f2:	bls.n	96fa <sm_align_pool+0x2a>

int sm_align_pool(struct smalloc_pool *spool)
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;
    96f4:	movs	r3, #1
		errno = ENOSPC;
		return 0;
	}

	return 1;
}
    96f6:	mov	r0, r3
    96f8:	pop	{r3, pc}
	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
	if (x) spool->pool_size -= x;
	if (spool->pool_size <= MIN_POOL_SZ) {
		errno = ENOSPC;
    96fa:	bl	b07c <__errno>
    96fe:	movs	r2, #28
    9700:	movs	r3, #0
    9702:	str	r2, [r0, #0]
		return 0;
	}

	return 1;
}
    9704:	mov	r0, r3
    9706:	pop	{r3, pc}
{
	size_t x;

	if (smalloc_verify_pool(spool)) return 1;

	x = spool->pool_size % HEADER_SZ;
    9708:	ldr	r3, [pc, #16]	; (971c <sm_align_pool+0x4c>)
    970a:	umull	r1, r3, r3, r2
    970e:	lsrs	r3, r3, #3
    9710:	add.w	r3, r3, r3, lsl #1
	if (x) spool->pool_size -= x;
    9714:	subs.w	r3, r2, r3, lsl #2
    9718:	bne.n	96ec <sm_align_pool+0x1c>
    971a:	b.n	96f0 <sm_align_pool+0x20>
    971c:	.word	0xaaaaaaab

00009720 <sm_set_pool>:

	return 1;
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
    9720:	push	{r4, r5, r6, lr}
	if (!spool) {
    9722:	mov	r4, r0
    9724:	cmp	r0, #0
    9726:	beq.n	979e <sm_set_pool+0x7e>
		errno = EINVAL;
		return 0;
	}

	if (!new_pool || !new_pool_size) {
    9728:	cbz	r1, 9732 <sm_set_pool+0x12>
    972a:	clz	r5, r2
    972e:	lsrs	r5, r5, #5
    9730:	cbz	r5, 9772 <sm_set_pool+0x52>

struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
    9732:	ldr	r0, [r4, #0]
    9734:	cbz	r0, 973a <sm_set_pool+0x1a>
    9736:	ldr	r2, [r4, #4]
    9738:	cbnz	r2, 9748 <sm_set_pool+0x28>
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    973a:	bl	b07c <__errno>
    973e:	movs	r3, #22
		return 0;
    9740:	movs	r2, #0
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
			return 1;
		}

		errno = EINVAL;
    9742:	str	r3, [r0, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    9744:	mov	r0, r2
    9746:	pop	{r4, r5, r6, pc}
struct smalloc_pool smalloc_curr_pool;

int smalloc_verify_pool(struct smalloc_pool *spool)
{
	if (!spool->pool || !spool->pool_size) return 0;
	if (spool->pool_size % HEADER_SZ) return 0;
    9748:	ldr	r1, [pc, #96]	; (97ac <sm_set_pool+0x8c>)
    974a:	umull	r3, r1, r1, r2
    974e:	lsrs	r1, r1, #3
    9750:	add.w	r1, r1, r1, lsl #1
    9754:	subs.w	r1, r2, r1, lsl #2
    9758:	bne.n	973a <sm_set_pool+0x1a>
		return 0;
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
    975a:	ldr	r3, [r4, #8]
    975c:	cbz	r3, 9762 <sm_set_pool+0x42>
    975e:	bl	b73c <memset>
			memset(spool, 0, sizeof(struct smalloc_pool));
    9762:	movs	r3, #0
			return 1;
    9764:	movs	r2, #1
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    9766:	str	r3, [r4, #0]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    9768:	mov	r0, r2
	}

	if (!new_pool || !new_pool_size) {
		if (smalloc_verify_pool(spool)) {
			if (spool->do_zero) memset(spool->pool, 0, spool->pool_size);
			memset(spool, 0, sizeof(struct smalloc_pool));
    976a:	str	r3, [r4, #4]
    976c:	str	r3, [r4, #8]
    976e:	str	r3, [r4, #12]
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
}
    9770:	pop	{r4, r5, r6, pc}
    9772:	mov	r6, r3
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
    9774:	ldr	r3, [sp, #16]
		errno = EINVAL;
		return 0;
	}

	spool->pool = new_pool;
	spool->pool_size = new_pool_size;
    9776:	stmia.w	r0, {r1, r2}
	spool->oomfn = oom_handler;
    977a:	str	r3, [r0, #12]
	if (!sm_align_pool(spool)) return 0;
    977c:	bl	96d0 <sm_align_pool>
    9780:	mov	r2, r0
    9782:	cmp	r0, #0
    9784:	beq.n	9744 <sm_set_pool+0x24>

	if (do_zero) {
    9786:	cbnz	r6, 978e <sm_set_pool+0x6e>
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
	}

	return 1;
    9788:	movs	r2, #1
}
    978a:	mov	r0, r2
    978c:	pop	{r4, r5, r6, pc}
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
		memset(spool->pool, 0, spool->pool_size);
    978e:	ldmia.w	r4, {r0, r2}
	spool->pool_size = new_pool_size;
	spool->oomfn = oom_handler;
	if (!sm_align_pool(spool)) return 0;

	if (do_zero) {
		spool->do_zero = do_zero;
    9792:	str	r6, [r4, #8]
		memset(spool->pool, 0, spool->pool_size);
    9794:	mov	r1, r5
    9796:	bl	b73c <memset>
	}

	return 1;
    979a:	movs	r2, #1
    979c:	b.n	9744 <sm_set_pool+0x24>
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    979e:	bl	b07c <__errno>
    97a2:	movs	r3, #22
		return 0;
    97a4:	mov	r2, r4
}

int sm_set_pool(struct smalloc_pool *spool, void *new_pool, size_t new_pool_size, int do_zero, smalloc_oom_handler oom_handler)
{
	if (!spool) {
		errno = EINVAL;
    97a6:	str	r3, [r0, #0]
		return 0;
    97a8:	b.n	9744 <sm_set_pool+0x24>
    97aa:	nop
    97ac:	.word	0xaaaaaaab

000097b0 <Panic_Temp_isr>:

static uint32_t s_hotTemp, s_hotCount, s_roomC_hotC;
static float s_hot_ROOM;

void Panic_Temp_isr(void) {
  __disable_irq();
    97b0:	cpsid	i
  IOMUXC_GPR_GPR16 = 0x00000007;
  SNVS_LPCR |= SNVS_LPCR_TOP; //Switch off now
    97b2:	ldr	r2, [pc, #24]	; (97cc <Panic_Temp_isr+0x1c>)
static uint32_t s_hotTemp, s_hotCount, s_roomC_hotC;
static float s_hot_ROOM;

void Panic_Temp_isr(void) {
  __disable_irq();
  IOMUXC_GPR_GPR16 = 0x00000007;
    97b4:	movs	r1, #7
    97b6:	ldr	r3, [pc, #24]	; (97d0 <Panic_Temp_isr+0x20>)
    97b8:	str	r1, [r3, #64]	; 0x40
  SNVS_LPCR |= SNVS_LPCR_TOP; //Switch off now
    97ba:	ldr	r3, [r2, #56]	; 0x38
    97bc:	orr.w	r3, r3, #64	; 0x40
    97c0:	str	r3, [r2, #56]	; 0x38
  asm volatile ("dsb":::"memory");
    97c2:	dsb	sy
  while (1) asm ("wfi");
    97c6:	wfi
    97c8:	b.n	97c6 <Panic_Temp_isr+0x16>
    97ca:	nop
    97cc:	.word	0x400d4000
    97d0:	.word	0x400ac000

000097d4 <digitalWrite.part.0>:
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    97d4:	lsls	r0, r0, #4
    97d6:	ldr	r3, [pc, #60]	; (9814 <digitalWrite.part.0+0x40>)
    97d8:	adds	r2, r3, r0
	pinmode = *(p->reg + 1);
    97da:	ldr	r3, [r3, r0]
	{&CORE_PIN53_PORTREG, &CORE_PIN53_CONFIG, &CORE_PIN53_PADCONFIG, CORE_PIN53_BITMASK},
	{&CORE_PIN54_PORTREG, &CORE_PIN54_CONFIG, &CORE_PIN54_PADCONFIG, CORE_PIN54_BITMASK},
#endif
};

void digitalWrite(uint8_t pin, uint8_t val)
    97dc:	push	{r4}
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
	mask = p->mask;
    97de:	ldr	r0, [r2, #12]
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	pinmode = *(p->reg + 1);
    97e0:	ldr	r4, [r3, #4]
	mask = p->mask;
	if (pinmode & mask) {
    97e2:	tst	r4, r0
    97e4:	beq.n	97f2 <digitalWrite.part.0+0x1e>
		// pin is configured for output mode
		if (val) {
    97e6:	cbz	r1, 9800 <digitalWrite.part.0+0x2c>
			*(p->reg + 0x21) = mask; // set register
    97e8:	str.w	r0, [r3, #132]	; 0x84
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    97ec:	ldr.w	r4, [sp], #4
    97f0:	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    97f2:	ldr	r3, [r2, #8]
			*(p->reg + 0x22) = mask; // clear register
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
    97f4:	cbnz	r1, 980a <digitalWrite.part.0+0x36>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    97f6:	ldr	r2, [pc, #32]	; (9818 <digitalWrite.part.0+0x44>)
		}
	}
}
    97f8:	ldr.w	r4, [sp], #4
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    97fc:	str	r2, [r3, #0]
		}
	}
}
    97fe:	bx	lr
	if (pinmode & mask) {
		// pin is configured for output mode
		if (val) {
			*(p->reg + 0x21) = mask; // set register
		} else {
			*(p->reg + 0x22) = mask; // clear register
    9800:	str.w	r0, [r3, #136]	; 0x88
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    9804:	ldr.w	r4, [sp], #4
    9808:	bx	lr
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    980a:	ldr	r2, [pc, #16]	; (981c <digitalWrite.part.0+0x48>)
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    980c:	ldr.w	r4, [sp], #4
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    9810:	str	r2, [r3, #0]
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		}
	}
}
    9812:	bx	lr
    9814:	.word	0x200004dc
    9818:	.word	0x00013038
    981c:	.word	0x0001f038

00009820 <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    9820:	cmp	r0, #54	; 0x36
    9822:	bhi.n	9828 <digitalWrite+0x8>
    9824:	b.w	97d4 <digitalWrite.part.0>
    9828:	bx	lr
    982a:	nop

0000982c <pinMode>:

void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
    982c:	cmp	r0, #54	; 0x36
    982e:	bhi.n	986a <pinMode+0x3e>
	p = digital_pin_to_info_PGM + pin;
    9830:	lsls	r0, r0, #4
    9832:	ldr	r2, [pc, #104]	; (989c <pinMode+0x70>)
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    9834:	cmp	r1, #1
void pinMode(uint8_t pin, uint8_t mode)
{
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    9836:	add.w	r3, r2, r0
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    983a:	ldr	r0, [r2, r0]
	p = digital_pin_to_info_PGM + pin;
	return (*(p->reg + 2) & p->mask) ? 1 : 0;
}

void pinMode(uint8_t pin, uint8_t mode)
{
    983c:	push	{r4}
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
    983e:	beq.n	986c <pinMode+0x40>
    9840:	cmp	r1, #4
    9842:	beq.n	986c <pinMode+0x40>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
    9844:	ldr	r4, [r3, #12]
    9846:	ldr	r2, [r0, #4]
    9848:	bic.w	r2, r2, r4
    984c:	str	r2, [r0, #4]
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    984e:	ldr	r2, [r3, #8]
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
    9850:	cbz	r1, 988e <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
    9852:	cmp	r1, #2
    9854:	beq.n	9894 <pinMode+0x68>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
    9856:	cmp	r1, #3
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    9858:	ldr	r3, [r3, #4]
}
    985a:	ldr.w	r4, [sp], #4
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
		} else if (mode == INPUT_PULLDOWN) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    985e:	ite	eq
    9860:	ldreq	r1, [pc, #60]	; (98a0 <pinMode+0x74>)
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
    9862:	ldrne	r1, [pc, #64]	; (98a4 <pinMode+0x78>)
    9864:	str	r1, [r2, #0]
		}
	}
	*(p->mux) = 5 | 0x10;
    9866:	movs	r2, #21
    9868:	str	r2, [r3, #0]
}
    986a:	bx	lr
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
    986c:	ldr	r2, [r3, #12]
		if (mode == OUTPUT) {
    986e:	cmp	r1, #1
	const struct digital_pin_bitband_and_config_table_struct *p;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
    9870:	ldr	r4, [r0, #4]
    9872:	orr.w	r2, r2, r4
    9876:	str	r2, [r0, #4]
		if (mode == OUTPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    9878:	ldr	r2, [r3, #8]

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
	if (mode == OUTPUT || mode == OUTPUT_OPENDRAIN) {
		*(p->reg + 1) |= p->mask; // TODO: atomic
		if (mode == OUTPUT) {
    987a:	beq.n	988e <pinMode+0x62>
			*(p->pad) = IOMUXC_PAD_DSE(7);
		} else { // OUTPUT_OPENDRAIN
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
    987c:	movw	r1, #2104	; 0x838
    9880:	str	r1, [r2, #0]
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    9882:	ldr	r3, [r3, #4]
    9884:	movs	r2, #21
}
    9886:	ldr.w	r4, [sp], #4
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
		} else { // INPUT_DISABLE
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_HYS;
		}
	}
	*(p->mux) = 5 | 0x10;
    988a:	str	r2, [r3, #0]
}
    988c:	bx	lr
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_ODE;
		}
	} else {
		*(p->reg + 1) &= ~(p->mask); // TODO: atomic
		if (mode == INPUT) {
			*(p->pad) = IOMUXC_PAD_DSE(7);
    988e:	movs	r1, #56	; 0x38
    9890:	str	r1, [r2, #0]
    9892:	b.n	9882 <pinMode+0x56>
		} else if (mode == INPUT_PULLUP) {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    9894:	ldr	r1, [pc, #16]	; (98a8 <pinMode+0x7c>)
    9896:	str	r1, [r2, #0]
    9898:	b.n	9882 <pinMode+0x56>
    989a:	nop
    989c:	.word	0x200004dc
    98a0:	.word	0x00013038
    98a4:	.word	0x00010038
    98a8:	.word	0x0001f038

000098ac <pwm_init>:
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    98ac:	ldr	r0, [pc, #656]	; (9b40 <pwm_init+0x294>)
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    98ae:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    98b2:	ldr	r3, [pc, #656]	; (9b44 <pwm_init+0x298>)
}

void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    98b4:	ldr	r2, [r0, #120]	; 0x78
    98b6:	orr.w	r2, r2, #16711680	; 0xff0000
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}

void pwm_init(void)
{
    98ba:	push	{r4, r5, r6, r7, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    98bc:	str	r2, [r0, #120]	; 0x78
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
    98be:	movs	r5, #0
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    98c0:	ldr.w	r2, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    98c4:	mov.w	r6, #61440	; 0xf000
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    98c8:	ldr	r4, [pc, #636]	; (9b48 <pwm_init+0x29c>)
	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    98ca:	mov.w	lr, #57344	; 0xe000

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    98ce:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    98d0:	mov.w	r7, #1024	; 0x400
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    98d4:	orrs	r4, r2
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    98d6:	mov	r2, r5
void pwm_init(void)
{
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    98d8:	str.w	r4, [r0, #128]	; 0x80

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    98dc:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    98e0:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    98e4:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    98e8:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    98ec:	ldrh.w	r0, [r3, #392]	; 0x188
    98f0:	uxth	r0, r0
    98f2:	orr.w	r0, r0, #240	; 0xf0
    98f6:	strh.w	r0, [r3, #392]	; 0x188
    98fa:	add.w	r0, r1, r1, lsl #1
    98fe:	ldr	r3, [pc, #580]	; (9b44 <pwm_init+0x298>)
	for (i=0; i < 4; i++) {
    9900:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    9902:	movs	r5, #0
    9904:	lsls	r0, r0, #5
    9906:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    9908:	cmp	r1, #4
    990a:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    990c:	strh.w	lr, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    9910:	strh	r7, [r3, #6]
		p->SM[i].OCTRL = 0;
    9912:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    9914:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    9916:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    9918:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    991a:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    991c:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    991e:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    9920:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    9922:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    9924:	bne.n	98fa <pwm_init+0x4e>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9926:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    992a:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    992e:	ldr	r3, [pc, #540]	; (9b4c <pwm_init+0x2a0>)
    9930:	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9934:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    9936:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    9938:	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    993c:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    993e:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    9942:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9946:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    994a:	ldrh.w	r0, [r4, #392]	; 0x188
    994e:	uxth	r0, r0
    9950:	orr.w	r0, r0, #3840	; 0xf00
    9954:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    9958:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    995c:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    9960:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    9964:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    9968:	ldrh.w	r0, [r3, #392]	; 0x188
    996c:	uxth	r0, r0
    996e:	orr.w	r0, r0, #240	; 0xf0
    9972:	strh.w	r0, [r3, #392]	; 0x188
    9976:	add.w	r0, r1, r1, lsl #1
    997a:	ldr	r3, [pc, #464]	; (9b4c <pwm_init+0x2a0>)
	for (i=0; i < 4; i++) {
    997c:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    997e:	movs	r5, #0
    9980:	lsls	r0, r0, #5
    9982:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    9984:	cmp	r1, #4
    9986:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    9988:	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    998a:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    998e:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    9990:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    9992:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    9994:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    9996:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    9998:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    999a:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    999c:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    999e:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    99a0:	bne.n	9976 <pwm_init+0xca>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    99a2:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    99a6:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    99aa:	ldr	r3, [pc, #420]	; (9b50 <pwm_init+0x2a4>)
    99ac:	mov.w	r6, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    99b0:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    99b2:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    99b4:	mov.w	r7, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    99b8:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    99ba:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    99be:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    99c2:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    99c6:	ldrh.w	r0, [r4, #392]	; 0x188
    99ca:	uxth	r0, r0
    99cc:	orr.w	r0, r0, #3840	; 0xf00
    99d0:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    99d4:	strh.w	r6, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    99d8:	movw	r6, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    99dc:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    99e0:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    99e4:	ldrh.w	r0, [r3, #392]	; 0x188
    99e8:	uxth	r0, r0
    99ea:	orr.w	r0, r0, #240	; 0xf0
    99ee:	strh.w	r0, [r3, #392]	; 0x188
    99f2:	add.w	r0, r1, r1, lsl #1
    99f6:	ldr	r3, [pc, #344]	; (9b50 <pwm_init+0x2a4>)
	for (i=0; i < 4; i++) {
    99f8:	adds	r1, #1
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    99fa:	movs	r5, #0
    99fc:	lsls	r0, r0, #5
    99fe:	mov	r4, r3

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    9a00:	cmp	r1, #4
    9a02:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    9a04:	strh	r7, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    9a06:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    9a0a:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    9a0c:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    9a0e:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    9a10:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    9a12:	strh	r6, [r3, #14]
		p->SM[i].VAL2 = 0;
    9a14:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    9a16:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    9a18:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    9a1a:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    9a1c:	bne.n	99f2 <pwm_init+0x146>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9a1e:	ldrh.w	r0, [r4, #392]	; 0x188
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    9a22:	mov.w	ip, #15

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    9a26:	ldr	r3, [pc, #300]	; (9b54 <pwm_init+0x2a8>)
    9a28:	mov.w	r7, #61440	; 0xf000
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9a2c:	uxth	r0, r0

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    9a2e:	mov	r1, r5
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    9a30:	mov.w	r6, #57344	; 0xe000
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
    9a34:	mov	r2, r5
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9a36:	orr.w	r0, r0, ip
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    9a3a:	mov.w	lr, #1024	; 0x400
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9a3e:	strh.w	r0, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    9a42:	ldrh.w	r0, [r4, #392]	; 0x188
    9a46:	uxth	r0, r0
    9a48:	orr.w	r0, r0, #3840	; 0xf00
    9a4c:	strh.w	r0, [r4, #392]	; 0x188

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    9a50:	strh.w	r7, [r3, #396]	; 0x18c
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
		p->SM[i].OCTRL = 0;
		p->SM[i].DTCNT0 = 0;
		p->SM[i].INIT = 0;
		p->SM[i].VAL0 = 0;
		p->SM[i].VAL1 = 33464;
    9a54:	movw	r7, #33464	; 0x82b8
void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
    9a58:	strh.w	ip, [r3, #398]	; 0x18e
	p->FFILT0 = 0;
    9a5c:	strh.w	r5, [r3, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    9a60:	ldrh.w	r0, [r3, #392]	; 0x188
    9a64:	uxth	r0, r0
    9a66:	orr.w	r0, r0, #240	; 0xf0
    9a6a:	strh.w	r0, [r3, #392]	; 0x188
    9a6e:	add.w	r0, r1, r1, lsl #1
    9a72:	ldr	r3, [pc, #224]	; (9b54 <pwm_init+0x2a8>)
	for (i=0; i < 4; i++) {
    9a74:	adds	r1, #1
    9a76:	lsls	r0, r0, #5
    9a78:	mov	r4, r3
    9a7a:	cmp	r1, #4
    9a7c:	add	r3, r0
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    9a7e:	strh	r6, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    9a80:	strh.w	lr, [r3, #6]
		p->SM[i].OCTRL = 0;
    9a84:	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    9a86:	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    9a88:	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    9a8a:	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    9a8c:	strh	r7, [r3, #14]
		p->SM[i].VAL2 = 0;
    9a8e:	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    9a90:	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    9a92:	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    9a94:	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    9a96:	bne.n	9a6e <pwm_init+0x1c2>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9a98:	ldrh.w	r3, [r4, #392]	; 0x188
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    9a9c:	movs	r7, #15

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9a9e:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    9aa0:	movw	r6, #4097	; 0x1001
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9aa4:	uxth	r3, r3
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    9aa6:	movw	lr, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    9aaa:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    9aac:	movw	r5, #12326	; 0x3026
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    9ab0:	orrs	r3, r7
    9ab2:	strh.w	r3, [r4, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    9ab6:	ldrh.w	r3, [r4, #392]	; 0x188
    9aba:	uxth	r3, r3
    9abc:	orr.w	r3, r3, #3840	; 0xf00
    9ac0:	strh.w	r3, [r4, #392]	; 0x188
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    9ac4:	lsls	r0, r2, #5
    9ac6:	ldr	r3, [pc, #144]	; (9b58 <pwm_init+0x2ac>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9ac8:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    9aca:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9acc:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    9ace:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    9ad0:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    9ad2:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    9ad4:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    9ad6:	strh.w	lr, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    9ada:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    9adc:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    9ade:	strh	r5, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9ae0:	bne.n	9ac4 <pwm_init+0x218>
    9ae2:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    9ae4:	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    9ae6:	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    9aea:	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    9aee:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    9af0:	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    9af4:	lsls	r0, r2, #5
    9af6:	ldr	r3, [pc, #100]	; (9b5c <pwm_init+0x2b0>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9af8:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    9afa:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9afc:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    9afe:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    9b00:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    9b02:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    9b04:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    9b06:	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    9b08:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    9b0a:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    9b0c:	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9b0e:	bne.n	9af4 <pwm_init+0x248>
    9b10:	movs	r2, #0
		p->CH[i].CTRL = 0; // stop timer
		p->CH[i].CNTR = 0;
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    9b12:	movs	r7, #15
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    9b14:	movw	r6, #4097	; 0x1001
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    9b18:	movw	r5, #24000	; 0x5dc0
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    9b1c:	mov	r1, r2
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    9b1e:	movw	r4, #12326	; 0x3026
void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
		p->CH[i].CTRL = 0; // stop timer
    9b22:	lsls	r0, r2, #5
    9b24:	ldr	r3, [pc, #56]	; (9b60 <pwm_init+0x2b4>)

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9b26:	adds	r2, #1
		p->CH[i].CTRL = 0; // stop timer
    9b28:	add	r3, r0

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9b2a:	cmp	r2, #4
		p->CH[i].CTRL = 0; // stop timer
    9b2c:	strh	r1, [r3, #12]
		p->CH[i].CNTR = 0;
    9b2e:	strh	r1, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    9b30:	strh	r7, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    9b32:	strh	r6, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    9b34:	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    9b36:	strh	r1, [r3, #0]
		p->CH[i].CMPLD1 = 0;
    9b38:	strh	r1, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    9b3a:	strh	r4, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    9b3c:	bne.n	9b22 <pwm_init+0x276>
	flexpwm_init(&IMXRT_FLEXPWM3);
	flexpwm_init(&IMXRT_FLEXPWM4);
	quadtimer_init(&IMXRT_TMR1);
	quadtimer_init(&IMXRT_TMR2);
	quadtimer_init(&IMXRT_TMR3);
}
    9b3e:	pop	{r4, r5, r6, r7, pc}
    9b40:	.word	0x400fc000
    9b44:	.word	0x403dc000
    9b48:	.word	0xfc030000
    9b4c:	.word	0x403e0000
    9b50:	.word	0x403e4000
    9b54:	.word	0x403e8000
    9b58:	.word	0x401dc000
    9b5c:	.word	0x401e0000
    9b60:	.word	0x401e4000

00009b64 <rx_event>:
static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    9b64:	ldr	r2, [pc, #40]	; (9b90 <rx_event+0x2c>)
	usb_receive(MTP_RX_ENDPOINT, rx_transfer + i);
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
    9b66:	push	{r4}
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
    9b68:	ldrb	r3, [r2, #0]
	NVIC_ENABLE_IRQ(IRQ_USB1);
}

static void rx_event(transfer_t *t)
{
	int i = t->callback_param;
    9b6a:	ldr	r4, [r0, #28]
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    9b6c:	adds	r3, #1
    9b6e:	cmp	r3, #4
    9b70:	bls.n	9b82 <rx_event+0x1e>
    9b72:	movs	r1, #0
	rx_list[head] = i;
    9b74:	ldr	r0, [pc, #28]	; (9b94 <rx_event+0x30>)
{
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
    9b76:	mov	r3, r1
	rx_list[head] = i;
	rx_head = head;
    9b78:	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    9b7a:	strb	r4, [r0, r3]
	rx_head = head;
}
    9b7c:	ldr.w	r4, [sp], #4
    9b80:	bx	lr
    9b82:	uxtb	r1, r3
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    9b84:	ldr	r0, [pc, #12]	; (9b94 <rx_event+0x30>)
	rx_head = head;
    9b86:	strb	r1, [r2, #0]
	int i = t->callback_param;
	//printf("rx event i=%d\n", i);
	// received a packet with data
	uint32_t head = rx_head;
	if (++head > RX_NUM) head = 0;
	rx_list[head] = i;
    9b88:	strb	r4, [r0, r3]
	rx_head = head;
}
    9b8a:	ldr.w	r4, [sp], #4
    9b8e:	bx	lr
    9b90:	.word	0x2000b1ec
    9b94:	.word	0x2000b1e4

00009b98 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    9b98:	push	{r4, r5, r6, lr}
	void *buffer = rx_buffer + i * MTP_RX_SIZE_480;
    9b9a:	ldr	r1, [pc, #76]	; (9be8 <rx_queue_transfer+0x50>)
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    9b9c:	mov	r3, r0
	void *buffer = rx_buffer + i * MTP_RX_SIZE_480;
	arm_dcache_delete(buffer, rx_packet_size);
    9b9e:	ldr	r6, [pc, #76]	; (9bec <rx_queue_transfer+0x54>)
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * MTP_RX_SIZE_480;
    9ba0:	add.w	r1, r1, r0, lsl #9
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
    9ba4:	ldrh	r4, [r6, #0]
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    9ba6:	bic.w	r2, r1, #31
	uint32_t end_addr = (uint32_t)addr + size;
    9baa:	add	r4, r1
	asm volatile("": : :"memory");
	asm("dsb");
    9bac:	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    9bb0:	ldr	r5, [pc, #60]	; (9bf0 <rx_queue_transfer+0x58>)
    9bb2:	str	r2, [r5, #0]
		location += 32;
    9bb4:	adds	r2, #32
	} while (location < end_addr);
    9bb6:	cmp	r4, r2
    9bb8:	bhi.n	9bb2 <rx_queue_transfer+0x1a>
	asm("dsb");
    9bba:	dsb	sy
	asm("isb");
    9bbe:	isb	sy
	arm_dcache_delete(buffer, rx_packet_size);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    9bc2:	ldr	r4, [pc, #48]	; (9bf4 <rx_queue_transfer+0x5c>)
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * MTP_RX_SIZE_480;
	arm_dcache_delete(buffer, rx_packet_size);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    9bc4:	mov.w	r5, #131072	; 0x20000
    9bc8:	ldr	r2, [pc, #44]	; (9bf8 <rx_queue_transfer+0x60>)
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    9bca:	add.w	r4, r4, r3, lsl #5
static void rx_queue_transfer(int i)
{
	void *buffer = rx_buffer + i * MTP_RX_SIZE_480;
	arm_dcache_delete(buffer, rx_packet_size);
	//memset(buffer, )
	NVIC_DISABLE_IRQ(IRQ_USB1);
    9bce:	str	r5, [r2, #0]
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    9bd0:	mov	r0, r4
    9bd2:	ldrh	r2, [r6, #0]
    9bd4:	bl	9050 <usb_prepare_transfer>
	usb_receive(MTP_RX_ENDPOINT, rx_transfer + i);
    9bd8:	mov	r1, r4
    9bda:	movs	r0, #4
    9bdc:	bl	90a8 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    9be0:	ldr	r3, [pc, #24]	; (9bfc <rx_queue_transfer+0x64>)
    9be2:	str	r5, [r3, #0]
    9be4:	pop	{r4, r5, r6, pc}
    9be6:	nop
    9be8:	.word	0x20203000
    9bec:	.word	0x2000b1ea
    9bf0:	.word	0xe000ef5c
    9bf4:	.word	0x2000b160
    9bf8:	.word	0xe000e18c
    9bfc:	.word	0xe000e10c

00009c00 <usb_mtp_configure>:
static void rx_event(transfer_t *t);
extern volatile uint8_t usb_configuration;


void usb_mtp_configure(void)
{
    9c00:	push	{r3, r4, r5, r6, r7, lr}
	printf("usb_mtp_configure\n");
    	if (usb_high_speed) {
    9c02:	ldr	r3, [pc, #120]	; (9c7c <usb_mtp_configure+0x7c>)
    9c04:	ldrb	r3, [r3, #0]
    9c06:	cbz	r3, 9c6c <usb_mtp_configure+0x6c>
		tx_packet_size = MTP_TX_SIZE_480;
    9c08:	mov.w	r3, #512	; 0x200
    9c0c:	ldr	r2, [pc, #112]	; (9c80 <usb_mtp_configure+0x80>)
		rx_packet_size = MTP_RX_SIZE_480;
    9c0e:	ldr	r5, [pc, #116]	; (9c84 <usb_mtp_configure+0x84>)
    9c10:	mov	r6, r3

void usb_mtp_configure(void)
{
	printf("usb_mtp_configure\n");
    	if (usb_high_speed) {
		tx_packet_size = MTP_TX_SIZE_480;
    9c12:	strh	r3, [r2, #0]
		rx_packet_size = MTP_RX_SIZE_480;
    9c14:	strh	r3, [r5, #0]
	} else {
		tx_packet_size = MTP_TX_SIZE_12;
		rx_packet_size = MTP_RX_SIZE_12;
    }
	memset(tx_transfer, 0, sizeof(tx_transfer));
    9c16:	movs	r1, #0
    9c18:	movs	r2, #128	; 0x80
    9c1a:	ldr	r0, [pc, #108]	; (9c88 <usb_mtp_configure+0x88>)
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    9c1c:	mov	r4, r1
		rx_packet_size = MTP_RX_SIZE_480;
	} else {
		tx_packet_size = MTP_TX_SIZE_12;
		rx_packet_size = MTP_RX_SIZE_12;
    }
	memset(tx_transfer, 0, sizeof(tx_transfer));
    9c1e:	bl	b73c <memset>
	memset(rx_transfer, 0, sizeof(rx_transfer));
    9c22:	movs	r2, #128	; 0x80
    9c24:	ldr	r0, [pc, #100]	; (9c8c <usb_mtp_configure+0x8c>)
    9c26:	mov	r1, r4
	tx_head = 0;
    9c28:	ldr	r7, [pc, #100]	; (9c90 <usb_mtp_configure+0x90>)
	} else {
		tx_packet_size = MTP_TX_SIZE_12;
		rx_packet_size = MTP_RX_SIZE_12;
    }
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
    9c2a:	bl	b73c <memset>
	tx_head = 0;
	rx_head = 0;
    9c2e:	ldr	r0, [pc, #100]	; (9c94 <usb_mtp_configure+0x94>)
	rx_tail = 0;
	usb_config_tx(MTP_TX_ENDPOINT, tx_packet_size, 0, NULL);
    9c30:	mov	r1, r6
    }
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
	rx_head = 0;
	rx_tail = 0;
    9c32:	ldr	r6, [pc, #100]	; (9c98 <usb_mtp_configure+0x98>)
		rx_packet_size = MTP_RX_SIZE_12;
    }
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
	rx_head = 0;
    9c34:	strb	r4, [r0, #0]
	rx_tail = 0;
	usb_config_tx(MTP_TX_ENDPOINT, tx_packet_size, 0, NULL);
    9c36:	mov	r3, r4
    9c38:	mov	r2, r4
    9c3a:	movs	r0, #4
		tx_packet_size = MTP_TX_SIZE_12;
		rx_packet_size = MTP_RX_SIZE_12;
    }
	memset(tx_transfer, 0, sizeof(tx_transfer));
	memset(rx_transfer, 0, sizeof(rx_transfer));
	tx_head = 0;
    9c3c:	strb	r4, [r7, #0]
	rx_head = 0;
	rx_tail = 0;
    9c3e:	strb	r4, [r6, #0]
	usb_config_tx(MTP_TX_ENDPOINT, tx_packet_size, 0, NULL);
    9c40:	bl	8fe8 <usb_config_tx>
	usb_config_rx(MTP_RX_ENDPOINT, rx_packet_size, 0, rx_event);
    9c44:	ldrh	r1, [r5, #0]
    9c46:	mov	r2, r4
    9c48:	ldr	r3, [pc, #80]	; (9c9c <usb_mtp_configure+0x9c>)
    9c4a:	movs	r0, #4
    9c4c:	bl	8f84 <usb_config_rx>
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    9c50:	mov	r0, r4
    9c52:	bl	9b98 <rx_queue_transfer>
    9c56:	movs	r0, #1
    9c58:	bl	9b98 <rx_queue_transfer>
    9c5c:	movs	r0, #2
    9c5e:	bl	9b98 <rx_queue_transfer>
    9c62:	movs	r0, #3
}
    9c64:	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	rx_head = 0;
	rx_tail = 0;
	usb_config_tx(MTP_TX_ENDPOINT, tx_packet_size, 0, NULL);
	usb_config_rx(MTP_RX_ENDPOINT, rx_packet_size, 0, rx_event);
	int i;
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    9c68:	b.w	9b98 <rx_queue_transfer>
	printf("usb_mtp_configure\n");
    	if (usb_high_speed) {
		tx_packet_size = MTP_TX_SIZE_480;
		rx_packet_size = MTP_RX_SIZE_480;
	} else {
		tx_packet_size = MTP_TX_SIZE_12;
    9c6c:	movs	r3, #64	; 0x40
    9c6e:	ldr	r2, [pc, #16]	; (9c80 <usb_mtp_configure+0x80>)
		rx_packet_size = MTP_RX_SIZE_12;
    9c70:	ldr	r5, [pc, #16]	; (9c84 <usb_mtp_configure+0x84>)
    9c72:	mov	r6, r3
	printf("usb_mtp_configure\n");
    	if (usb_high_speed) {
		tx_packet_size = MTP_TX_SIZE_480;
		rx_packet_size = MTP_RX_SIZE_480;
	} else {
		tx_packet_size = MTP_TX_SIZE_12;
    9c74:	strh	r3, [r2, #0]
		rx_packet_size = MTP_RX_SIZE_12;
    9c76:	strh	r3, [r5, #0]
    9c78:	b.n	9c16 <usb_mtp_configure+0x16>
    9c7a:	nop
    9c7c:	.word	0x2000b110
    9c80:	.word	0x2000b15c
    9c84:	.word	0x2000b1ea
    9c88:	.word	0x2000b200
    9c8c:	.word	0x2000b160
    9c90:	.word	0x2000b15e
    9c94:	.word	0x2000b1ec
    9c98:	.word	0x2000b1e0
    9c9c:	.word	0x00009b65

00009ca0 <usb_mtp_recv>:
	rx_head = head;
}


int usb_mtp_recv(void *buffer, uint32_t timeout)
{
    9ca0:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint32_t wait_begin_at = systick_millis_count;
    9ca4:	ldr	r6, [pc, #140]	; (9d34 <usb_mtp_recv+0x94>)
	uint32_t tail = rx_tail;
    9ca6:	ldr.w	fp, [pc, #160]	; 9d48 <usb_mtp_recv+0xa8>
	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
    9caa:	ldr	r7, [pc, #140]	; (9d38 <usb_mtp_recv+0x98>)
}


int usb_mtp_recv(void *buffer, uint32_t timeout)
{
	uint32_t wait_begin_at = systick_millis_count;
    9cac:	ldr.w	r9, [r6]
	uint32_t tail = rx_tail;
    9cb0:	ldrb.w	r4, [fp]
	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
    9cb4:	ldrb	r3, [r7, #0]
    9cb6:	cbz	r3, 9cf2 <usb_mtp_recv+0x52>
		if (tail != rx_head) break;
    9cb8:	ldr.w	r8, [pc, #144]	; 9d4c <usb_mtp_recv+0xac>
    9cbc:	uxtb	r4, r4
    9cbe:	mov	r5, r1
    9cc0:	mov	sl, r0
    9cc2:	ldrb.w	r3, [r8]
    9cc6:	cmp	r4, r3
    9cc8:	bne.n	9cfa <usb_mtp_recv+0x5a>
		if (systick_millis_count - wait_begin_at > timeout)  {
    9cca:	ldr	r3, [r6, #0]
    9ccc:	rsb	r3, r9, r3
    9cd0:	cmp	r1, r3
    9cd2:	bcs.n	9ce8 <usb_mtp_recv+0x48>
    9cd4:	b.n	9d26 <usb_mtp_recv+0x86>
{
	uint32_t wait_begin_at = systick_millis_count;
	uint32_t tail = rx_tail;
	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
		if (tail != rx_head) break;
    9cd6:	ldrb.w	r3, [r8]
    9cda:	cmp	r4, r3
    9cdc:	bne.n	9cfa <usb_mtp_recv+0x5a>
		if (systick_millis_count - wait_begin_at > timeout)  {
    9cde:	ldr	r3, [r6, #0]
    9ce0:	rsb	r3, r9, r3
    9ce4:	cmp	r3, r5
    9ce6:	bhi.n	9d26 <usb_mtp_recv+0x86>
			return 0;
		}
		yield();
    9ce8:	bl	9ea4 <yield>
int usb_mtp_recv(void *buffer, uint32_t timeout)
{
	uint32_t wait_begin_at = systick_millis_count;
	uint32_t tail = rx_tail;
	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
    9cec:	ldrb	r3, [r7, #0]
    9cee:	cmp	r3, #0
    9cf0:	bne.n	9cd6 <usb_mtp_recv+0x36>
    9cf2:	mov.w	r0, #4294967295
    9cf6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			return 0;
		}
		yield();
	}
//	digitalWriteFast(0, LOW);
	if (++tail > RX_NUM) tail = 0;
    9cfa:	adds	r4, #1
    9cfc:	cmp	r4, #4
    9cfe:	bhi.n	9d2c <usb_mtp_recv+0x8c>
    9d00:	uxtb	r3, r4
	uint32_t i = rx_list[tail];
    9d02:	ldr	r2, [pc, #56]	; (9d3c <usb_mtp_recv+0x9c>)
	rx_tail = tail;

	memcpy(buffer,  rx_buffer + i * MTP_RX_SIZE_480, rx_packet_size);
    9d04:	mov	r0, sl
    9d06:	ldr	r1, [pc, #56]	; (9d40 <usb_mtp_recv+0xa0>)
		}
		yield();
	}
//	digitalWriteFast(0, LOW);
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
    9d08:	ldrb	r5, [r2, r4]
	rx_tail = tail;

	memcpy(buffer,  rx_buffer + i * MTP_RX_SIZE_480, rx_packet_size);
    9d0a:	ldr	r4, [pc, #56]	; (9d44 <usb_mtp_recv+0xa4>)
    9d0c:	add.w	r1, r1, r5, lsl #9
		yield();
	}
//	digitalWriteFast(0, LOW);
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	rx_tail = tail;
    9d10:	strb.w	r3, [fp]

	memcpy(buffer,  rx_buffer + i * MTP_RX_SIZE_480, rx_packet_size);
    9d14:	ldrh	r2, [r4, #0]
    9d16:	bl	7f58 <memcpy>
	rx_queue_transfer(i);
    9d1a:	mov	r0, r5
    9d1c:	bl	9b98 <rx_queue_transfer>
	//memset(rx_transfer, 0, sizeof(rx_transfer));
	//usb_prepare_transfer(rx_transfer + 0, rx_buffer, rx_packet_size, 0);
	//usb_receive(MTP_RX_ENDPOINT, rx_transfer + 0);
	return rx_packet_size;
    9d20:	ldrh	r0, [r4, #0]
}
    9d22:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t tail = rx_tail;
	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
		if (tail != rx_head) break;
		if (systick_millis_count - wait_begin_at > timeout)  {
			return 0;
    9d26:	movs	r0, #0
    9d28:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9d2c:	movs	r3, #0
		}
		yield();
	}
//	digitalWriteFast(0, LOW);
	if (++tail > RX_NUM) tail = 0;
    9d2e:	mov	r4, r3
    9d30:	b.n	9d02 <usb_mtp_recv+0x62>
    9d32:	nop
    9d34:	.word	0x2000b144
    9d38:	.word	0x2000b138
    9d3c:	.word	0x2000b1e4
    9d40:	.word	0x20203000
    9d44:	.word	0x2000b1ea
    9d48:	.word	0x2000b1e0
    9d4c:	.word	0x2000b1ec

00009d50 <usb_mtp_send>:
	//usb_receive(MTP_RX_ENDPOINT, rx_transfer + 0);
	return rx_packet_size;
}

int usb_mtp_send(const void *buffer, uint32_t len, uint32_t timeout)
{
    9d50:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	transfer_t *xfer = tx_transfer + tx_head;
    9d54:	ldr.w	sl, [pc, #192]	; 9e18 <usb_mtp_send+0xc8>
	//usb_receive(MTP_RX_ENDPOINT, rx_transfer + 0);
	return rx_packet_size;
}

int usb_mtp_send(const void *buffer, uint32_t len, uint32_t timeout)
{
    9d58:	mov	r8, r2
	transfer_t *xfer = tx_transfer + tx_head;
	uint32_t wait_begin_at = systick_millis_count;
    9d5a:	ldr	r5, [pc, #164]	; (9e00 <usb_mtp_send+0xb0>)

	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
    9d5c:	ldr	r6, [pc, #164]	; (9e04 <usb_mtp_send+0xb4>)
	return rx_packet_size;
}

int usb_mtp_send(const void *buffer, uint32_t len, uint32_t timeout)
{
	transfer_t *xfer = tx_transfer + tx_head;
    9d5e:	ldrb.w	r4, [sl]
    9d62:	ldr	r2, [pc, #164]	; (9e08 <usb_mtp_send+0xb8>)
	uint32_t wait_begin_at = systick_millis_count;
    9d64:	ldr	r7, [r5, #0]

	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
    9d66:	ldrb	r3, [r6, #0]
	return rx_packet_size;
}

int usb_mtp_send(const void *buffer, uint32_t len, uint32_t timeout)
{
	transfer_t *xfer = tx_transfer + tx_head;
    9d68:	add.w	r4, r2, r4, lsl #5
	uint32_t wait_begin_at = systick_millis_count;

	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
    9d6c:	cmp	r3, #0
    9d6e:	beq.n	9df0 <usb_mtp_send+0xa0>
    9d70:	mov	fp, r0
    9d72:	mov	r9, r1
    9d74:	b.n	9d86 <usb_mtp_send+0x36>
		uint32_t status = usb_transfer_status(xfer);
		if (!(status & 0x80)) break; // transfer descriptor ready
		if (systick_millis_count - wait_begin_at > timeout) return 0;
    9d76:	ldr	r3, [r5, #0]
    9d78:	subs	r3, r3, r7
    9d7a:	cmp	r3, r8
    9d7c:	bhi.n	9df8 <usb_mtp_send+0xa8>
		yield();
    9d7e:	bl	9ea4 <yield>
{
	transfer_t *xfer = tx_transfer + tx_head;
	uint32_t wait_begin_at = systick_millis_count;

	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
    9d82:	ldrb	r3, [r6, #0]
    9d84:	cbz	r3, 9df0 <usb_mtp_send+0xa0>
		uint32_t status = usb_transfer_status(xfer);
    9d86:	mov	r0, r4
    9d88:	bl	90cc <usb_transfer_status>
		if (!(status & 0x80)) break; // transfer descriptor ready
    9d8c:	lsls	r3, r0, #24
    9d8e:	bmi.n	9d76 <usb_mtp_send+0x26>
		if (systick_millis_count - wait_begin_at > timeout) return 0;
		yield();
	}
	uint8_t *txdata = txbuffer + (tx_head * MTP_TX_SIZE_480);
    9d90:	ldr	r3, [pc, #120]	; (9e0c <usb_mtp_send+0xbc>)
	memcpy(txdata, buffer, len);
    9d92:	mov	r2, r9
		uint32_t status = usb_transfer_status(xfer);
		if (!(status & 0x80)) break; // transfer descriptor ready
		if (systick_millis_count - wait_begin_at > timeout) return 0;
		yield();
	}
	uint8_t *txdata = txbuffer + (tx_head * MTP_TX_SIZE_480);
    9d94:	ldrb.w	r5, [sl]
	memcpy(txdata, buffer, len);
    9d98:	mov	r1, fp
		uint32_t status = usb_transfer_status(xfer);
		if (!(status & 0x80)) break; // transfer descriptor ready
		if (systick_millis_count - wait_begin_at > timeout) return 0;
		yield();
	}
	uint8_t *txdata = txbuffer + (tx_head * MTP_TX_SIZE_480);
    9d9a:	add.w	r5, r3, r5, lsl #9
	memcpy(txdata, buffer, len);
    9d9e:	mov	r0, r5
    9da0:	bl	7f58 <memcpy>
	arm_dcache_flush_delete(txdata, tx_packet_size );
    9da4:	ldr	r2, [pc, #104]	; (9e10 <usb_mtp_send+0xc0>)
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    9da6:	bic.w	r3, r5, #31
	uint32_t end_addr = (uint32_t)addr + size;
    9daa:	ldrh	r2, [r2, #0]
    9dac:	add	r2, r5
	asm volatile("": : :"memory");
	asm("dsb");
    9dae:	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    9db2:	ldr	r1, [pc, #96]	; (9e14 <usb_mtp_send+0xc4>)
    9db4:	str	r3, [r1, #0]
		location += 32;
    9db6:	adds	r3, #32
	} while (location < end_addr);
    9db8:	cmp	r2, r3
    9dba:	bhi.n	9db4 <usb_mtp_send+0x64>
	asm("dsb");
    9dbc:	dsb	sy
	asm("isb");
    9dc0:	isb	sy
	usb_prepare_transfer(xfer, txdata, len, 0);
    9dc4:	movs	r3, #0
    9dc6:	mov	r2, r9
    9dc8:	mov	r1, r5
    9dca:	mov	r0, r4
    9dcc:	bl	9050 <usb_prepare_transfer>
	usb_transmit(MTP_TX_ENDPOINT, xfer);
    9dd0:	mov	r1, r4
    9dd2:	movs	r0, #4
    9dd4:	bl	9080 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    9dd8:	ldrb.w	r3, [sl]
    9ddc:	ldr	r2, [pc, #56]	; (9e18 <usb_mtp_send+0xc8>)
	return len;
    9dde:	mov	r0, r9
	uint8_t *txdata = txbuffer + (tx_head * MTP_TX_SIZE_480);
	memcpy(txdata, buffer, len);
	arm_dcache_flush_delete(txdata, tx_packet_size );
	usb_prepare_transfer(xfer, txdata, len, 0);
	usb_transmit(MTP_TX_ENDPOINT, xfer);
	if (++tx_head >= TX_NUM) tx_head = 0;
    9de0:	adds	r3, #1
    9de2:	uxtb	r3, r3
    9de4:	cmp	r3, #3
    9de6:	it	hi
    9de8:	movhi	r3, #0
    9dea:	strb	r3, [r2, #0]
	return len;
    9dec:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	transfer_t *xfer = tx_transfer + tx_head;
	uint32_t wait_begin_at = systick_millis_count;

	while (1) {
		if (!usb_configuration) return -1; // usb not enumerated by host
    9df0:	mov.w	r0, #4294967295
    9df4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint32_t status = usb_transfer_status(xfer);
		if (!(status & 0x80)) break; // transfer descriptor ready
		if (systick_millis_count - wait_begin_at > timeout) return 0;
    9df8:	movs	r0, #0
	arm_dcache_flush_delete(txdata, tx_packet_size );
	usb_prepare_transfer(xfer, txdata, len, 0);
	usb_transmit(MTP_TX_ENDPOINT, xfer);
	if (++tx_head >= TX_NUM) tx_head = 0;
	return len;
}
    9dfa:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9dfe:	nop
    9e00:	.word	0x2000b144
    9e04:	.word	0x2000b138
    9e08:	.word	0x2000b200
    9e0c:	.word	0x20203800
    9e10:	.word	0x2000b15c
    9e14:	.word	0xe000ef70
    9e18:	.word	0x2000b15e

00009e1c <usb_mtp_available>:

int usb_mtp_available(void)
{
	if (!usb_configuration) return 0;
    9e1c:	ldr	r3, [pc, #28]	; (9e3c <usb_mtp_available+0x20>)
    9e1e:	ldrb	r3, [r3, #0]
    9e20:	and.w	r0, r3, #255	; 0xff
    9e24:	cbz	r3, 9e3a <usb_mtp_available+0x1e>
	if (rx_head != rx_tail) return rx_packet_size;
    9e26:	ldr	r2, [pc, #24]	; (9e40 <usb_mtp_available+0x24>)
    9e28:	ldr	r3, [pc, #24]	; (9e44 <usb_mtp_available+0x28>)
    9e2a:	ldrb	r2, [r2, #0]
    9e2c:	ldrb	r3, [r3, #0]
    9e2e:	cmp	r2, r3
    9e30:	beq.n	9e38 <usb_mtp_available+0x1c>
    9e32:	ldr	r3, [pc, #20]	; (9e48 <usb_mtp_available+0x2c>)
    9e34:	ldrh	r0, [r3, #0]
    9e36:	bx	lr
	return len;
}

int usb_mtp_available(void)
{
	if (!usb_configuration) return 0;
    9e38:	movs	r0, #0
	if (rx_head != rx_tail) return rx_packet_size;
	//if (!(usb_transfer_status(rx_transfer) & 0x80)) return MTP_RX_SIZE;
	return 0;
}
    9e3a:	bx	lr
    9e3c:	.word	0x2000b138
    9e40:	.word	0x2000b1ec
    9e44:	.word	0x2000b1e0
    9e48:	.word	0x2000b1ea

00009e4c <usb_init_serialnumber>:
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    9e4c:	ldr	r2, [pc, #72]	; (9e98 <usb_init_serialnumber+0x4c>)
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    9e4e:	ldr	r3, [pc, #76]	; (9e9c <usb_init_serialnumber+0x50>)
void usb_init_serialnumber(void)
{
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    9e50:	ldr.w	r0, [r2, #544]	; 0x220
    9e54:	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    9e58:	cmp	r0, r3
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    9e5a:	push	{r4, lr}
    9e5c:	sub	sp, #16
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    9e5e:	bhi.n	9e66 <usb_init_serialnumber+0x1a>
    9e60:	add.w	r0, r0, r0, lsl #2
    9e64:	lsls	r0, r0, #1
    9e66:	ldr	r4, [pc, #56]	; (9ea0 <usb_init_serialnumber+0x54>)
	ultoa(num, buf, 10);
    9e68:	add	r1, sp, #4
    9e6a:	movs	r2, #10
    9e6c:	bl	9330 <ultoa>
    9e70:	add	r1, sp, #4
	for (i=0; i<10; i++) {
    9e72:	movs	r3, #0
    9e74:	mov	r0, r4
		char c = buf[i];
    9e76:	ldrb.w	r2, [r1], #1
    9e7a:	adds	r3, #1
		if (!c) break;
    9e7c:	cbz	r2, 9e8e <usb_init_serialnumber+0x42>

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    9e7e:	cmp	r3, #10
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
    9e80:	strh.w	r2, [r0, #2]!

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    9e84:	bne.n	9e76 <usb_init_serialnumber+0x2a>
    9e86:	movs	r3, #22
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    9e88:	strb	r3, [r4, #0]
}
    9e8a:	add	sp, #16
    9e8c:	pop	{r4, pc}
    9e8e:	lsls	r3, r3, #1
    9e90:	uxtb	r3, r3
	for (i=0; i<10; i++) {
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    9e92:	strb	r3, [r4, #0]
}
    9e94:	add	sp, #16
    9e96:	pop	{r4, pc}
    9e98:	.word	0x401f4400
    9e9c:	.word	0x0098967f
    9ea0:	.word	0x20000b94

00009ea4 <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    9ea4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    9ea8:	ldr	r6, [pc, #160]	; (9f4c <yield+0xa8>)
    9eaa:	ldrb	r3, [r6, #0]
    9eac:	cbz	r3, 9ed0 <yield+0x2c>
	if (running) return; // TODO: does this need to be atomic?
    9eae:	ldr	r7, [pc, #160]	; (9f50 <yield+0xac>)
    9eb0:	ldrb	r4, [r7, #0]
    9eb2:	cbnz	r4, 9ed0 <yield+0x2c>
	running = 1;
    9eb4:	movs	r2, #1
    9eb6:	strb	r2, [r7, #0]
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
    9eb8:	lsls	r2, r3, #30
    9eba:	bmi.n	9eee <yield+0x4a>

	running = 0;
    9ebc:	movs	r2, #0
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    9ebe:	lsls	r3, r3, #29
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();

	running = 0;
    9ec0:	strb	r2, [r7, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    9ec2:	bpl.n	9ed0 <yield+0x2c>
	// Wait for event(s) to occur.  These are most likely to be useful when
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);
	static void runFromYield() {
		if (!firstYield) return;  
    9ec4:	ldr	r3, [pc, #140]	; (9f54 <yield+0xb0>)
    9ec6:	ldr	r2, [r3, #0]
    9ec8:	cbz	r2, 9ed0 <yield+0x2c>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    9eca:	mrs	r2, IPSR
		if (ipsr != 0) return;
    9ece:	cbz	r2, 9ed4 <yield+0x30>
    9ed0:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9ed4:	mrs	r0, PRIMASK
		__disable_irq();
    9ed8:	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    9eda:	ldr	r2, [r3, #0]
		if (first == nullptr) {
    9edc:	cbz	r2, 9ee4 <yield+0x40>
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    9ede:	ldr	r4, [pc, #120]	; (9f58 <yield+0xb4>)
    9ee0:	ldrb	r1, [r4, #0]
    9ee2:	cbz	r1, 9f28 <yield+0x84>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9ee4:	cmp	r0, #0
    9ee6:	bne.n	9ed0 <yield+0x2c>
    9ee8:	cpsie	i
    9eea:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    9eee:	ldr.w	r8, [pc, #112]	; 9f60 <yield+0xbc>
    9ef2:	ldrb.w	r2, [r8]
    9ef6:	cmp	r2, #0
    9ef8:	beq.n	9ebc <yield+0x18>
    9efa:	ldr.w	r9, [pc, #104]	; 9f64 <yield+0xc0>
    9efe:	b.n	9f0c <yield+0x68>
    9f00:	adds	r4, #1
    9f02:	ldrb.w	r3, [r8]
    9f06:	uxtb	r4, r4
    9f08:	cmp	r3, r4
    9f0a:	bls.n	9f24 <yield+0x80>
			s_serials_with_serial_events[i]->doYieldCode();
    9f0c:	ldr.w	r5, [r9, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    9f10:	ldr	r3, [r5, #0]
    9f12:	mov	r0, r5
    9f14:	ldr	r3, [r3, #16]
    9f16:	blx	r3
    9f18:	cmp	r0, #0
    9f1a:	beq.n	9f00 <yield+0x5c>
    9f1c:	ldr	r3, [r5, #20]
    9f1e:	ldr	r3, [r3, #8]
    9f20:	blx	r3
    9f22:	b.n	9f00 <yield+0x5c>
    9f24:	ldrb	r3, [r6, #0]
    9f26:	b.n	9ebc <yield+0x18>
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    9f28:	movs	r6, #1
		firstYield = first->_next;
    9f2a:	ldr	r5, [r2, #20]
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    9f2c:	strb	r6, [r4, #0]
		firstYield = first->_next;
    9f2e:	str	r5, [r3, #0]
		if (firstYield) {
    9f30:	cbz	r5, 9f46 <yield+0xa2>
			firstYield->_prev = nullptr;
    9f32:	str	r1, [r5, #24]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9f34:	cbnz	r0, 9f38 <yield+0x94>
    9f36:	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    9f38:	movs	r5, #0
		(*(first->_function))(*first);
    9f3a:	ldr	r3, [r2, #8]
    9f3c:	mov	r0, r2
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    9f3e:	strb	r5, [r2, #29]
		(*(first->_function))(*first);
    9f40:	blx	r3
		runningFromYield = false;
    9f42:	strb	r5, [r4, #0]
    9f44:	b.n	9ed0 <yield+0x2c>
		runningFromYield = true;
		firstYield = first->_next;
		if (firstYield) {
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
    9f46:	ldr	r3, [pc, #20]	; (9f5c <yield+0xb8>)
    9f48:	str	r5, [r3, #0]
    9f4a:	b.n	9f34 <yield+0x90>
    9f4c:	.word	0x20000baa
    9f50:	.word	0x2000b280
    9f54:	.word	0x2000b290
    9f58:	.word	0x2000b294
    9f5c:	.word	0x2000b28c
    9f60:	.word	0x2000b2b8
    9f64:	.word	0x2000b298

00009f68 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    9f68:	push	{r4, r5, r6, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9f6a:	mrs	r1, PRIMASK
		__disable_irq();
    9f6e:	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    9f70:	ldr	r4, [pc, #48]	; (9fa4 <EventResponder::runFromInterrupt()+0x3c>)
    9f72:	ldr	r3, [r4, #0]
		if (first) {
    9f74:	cbz	r3, 9f9a <EventResponder::runFromInterrupt()+0x32>
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    9f76:	ldr	r6, [pc, #48]	; (9fa8 <EventResponder::runFromInterrupt()+0x40>)
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
    9f78:	movs	r5, #0
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
		if (first) {
			firstInterrupt = first->_next;
    9f7a:	ldr	r2, [r3, #20]
    9f7c:	str	r2, [r4, #0]
			if (firstInterrupt) {
    9f7e:	cbz	r2, 9fa0 <EventResponder::runFromInterrupt()+0x38>
				firstInterrupt->_prev = nullptr;
    9f80:	str	r5, [r2, #24]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9f82:	cbnz	r1, 9f86 <EventResponder::runFromInterrupt()+0x1e>
    9f84:	cpsie	i
			} else {
				lastInterrupt = nullptr;
			}
			enableInterrupts(irq);
			first->_triggered = false;
    9f86:	strb	r5, [r3, #29]
			(*(first->_function))(*first);
    9f88:	mov	r0, r3
    9f8a:	ldr	r3, [r3, #8]
    9f8c:	blx	r3
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    9f8e:	mrs	r1, PRIMASK
		__disable_irq();
    9f92:	cpsid	i

void EventResponder::runFromInterrupt()
{
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    9f94:	ldr	r3, [r4, #0]
		if (first) {
    9f96:	cmp	r3, #0
    9f98:	bne.n	9f7a <EventResponder::runFromInterrupt()+0x12>
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    9f9a:	cbnz	r1, 9f9e <EventResponder::runFromInterrupt()+0x36>
    9f9c:	cpsie	i
    9f9e:	pop	{r4, r5, r6, pc}
			firstInterrupt = first->_next;
			if (firstInterrupt) {
				firstInterrupt->_prev = nullptr;
			} else {
				lastInterrupt = nullptr;
    9fa0:	str	r2, [r6, #0]
    9fa2:	b.n	9f82 <EventResponder::runFromInterrupt()+0x1a>
    9fa4:	.word	0x2000b284
    9fa8:	.word	0x2000b288

00009fac <pendablesrvreq_isr>:
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
	EventResponder::runFromInterrupt();
    9fac:	b.w	9f68 <EventResponder::runFromInterrupt()>

00009fb0 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    9fb0:	ldr	r2, [pc, #16]	; (9fc4 <systick_isr+0x14>)
    9fb2:	ldr	r3, [pc, #20]	; (9fc8 <systick_isr+0x18>)
    9fb4:	ldr	r1, [r2, #0]
	systick_millis_count++;
    9fb6:	ldr	r2, [pc, #20]	; (9fcc <systick_isr+0x1c>)
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    9fb8:	str	r1, [r3, #0]
	systick_millis_count++;
    9fba:	ldr	r3, [r2, #0]
    9fbc:	adds	r3, #1
    9fbe:	str	r3, [r2, #0]
    9fc0:	bx	lr
    9fc2:	nop
    9fc4:	.word	0xe0001004
    9fc8:	.word	0x2000b13c
    9fcc:	.word	0x2000b144

00009fd0 <usb_serial_class::clear()>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    9fd0:	b.w	8608 <usb_serial_flush_input>

00009fd4 <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    9fd4:	b.w	85b8 <usb_serial_peekchar>

00009fd8 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    9fd8:	b.w	867c <usb_serial_getchar>

00009fdc <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    9fdc:	b.w	85fc <usb_serial_available>

00009fe0 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    9fe0:	b.w	872c <usb_serial_flush_output>

00009fe4 <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    9fe4:	b.w	86e0 <usb_serial_write_buffer_free>

00009fe8 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    9fe8:	mov	r0, r1
    9fea:	mov	r1, r2
    9fec:	b.w	86c8 <usb_serial_write>

00009ff0 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    9ff0:	mov	r0, r1
    9ff2:	b.w	869c <usb_serial_putchar>
    9ff6:	nop

00009ff8 <Print::println()>:
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    9ff8:	push	{r4, lr}
	uint8_t buf[2]={'\r', '\n'};
    9ffa:	ldr	r4, [pc, #24]	; (a014 <Print::println()+0x1c>)
	if (n < 0) return printNumber64(-n, 10, 1);
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
    9ffc:	sub	sp, #8
	uint8_t buf[2]={'\r', '\n'};
	return write(buf, 2);
    9ffe:	ldr	r3, [r0, #0]
    a000:	movs	r2, #2
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    a002:	ldrh	r4, [r4, #0]
	return write(buf, 2);
    a004:	add	r1, sp, #4
    a006:	ldr	r3, [r3, #4]
	return printNumber64(n, 10, 0);
}

size_t Print::println(void)
{
	uint8_t buf[2]={'\r', '\n'};
    a008:	strh.w	r4, [sp, #4]
	return write(buf, 2);
    a00c:	blx	r3
}
    a00e:	add	sp, #8
    a010:	pop	{r4, pc}
    a012:	nop
    a014:	.word	0x200008ec

0000a018 <_write>:

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
	((class Print *)file)->write((uint8_t *)ptr, len);
    a018:	ldr	r3, [r0, #0]
}

extern "C" {
__attribute__((weak))
int _write(int file, char *ptr, int len)
{
    a01a:	push	{r4, lr}
    a01c:	mov	r4, r2
	((class Print *)file)->write((uint8_t *)ptr, len);
    a01e:	ldr	r3, [r3, #4]
    a020:	blx	r3
	return len;
}
    a022:	mov	r0, r4
    a024:	pop	{r4, pc}
    a026:	nop

0000a028 <Print::printf(char const*, ...)>:
}

int Print::printf(const char *format, ...)
{
    a028:	push	{r1, r2, r3}
    a02a:	push	{lr}
    a02c:	sub	sp, #8
    a02e:	add	r3, sp, #12
    a030:	ldr.w	r1, [r3], #4
	va_list ap;
	va_start(ap, format);
#ifdef __STRICT_ANSI__
	return 0;  // TODO: make this work with -std=c++0x
#else
	return vdprintf((int)this, format, ap);
    a034:	mov	r2, r3
}

int Print::printf(const char *format, ...)
{
	va_list ap;
	va_start(ap, format);
    a036:	str	r3, [sp, #4]
#ifdef __STRICT_ANSI__
	return 0;  // TODO: make this work with -std=c++0x
#else
	return vdprintf((int)this, format, ap);
    a038:	bl	d890 <vdprintf>
#endif
}
    a03c:	add	sp, #8
    a03e:	ldr.w	lr, [sp], #4
    a042:	add	sp, #12
    a044:	bx	lr
    a046:	nop

0000a048 <Print::printNumber(unsigned long, unsigned char, unsigned char)>:
	return vdprintf((int)this, (const char *)format, ap);
#endif
}

size_t Print::printNumber(unsigned long n, uint8_t base, uint8_t sign)
{
    a048:	push	{r4, r5, r6, r7, lr}
    a04a:	mov	r6, r0
    a04c:	sub	sp, #44	; 0x2c
	uint8_t digit, i;

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
    a04e:	cmp	r2, #0
    a050:	beq.n	a0ba <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x72>
		return write((uint8_t)n);
	} else if (base == 1) {
		base = 10;
    a052:	cmp	r2, #1
    a054:	it	eq
    a056:	moveq	r2, #10
	}


	if (n == 0) {
    a058:	cbz	r1, a0b0 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x68>
    a05a:	movs	r5, #33	; 0x21
    a05c:	b.n	a060 <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x18>
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
			n /= base;
			if (n == 0) break;
			i--;
    a05e:	uxtb	r5, r7
    a060:	subs	r7, r5, #1
		buf[sizeof(buf) - 1] = '0';
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
    a062:	udiv	r4, r1, r2
    a066:	mls	r1, r2, r4, r1
    a06a:	uxtb	r0, r1
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a06c:	cmp	r1, #9
    a06e:	add.w	r1, r0, #55	; 0x37
    a072:	add.w	r0, r0, #48	; 0x30
    a076:	it	hi
    a078:	uxtbhi	r0, r1
			n /= base;
			if (n == 0) break;
    a07a:	mov	r1, r4
		i = sizeof(buf) - 1;
	} else {
		i = sizeof(buf) - 1;
		while (1) {
			digit = n % base;
			buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    a07c:	add	r4, sp, #40	; 0x28
    a07e:	it	ls
    a080:	uxtbls	r0, r0
    a082:	add	r4, r5
    a084:	strb.w	r0, [r4, #-36]
			n /= base;
			if (n == 0) break;
    a088:	cmp	r1, #0
    a08a:	bne.n	a05e <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x16>
			i--;
		}
	}
	if (sign) {
    a08c:	cbz	r3, a09c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x54>
		i--;
    a08e:	subs	r5, #1
		buf[i] = '-';
    a090:	add	r3, sp, #40	; 0x28
    a092:	movs	r2, #45	; 0x2d
			if (n == 0) break;
			i--;
		}
	}
	if (sign) {
		i--;
    a094:	uxtb	r5, r5
		buf[i] = '-';
    a096:	add	r3, r5
    a098:	strb.w	r2, [r3, #-36]
	}
	return write(buf + i, sizeof(buf) - i);
    a09c:	ldr	r3, [r6, #0]
    a09e:	add	r1, sp, #4
    a0a0:	rsb	r2, r5, #34	; 0x22
    a0a4:	mov	r0, r6
    a0a6:	add	r1, r5
    a0a8:	ldr	r3, [r3, #4]
    a0aa:	blx	r3
}
    a0ac:	add	sp, #44	; 0x2c
    a0ae:	pop	{r4, r5, r6, r7, pc}
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    a0b0:	movs	r2, #48	; 0x30
		i = sizeof(buf) - 1;
    a0b2:	movs	r5, #33	; 0x21
		base = 10;
	}


	if (n == 0) {
		buf[sizeof(buf) - 1] = '0';
    a0b4:	strb.w	r2, [sp, #37]	; 0x25
    a0b8:	b.n	a08c <Print::printNumber(unsigned long, unsigned char, unsigned char)+0x44>

	// TODO: make these checks as inline, since base is
	// almost always a constant.  base = 0 (BYTE) should
	// inline as a call directly to write()
	if (base == 0) {
		return write((uint8_t)n);
    a0ba:	ldr	r3, [r0, #0]
    a0bc:	uxtb	r1, r1
    a0be:	ldr	r3, [r3, #0]
    a0c0:	blx	r3
	if (sign) {
		i--;
		buf[i] = '-';
	}
	return write(buf + i, sizeof(buf) - i);
}
    a0c2:	add	sp, #44	; 0x2c
    a0c4:	pop	{r4, r5, r6, r7, pc}
    a0c6:	nop

0000a0c8 <Print::print(long)>:

size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
    a0c8:	cmp	r1, #0
    a0ca:	blt.n	a0d4 <Print::print(long)+0xc>
	return count;
}

size_t Print::print(long n)
{
	uint8_t sign=0;
    a0cc:	movs	r3, #0

	if (n < 0) {
		sign = '-';
		n = -n;
	}
	return printNumber(n, 10, sign);
    a0ce:	movs	r2, #10
    a0d0:	b.w	a048 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
		n = -n;
    a0d4:	negs	r1, r1
size_t Print::print(long n)
{
	uint8_t sign=0;

	if (n < 0) {
		sign = '-';
    a0d6:	movs	r3, #45	; 0x2d
		n = -n;
	}
	return printNumber(n, 10, sign);
    a0d8:	movs	r2, #10
    a0da:	b.w	a048 <Print::printNumber(unsigned long, unsigned char, unsigned char)>
    a0de:	nop

0000a0e0 <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    a0e0:	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    a0e2:	bl	100 <setup>
	while (1) {
		loop();
    a0e6:	bl	5178 <loop>
		yield();
    a0ea:	bl	9ea4 <yield>
    a0ee:	b.n	a0e6 <main+0x6>

0000a0f0 <Stream::timedPeek()>:
  return -1;     // -1 indicates timeout
}

// private method to peek stream with timeout
int Stream::timedPeek()
{
    a0f0:	push	{r4, r5, r6, lr}
    a0f2:	ldr	r5, [pc, #40]	; (a11c <Stream::timedPeek()+0x2c>)
    a0f4:	mov	r4, r0
    a0f6:	ldr	r6, [r5, #0]
    a0f8:	b.n	a108 <Stream::timedPeek()+0x18>
  int c;
  unsigned long startMillis = millis();
  do {
    c = peek();
    if (c >= 0) return c;
    yield();
    a0fa:	bl	9ea4 <yield>
    a0fe:	ldr	r3, [r5, #0]
// private method to peek stream with timeout
int Stream::timedPeek()
{
  int c;
  unsigned long startMillis = millis();
  do {
    a100:	ldr	r2, [r4, #8]
    a102:	subs	r3, r3, r6
    a104:	cmp	r3, r2
    a106:	bcs.n	a116 <Stream::timedPeek()+0x26>
    c = peek();
    a108:	ldr	r3, [r4, #0]
    a10a:	mov	r0, r4
    a10c:	ldr	r3, [r3, #24]
    a10e:	blx	r3
    if (c >= 0) return c;
    a110:	cmp	r0, #0
    a112:	blt.n	a0fa <Stream::timedPeek()+0xa>
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
}
    a114:	pop	{r4, r5, r6, pc}
  do {
    c = peek();
    if (c >= 0) return c;
    yield();
  } while(millis() - startMillis < _timeout);
  return -1;     // -1 indicates timeout
    a116:	mov.w	r0, #4294967295
}
    a11a:	pop	{r4, r5, r6, pc}
    a11c:	.word	0x2000b144

0000a120 <Stream::peekNextDigit()>:

// returns peek of the next digit in the stream or -1 if timeout
// discards non-numeric characters
int Stream::peekNextDigit()
{
    a120:	push	{r4, lr}
    a122:	mov	r4, r0
    a124:	b.n	a134 <Stream::peekNextDigit()+0x14>
  int c;
  while (1) {
    c = timedPeek();
    if (c < 0) return c;  // timeout
    if (c == '-') return c;
    a126:	cmp	r3, #45	; 0x2d
    a128:	beq.n	a144 <Stream::peekNextDigit()+0x24>
    if (c >= '0' && c <= '9') return c;
    a12a:	cmp	r2, #9
    a12c:	bls.n	a144 <Stream::peekNextDigit()+0x24>
    read();  // discard non-numeric
    a12e:	ldr	r3, [r4, #0]
    a130:	ldr	r3, [r3, #20]
    a132:	blx	r3
// discards non-numeric characters
int Stream::peekNextDigit()
{
  int c;
  while (1) {
    c = timedPeek();
    a134:	mov	r0, r4
    a136:	bl	a0f0 <Stream::timedPeek()>
    if (c < 0) return c;  // timeout
    a13a:	subs	r3, r0, #0
    if (c == '-') return c;
    if (c >= '0' && c <= '9') return c;
    read();  // discard non-numeric
    a13c:	mov	r0, r4
  int c;
  while (1) {
    c = timedPeek();
    if (c < 0) return c;  // timeout
    if (c == '-') return c;
    if (c >= '0' && c <= '9') return c;
    a13e:	sub.w	r2, r3, #48	; 0x30
int Stream::peekNextDigit()
{
  int c;
  while (1) {
    c = timedPeek();
    if (c < 0) return c;  // timeout
    a142:	bge.n	a126 <Stream::peekNextDigit()+0x6>
    if (c == '-') return c;
    if (c >= '0' && c <= '9') return c;
    read();  // discard non-numeric
  }
}
    a144:	mov	r0, r3
    a146:	pop	{r4, pc}

0000a148 <Stream::parseInt(char)>:
}

// as above but a given skipChar is ignored
// this allows format characters (typically commas) in values to be ignored
long Stream::parseInt(char skipChar)
{
    a148:	push	{r3, r4, r5, r6, r7, lr}
    a14a:	mov	r5, r1
    a14c:	mov	r4, r0
  boolean isNegative = false;
  long value = 0;
  int c;

  c = peekNextDigit();
    a14e:	bl	a120 <Stream::peekNextDigit()>
  // ignore non numeric leading characters
  if(c < 0)
    a152:	cmp	r0, #0
    a154:	blt.n	a19e <Stream::parseInt(char)+0x56>
    a156:	movs	r6, #0
    a158:	mov	r7, r6
    return 0; // zero returned if timeout

  do{
    if(c == skipChar)
    a15a:	cmp	r0, r5
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
    a15c:	sub.w	r2, r0, #48	; 0x30
  // ignore non numeric leading characters
  if(c < 0)
    return 0; // zero returned if timeout

  do{
    if(c == skipChar)
    a160:	beq.n	a176 <Stream::parseInt(char)+0x2e>
      ; // ignore this charactor
    else if(c == '-')
    a162:	cmp	r0, #45	; 0x2d
    a164:	beq.n	a196 <Stream::parseInt(char)+0x4e>
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
      value = value * 10 + c - '0';
    a166:	add.w	r3, r6, r6, lsl #2
  do{
    if(c == skipChar)
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
    a16a:	cmp	r2, #9
      value = value * 10 + c - '0';
    a16c:	add.w	r0, r0, r3, lsl #1
  do{
    if(c == skipChar)
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    else if(c >= '0' && c <= '9')        // is c a digit?
    a170:	bhi.n	a176 <Stream::parseInt(char)+0x2e>
      value = value * 10 + c - '0';
    a172:	sub.w	r6, r0, #48	; 0x30
    read();  // consume the character we got with peek
    a176:	ldr	r3, [r4, #0]
    a178:	mov	r0, r4
    a17a:	ldr	r3, [r3, #20]
    a17c:	blx	r3
    c = timedPeek();
    a17e:	mov	r0, r4
    a180:	bl	a0f0 <Stream::timedPeek()>
  }
  while( (c >= '0' && c <= '9') || c == skipChar );
    a184:	sub.w	r3, r0, #48	; 0x30
    a188:	cmp	r3, #9
    a18a:	bls.n	a15a <Stream::parseInt(char)+0x12>
    a18c:	cmp	r0, r5
    a18e:	beq.n	a15a <Stream::parseInt(char)+0x12>

  if(isNegative)
    a190:	cbz	r7, a19a <Stream::parseInt(char)+0x52>
    value = -value;
    a192:	negs	r0, r6
    a194:	pop	{r3, r4, r5, r6, r7, pc}

  do{
    if(c == skipChar)
      ; // ignore this charactor
    else if(c == '-')
      isNegative = true;
    a196:	movs	r7, #1
    a198:	b.n	a176 <Stream::parseInt(char)+0x2e>
    a19a:	mov	r0, r6
  while( (c >= '0' && c <= '9') || c == skipChar );

  if(isNegative)
    value = -value;
  return value;
}
    a19c:	pop	{r3, r4, r5, r6, r7, pc}
  int c;

  c = peekNextDigit();
  // ignore non numeric leading characters
  if(c < 0)
    return 0; // zero returned if timeout
    a19e:	movs	r0, #0
    a1a0:	pop	{r3, r4, r5, r6, r7, pc}
    a1a2:	nop

0000a1a4 <Stream::parseInt()>:
// returns the first valid (long) integer value from the current position.
// initial characters that are not digits (or the minus sign) are skipped
// function is terminated by the first character that is not a digit.
long Stream::parseInt()
{
  return parseInt(NO_SKIP_CHAR); // terminate on first non-digit character (or timeout)
    a1a4:	movs	r1, #1
    a1a6:	b.w	a148 <Stream::parseInt(char)>
    a1aa:	nop

0000a1ac <set_arm_clock>:
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    a1ac:	ldr	r2, [pc, #600]	; (a408 <set_arm_clock+0x25c>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    a1ae:	ldr	r3, [pc, #604]	; (a40c <set_arm_clock+0x260>)
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    a1b0:	cmp	r0, r2
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
    a1b2:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;
    a1b6:	ldr	r4, [pc, #600]	; (a410 <set_arm_clock+0x264>)
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    a1b8:	ldr.w	lr, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    a1bc:	ldr	r1, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    a1be:	ldr	r6, [r4, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    a1c0:	bls.n	a1fc <set_arm_clock+0x50>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    a1c2:	ldr	r3, [pc, #592]	; (a414 <set_arm_clock+0x268>)
    a1c4:	cmp	r0, r3
    a1c6:	bls.w	a3f4 <set_arm_clock+0x248>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    a1ca:	ldr	r3, [pc, #588]	; (a418 <set_arm_clock+0x26c>)
    a1cc:	movw	r5, #1575	; 0x627
    a1d0:	ldr	r7, [pc, #584]	; (a41c <set_arm_clock+0x270>)
    a1d2:	add	r3, r0
    a1d4:	ldr	r4, [pc, #584]	; (a420 <set_arm_clock+0x274>)
    a1d6:	lsrs	r2, r3, #8
    a1d8:	umull	r3, r2, r7, r2
    a1dc:	lsrs	r3, r2, #7
    a1de:	add.w	r3, r3, r3, lsl #2
    a1e2:	add.w	r2, r3, r3, lsl #2
    a1e6:	addw	r3, r2, #1250	; 0x4e2
    a1ea:	cmp	r3, r5
    a1ec:	it	cs
    a1ee:	movcs	r3, r5
    a1f0:	sub.w	r3, r3, #800	; 0x320
    a1f4:	umull	r3, r5, r4, r3
    a1f8:	lsrs	r5, r5, #3
    a1fa:	b.n	a206 <set_arm_clock+0x5a>
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
		}
#endif
	} else if (frequency <= 24000000) {
    a1fc:	ldr	r5, [pc, #548]	; (a424 <set_arm_clock+0x278>)
    a1fe:	cmp	r0, r5
    a200:	ite	ls
    a202:	movls	r5, #6
    a204:	movhi	r5, #14
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    a206:	ldr	r2, [pc, #516]	; (a40c <set_arm_clock+0x260>)
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    a208:	and.w	r7, r6, #31
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    a20c:	ldr.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    a210:	cmp	r7, r5
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    a212:	orr.w	r3, r3, #192	; 0xc0
    a216:	str.w	r3, [r2, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    a21a:	bcs.n	a232 <set_arm_clock+0x86>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    a21c:	ldr	r3, [pc, #496]	; (a410 <set_arm_clock+0x264>)

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    a21e:	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    a222:	mov	r2, r3
	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    a224:	orrs	r6, r5
		DCDC_REG3 = dcdc;
    a226:	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    a228:	ldr	r3, [r2, #0]
    a22a:	cmp	r3, #0
    a22c:	bge.n	a228 <set_arm_clock+0x7c>
    a22e:	and.w	r7, r6, #31
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    a232:	ands.w	r3, lr, #33554432	; 0x2000000
    a236:	bne.n	a29c <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    a238:	ldr	r4, [pc, #492]	; (a428 <set_arm_clock+0x27c>)
    a23a:	ldr	r2, [pc, #496]	; (a42c <set_arm_clock+0x280>)
    a23c:	ldr.w	ip, [r4, #16]
    a240:	mov	r4, r2
    a242:	and.w	r2, ip, r2
    a246:	cmp	r2, r4
    a248:	itet	eq
    a24a:	moveq.w	r3, #402653184	; 0x18000000
    a24e:	movne.w	r2, #4096	; 0x1000
    a252:	moveq	r2, #0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    a254:	eor.w	r4, lr, r3
    a258:	tst.w	r4, #939524096	; 0x38000000
    a25c:	beq.n	a270 <set_arm_clock+0xc4>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    a25e:	bic.w	lr, lr, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    a262:	and.w	r3, r3, #939524096	; 0x38000000
			CCM_CBCDR = cbcdr;
    a266:	ldr	r4, [pc, #420]	; (a40c <set_arm_clock+0x260>)
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    a268:	orr.w	lr, r3, lr
			CCM_CBCDR = cbcdr;
    a26c:	str.w	lr, [r4, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    a270:	eor.w	r3, r1, r2
    a274:	tst.w	r3, #12288	; 0x3000
    a278:	beq.n	a28c <set_arm_clock+0xe0>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    a27a:	ldr	r3, [pc, #400]	; (a40c <set_arm_clock+0x260>)
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
			CCM_CBCDR = cbcdr;
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    a27c:	bic.w	r1, r1, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    a280:	orrs	r1, r2
			CCM_CBCMR = cbcmr;
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    a282:	mov	r2, r3
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
			CCM_CBCMR = cbcmr;
    a284:	str	r1, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    a286:	ldr	r3, [r2, #72]	; 0x48
    a288:	lsls	r4, r3, #28
    a28a:	bmi.n	a286 <set_arm_clock+0xda>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    a28c:	orr.w	lr, lr, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    a290:	ldr	r2, [pc, #376]	; (a40c <set_arm_clock+0x260>)
    a292:	str.w	lr, [r2, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    a296:	ldr	r3, [r2, #72]	; 0x48
    a298:	lsls	r1, r3, #26
    a29a:	bmi.n	a296 <set_arm_clock+0xea>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
    a29c:	movs	r1, #1
	while (frequency * div_arm * div_ahb < 648000000) {
    a29e:	ldr	r4, [pc, #400]	; (a430 <set_arm_clock+0x284>)
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
    a2a0:	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    a2a2:	mul.w	r3, r1, r2
    a2a6:	mul.w	r3, r0, r3
    a2aa:	cmp	r3, r4
    a2ac:	bhi.n	a2c2 <set_arm_clock+0x116>
		if (div_arm < 8) {
    a2ae:	cmp	r2, #7
    a2b0:	bhi.w	a3de <set_arm_clock+0x232>
			div_arm = div_arm + 1;
    a2b4:	adds	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    a2b6:	mul.w	r3, r1, r2
    a2ba:	mul.w	r3, r0, r3
    a2be:	cmp	r3, r4
    a2c0:	bls.n	a2ae <set_arm_clock+0x102>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    a2c2:	ldr	r0, [pc, #368]	; (a434 <set_arm_clock+0x288>)
    a2c4:	ldr	r4, [pc, #368]	; (a438 <set_arm_clock+0x28c>)
    a2c6:	add	r0, r3
    a2c8:	umull	r0, r3, r4, r0
    a2cc:	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
    a2ce:	cmp	r3, #108	; 0x6c
    a2d0:	bhi.w	a3ea <set_arm_clock+0x23e>
	if (mult < 54) mult = 54;
    a2d4:	cmp	r3, #53	; 0x35
    a2d6:	bhi.w	a3f8 <set_arm_clock+0x24c>
    a2da:	ldr.w	r8, [pc, #392]	; a464 <set_arm_clock+0x2b8>
    a2de:	movs	r3, #54	; 0x36
    a2e0:	ldr	r0, [pc, #344]	; (a43c <set_arm_clock+0x290>)

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    a2e2:	ldr.w	ip, [pc, #324]	; a428 <set_arm_clock+0x27c>
    a2e6:	ldr	r4, [pc, #344]	; (a440 <set_arm_clock+0x294>)
    a2e8:	ldr.w	r9, [ip]
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    a2ec:	udiv	r0, r0, r2

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    a2f0:	and.w	r4, r9, r4
    a2f4:	cmp	r4, r8
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
	if (mult < 54) mult = 54;
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    a2f6:	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    a2fa:	beq.n	a314 <set_arm_clock+0x168>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    a2fc:	orr.w	r3, r3, #8192	; 0x2000
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    a300:	mov.w	r8, #4096	; 0x1000
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    a304:	mov	r4, ip
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    a306:	str.w	r8, [ip]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    a30a:	str.w	r3, [ip]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    a30e:	ldr	r3, [r4, #0]
    a310:	cmp	r3, #0
    a312:	bge.n	a30e <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    a314:	ldr.w	ip, [pc, #244]	; a40c <set_arm_clock+0x260>
    a318:	subs	r2, #1
    a31a:	ldr.w	r3, [ip, #16]
    a31e:	and.w	r3, r3, #7
    a322:	cmp	r3, r2
    a324:	beq.n	a336 <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    a326:	and.w	r2, r2, #7
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    a32a:	mov	r4, ip
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    a32c:	str.w	r2, [ip, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    a330:	ldr	r3, [r4, #72]	; 0x48
    a332:	lsls	r3, r3, #15
    a334:	bmi.n	a330 <set_arm_clock+0x184>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    a336:	subs	r1, #1
    a338:	lsls	r1, r1, #10
    a33a:	eor.w	r3, lr, r1
    a33e:	tst.w	r3, #7168	; 0x1c00
    a342:	beq.n	a35e <set_arm_clock+0x1b2>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
		CCM_CBCDR = cbcdr;
    a344:	ldr	r3, [pc, #196]	; (a40c <set_arm_clock+0x260>)
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    a346:	bic.w	lr, lr, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    a34a:	and.w	r1, r1, #7168	; 0x1c00
		CCM_CBCDR = cbcdr;
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    a34e:	mov	r2, r3
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    a350:	orr.w	lr, r1, lr
		CCM_CBCDR = cbcdr;
    a354:	str.w	lr, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    a358:	ldr	r3, [r2, #72]	; 0x48
    a35a:	lsls	r1, r3, #30
    a35c:	bmi.n	a358 <set_arm_clock+0x1ac>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    a35e:	ldr	r3, [pc, #228]	; (a444 <set_arm_clock+0x298>)
    a360:	ldr	r1, [pc, #228]	; (a448 <set_arm_clock+0x29c>)
    a362:	add	r3, r0
    a364:	lsrs	r3, r3, #7
    a366:	umull	r3, r1, r1, r3
    a36a:	lsrs	r1, r1, #12
    a36c:	cmp	r1, #4
    a36e:	it	cs
    a370:	movcs	r1, #4
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    a372:	subs	r3, r1, #1
    a374:	lsls	r3, r3, #8
    a376:	eor.w	r2, lr, r3
    a37a:	tst.w	r2, #768	; 0x300
    a37e:	beq.n	a390 <set_arm_clock+0x1e4>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    a380:	bic.w	lr, lr, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    a384:	and.w	r3, r3, #768	; 0x300
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    a388:	ldr	r2, [pc, #128]	; (a40c <set_arm_clock+0x260>)

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
	if (div_ipg > 4) div_ipg = 4;
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    a38a:	orr.w	r3, r3, lr
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    a38e:	str	r3, [r2, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    a390:	ldr	r3, [pc, #120]	; (a40c <set_arm_clock+0x260>)
    a392:	ldr	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    a394:	mov	r2, r3
		CCM_CBCDR = cbcdr;
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    a396:	bic.w	r4, r4, #33554432	; 0x2000000
    a39a:	str	r4, [r3, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    a39c:	ldr	r3, [r2, #72]	; 0x48
    a39e:	lsls	r3, r3, #26
    a3a0:	bmi.n	a39c <set_arm_clock+0x1f0>

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    a3a2:	ldr	r3, [pc, #168]	; (a44c <set_arm_clock+0x2a0>)
    a3a4:	mov.w	r2, #4294967295
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    a3a8:	ldr	r4, [pc, #164]	; (a450 <set_arm_clock+0x2a4>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    a3aa:	cmp	r5, r7
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    a3ac:	umull	lr, r3, r3, r0
	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
    a3b0:	str	r0, [r4, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    a3b2:	mov.w	r3, r3, lsr #18
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    a3b6:	ldr	r4, [pc, #156]	; (a454 <set_arm_clock+0x2a8>)
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    a3b8:	udiv	r3, r2, r3
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    a3bc:	udiv	r1, r0, r1
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    a3c0:	ldr	r2, [pc, #148]	; (a458 <set_arm_clock+0x2ac>)
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait

	F_CPU_ACTUAL = frequency;
	F_BUS_ACTUAL = frequency / div_ipg;
    a3c2:	str	r1, [r4, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    a3c4:	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    a3c6:	bcs.n	a3da <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
    a3c8:	ldr	r3, [pc, #68]	; (a410 <set_arm_clock+0x264>)
	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    a3ca:	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
		DCDC_REG3 = dcdc;
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    a3ce:	mov	r2, r3

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    a3d0:	orrs	r6, r5
		DCDC_REG3 = dcdc;
    a3d2:	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    a3d4:	ldr	r3, [r2, #0]
    a3d6:	cmp	r3, #0
    a3d8:	bge.n	a3d4 <set_arm_clock+0x228>
	}

	return frequency;
}
    a3da:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
		if (div_arm < 8) {
			div_arm = div_arm + 1;
		} else {
			if (div_ahb < 5) {
    a3de:	cmp	r1, #4
    a3e0:	bhi.w	a2c2 <set_arm_clock+0x116>
				div_ahb = div_ahb + 1;
    a3e4:	adds	r1, #1
				div_arm = 1;
    a3e6:	movs	r2, #1
    a3e8:	b.n	a2a2 <set_arm_clock+0xf6>
    a3ea:	ldr.w	r8, [pc, #124]	; a468 <set_arm_clock+0x2bc>
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
	if (mult > 108) mult = 108;
    a3ee:	movs	r3, #108	; 0x6c
    a3f0:	ldr	r0, [pc, #104]	; (a45c <set_arm_clock+0x2b0>)
    a3f2:	b.n	a2e2 <set_arm_clock+0x136>
    a3f4:	movs	r5, #18
    a3f6:	b.n	a206 <set_arm_clock+0x5a>
    a3f8:	ldr	r0, [pc, #100]	; (a460 <set_arm_clock+0x2b4>)
    a3fa:	ldr.w	r8, [pc, #112]	; a46c <set_arm_clock+0x2c0>
    a3fe:	mul.w	r0, r0, r3
    a402:	orr.w	r8, r3, r8
    a406:	b.n	a2e2 <set_arm_clock+0x136>
    a408:	.word	0x1f78a400
    a40c:	.word	0x400fc000
    a410:	.word	0x40080000
    a414:	.word	0x23c34600
    a418:	.word	0xdc3cba00
    a41c:	.word	0x004cb223
    a420:	.word	0x51eb851f
    a424:	.word	0x016e3600
    a428:	.word	0x400d8000
    a42c:	.word	0x80003040
    a430:	.word	0x269fb1ff
    a434:	.word	0x005b8d80
    a438:	.word	0x165e9f81
    a43c:	.word	0x269fb200
    a440:	.word	0x8001307f
    a444:	.word	0x08f0d17f
    a448:	.word	0x00e5109f
    a44c:	.word	0x431bde83
    a450:	.word	0x20000bc0
    a454:	.word	0x20000bbc
    a458:	.word	0x2000b140
    a45c:	.word	0x4d3f6400
    a460:	.word	0x00b71b00
    a464:	.word	0x80002036
    a468:	.word	0x8000206c
    a46c:	.word	0x80002000

0000a470 <__aeabi_drsub>:
    a470:	eor.w	r1, r1, #2147483648	; 0x80000000
    a474:	b.n	a47c <__adddf3>
    a476:	nop

0000a478 <__aeabi_dsub>:
    a478:	eor.w	r3, r3, #2147483648	; 0x80000000

0000a47c <__adddf3>:
    a47c:	push	{r4, r5, lr}
    a47e:	mov.w	r4, r1, lsl #1
    a482:	mov.w	r5, r3, lsl #1
    a486:	teq	r4, r5
    a48a:	it	eq
    a48c:	teqeq	r0, r2
    a490:	itttt	ne
    a492:	orrsne.w	ip, r4, r0
    a496:	orrsne.w	ip, r5, r2
    a49a:	mvnsne.w	ip, r4, asr #21
    a49e:	mvnsne.w	ip, r5, asr #21
    a4a2:	beq.w	a66a <__adddf3+0x1ee>
    a4a6:	mov.w	r4, r4, lsr #21
    a4aa:	rsbs	r5, r4, r5, lsr #21
    a4ae:	it	lt
    a4b0:	neglt	r5, r5
    a4b2:	ble.n	a4ce <__adddf3+0x52>
    a4b4:	add	r4, r5
    a4b6:	eor.w	r2, r0, r2
    a4ba:	eor.w	r3, r1, r3
    a4be:	eor.w	r0, r2, r0
    a4c2:	eor.w	r1, r3, r1
    a4c6:	eor.w	r2, r0, r2
    a4ca:	eor.w	r3, r1, r3
    a4ce:	cmp	r5, #54	; 0x36
    a4d0:	it	hi
    a4d2:	pophi	{r4, r5, pc}
    a4d4:	tst.w	r1, #2147483648	; 0x80000000
    a4d8:	mov.w	r1, r1, lsl #12
    a4dc:	mov.w	ip, #1048576	; 0x100000
    a4e0:	orr.w	r1, ip, r1, lsr #12
    a4e4:	beq.n	a4ec <__adddf3+0x70>
    a4e6:	negs	r0, r0
    a4e8:	sbc.w	r1, r1, r1, lsl #1
    a4ec:	tst.w	r3, #2147483648	; 0x80000000
    a4f0:	mov.w	r3, r3, lsl #12
    a4f4:	orr.w	r3, ip, r3, lsr #12
    a4f8:	beq.n	a500 <__adddf3+0x84>
    a4fa:	negs	r2, r2
    a4fc:	sbc.w	r3, r3, r3, lsl #1
    a500:	teq	r4, r5
    a504:	beq.w	a656 <__adddf3+0x1da>
    a508:	sub.w	r4, r4, #1
    a50c:	rsbs	lr, r5, #32
    a510:	blt.n	a52e <__adddf3+0xb2>
    a512:	lsl.w	ip, r2, lr
    a516:	lsr.w	r2, r2, r5
    a51a:	adds	r0, r0, r2
    a51c:	adc.w	r1, r1, #0
    a520:	lsl.w	r2, r3, lr
    a524:	adds	r0, r0, r2
    a526:	asr.w	r3, r3, r5
    a52a:	adcs	r1, r3
    a52c:	b.n	a54c <__adddf3+0xd0>
    a52e:	sub.w	r5, r5, #32
    a532:	add.w	lr, lr, #32
    a536:	cmp	r2, #1
    a538:	lsl.w	ip, r3, lr
    a53c:	it	cs
    a53e:	orrcs.w	ip, ip, #2
    a542:	asr.w	r3, r3, r5
    a546:	adds	r0, r0, r3
    a548:	adcs.w	r1, r1, r3, asr #31
    a54c:	and.w	r5, r1, #2147483648	; 0x80000000
    a550:	bpl.n	a562 <__adddf3+0xe6>
    a552:	mov.w	lr, #0
    a556:	rsbs	ip, ip, #0
    a55a:	sbcs.w	r0, lr, r0
    a55e:	sbc.w	r1, lr, r1
    a562:	cmp.w	r1, #1048576	; 0x100000
    a566:	bcc.n	a5a0 <__adddf3+0x124>
    a568:	cmp.w	r1, #2097152	; 0x200000
    a56c:	bcc.n	a588 <__adddf3+0x10c>
    a56e:	lsrs	r1, r1, #1
    a570:	movs.w	r0, r0, rrx
    a574:	mov.w	ip, ip, rrx
    a578:	add.w	r4, r4, #1
    a57c:	mov.w	r2, r4, lsl #21
    a580:	cmn.w	r2, #4194304	; 0x400000
    a584:	bcs.w	a6bc <__adddf3+0x240>
    a588:	cmp.w	ip, #2147483648	; 0x80000000
    a58c:	it	eq
    a58e:	movseq.w	ip, r0, lsr #1
    a592:	adcs.w	r0, r0, #0
    a596:	adc.w	r1, r1, r4, lsl #20
    a59a:	orr.w	r1, r1, r5
    a59e:	pop	{r4, r5, pc}
    a5a0:	movs.w	ip, ip, lsl #1
    a5a4:	adcs	r0, r0
    a5a6:	adc.w	r1, r1, r1
    a5aa:	tst.w	r1, #1048576	; 0x100000
    a5ae:	sub.w	r4, r4, #1
    a5b2:	bne.n	a588 <__adddf3+0x10c>
    a5b4:	teq	r1, #0
    a5b8:	itt	eq
    a5ba:	moveq	r1, r0
    a5bc:	moveq	r0, #0
    a5be:	clz	r3, r1
    a5c2:	it	eq
    a5c4:	addeq	r3, #32
    a5c6:	sub.w	r3, r3, #11
    a5ca:	subs.w	r2, r3, #32
    a5ce:	bge.n	a5ea <__adddf3+0x16e>
    a5d0:	adds	r2, #12
    a5d2:	ble.n	a5e6 <__adddf3+0x16a>
    a5d4:	add.w	ip, r2, #20
    a5d8:	rsb	r2, r2, #12
    a5dc:	lsl.w	r0, r1, ip
    a5e0:	lsr.w	r1, r1, r2
    a5e4:	b.n	a600 <__adddf3+0x184>
    a5e6:	add.w	r2, r2, #20
    a5ea:	it	le
    a5ec:	rsble	ip, r2, #32
    a5f0:	lsl.w	r1, r1, r2
    a5f4:	lsr.w	ip, r0, ip
    a5f8:	itt	le
    a5fa:	orrle.w	r1, r1, ip
    a5fe:	lslle	r0, r2
    a600:	subs	r4, r4, r3
    a602:	ittt	ge
    a604:	addge.w	r1, r1, r4, lsl #20
    a608:	orrge	r1, r5
    a60a:	popge	{r4, r5, pc}
    a60c:	mvn.w	r4, r4
    a610:	subs	r4, #31
    a612:	bge.n	a64e <__adddf3+0x1d2>
    a614:	adds	r4, #12
    a616:	bgt.n	a636 <__adddf3+0x1ba>
    a618:	add.w	r4, r4, #20
    a61c:	rsb	r2, r4, #32
    a620:	lsr.w	r0, r0, r4
    a624:	lsl.w	r3, r1, r2
    a628:	orr.w	r0, r0, r3
    a62c:	lsr.w	r3, r1, r4
    a630:	orr.w	r1, r5, r3
    a634:	pop	{r4, r5, pc}
    a636:	rsb	r4, r4, #12
    a63a:	rsb	r2, r4, #32
    a63e:	lsr.w	r0, r0, r2
    a642:	lsl.w	r3, r1, r4
    a646:	orr.w	r0, r0, r3
    a64a:	mov	r1, r5
    a64c:	pop	{r4, r5, pc}
    a64e:	lsr.w	r0, r1, r4
    a652:	mov	r1, r5
    a654:	pop	{r4, r5, pc}
    a656:	teq	r4, #0
    a65a:	eor.w	r3, r3, #1048576	; 0x100000
    a65e:	itte	eq
    a660:	eoreq.w	r1, r1, #1048576	; 0x100000
    a664:	addeq	r4, #1
    a666:	subne	r5, #1
    a668:	b.n	a508 <__adddf3+0x8c>
    a66a:	mvns.w	ip, r4, asr #21
    a66e:	it	ne
    a670:	mvnsne.w	ip, r5, asr #21
    a674:	beq.n	a6ca <__adddf3+0x24e>
    a676:	teq	r4, r5
    a67a:	it	eq
    a67c:	teqeq	r0, r2
    a680:	beq.n	a68e <__adddf3+0x212>
    a682:	orrs.w	ip, r4, r0
    a686:	itt	eq
    a688:	moveq	r1, r3
    a68a:	moveq	r0, r2
    a68c:	pop	{r4, r5, pc}
    a68e:	teq	r1, r3
    a692:	ittt	ne
    a694:	movne	r1, #0
    a696:	movne	r0, #0
    a698:	popne	{r4, r5, pc}
    a69a:	movs.w	ip, r4, lsr #21
    a69e:	bne.n	a6ac <__adddf3+0x230>
    a6a0:	lsls	r0, r0, #1
    a6a2:	adcs	r1, r1
    a6a4:	it	cs
    a6a6:	orrcs.w	r1, r1, #2147483648	; 0x80000000
    a6aa:	pop	{r4, r5, pc}
    a6ac:	adds.w	r4, r4, #4194304	; 0x400000
    a6b0:	itt	cc
    a6b2:	addcc.w	r1, r1, #1048576	; 0x100000
    a6b6:	popcc	{r4, r5, pc}
    a6b8:	and.w	r5, r1, #2147483648	; 0x80000000
    a6bc:	orr.w	r1, r5, #2130706432	; 0x7f000000
    a6c0:	orr.w	r1, r1, #15728640	; 0xf00000
    a6c4:	mov.w	r0, #0
    a6c8:	pop	{r4, r5, pc}
    a6ca:	mvns.w	ip, r4, asr #21
    a6ce:	itte	ne
    a6d0:	movne	r1, r3
    a6d2:	movne	r0, r2
    a6d4:	mvnseq.w	ip, r5, asr #21
    a6d8:	itt	ne
    a6da:	movne	r3, r1
    a6dc:	movne	r2, r0
    a6de:	orrs.w	r4, r0, r1, lsl #12
    a6e2:	itte	eq
    a6e4:	orrseq.w	r5, r2, r3, lsl #12
    a6e8:	teqeq	r1, r3
    a6ec:	orrne.w	r1, r1, #524288	; 0x80000
    a6f0:	pop	{r4, r5, pc}
    a6f2:	nop

0000a6f4 <__aeabi_ui2d>:
    a6f4:	teq	r0, #0
    a6f8:	itt	eq
    a6fa:	moveq	r1, #0
    a6fc:	bxeq	lr
    a6fe:	push	{r4, r5, lr}
    a700:	mov.w	r4, #1024	; 0x400
    a704:	add.w	r4, r4, #50	; 0x32
    a708:	mov.w	r5, #0
    a70c:	mov.w	r1, #0
    a710:	b.n	a5b4 <__adddf3+0x138>
    a712:	nop

0000a714 <__aeabi_i2d>:
    a714:	teq	r0, #0
    a718:	itt	eq
    a71a:	moveq	r1, #0
    a71c:	bxeq	lr
    a71e:	push	{r4, r5, lr}
    a720:	mov.w	r4, #1024	; 0x400
    a724:	add.w	r4, r4, #50	; 0x32
    a728:	ands.w	r5, r0, #2147483648	; 0x80000000
    a72c:	it	mi
    a72e:	negmi	r0, r0
    a730:	mov.w	r1, #0
    a734:	b.n	a5b4 <__adddf3+0x138>
    a736:	nop

0000a738 <__aeabi_f2d>:
    a738:	lsls	r2, r0, #1
    a73a:	mov.w	r1, r2, asr #3
    a73e:	mov.w	r1, r1, rrx
    a742:	mov.w	r0, r2, lsl #28
    a746:	itttt	ne
    a748:	andsne.w	r3, r2, #4278190080	; 0xff000000
    a74c:	teqne	r3, #4278190080	; 0xff000000
    a750:	eorne.w	r1, r1, #939524096	; 0x38000000
    a754:	bxne	lr
    a756:	teq	r2, #0
    a75a:	ite	ne
    a75c:	teqne	r3, #4278190080	; 0xff000000
    a760:	bxeq	lr
    a762:	push	{r4, r5, lr}
    a764:	mov.w	r4, #896	; 0x380
    a768:	and.w	r5, r1, #2147483648	; 0x80000000
    a76c:	bic.w	r1, r1, #2147483648	; 0x80000000
    a770:	b.n	a5b4 <__adddf3+0x138>
    a772:	nop

0000a774 <__aeabi_ul2d>:
    a774:	orrs.w	r2, r0, r1
    a778:	it	eq
    a77a:	bxeq	lr
    a77c:	push	{r4, r5, lr}
    a77e:	mov.w	r5, #0
    a782:	b.n	a79a <__aeabi_l2d+0x16>

0000a784 <__aeabi_l2d>:
    a784:	orrs.w	r2, r0, r1
    a788:	it	eq
    a78a:	bxeq	lr
    a78c:	push	{r4, r5, lr}
    a78e:	ands.w	r5, r1, #2147483648	; 0x80000000
    a792:	bpl.n	a79a <__aeabi_l2d+0x16>
    a794:	negs	r0, r0
    a796:	sbc.w	r1, r1, r1, lsl #1
    a79a:	mov.w	r4, #1024	; 0x400
    a79e:	add.w	r4, r4, #50	; 0x32
    a7a2:	movs.w	ip, r1, lsr #22
    a7a6:	beq.w	a562 <__adddf3+0xe6>
    a7aa:	mov.w	r2, #3
    a7ae:	movs.w	ip, ip, lsr #3
    a7b2:	it	ne
    a7b4:	addne	r2, #3
    a7b6:	movs.w	ip, ip, lsr #3
    a7ba:	it	ne
    a7bc:	addne	r2, #3
    a7be:	add.w	r2, r2, ip, lsr #3
    a7c2:	rsb	r3, r2, #32
    a7c6:	lsl.w	ip, r0, r3
    a7ca:	lsr.w	r0, r0, r2
    a7ce:	lsl.w	lr, r1, r3
    a7d2:	orr.w	r0, r0, lr
    a7d6:	lsr.w	r1, r1, r2
    a7da:	add	r4, r2
    a7dc:	b.n	a562 <__adddf3+0xe6>
    a7de:	nop

0000a7e0 <__aeabi_dmul>:
    a7e0:	push	{r4, r5, r6, lr}
    a7e2:	mov.w	ip, #255	; 0xff
    a7e6:	orr.w	ip, ip, #1792	; 0x700
    a7ea:	ands.w	r4, ip, r1, lsr #20
    a7ee:	ittte	ne
    a7f0:	andsne.w	r5, ip, r3, lsr #20
    a7f4:	teqne	r4, ip
    a7f8:	teqne	r5, ip
    a7fc:	bleq	a9bc <__aeabi_dmul+0x1dc>
    a800:	add	r4, r5
    a802:	eor.w	r6, r1, r3
    a806:	bic.w	r1, r1, ip, lsl #21
    a80a:	bic.w	r3, r3, ip, lsl #21
    a80e:	orrs.w	r5, r0, r1, lsl #12
    a812:	it	ne
    a814:	orrsne.w	r5, r2, r3, lsl #12
    a818:	orr.w	r1, r1, #1048576	; 0x100000
    a81c:	orr.w	r3, r3, #1048576	; 0x100000
    a820:	beq.n	a894 <__aeabi_dmul+0xb4>
    a822:	umull	ip, lr, r0, r2
    a826:	mov.w	r5, #0
    a82a:	umlal	lr, r5, r1, r2
    a82e:	and.w	r2, r6, #2147483648	; 0x80000000
    a832:	umlal	lr, r5, r0, r3
    a836:	mov.w	r6, #0
    a83a:	umlal	r5, r6, r1, r3
    a83e:	teq	ip, #0
    a842:	it	ne
    a844:	orrne.w	lr, lr, #1
    a848:	sub.w	r4, r4, #255	; 0xff
    a84c:	cmp.w	r6, #512	; 0x200
    a850:	sbc.w	r4, r4, #768	; 0x300
    a854:	bcs.n	a860 <__aeabi_dmul+0x80>
    a856:	movs.w	lr, lr, lsl #1
    a85a:	adcs	r5, r5
    a85c:	adc.w	r6, r6, r6
    a860:	orr.w	r1, r2, r6, lsl #11
    a864:	orr.w	r1, r1, r5, lsr #21
    a868:	mov.w	r0, r5, lsl #11
    a86c:	orr.w	r0, r0, lr, lsr #21
    a870:	mov.w	lr, lr, lsl #11
    a874:	subs.w	ip, r4, #253	; 0xfd
    a878:	it	hi
    a87a:	cmphi.w	ip, #1792	; 0x700
    a87e:	bhi.n	a8be <__aeabi_dmul+0xde>
    a880:	cmp.w	lr, #2147483648	; 0x80000000
    a884:	it	eq
    a886:	movseq.w	lr, r0, lsr #1
    a88a:	adcs.w	r0, r0, #0
    a88e:	adc.w	r1, r1, r4, lsl #20
    a892:	pop	{r4, r5, r6, pc}
    a894:	and.w	r6, r6, #2147483648	; 0x80000000
    a898:	orr.w	r1, r6, r1
    a89c:	orr.w	r0, r0, r2
    a8a0:	eor.w	r1, r1, r3
    a8a4:	subs.w	r4, r4, ip, lsr #1
    a8a8:	ittt	gt
    a8aa:	rsbsgt	r5, r4, ip
    a8ae:	orrgt.w	r1, r1, r4, lsl #20
    a8b2:	popgt	{r4, r5, r6, pc}
    a8b4:	orr.w	r1, r1, #1048576	; 0x100000
    a8b8:	mov.w	lr, #0
    a8bc:	subs	r4, #1
    a8be:	bgt.w	aa18 <__aeabi_dmul+0x238>
    a8c2:	cmn.w	r4, #54	; 0x36
    a8c6:	ittt	le
    a8c8:	movle	r0, #0
    a8ca:	andle.w	r1, r1, #2147483648	; 0x80000000
    a8ce:	pople	{r4, r5, r6, pc}
    a8d0:	rsb	r4, r4, #0
    a8d4:	subs	r4, #32
    a8d6:	bge.n	a944 <__aeabi_dmul+0x164>
    a8d8:	adds	r4, #12
    a8da:	bgt.n	a914 <__aeabi_dmul+0x134>
    a8dc:	add.w	r4, r4, #20
    a8e0:	rsb	r5, r4, #32
    a8e4:	lsl.w	r3, r0, r5
    a8e8:	lsr.w	r0, r0, r4
    a8ec:	lsl.w	r2, r1, r5
    a8f0:	orr.w	r0, r0, r2
    a8f4:	and.w	r2, r1, #2147483648	; 0x80000000
    a8f8:	bic.w	r1, r1, #2147483648	; 0x80000000
    a8fc:	adds.w	r0, r0, r3, lsr #31
    a900:	lsr.w	r6, r1, r4
    a904:	adc.w	r1, r2, r6
    a908:	orrs.w	lr, lr, r3, lsl #1
    a90c:	it	eq
    a90e:	biceq.w	r0, r0, r3, lsr #31
    a912:	pop	{r4, r5, r6, pc}
    a914:	rsb	r4, r4, #12
    a918:	rsb	r5, r4, #32
    a91c:	lsl.w	r3, r0, r4
    a920:	lsr.w	r0, r0, r5
    a924:	lsl.w	r2, r1, r4
    a928:	orr.w	r0, r0, r2
    a92c:	and.w	r1, r1, #2147483648	; 0x80000000
    a930:	adds.w	r0, r0, r3, lsr #31
    a934:	adc.w	r1, r1, #0
    a938:	orrs.w	lr, lr, r3, lsl #1
    a93c:	it	eq
    a93e:	biceq.w	r0, r0, r3, lsr #31
    a942:	pop	{r4, r5, r6, pc}
    a944:	rsb	r5, r4, #32
    a948:	lsl.w	r2, r0, r5
    a94c:	orr.w	lr, lr, r2
    a950:	lsr.w	r3, r0, r4
    a954:	lsl.w	r2, r1, r5
    a958:	orr.w	r3, r3, r2
    a95c:	lsr.w	r0, r1, r4
    a960:	and.w	r1, r1, #2147483648	; 0x80000000
    a964:	lsr.w	r2, r1, r4
    a968:	bic.w	r0, r0, r2
    a96c:	add.w	r0, r0, r3, lsr #31
    a970:	orrs.w	lr, lr, r3, lsl #1
    a974:	it	eq
    a976:	biceq.w	r0, r0, r3, lsr #31
    a97a:	pop	{r4, r5, r6, pc}
    a97c:	teq	r4, #0
    a980:	bne.n	a9a2 <__aeabi_dmul+0x1c2>
    a982:	and.w	r6, r1, #2147483648	; 0x80000000
    a986:	lsls	r0, r0, #1
    a988:	adc.w	r1, r1, r1
    a98c:	tst.w	r1, #1048576	; 0x100000
    a990:	it	eq
    a992:	subeq	r4, #1
    a994:	beq.n	a986 <__aeabi_dmul+0x1a6>
    a996:	orr.w	r1, r1, r6
    a99a:	teq	r5, #0
    a99e:	it	ne
    a9a0:	bxne	lr
    a9a2:	and.w	r6, r3, #2147483648	; 0x80000000
    a9a6:	lsls	r2, r2, #1
    a9a8:	adc.w	r3, r3, r3
    a9ac:	tst.w	r3, #1048576	; 0x100000
    a9b0:	it	eq
    a9b2:	subeq	r5, #1
    a9b4:	beq.n	a9a6 <__aeabi_dmul+0x1c6>
    a9b6:	orr.w	r3, r3, r6
    a9ba:	bx	lr
    a9bc:	teq	r4, ip
    a9c0:	and.w	r5, ip, r3, lsr #20
    a9c4:	it	ne
    a9c6:	teqne	r5, ip
    a9ca:	beq.n	a9e6 <__aeabi_dmul+0x206>
    a9cc:	orrs.w	r6, r0, r1, lsl #1
    a9d0:	it	ne
    a9d2:	orrsne.w	r6, r2, r3, lsl #1
    a9d6:	bne.n	a97c <__aeabi_dmul+0x19c>
    a9d8:	eor.w	r1, r1, r3
    a9dc:	and.w	r1, r1, #2147483648	; 0x80000000
    a9e0:	mov.w	r0, #0
    a9e4:	pop	{r4, r5, r6, pc}
    a9e6:	orrs.w	r6, r0, r1, lsl #1
    a9ea:	itte	eq
    a9ec:	moveq	r0, r2
    a9ee:	moveq	r1, r3
    a9f0:	orrsne.w	r6, r2, r3, lsl #1
    a9f4:	beq.n	aa2a <__aeabi_dmul+0x24a>
    a9f6:	teq	r4, ip
    a9fa:	bne.n	aa02 <__aeabi_dmul+0x222>
    a9fc:	orrs.w	r6, r0, r1, lsl #12
    aa00:	bne.n	aa2a <__aeabi_dmul+0x24a>
    aa02:	teq	r5, ip
    aa06:	bne.n	aa14 <__aeabi_dmul+0x234>
    aa08:	orrs.w	r6, r2, r3, lsl #12
    aa0c:	itt	ne
    aa0e:	movne	r0, r2
    aa10:	movne	r1, r3
    aa12:	bne.n	aa2a <__aeabi_dmul+0x24a>
    aa14:	eor.w	r1, r1, r3
    aa18:	and.w	r1, r1, #2147483648	; 0x80000000
    aa1c:	orr.w	r1, r1, #2130706432	; 0x7f000000
    aa20:	orr.w	r1, r1, #15728640	; 0xf00000
    aa24:	mov.w	r0, #0
    aa28:	pop	{r4, r5, r6, pc}
    aa2a:	orr.w	r1, r1, #2130706432	; 0x7f000000
    aa2e:	orr.w	r1, r1, #16252928	; 0xf80000
    aa32:	pop	{r4, r5, r6, pc}

0000aa34 <__aeabi_ddiv>:
    aa34:	push	{r4, r5, r6, lr}
    aa36:	mov.w	ip, #255	; 0xff
    aa3a:	orr.w	ip, ip, #1792	; 0x700
    aa3e:	ands.w	r4, ip, r1, lsr #20
    aa42:	ittte	ne
    aa44:	andsne.w	r5, ip, r3, lsr #20
    aa48:	teqne	r4, ip
    aa4c:	teqne	r5, ip
    aa50:	bleq	aba2 <__aeabi_ddiv+0x16e>
    aa54:	sub.w	r4, r4, r5
    aa58:	eor.w	lr, r1, r3
    aa5c:	orrs.w	r5, r2, r3, lsl #12
    aa60:	mov.w	r1, r1, lsl #12
    aa64:	beq.w	ab78 <__aeabi_ddiv+0x144>
    aa68:	mov.w	r3, r3, lsl #12
    aa6c:	mov.w	r5, #268435456	; 0x10000000
    aa70:	orr.w	r3, r5, r3, lsr #4
    aa74:	orr.w	r3, r3, r2, lsr #24
    aa78:	mov.w	r2, r2, lsl #8
    aa7c:	orr.w	r5, r5, r1, lsr #4
    aa80:	orr.w	r5, r5, r0, lsr #24
    aa84:	mov.w	r6, r0, lsl #8
    aa88:	and.w	r1, lr, #2147483648	; 0x80000000
    aa8c:	cmp	r5, r3
    aa8e:	it	eq
    aa90:	cmpeq	r6, r2
    aa92:	adc.w	r4, r4, #253	; 0xfd
    aa96:	add.w	r4, r4, #768	; 0x300
    aa9a:	bcs.n	aaa2 <__aeabi_ddiv+0x6e>
    aa9c:	lsrs	r3, r3, #1
    aa9e:	mov.w	r2, r2, rrx
    aaa2:	subs	r6, r6, r2
    aaa4:	sbc.w	r5, r5, r3
    aaa8:	lsrs	r3, r3, #1
    aaaa:	mov.w	r2, r2, rrx
    aaae:	mov.w	r0, #1048576	; 0x100000
    aab2:	mov.w	ip, #524288	; 0x80000
    aab6:	subs.w	lr, r6, r2
    aaba:	sbcs.w	lr, r5, r3
    aabe:	ittt	cs
    aac0:	subcs	r6, r6, r2
    aac2:	movcs	r5, lr
    aac4:	orrcs.w	r0, r0, ip
    aac8:	lsrs	r3, r3, #1
    aaca:	mov.w	r2, r2, rrx
    aace:	subs.w	lr, r6, r2
    aad2:	sbcs.w	lr, r5, r3
    aad6:	ittt	cs
    aad8:	subcs	r6, r6, r2
    aada:	movcs	r5, lr
    aadc:	orrcs.w	r0, r0, ip, lsr #1
    aae0:	lsrs	r3, r3, #1
    aae2:	mov.w	r2, r2, rrx
    aae6:	subs.w	lr, r6, r2
    aaea:	sbcs.w	lr, r5, r3
    aaee:	ittt	cs
    aaf0:	subcs	r6, r6, r2
    aaf2:	movcs	r5, lr
    aaf4:	orrcs.w	r0, r0, ip, lsr #2
    aaf8:	lsrs	r3, r3, #1
    aafa:	mov.w	r2, r2, rrx
    aafe:	subs.w	lr, r6, r2
    ab02:	sbcs.w	lr, r5, r3
    ab06:	ittt	cs
    ab08:	subcs	r6, r6, r2
    ab0a:	movcs	r5, lr
    ab0c:	orrcs.w	r0, r0, ip, lsr #3
    ab10:	orrs.w	lr, r5, r6
    ab14:	beq.n	ab48 <__aeabi_ddiv+0x114>
    ab16:	mov.w	r5, r5, lsl #4
    ab1a:	orr.w	r5, r5, r6, lsr #28
    ab1e:	mov.w	r6, r6, lsl #4
    ab22:	mov.w	r3, r3, lsl #3
    ab26:	orr.w	r3, r3, r2, lsr #29
    ab2a:	mov.w	r2, r2, lsl #3
    ab2e:	movs.w	ip, ip, lsr #4
    ab32:	bne.n	aab6 <__aeabi_ddiv+0x82>
    ab34:	tst.w	r1, #1048576	; 0x100000
    ab38:	bne.n	ab52 <__aeabi_ddiv+0x11e>
    ab3a:	orr.w	r1, r1, r0
    ab3e:	mov.w	r0, #0
    ab42:	mov.w	ip, #2147483648	; 0x80000000
    ab46:	b.n	aab6 <__aeabi_ddiv+0x82>
    ab48:	tst.w	r1, #1048576	; 0x100000
    ab4c:	itt	eq
    ab4e:	orreq	r1, r0
    ab50:	moveq	r0, #0
    ab52:	subs.w	ip, r4, #253	; 0xfd
    ab56:	it	hi
    ab58:	cmphi.w	ip, #1792	; 0x700
    ab5c:	bhi.w	a8be <__aeabi_dmul+0xde>
    ab60:	subs.w	ip, r5, r3
    ab64:	itt	eq
    ab66:	subseq.w	ip, r6, r2
    ab6a:	movseq.w	ip, r0, lsr #1
    ab6e:	adcs.w	r0, r0, #0
    ab72:	adc.w	r1, r1, r4, lsl #20
    ab76:	pop	{r4, r5, r6, pc}
    ab78:	and.w	lr, lr, #2147483648	; 0x80000000
    ab7c:	orr.w	r1, lr, r1, lsr #12
    ab80:	adds.w	r4, r4, ip, lsr #1
    ab84:	ittt	gt
    ab86:	rsbsgt	r5, r4, ip
    ab8a:	orrgt.w	r1, r1, r4, lsl #20
    ab8e:	popgt	{r4, r5, r6, pc}
    ab90:	orr.w	r1, r1, #1048576	; 0x100000
    ab94:	mov.w	lr, #0
    ab98:	subs	r4, #1
    ab9a:	b.n	a8be <__aeabi_dmul+0xde>
    ab9c:	orr.w	lr, r5, r6
    aba0:	b.n	a8be <__aeabi_dmul+0xde>
    aba2:	and.w	r5, ip, r3, lsr #20
    aba6:	teq	r4, ip
    abaa:	it	eq
    abac:	teqeq	r5, ip
    abb0:	beq.w	aa2a <__aeabi_dmul+0x24a>
    abb4:	teq	r4, ip
    abb8:	bne.n	abd0 <__aeabi_ddiv+0x19c>
    abba:	orrs.w	r4, r0, r1, lsl #12
    abbe:	bne.w	aa2a <__aeabi_dmul+0x24a>
    abc2:	teq	r5, ip
    abc6:	bne.w	aa14 <__aeabi_dmul+0x234>
    abca:	mov	r0, r2
    abcc:	mov	r1, r3
    abce:	b.n	aa2a <__aeabi_dmul+0x24a>
    abd0:	teq	r5, ip
    abd4:	bne.n	abe4 <__aeabi_ddiv+0x1b0>
    abd6:	orrs.w	r5, r2, r3, lsl #12
    abda:	beq.w	a9d8 <__aeabi_dmul+0x1f8>
    abde:	mov	r0, r2
    abe0:	mov	r1, r3
    abe2:	b.n	aa2a <__aeabi_dmul+0x24a>
    abe4:	orrs.w	r6, r0, r1, lsl #1
    abe8:	it	ne
    abea:	orrsne.w	r6, r2, r3, lsl #1
    abee:	bne.w	a97c <__aeabi_dmul+0x19c>
    abf2:	orrs.w	r4, r0, r1, lsl #1
    abf6:	bne.w	aa14 <__aeabi_dmul+0x234>
    abfa:	orrs.w	r5, r2, r3, lsl #1
    abfe:	bne.w	a9d8 <__aeabi_dmul+0x1f8>
    ac02:	b.n	aa2a <__aeabi_dmul+0x24a>

0000ac04 <__gedf2>:
    ac04:	mov.w	ip, #4294967295
    ac08:	b.n	ac18 <__cmpdf2+0x4>
    ac0a:	nop

0000ac0c <__ledf2>:
    ac0c:	mov.w	ip, #1
    ac10:	b.n	ac18 <__cmpdf2+0x4>
    ac12:	nop

0000ac14 <__cmpdf2>:
    ac14:	mov.w	ip, #1
    ac18:	str.w	ip, [sp, #-4]!
    ac1c:	mov.w	ip, r1, lsl #1
    ac20:	mvns.w	ip, ip, asr #21
    ac24:	mov.w	ip, r3, lsl #1
    ac28:	it	ne
    ac2a:	mvnsne.w	ip, ip, asr #21
    ac2e:	beq.n	ac68 <__cmpdf2+0x54>
    ac30:	add	sp, #4
    ac32:	orrs.w	ip, r0, r1, lsl #1
    ac36:	ite	eq
    ac38:	orrseq.w	ip, r2, r3, lsl #1
    ac3c:	teqne	r1, r3
    ac40:	ittt	eq
    ac42:	teqeq	r0, r2
    ac46:	moveq	r0, #0
    ac48:	bxeq	lr
    ac4a:	cmn.w	r0, #0
    ac4e:	teq	r1, r3
    ac52:	it	pl
    ac54:	cmppl	r1, r3
    ac56:	it	eq
    ac58:	cmpeq	r0, r2
    ac5a:	ite	cs
    ac5c:	asrcs	r0, r3, #31
    ac5e:	mvncc.w	r0, r3, asr #31
    ac62:	orr.w	r0, r0, #1
    ac66:	bx	lr
    ac68:	mov.w	ip, r1, lsl #1
    ac6c:	mvns.w	ip, ip, asr #21
    ac70:	bne.n	ac78 <__cmpdf2+0x64>
    ac72:	orrs.w	ip, r0, r1, lsl #12
    ac76:	bne.n	ac88 <__cmpdf2+0x74>
    ac78:	mov.w	ip, r3, lsl #1
    ac7c:	mvns.w	ip, ip, asr #21
    ac80:	bne.n	ac30 <__cmpdf2+0x1c>
    ac82:	orrs.w	ip, r2, r3, lsl #12
    ac86:	beq.n	ac30 <__cmpdf2+0x1c>
    ac88:	ldr.w	r0, [sp], #4
    ac8c:	bx	lr
    ac8e:	nop

0000ac90 <__aeabi_cdrcmple>:
    ac90:	mov	ip, r0
    ac92:	mov	r0, r2
    ac94:	mov	r2, ip
    ac96:	mov	ip, r1
    ac98:	mov	r1, r3
    ac9a:	mov	r3, ip
    ac9c:	b.n	aca0 <__aeabi_cdcmpeq>
    ac9e:	nop

0000aca0 <__aeabi_cdcmpeq>:
    aca0:	push	{r0, lr}
    aca2:	bl	ac14 <__cmpdf2>
    aca6:	cmp	r0, #0
    aca8:	it	mi
    acaa:	cmnmi.w	r0, #0
    acae:	pop	{r0, pc}

0000acb0 <__aeabi_dcmpeq>:
    acb0:	str.w	lr, [sp, #-8]!
    acb4:	bl	aca0 <__aeabi_cdcmpeq>
    acb8:	ite	eq
    acba:	moveq	r0, #1
    acbc:	movne	r0, #0
    acbe:	ldr.w	pc, [sp], #8
    acc2:	nop

0000acc4 <__aeabi_dcmplt>:
    acc4:	str.w	lr, [sp, #-8]!
    acc8:	bl	aca0 <__aeabi_cdcmpeq>
    accc:	ite	cc
    acce:	movcc	r0, #1
    acd0:	movcs	r0, #0
    acd2:	ldr.w	pc, [sp], #8
    acd6:	nop

0000acd8 <__aeabi_dcmple>:
    acd8:	str.w	lr, [sp, #-8]!
    acdc:	bl	aca0 <__aeabi_cdcmpeq>
    ace0:	ite	ls
    ace2:	movls	r0, #1
    ace4:	movhi	r0, #0
    ace6:	ldr.w	pc, [sp], #8
    acea:	nop

0000acec <__aeabi_dcmpge>:
    acec:	str.w	lr, [sp, #-8]!
    acf0:	bl	ac90 <__aeabi_cdrcmple>
    acf4:	ite	ls
    acf6:	movls	r0, #1
    acf8:	movhi	r0, #0
    acfa:	ldr.w	pc, [sp], #8
    acfe:	nop

0000ad00 <__aeabi_dcmpgt>:
    ad00:	str.w	lr, [sp, #-8]!
    ad04:	bl	ac90 <__aeabi_cdrcmple>
    ad08:	ite	cc
    ad0a:	movcc	r0, #1
    ad0c:	movcs	r0, #0
    ad0e:	ldr.w	pc, [sp], #8
    ad12:	nop

0000ad14 <__aeabi_dcmpun>:
    ad14:	mov.w	ip, r1, lsl #1
    ad18:	mvns.w	ip, ip, asr #21
    ad1c:	bne.n	ad24 <__aeabi_dcmpun+0x10>
    ad1e:	orrs.w	ip, r0, r1, lsl #12
    ad22:	bne.n	ad3a <__aeabi_dcmpun+0x26>
    ad24:	mov.w	ip, r3, lsl #1
    ad28:	mvns.w	ip, ip, asr #21
    ad2c:	bne.n	ad34 <__aeabi_dcmpun+0x20>
    ad2e:	orrs.w	ip, r2, r3, lsl #12
    ad32:	bne.n	ad3a <__aeabi_dcmpun+0x26>
    ad34:	mov.w	r0, #0
    ad38:	bx	lr
    ad3a:	mov.w	r0, #1
    ad3e:	bx	lr

0000ad40 <__aeabi_uldivmod>:
    ad40:	cbnz	r3, ad58 <__aeabi_uldivmod+0x18>
    ad42:	cbnz	r2, ad58 <__aeabi_uldivmod+0x18>
    ad44:	cmp	r1, #0
    ad46:	it	eq
    ad48:	cmpeq	r0, #0
    ad4a:	itt	ne
    ad4c:	movne.w	r1, #4294967295
    ad50:	movne.w	r0, #4294967295
    ad54:	b.w	b054 <__aeabi_idiv0>
    ad58:	sub.w	ip, sp, #8
    ad5c:	strd	ip, lr, [sp, #-16]!
    ad60:	bl	ad70 <__udivmoddi4>
    ad64:	ldr.w	lr, [sp, #4]
    ad68:	ldrd	r2, r3, [sp, #8]
    ad6c:	add	sp, #16
    ad6e:	bx	lr

0000ad70 <__udivmoddi4>:
    ad70:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ad74:	mov	ip, r1
    ad76:	mov	r6, r1
    ad78:	mov	r4, r0
    ad7a:	ldr	r5, [sp, #32]
    ad7c:	cmp	r3, #0
    ad7e:	bne.n	ae22 <__udivmoddi4+0xb2>
    ad80:	cmp	r2, r1
    ad82:	mov	r7, r2
    ad84:	bls.n	ae60 <__udivmoddi4+0xf0>
    ad86:	clz	lr, r2
    ad8a:	cmp.w	lr, #0
    ad8e:	beq.n	ada8 <__udivmoddi4+0x38>
    ad90:	rsb	r4, lr, #32
    ad94:	lsr.w	r4, r0, r4
    ad98:	lsl.w	r6, r1, lr
    ad9c:	orr.w	ip, r4, r6
    ada0:	lsl.w	r7, r2, lr
    ada4:	lsl.w	r4, r0, lr
    ada8:	mov.w	r9, r7, lsr #16
    adac:	lsrs	r2, r4, #16
    adae:	udiv	r0, ip, r9
    adb2:	uxth.w	r8, r7
    adb6:	mls	r6, r9, r0, ip
    adba:	orr.w	r6, r2, r6, lsl #16
    adbe:	mul.w	r3, r0, r8
    adc2:	cmp	r3, r6
    adc4:	bls.n	adda <__udivmoddi4+0x6a>
    adc6:	adds	r6, r6, r7
    adc8:	add.w	r2, r0, #4294967295
    adcc:	bcs.w	b014 <__udivmoddi4+0x2a4>
    add0:	cmp	r3, r6
    add2:	bls.w	b014 <__udivmoddi4+0x2a4>
    add6:	subs	r0, #2
    add8:	add	r6, r7
    adda:	subs	r6, r6, r3
    addc:	uxth	r2, r4
    adde:	udiv	r3, r6, r9
    ade2:	mls	r6, r9, r3, r6
    ade6:	orr.w	r4, r2, r6, lsl #16
    adea:	mul.w	r8, r3, r8
    adee:	cmp	r8, r4
    adf0:	bls.n	ae06 <__udivmoddi4+0x96>
    adf2:	adds	r4, r4, r7
    adf4:	add.w	r2, r3, #4294967295
    adf8:	bcs.w	b010 <__udivmoddi4+0x2a0>
    adfc:	cmp	r8, r4
    adfe:	bls.w	b010 <__udivmoddi4+0x2a0>
    ae02:	subs	r3, #2
    ae04:	add	r4, r7
    ae06:	rsb	r4, r8, r4
    ae0a:	orr.w	r0, r3, r0, lsl #16
    ae0e:	movs	r1, #0
    ae10:	cmp	r5, #0
    ae12:	beq.n	aeda <__udivmoddi4+0x16a>
    ae14:	lsr.w	r4, r4, lr
    ae18:	movs	r3, #0
    ae1a:	str	r4, [r5, #0]
    ae1c:	str	r3, [r5, #4]
    ae1e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ae22:	cmp	r3, r1
    ae24:	bls.n	ae36 <__udivmoddi4+0xc6>
    ae26:	cmp	r5, #0
    ae28:	beq.n	aed6 <__udivmoddi4+0x166>
    ae2a:	movs	r1, #0
    ae2c:	stmia.w	r5, {r0, r6}
    ae30:	mov	r0, r1
    ae32:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ae36:	clz	r1, r3
    ae3a:	cmp	r1, #0
    ae3c:	bne.w	af60 <__udivmoddi4+0x1f0>
    ae40:	cmp	r3, r6
    ae42:	bcc.n	ae4a <__udivmoddi4+0xda>
    ae44:	cmp	r2, r0
    ae46:	bhi.w	b03a <__udivmoddi4+0x2ca>
    ae4a:	subs	r4, r0, r2
    ae4c:	sbc.w	r6, r6, r3
    ae50:	movs	r0, #1
    ae52:	mov	ip, r6
    ae54:	cmp	r5, #0
    ae56:	beq.n	aeda <__udivmoddi4+0x16a>
    ae58:	stmia.w	r5, {r4, ip}
    ae5c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ae60:	cbnz	r2, ae68 <__udivmoddi4+0xf8>
    ae62:	movs	r7, #1
    ae64:	udiv	r7, r7, r2
    ae68:	clz	lr, r7
    ae6c:	cmp.w	lr, #0
    ae70:	bne.n	aede <__udivmoddi4+0x16e>
    ae72:	subs	r3, r6, r7
    ae74:	mov.w	r8, r7, lsr #16
    ae78:	uxth.w	ip, r7
    ae7c:	movs	r1, #1
    ae7e:	udiv	r0, r3, r8
    ae82:	lsrs	r2, r4, #16
    ae84:	mls	r6, r8, r0, r3
    ae88:	orr.w	r6, r2, r6, lsl #16
    ae8c:	mul.w	r3, ip, r0
    ae90:	cmp	r3, r6
    ae92:	bls.n	aea4 <__udivmoddi4+0x134>
    ae94:	adds	r6, r6, r7
    ae96:	add.w	r2, r0, #4294967295
    ae9a:	bcs.n	aea2 <__udivmoddi4+0x132>
    ae9c:	cmp	r3, r6
    ae9e:	bhi.w	b03e <__udivmoddi4+0x2ce>
    aea2:	mov	r0, r2
    aea4:	subs	r6, r6, r3
    aea6:	uxth	r2, r4
    aea8:	udiv	r3, r6, r8
    aeac:	mls	r6, r8, r3, r6
    aeb0:	orr.w	r4, r2, r6, lsl #16
    aeb4:	mul.w	ip, ip, r3
    aeb8:	cmp	ip, r4
    aeba:	bls.n	aecc <__udivmoddi4+0x15c>
    aebc:	adds	r4, r4, r7
    aebe:	add.w	r2, r3, #4294967295
    aec2:	bcs.n	aeca <__udivmoddi4+0x15a>
    aec4:	cmp	ip, r4
    aec6:	bhi.w	b034 <__udivmoddi4+0x2c4>
    aeca:	mov	r3, r2
    aecc:	rsb	r4, ip, r4
    aed0:	orr.w	r0, r3, r0, lsl #16
    aed4:	b.n	ae10 <__udivmoddi4+0xa0>
    aed6:	mov	r1, r5
    aed8:	mov	r0, r5
    aeda:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    aede:	rsb	r1, lr, #32
    aee2:	lsl.w	r3, r6, lr
    aee6:	lsl.w	r7, r7, lr
    aeea:	lsr.w	r9, r0, r1
    aeee:	mov.w	r8, r7, lsr #16
    aef2:	lsrs	r6, r1
    aef4:	orr.w	r9, r9, r3
    aef8:	udiv	sl, r6, r8
    aefc:	mov.w	r4, r9, lsr #16
    af00:	mls	r6, r8, sl, r6
    af04:	uxth.w	ip, r7
    af08:	orr.w	r3, r4, r6, lsl #16
    af0c:	mul.w	r2, sl, ip
    af10:	cmp	r2, r3
    af12:	lsl.w	r4, r0, lr
    af16:	bls.n	af2e <__udivmoddi4+0x1be>
    af18:	adds	r3, r3, r7
    af1a:	add.w	r1, sl, #4294967295
    af1e:	bcs.w	b030 <__udivmoddi4+0x2c0>
    af22:	cmp	r2, r3
    af24:	bls.w	b030 <__udivmoddi4+0x2c0>
    af28:	sub.w	sl, sl, #2
    af2c:	add	r3, r7
    af2e:	subs	r3, r3, r2
    af30:	uxth.w	r9, r9
    af34:	udiv	r1, r3, r8
    af38:	mls	r3, r8, r1, r3
    af3c:	orr.w	r3, r9, r3, lsl #16
    af40:	mul.w	r6, r1, ip
    af44:	cmp	r6, r3
    af46:	bls.n	af58 <__udivmoddi4+0x1e8>
    af48:	adds	r3, r3, r7
    af4a:	add.w	r2, r1, #4294967295
    af4e:	bcs.n	b028 <__udivmoddi4+0x2b8>
    af50:	cmp	r6, r3
    af52:	bls.n	b028 <__udivmoddi4+0x2b8>
    af54:	subs	r1, #2
    af56:	add	r3, r7
    af58:	subs	r3, r3, r6
    af5a:	orr.w	r1, r1, sl, lsl #16
    af5e:	b.n	ae7e <__udivmoddi4+0x10e>
    af60:	rsb	lr, r1, #32
    af64:	lsr.w	r4, r2, lr
    af68:	lsls	r3, r1
    af6a:	orrs	r3, r4
    af6c:	lsr.w	r7, r0, lr
    af70:	lsl.w	r4, r6, r1
    af74:	mov.w	ip, r3, lsr #16
    af78:	lsr.w	r6, r6, lr
    af7c:	orrs	r4, r7
    af7e:	udiv	r9, r6, ip
    af82:	lsrs	r7, r4, #16
    af84:	mls	r6, ip, r9, r6
    af88:	uxth.w	r8, r3
    af8c:	orr.w	r6, r7, r6, lsl #16
    af90:	mul.w	r7, r9, r8
    af94:	cmp	r7, r6
    af96:	lsl.w	r2, r2, r1
    af9a:	lsl.w	sl, r0, r1
    af9e:	bls.n	afb2 <__udivmoddi4+0x242>
    afa0:	adds	r6, r6, r3
    afa2:	add.w	r0, r9, #4294967295
    afa6:	bcs.n	b02c <__udivmoddi4+0x2bc>
    afa8:	cmp	r7, r6
    afaa:	bls.n	b02c <__udivmoddi4+0x2bc>
    afac:	sub.w	r9, r9, #2
    afb0:	add	r6, r3
    afb2:	subs	r6, r6, r7
    afb4:	uxth	r0, r4
    afb6:	udiv	r4, r6, ip
    afba:	mls	r6, ip, r4, r6
    afbe:	orr.w	r7, r0, r6, lsl #16
    afc2:	mul.w	r8, r4, r8
    afc6:	cmp	r8, r7
    afc8:	bls.n	afda <__udivmoddi4+0x26a>
    afca:	adds	r7, r7, r3
    afcc:	add.w	r0, r4, #4294967295
    afd0:	bcs.n	b024 <__udivmoddi4+0x2b4>
    afd2:	cmp	r8, r7
    afd4:	bls.n	b024 <__udivmoddi4+0x2b4>
    afd6:	subs	r4, #2
    afd8:	add	r7, r3
    afda:	orr.w	r0, r4, r9, lsl #16
    afde:	rsb	r7, r8, r7
    afe2:	umull	r8, r9, r0, r2
    afe6:	cmp	r7, r9
    afe8:	mov	r4, r8
    afea:	mov	r6, r9
    afec:	bcc.n	b018 <__udivmoddi4+0x2a8>
    afee:	beq.n	b044 <__udivmoddi4+0x2d4>
    aff0:	cbz	r5, b04c <__udivmoddi4+0x2dc>
    aff2:	subs.w	r3, sl, r4
    aff6:	sbc.w	r7, r7, r6
    affa:	lsl.w	lr, r7, lr
    affe:	lsrs	r3, r1
    b000:	lsrs	r7, r1
    b002:	orr.w	r3, lr, r3
    b006:	stmia.w	r5, {r3, r7}
    b00a:	movs	r1, #0
    b00c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b010:	mov	r3, r2
    b012:	b.n	ae06 <__udivmoddi4+0x96>
    b014:	mov	r0, r2
    b016:	b.n	adda <__udivmoddi4+0x6a>
    b018:	subs.w	r4, r8, r2
    b01c:	sbc.w	r6, r9, r3
    b020:	subs	r0, #1
    b022:	b.n	aff0 <__udivmoddi4+0x280>
    b024:	mov	r4, r0
    b026:	b.n	afda <__udivmoddi4+0x26a>
    b028:	mov	r1, r2
    b02a:	b.n	af58 <__udivmoddi4+0x1e8>
    b02c:	mov	r9, r0
    b02e:	b.n	afb2 <__udivmoddi4+0x242>
    b030:	mov	sl, r1
    b032:	b.n	af2e <__udivmoddi4+0x1be>
    b034:	subs	r3, #2
    b036:	add	r4, r7
    b038:	b.n	aecc <__udivmoddi4+0x15c>
    b03a:	mov	r0, r1
    b03c:	b.n	ae54 <__udivmoddi4+0xe4>
    b03e:	subs	r0, #2
    b040:	add	r6, r7
    b042:	b.n	aea4 <__udivmoddi4+0x134>
    b044:	cmp	sl, r8
    b046:	bcc.n	b018 <__udivmoddi4+0x2a8>
    b048:	mov	r6, r7
    b04a:	b.n	aff0 <__udivmoddi4+0x280>
    b04c:	mov	r1, r5
    b04e:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    b052:	nop

0000b054 <__aeabi_idiv0>:
    b054:	bx	lr
    b056:	nop

0000b058 <fcvtf>:
    b058:	push	{r4, r5, r6, lr}
    b05a:	mov	r4, r0
    b05c:	vmov	r0, s0
    b060:	mov	r5, r1
    b062:	mov	r6, r2
    b064:	bl	a738 <__aeabi_f2d>
    b068:	mov	r2, r6
    b06a:	vmov	d0, r0, r1
    b06e:	movs	r3, #0
    b070:	mov	r1, r5
    b072:	mov	r0, r4
    b074:	ldmia.w	sp!, {r4, r5, r6, lr}
    b078:	b.w	e84c <fcvtbuf>

0000b07c <__errno>:
    b07c:	ldr	r3, [pc, #4]	; (b084 <__errno+0x8>)
    b07e:	ldr	r0, [r3, #0]
    b080:	bx	lr
    b082:	nop
    b084:	.word	0x20000ff0

0000b088 <__libc_init_array>:
    b088:	push	{r4, r5, r6, lr}
    b08a:	ldr	r6, [pc, #60]	; (b0c8 <__libc_init_array+0x40>)
    b08c:	ldr	r5, [pc, #60]	; (b0cc <__libc_init_array+0x44>)
    b08e:	subs	r6, r6, r5
    b090:	asrs	r6, r6, #2
    b092:	it	ne
    b094:	movne	r4, #0
    b096:	beq.n	b0a4 <__libc_init_array+0x1c>
    b098:	adds	r4, #1
    b09a:	ldr.w	r3, [r5], #4
    b09e:	blx	r3
    b0a0:	cmp	r6, r4
    b0a2:	bne.n	b098 <__libc_init_array+0x10>
    b0a4:	ldr	r6, [pc, #40]	; (b0d0 <__libc_init_array+0x48>)
    b0a6:	ldr	r5, [pc, #44]	; (b0d4 <__libc_init_array+0x4c>)
    b0a8:	subs	r6, r6, r5
    b0aa:	bl	f4b8 <___init_veneer>
    b0ae:	asrs	r6, r6, #2
    b0b0:	it	ne
    b0b2:	movne	r4, #0
    b0b4:	beq.n	b0c4 <__libc_init_array+0x3c>
    b0b6:	adds	r4, #1
    b0b8:	ldr.w	r3, [r5], #4
    b0bc:	blx	r3
    b0be:	cmp	r6, r4
    b0c0:	bne.n	b0b6 <__libc_init_array+0x2e>
    b0c2:	pop	{r4, r5, r6, pc}
    b0c4:	pop	{r4, r5, r6, pc}
    b0c6:	nop
    b0c8:	.word	0x60001ba8
    b0cc:	.word	0x60001ba8
    b0d0:	.word	0x60001bb0
    b0d4:	.word	0x60001ba8

0000b0d8 <_malloc_r>:
    b0d8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b0dc:	add.w	r5, r1, #11
    b0e0:	cmp	r5, #22
    b0e2:	sub	sp, #12
    b0e4:	mov	r6, r0
    b0e6:	bls.w	b228 <_malloc_r+0x150>
    b0ea:	bics.w	r5, r5, #7
    b0ee:	bmi.w	b270 <_malloc_r+0x198>
    b0f2:	cmp	r1, r5
    b0f4:	bhi.w	b270 <_malloc_r+0x198>
    b0f8:	bl	b7d8 <__malloc_lock>
    b0fc:	cmp.w	r5, #504	; 0x1f8
    b100:	bcc.w	b63c <_malloc_r+0x564>
    b104:	lsrs	r3, r5, #9
    b106:	beq.w	b27e <_malloc_r+0x1a6>
    b10a:	cmp	r3, #4
    b10c:	bhi.w	b416 <_malloc_r+0x33e>
    b110:	lsrs	r0, r5, #6
    b112:	add.w	lr, r0, #57	; 0x39
    b116:	mov.w	r3, lr, lsl #1
    b11a:	adds	r0, #56	; 0x38
    b11c:	ldr	r7, [pc, #784]	; (b430 <_malloc_r+0x358>)
    b11e:	add.w	r3, r7, r3, lsl #2
    b122:	sub.w	r1, r3, #8
    b126:	ldr	r4, [r3, #4]
    b128:	cmp	r1, r4
    b12a:	bne.n	b13c <_malloc_r+0x64>
    b12c:	b.n	b288 <_malloc_r+0x1b0>
    b12e:	cmp	r2, #0
    b130:	bge.w	b28c <_malloc_r+0x1b4>
    b134:	ldr	r4, [r4, #12]
    b136:	cmp	r1, r4
    b138:	beq.w	b288 <_malloc_r+0x1b0>
    b13c:	ldr	r3, [r4, #4]
    b13e:	bic.w	r3, r3, #3
    b142:	subs	r2, r3, r5
    b144:	cmp	r2, #15
    b146:	ble.n	b12e <_malloc_r+0x56>
    b148:	ldr	r1, [pc, #740]	; (b430 <_malloc_r+0x358>)
    b14a:	ldr	r4, [r7, #16]
    b14c:	add.w	lr, r1, #8
    b150:	cmp	r4, lr
    b152:	beq.w	b4bc <_malloc_r+0x3e4>
    b156:	ldr	r3, [r4, #4]
    b158:	bic.w	r3, r3, #3
    b15c:	subs	r2, r3, r5
    b15e:	cmp	r2, #15
    b160:	bgt.w	b496 <_malloc_r+0x3be>
    b164:	cmp	r2, #0
    b166:	str.w	lr, [r1, #20]
    b16a:	str.w	lr, [r1, #16]
    b16e:	bge.w	b2ae <_malloc_r+0x1d6>
    b172:	cmp.w	r3, #512	; 0x200
    b176:	bcs.w	b448 <_malloc_r+0x370>
    b17a:	lsrs	r3, r3, #3
    b17c:	add.w	ip, r3, #1
    b180:	movs	r2, #1
    b182:	asrs	r3, r3, #2
    b184:	lsl.w	r3, r2, r3
    b188:	ldr	r2, [r1, #4]
    b18a:	ldr.w	r8, [r1, ip, lsl #3]
    b18e:	str.w	r8, [r4, #8]
    b192:	add.w	r9, r1, ip, lsl #3
    b196:	orrs	r2, r3
    b198:	sub.w	r3, r9, #8
    b19c:	str	r3, [r4, #12]
    b19e:	str	r2, [r1, #4]
    b1a0:	str.w	r4, [r1, ip, lsl #3]
    b1a4:	str.w	r4, [r8, #12]
    b1a8:	asrs	r3, r0, #2
    b1aa:	movs	r4, #1
    b1ac:	lsls	r4, r3
    b1ae:	cmp	r4, r2
    b1b0:	bhi.w	b2c8 <_malloc_r+0x1f0>
    b1b4:	tst	r4, r2
    b1b6:	bne.n	b1c6 <_malloc_r+0xee>
    b1b8:	bic.w	r0, r0, #3
    b1bc:	lsls	r4, r4, #1
    b1be:	tst	r4, r2
    b1c0:	add.w	r0, r0, #4
    b1c4:	beq.n	b1bc <_malloc_r+0xe4>
    b1c6:	add.w	r9, r7, r0, lsl #3
    b1ca:	mov	ip, r9
    b1cc:	mov	r8, r0
    b1ce:	ldr.w	r1, [ip, #12]
    b1d2:	cmp	ip, r1
    b1d4:	bne.n	b1e6 <_malloc_r+0x10e>
    b1d6:	b.n	b4c0 <_malloc_r+0x3e8>
    b1d8:	cmp	r2, #0
    b1da:	bge.w	b4e0 <_malloc_r+0x408>
    b1de:	ldr	r1, [r1, #12]
    b1e0:	cmp	ip, r1
    b1e2:	beq.w	b4c0 <_malloc_r+0x3e8>
    b1e6:	ldr	r3, [r1, #4]
    b1e8:	bic.w	r3, r3, #3
    b1ec:	subs	r2, r3, r5
    b1ee:	cmp	r2, #15
    b1f0:	ble.n	b1d8 <_malloc_r+0x100>
    b1f2:	mov	r4, r1
    b1f4:	ldr.w	ip, [r1, #12]
    b1f8:	ldr.w	r8, [r4, #8]!
    b1fc:	adds	r3, r1, r5
    b1fe:	orr.w	r5, r5, #1
    b202:	str	r5, [r1, #4]
    b204:	orr.w	r1, r2, #1
    b208:	str.w	ip, [r8, #12]
    b20c:	mov	r0, r6
    b20e:	str.w	r8, [ip, #8]
    b212:	str	r3, [r7, #20]
    b214:	str	r3, [r7, #16]
    b216:	str.w	lr, [r3, #12]
    b21a:	str.w	lr, [r3, #8]
    b21e:	str	r1, [r3, #4]
    b220:	str	r2, [r3, r2]
    b222:	bl	b7dc <__malloc_unlock>
    b226:	b.n	b268 <_malloc_r+0x190>
    b228:	cmp	r1, #16
    b22a:	bhi.n	b270 <_malloc_r+0x198>
    b22c:	bl	b7d8 <__malloc_lock>
    b230:	movs	r5, #16
    b232:	movs	r3, #6
    b234:	movs	r0, #2
    b236:	ldr	r7, [pc, #504]	; (b430 <_malloc_r+0x358>)
    b238:	add.w	r3, r7, r3, lsl #2
    b23c:	sub.w	r2, r3, #8
    b240:	ldr	r4, [r3, #4]
    b242:	cmp	r4, r2
    b244:	beq.w	b4d2 <_malloc_r+0x3fa>
    b248:	ldr	r3, [r4, #4]
    b24a:	ldr	r1, [r4, #12]
    b24c:	ldr	r5, [r4, #8]
    b24e:	bic.w	r3, r3, #3
    b252:	add	r3, r4
    b254:	mov	r0, r6
    b256:	ldr	r2, [r3, #4]
    b258:	str	r1, [r5, #12]
    b25a:	orr.w	r2, r2, #1
    b25e:	str	r5, [r1, #8]
    b260:	str	r2, [r3, #4]
    b262:	bl	b7dc <__malloc_unlock>
    b266:	adds	r4, #8
    b268:	mov	r0, r4
    b26a:	add	sp, #12
    b26c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b270:	movs	r4, #0
    b272:	movs	r3, #12
    b274:	mov	r0, r4
    b276:	str	r3, [r6, #0]
    b278:	add	sp, #12
    b27a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b27e:	movs	r3, #128	; 0x80
    b280:	mov.w	lr, #64	; 0x40
    b284:	movs	r0, #63	; 0x3f
    b286:	b.n	b11c <_malloc_r+0x44>
    b288:	mov	r0, lr
    b28a:	b.n	b148 <_malloc_r+0x70>
    b28c:	add	r3, r4
    b28e:	ldr	r1, [r4, #12]
    b290:	ldr	r2, [r3, #4]
    b292:	ldr	r5, [r4, #8]
    b294:	orr.w	r2, r2, #1
    b298:	str	r1, [r5, #12]
    b29a:	mov	r0, r6
    b29c:	str	r5, [r1, #8]
    b29e:	str	r2, [r3, #4]
    b2a0:	bl	b7dc <__malloc_unlock>
    b2a4:	adds	r4, #8
    b2a6:	mov	r0, r4
    b2a8:	add	sp, #12
    b2aa:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b2ae:	add	r3, r4
    b2b0:	mov	r0, r6
    b2b2:	ldr	r2, [r3, #4]
    b2b4:	orr.w	r2, r2, #1
    b2b8:	str	r2, [r3, #4]
    b2ba:	bl	b7dc <__malloc_unlock>
    b2be:	adds	r4, #8
    b2c0:	mov	r0, r4
    b2c2:	add	sp, #12
    b2c4:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b2c8:	ldr	r4, [r7, #8]
    b2ca:	ldr	r3, [r4, #4]
    b2cc:	bic.w	r8, r3, #3
    b2d0:	cmp	r8, r5
    b2d2:	bcc.n	b2de <_malloc_r+0x206>
    b2d4:	rsb	r3, r5, r8
    b2d8:	cmp	r3, #15
    b2da:	bgt.w	b3f6 <_malloc_r+0x31e>
    b2de:	ldr	r3, [pc, #340]	; (b434 <_malloc_r+0x35c>)
    b2e0:	ldr.w	r9, [pc, #352]	; b444 <_malloc_r+0x36c>
    b2e4:	ldr	r2, [r3, #0]
    b2e6:	ldr.w	r3, [r9]
    b2ea:	adds	r3, #1
    b2ec:	add	r2, r5
    b2ee:	add.w	sl, r4, r8
    b2f2:	beq.w	b5b6 <_malloc_r+0x4de>
    b2f6:	add.w	r2, r2, #4096	; 0x1000
    b2fa:	adds	r2, #15
    b2fc:	bic.w	r2, r2, #4080	; 0xff0
    b300:	bic.w	r2, r2, #15
    b304:	mov	r1, r2
    b306:	mov	r0, r6
    b308:	str	r2, [sp, #4]
    b30a:	bl	bbc0 <_sbrk_r>
    b30e:	cmp.w	r0, #4294967295
    b312:	mov	fp, r0
    b314:	ldr	r2, [sp, #4]
    b316:	beq.w	b5ca <_malloc_r+0x4f2>
    b31a:	cmp	sl, r0
    b31c:	bhi.w	b518 <_malloc_r+0x440>
    b320:	ldr	r3, [pc, #276]	; (b438 <_malloc_r+0x360>)
    b322:	ldr	r1, [r3, #0]
    b324:	cmp	sl, fp
    b326:	add	r1, r2
    b328:	str	r1, [r3, #0]
    b32a:	beq.w	b5d4 <_malloc_r+0x4fc>
    b32e:	ldr.w	r0, [r9]
    b332:	ldr.w	lr, [pc, #272]	; b444 <_malloc_r+0x36c>
    b336:	adds	r0, #1
    b338:	ittet	ne
    b33a:	rsbne	sl, sl, fp
    b33e:	addne	r1, sl
    b340:	streq.w	fp, [lr]
    b344:	strne	r1, [r3, #0]
    b346:	ands.w	r1, fp, #7
    b34a:	beq.w	b57c <_malloc_r+0x4a4>
    b34e:	rsb	r0, r1, #8
    b352:	rsb	r1, r1, #4096	; 0x1000
    b356:	add	fp, r0
    b358:	adds	r1, #8
    b35a:	add	r2, fp
    b35c:	ubfx	r2, r2, #0, #12
    b360:	rsb	r9, r2, r1
    b364:	mov	r1, r9
    b366:	mov	r0, r6
    b368:	str	r3, [sp, #4]
    b36a:	bl	bbc0 <_sbrk_r>
    b36e:	adds	r3, r0, #1
    b370:	ldr	r3, [sp, #4]
    b372:	beq.w	b5f4 <_malloc_r+0x51c>
    b376:	rsb	r2, fp, r0
    b37a:	add	r2, r9
    b37c:	orr.w	r2, r2, #1
    b380:	ldr	r1, [r3, #0]
    b382:	str.w	fp, [r7, #8]
    b386:	add	r1, r9
    b388:	cmp	r4, r7
    b38a:	str.w	r2, [fp, #4]
    b38e:	str	r1, [r3, #0]
    b390:	ldr.w	r9, [pc, #164]	; b438 <_malloc_r+0x360>
    b394:	beq.n	b3c4 <_malloc_r+0x2ec>
    b396:	cmp.w	r8, #15
    b39a:	bls.w	b598 <_malloc_r+0x4c0>
    b39e:	ldr	r2, [r4, #4]
    b3a0:	sub.w	r3, r8, #12
    b3a4:	bic.w	r3, r3, #7
    b3a8:	adds	r0, r4, r3
    b3aa:	and.w	r2, r2, #1
    b3ae:	mov.w	lr, #5
    b3b2:	orrs	r2, r3
    b3b4:	cmp	r3, #15
    b3b6:	str	r2, [r4, #4]
    b3b8:	str.w	lr, [r0, #4]
    b3bc:	str.w	lr, [r0, #8]
    b3c0:	bhi.w	b5fc <_malloc_r+0x524>
    b3c4:	ldr	r3, [pc, #116]	; (b43c <_malloc_r+0x364>)
    b3c6:	ldr	r4, [r7, #8]
    b3c8:	ldr	r2, [r3, #0]
    b3ca:	cmp	r1, r2
    b3cc:	it	hi
    b3ce:	strhi	r1, [r3, #0]
    b3d0:	ldr	r3, [pc, #108]	; (b440 <_malloc_r+0x368>)
    b3d2:	ldr	r2, [r3, #0]
    b3d4:	cmp	r1, r2
    b3d6:	ldr	r2, [r4, #4]
    b3d8:	it	hi
    b3da:	strhi	r1, [r3, #0]
    b3dc:	bic.w	r2, r2, #3
    b3e0:	cmp	r5, r2
    b3e2:	sub.w	r3, r2, r5
    b3e6:	bhi.n	b3ec <_malloc_r+0x314>
    b3e8:	cmp	r3, #15
    b3ea:	bgt.n	b3f6 <_malloc_r+0x31e>
    b3ec:	mov	r0, r6
    b3ee:	bl	b7dc <__malloc_unlock>
    b3f2:	movs	r4, #0
    b3f4:	b.n	b268 <_malloc_r+0x190>
    b3f6:	adds	r2, r4, r5
    b3f8:	orr.w	r3, r3, #1
    b3fc:	orr.w	r5, r5, #1
    b400:	str	r5, [r4, #4]
    b402:	mov	r0, r6
    b404:	str	r2, [r7, #8]
    b406:	str	r3, [r2, #4]
    b408:	bl	b7dc <__malloc_unlock>
    b40c:	adds	r4, #8
    b40e:	mov	r0, r4
    b410:	add	sp, #12
    b412:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b416:	cmp	r3, #20
    b418:	bls.n	b4fe <_malloc_r+0x426>
    b41a:	cmp	r3, #84	; 0x54
    b41c:	bhi.w	b568 <_malloc_r+0x490>
    b420:	lsrs	r0, r5, #12
    b422:	add.w	lr, r0, #111	; 0x6f
    b426:	mov.w	r3, lr, lsl #1
    b42a:	adds	r0, #110	; 0x6e
    b42c:	b.n	b11c <_malloc_r+0x44>
    b42e:	nop
    b430:	.word	0x20001160
    b434:	.word	0x2000b2c4
    b438:	.word	0x2000b2c8
    b43c:	.word	0x2000b2c0
    b440:	.word	0x2000b2bc
    b444:	.word	0x2000156c
    b448:	lsrs	r2, r3, #9
    b44a:	cmp	r2, #4
    b44c:	bls.n	b50c <_malloc_r+0x434>
    b44e:	cmp	r2, #20
    b450:	bhi.w	b5ba <_malloc_r+0x4e2>
    b454:	add.w	r1, r2, #92	; 0x5c
    b458:	lsls	r1, r1, #1
    b45a:	adds	r2, #91	; 0x5b
    b45c:	add.w	ip, r7, r1, lsl #2
    b460:	ldr.w	r1, [r7, r1, lsl #2]
    b464:	ldr.w	r8, [pc, #476]	; b644 <_malloc_r+0x56c>
    b468:	sub.w	ip, ip, #8
    b46c:	cmp	ip, r1
    b46e:	beq.w	b582 <_malloc_r+0x4aa>
    b472:	ldr	r2, [r1, #4]
    b474:	bic.w	r2, r2, #3
    b478:	cmp	r3, r2
    b47a:	bcs.n	b482 <_malloc_r+0x3aa>
    b47c:	ldr	r1, [r1, #8]
    b47e:	cmp	ip, r1
    b480:	bne.n	b472 <_malloc_r+0x39a>
    b482:	ldr.w	ip, [r1, #12]
    b486:	ldr	r2, [r7, #4]
    b488:	str.w	ip, [r4, #12]
    b48c:	str	r1, [r4, #8]
    b48e:	str.w	r4, [ip, #8]
    b492:	str	r4, [r1, #12]
    b494:	b.n	b1a8 <_malloc_r+0xd0>
    b496:	adds	r3, r4, r5
    b498:	orr.w	r7, r2, #1
    b49c:	orr.w	r5, r5, #1
    b4a0:	str	r5, [r4, #4]
    b4a2:	mov	r0, r6
    b4a4:	str	r3, [r1, #20]
    b4a6:	str	r3, [r1, #16]
    b4a8:	str.w	lr, [r3, #12]
    b4ac:	str.w	lr, [r3, #8]
    b4b0:	str	r7, [r3, #4]
    b4b2:	str	r2, [r3, r2]
    b4b4:	adds	r4, #8
    b4b6:	bl	b7dc <__malloc_unlock>
    b4ba:	b.n	b268 <_malloc_r+0x190>
    b4bc:	ldr	r2, [r1, #4]
    b4be:	b.n	b1a8 <_malloc_r+0xd0>
    b4c0:	add.w	r8, r8, #1
    b4c4:	tst.w	r8, #3
    b4c8:	add.w	ip, ip, #8
    b4cc:	bne.w	b1ce <_malloc_r+0xf6>
    b4d0:	b.n	b534 <_malloc_r+0x45c>
    b4d2:	ldr	r4, [r3, #12]
    b4d4:	cmp	r3, r4
    b4d6:	it	eq
    b4d8:	addeq	r0, #2
    b4da:	beq.w	b148 <_malloc_r+0x70>
    b4de:	b.n	b248 <_malloc_r+0x170>
    b4e0:	add	r3, r1
    b4e2:	mov	r4, r1
    b4e4:	ldr	r2, [r3, #4]
    b4e6:	ldr	r1, [r1, #12]
    b4e8:	ldr.w	r5, [r4, #8]!
    b4ec:	orr.w	r2, r2, #1
    b4f0:	str	r2, [r3, #4]
    b4f2:	mov	r0, r6
    b4f4:	str	r1, [r5, #12]
    b4f6:	str	r5, [r1, #8]
    b4f8:	bl	b7dc <__malloc_unlock>
    b4fc:	b.n	b268 <_malloc_r+0x190>
    b4fe:	add.w	lr, r3, #92	; 0x5c
    b502:	add.w	r0, r3, #91	; 0x5b
    b506:	mov.w	r3, lr, lsl #1
    b50a:	b.n	b11c <_malloc_r+0x44>
    b50c:	lsrs	r2, r3, #6
    b50e:	add.w	r1, r2, #57	; 0x39
    b512:	lsls	r1, r1, #1
    b514:	adds	r2, #56	; 0x38
    b516:	b.n	b45c <_malloc_r+0x384>
    b518:	cmp	r4, r7
    b51a:	ldr	r3, [pc, #296]	; (b644 <_malloc_r+0x56c>)
    b51c:	beq.w	b320 <_malloc_r+0x248>
    b520:	ldr	r4, [r3, #8]
    b522:	ldr	r2, [r4, #4]
    b524:	bic.w	r2, r2, #3
    b528:	b.n	b3e0 <_malloc_r+0x308>
    b52a:	ldr.w	r3, [r9], #-8
    b52e:	cmp	r9, r3
    b530:	bne.w	b638 <_malloc_r+0x560>
    b534:	tst.w	r0, #3
    b538:	add.w	r0, r0, #4294967295
    b53c:	bne.n	b52a <_malloc_r+0x452>
    b53e:	ldr	r3, [r7, #4]
    b540:	bic.w	r3, r3, r4
    b544:	str	r3, [r7, #4]
    b546:	lsls	r4, r4, #1
    b548:	cmp	r4, r3
    b54a:	bhi.w	b2c8 <_malloc_r+0x1f0>
    b54e:	cmp	r4, #0
    b550:	beq.w	b2c8 <_malloc_r+0x1f0>
    b554:	tst	r4, r3
    b556:	mov	r0, r8
    b558:	bne.w	b1c6 <_malloc_r+0xee>
    b55c:	lsls	r4, r4, #1
    b55e:	tst	r4, r3
    b560:	add.w	r0, r0, #4
    b564:	beq.n	b55c <_malloc_r+0x484>
    b566:	b.n	b1c6 <_malloc_r+0xee>
    b568:	cmp.w	r3, #340	; 0x154
    b56c:	bhi.n	b5a0 <_malloc_r+0x4c8>
    b56e:	lsrs	r0, r5, #15
    b570:	add.w	lr, r0, #120	; 0x78
    b574:	mov.w	r3, lr, lsl #1
    b578:	adds	r0, #119	; 0x77
    b57a:	b.n	b11c <_malloc_r+0x44>
    b57c:	mov.w	r1, #4096	; 0x1000
    b580:	b.n	b35a <_malloc_r+0x282>
    b582:	movs	r1, #1
    b584:	ldr.w	r3, [r8, #4]
    b588:	asrs	r2, r2, #2
    b58a:	lsl.w	r2, r1, r2
    b58e:	orrs	r2, r3
    b590:	str.w	r2, [r8, #4]
    b594:	mov	r1, ip
    b596:	b.n	b488 <_malloc_r+0x3b0>
    b598:	movs	r3, #1
    b59a:	str.w	r3, [fp, #4]
    b59e:	b.n	b3ec <_malloc_r+0x314>
    b5a0:	movw	r2, #1364	; 0x554
    b5a4:	cmp	r3, r2
    b5a6:	bhi.n	b5ea <_malloc_r+0x512>
    b5a8:	lsrs	r0, r5, #18
    b5aa:	add.w	lr, r0, #125	; 0x7d
    b5ae:	mov.w	r3, lr, lsl #1
    b5b2:	adds	r0, #124	; 0x7c
    b5b4:	b.n	b11c <_malloc_r+0x44>
    b5b6:	adds	r2, #16
    b5b8:	b.n	b304 <_malloc_r+0x22c>
    b5ba:	cmp	r2, #84	; 0x54
    b5bc:	bhi.n	b60c <_malloc_r+0x534>
    b5be:	lsrs	r2, r3, #12
    b5c0:	add.w	r1, r2, #111	; 0x6f
    b5c4:	lsls	r1, r1, #1
    b5c6:	adds	r2, #110	; 0x6e
    b5c8:	b.n	b45c <_malloc_r+0x384>
    b5ca:	ldr	r4, [r7, #8]
    b5cc:	ldr	r2, [r4, #4]
    b5ce:	bic.w	r2, r2, #3
    b5d2:	b.n	b3e0 <_malloc_r+0x308>
    b5d4:	ubfx	r0, sl, #0, #12
    b5d8:	cmp	r0, #0
    b5da:	bne.w	b32e <_malloc_r+0x256>
    b5de:	add	r2, r8
    b5e0:	ldr	r3, [r7, #8]
    b5e2:	orr.w	r2, r2, #1
    b5e6:	str	r2, [r3, #4]
    b5e8:	b.n	b3c4 <_malloc_r+0x2ec>
    b5ea:	movs	r3, #254	; 0xfe
    b5ec:	mov.w	lr, #127	; 0x7f
    b5f0:	movs	r0, #126	; 0x7e
    b5f2:	b.n	b11c <_malloc_r+0x44>
    b5f4:	movs	r2, #1
    b5f6:	mov.w	r9, #0
    b5fa:	b.n	b380 <_malloc_r+0x2a8>
    b5fc:	add.w	r1, r4, #8
    b600:	mov	r0, r6
    b602:	bl	e9e8 <_free_r>
    b606:	ldr.w	r1, [r9]
    b60a:	b.n	b3c4 <_malloc_r+0x2ec>
    b60c:	cmp.w	r2, #340	; 0x154
    b610:	bhi.n	b61e <_malloc_r+0x546>
    b612:	lsrs	r2, r3, #15
    b614:	add.w	r1, r2, #120	; 0x78
    b618:	lsls	r1, r1, #1
    b61a:	adds	r2, #119	; 0x77
    b61c:	b.n	b45c <_malloc_r+0x384>
    b61e:	movw	r1, #1364	; 0x554
    b622:	cmp	r2, r1
    b624:	bhi.n	b632 <_malloc_r+0x55a>
    b626:	lsrs	r2, r3, #18
    b628:	add.w	r1, r2, #125	; 0x7d
    b62c:	lsls	r1, r1, #1
    b62e:	adds	r2, #124	; 0x7c
    b630:	b.n	b45c <_malloc_r+0x384>
    b632:	movs	r1, #254	; 0xfe
    b634:	movs	r2, #126	; 0x7e
    b636:	b.n	b45c <_malloc_r+0x384>
    b638:	ldr	r3, [r7, #4]
    b63a:	b.n	b546 <_malloc_r+0x46e>
    b63c:	lsrs	r0, r5, #3
    b63e:	adds	r3, r0, #1
    b640:	lsls	r3, r3, #1
    b642:	b.n	b236 <_malloc_r+0x15e>
    b644:	.word	0x20001160

0000b648 <__ascii_mbtowc>:
    b648:	sub	sp, #8
    b64a:	cbz	r1, b660 <__ascii_mbtowc+0x18>
    b64c:	cbz	r2, b666 <__ascii_mbtowc+0x1e>
    b64e:	cbz	r3, b66c <__ascii_mbtowc+0x24>
    b650:	ldrb	r3, [r2, #0]
    b652:	str	r3, [r1, #0]
    b654:	ldrb	r2, [r2, #0]
    b656:	adds	r0, r2, #0
    b658:	it	ne
    b65a:	movne	r0, #1
    b65c:	add	sp, #8
    b65e:	bx	lr
    b660:	add	r1, sp, #4
    b662:	cmp	r2, #0
    b664:	bne.n	b64e <__ascii_mbtowc+0x6>
    b666:	mov	r0, r2
    b668:	add	sp, #8
    b66a:	bx	lr
    b66c:	mvn.w	r0, #1
    b670:	b.n	b65c <__ascii_mbtowc+0x14>
    b672:	nop

0000b674 <memmove>:
    b674:	cmp	r0, r1
    b676:	push	{r4, r5, r6, r7, lr}
    b678:	bls.n	b696 <memmove+0x22>
    b67a:	adds	r3, r1, r2
    b67c:	cmp	r0, r3
    b67e:	bcs.n	b696 <memmove+0x22>
    b680:	adds	r1, r0, r2
    b682:	cmp	r2, #0
    b684:	beq.n	b72a <memmove+0xb6>
    b686:	subs	r2, r3, r2
    b688:	ldrb.w	r4, [r3, #-1]!
    b68c:	strb.w	r4, [r1, #-1]!
    b690:	cmp	r3, r2
    b692:	bne.n	b688 <memmove+0x14>
    b694:	pop	{r4, r5, r6, r7, pc}
    b696:	cmp	r2, #15
    b698:	bls.n	b72c <memmove+0xb8>
    b69a:	orr.w	r3, r1, r0
    b69e:	lsls	r3, r3, #30
    b6a0:	bne.n	b730 <memmove+0xbc>
    b6a2:	add.w	r4, r0, #16
    b6a6:	add.w	r3, r1, #16
    b6aa:	mov	r5, r2
    b6ac:	ldr.w	r6, [r3, #-16]
    b6b0:	str.w	r6, [r4, #-16]
    b6b4:	ldr.w	r6, [r3, #-12]
    b6b8:	str.w	r6, [r4, #-12]
    b6bc:	ldr.w	r6, [r3, #-8]
    b6c0:	str.w	r6, [r4, #-8]
    b6c4:	subs	r5, #16
    b6c6:	ldr.w	r6, [r3, #-4]
    b6ca:	str.w	r6, [r4, #-4]
    b6ce:	cmp	r5, #15
    b6d0:	add.w	r3, r3, #16
    b6d4:	add.w	r4, r4, #16
    b6d8:	bhi.n	b6ac <memmove+0x38>
    b6da:	sub.w	r3, r2, #16
    b6de:	bic.w	r3, r3, #15
    b6e2:	and.w	lr, r2, #15
    b6e6:	adds	r3, #16
    b6e8:	cmp.w	lr, #3
    b6ec:	add	r1, r3
    b6ee:	add	r3, r0
    b6f0:	bls.n	b736 <memmove+0xc2>
    b6f2:	subs	r6, r3, #4
    b6f4:	mov	r5, r1
    b6f6:	mov	r4, lr
    b6f8:	subs	r4, #4
    b6fa:	ldr.w	r7, [r5], #4
    b6fe:	str.w	r7, [r6, #4]!
    b702:	cmp	r4, #3
    b704:	bhi.n	b6f8 <memmove+0x84>
    b706:	sub.w	r4, lr, #4
    b70a:	bic.w	r4, r4, #3
    b70e:	adds	r4, #4
    b710:	add	r3, r4
    b712:	add	r1, r4
    b714:	and.w	r2, r2, #3
    b718:	cbz	r2, b734 <memmove+0xc0>
    b71a:	subs	r3, #1
    b71c:	add	r2, r1
    b71e:	ldrb.w	r4, [r1], #1
    b722:	strb.w	r4, [r3, #1]!
    b726:	cmp	r2, r1
    b728:	bne.n	b71e <memmove+0xaa>
    b72a:	pop	{r4, r5, r6, r7, pc}
    b72c:	mov	r3, r0
    b72e:	b.n	b718 <memmove+0xa4>
    b730:	mov	r3, r0
    b732:	b.n	b71a <memmove+0xa6>
    b734:	pop	{r4, r5, r6, r7, pc}
    b736:	mov	r2, lr
    b738:	b.n	b718 <memmove+0xa4>
    b73a:	nop

0000b73c <memset>:
    b73c:	push	{r4, r5, r6}
    b73e:	lsls	r4, r0, #30
    b740:	beq.n	b7d0 <memset+0x94>
    b742:	subs	r4, r2, #1
    b744:	cmp	r2, #0
    b746:	beq.n	b7cc <memset+0x90>
    b748:	uxtb	r5, r1
    b74a:	mov	r3, r0
    b74c:	b.n	b754 <memset+0x18>
    b74e:	subs	r2, r4, #1
    b750:	cbz	r4, b7cc <memset+0x90>
    b752:	mov	r4, r2
    b754:	strb.w	r5, [r3], #1
    b758:	lsls	r2, r3, #30
    b75a:	bne.n	b74e <memset+0x12>
    b75c:	cmp	r4, #3
    b75e:	bls.n	b7be <memset+0x82>
    b760:	uxtb	r5, r1
    b762:	orr.w	r5, r5, r5, lsl #8
    b766:	cmp	r4, #15
    b768:	orr.w	r5, r5, r5, lsl #16
    b76c:	bls.n	b7a2 <memset+0x66>
    b76e:	add.w	r2, r3, #16
    b772:	mov	r6, r4
    b774:	subs	r6, #16
    b776:	cmp	r6, #15
    b778:	str.w	r5, [r2, #-16]
    b77c:	str.w	r5, [r2, #-12]
    b780:	str.w	r5, [r2, #-8]
    b784:	str.w	r5, [r2, #-4]
    b788:	add.w	r2, r2, #16
    b78c:	bhi.n	b774 <memset+0x38>
    b78e:	sub.w	r2, r4, #16
    b792:	bic.w	r2, r2, #15
    b796:	and.w	r4, r4, #15
    b79a:	adds	r2, #16
    b79c:	cmp	r4, #3
    b79e:	add	r3, r2
    b7a0:	bls.n	b7be <memset+0x82>
    b7a2:	mov	r6, r3
    b7a4:	mov	r2, r4
    b7a6:	subs	r2, #4
    b7a8:	cmp	r2, #3
    b7aa:	str.w	r5, [r6], #4
    b7ae:	bhi.n	b7a6 <memset+0x6a>
    b7b0:	subs	r2, r4, #4
    b7b2:	bic.w	r2, r2, #3
    b7b6:	adds	r2, #4
    b7b8:	add	r3, r2
    b7ba:	and.w	r4, r4, #3
    b7be:	cbz	r4, b7cc <memset+0x90>
    b7c0:	uxtb	r1, r1
    b7c2:	add	r4, r3
    b7c4:	strb.w	r1, [r3], #1
    b7c8:	cmp	r3, r4
    b7ca:	bne.n	b7c4 <memset+0x88>
    b7cc:	pop	{r4, r5, r6}
    b7ce:	bx	lr
    b7d0:	mov	r4, r2
    b7d2:	mov	r3, r0
    b7d4:	b.n	b75c <memset+0x20>
    b7d6:	nop

0000b7d8 <__malloc_lock>:
    b7d8:	bx	lr
    b7da:	nop

0000b7dc <__malloc_unlock>:
    b7dc:	bx	lr
    b7de:	nop

0000b7e0 <_realloc_r>:
    b7e0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b7e4:	mov	r7, r2
    b7e6:	sub	sp, #12
    b7e8:	cmp	r1, #0
    b7ea:	beq.w	b970 <_realloc_r+0x190>
    b7ee:	mov	r6, r1
    b7f0:	mov	r9, r0
    b7f2:	add.w	r5, r7, #11
    b7f6:	bl	b7d8 <__malloc_lock>
    b7fa:	ldr.w	lr, [r6, #-4]
    b7fe:	cmp	r5, #22
    b800:	bic.w	r4, lr, #3
    b804:	sub.w	r8, r6, #8
    b808:	bhi.n	b88c <_realloc_r+0xac>
    b80a:	movs	r2, #16
    b80c:	mov	r5, r2
    b80e:	cmp	r7, r5
    b810:	bhi.n	b896 <_realloc_r+0xb6>
    b812:	cmp	r4, r2
    b814:	bge.n	b902 <_realloc_r+0x122>
    b816:	ldr	r3, [pc, #804]	; (bb3c <_realloc_r+0x35c>)
    b818:	ldr	r1, [r3, #8]
    b81a:	add.w	r0, r8, r4
    b81e:	cmp	r0, r1
    b820:	ldr	r1, [r0, #4]
    b822:	beq.w	b9d8 <_realloc_r+0x1f8>
    b826:	bic.w	r3, r1, #1
    b82a:	add	r3, r0
    b82c:	ldr	r3, [r3, #4]
    b82e:	lsls	r3, r3, #31
    b830:	bpl.n	b92e <_realloc_r+0x14e>
    b832:	tst.w	lr, #1
    b836:	beq.n	b8a4 <_realloc_r+0xc4>
    b838:	mov	r1, r7
    b83a:	mov	r0, r9
    b83c:	bl	b0d8 <_malloc_r>
    b840:	mov	r7, r0
    b842:	cbz	r0, b87e <_realloc_r+0x9e>
    b844:	ldr.w	r3, [r6, #-4]
    b848:	bic.w	r3, r3, #1
    b84c:	add	r3, r8
    b84e:	sub.w	r2, r0, #8
    b852:	cmp	r2, r3
    b854:	beq.w	bae0 <_realloc_r+0x300>
    b858:	subs	r2, r4, #4
    b85a:	cmp	r2, #36	; 0x24
    b85c:	bhi.w	bac2 <_realloc_r+0x2e2>
    b860:	cmp	r2, #19
    b862:	bhi.w	ba6e <_realloc_r+0x28e>
    b866:	mov	r3, r0
    b868:	mov	r2, r6
    b86a:	ldr	r1, [r2, #0]
    b86c:	str	r1, [r3, #0]
    b86e:	ldr	r1, [r2, #4]
    b870:	str	r1, [r3, #4]
    b872:	ldr	r2, [r2, #8]
    b874:	str	r2, [r3, #8]
    b876:	mov	r1, r6
    b878:	mov	r0, r9
    b87a:	bl	e9e8 <_free_r>
    b87e:	mov	r0, r9
    b880:	bl	b7dc <__malloc_unlock>
    b884:	mov	r0, r7
    b886:	add	sp, #12
    b888:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b88c:	bic.w	r5, r5, #7
    b890:	cmp	r5, #0
    b892:	mov	r2, r5
    b894:	bge.n	b80e <_realloc_r+0x2e>
    b896:	movs	r3, #12
    b898:	movs	r0, #0
    b89a:	str.w	r3, [r9]
    b89e:	add	sp, #12
    b8a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b8a4:	ldr.w	r3, [r6, #-8]
    b8a8:	rsb	sl, r3, r8
    b8ac:	ldr.w	r3, [sl, #4]
    b8b0:	bic.w	ip, r3, #3
    b8b4:	add.w	r3, r4, ip
    b8b8:	cmp	r3, r2
    b8ba:	blt.n	b838 <_realloc_r+0x58>
    b8bc:	mov	r7, sl
    b8be:	ldr.w	r1, [sl, #12]
    b8c2:	ldr.w	r0, [r7, #8]!
    b8c6:	subs	r2, r4, #4
    b8c8:	cmp	r2, #36	; 0x24
    b8ca:	str	r1, [r0, #12]
    b8cc:	str	r0, [r1, #8]
    b8ce:	bhi.w	bb00 <_realloc_r+0x320>
    b8d2:	cmp	r2, #19
    b8d4:	bls.w	bafc <_realloc_r+0x31c>
    b8d8:	ldr	r1, [r6, #0]
    b8da:	str.w	r1, [sl, #8]
    b8de:	ldr	r1, [r6, #4]
    b8e0:	str.w	r1, [sl, #12]
    b8e4:	cmp	r2, #27
    b8e6:	bhi.w	bb40 <_realloc_r+0x360>
    b8ea:	adds	r6, #8
    b8ec:	add.w	r2, sl, #16
    b8f0:	ldr	r1, [r6, #0]
    b8f2:	str	r1, [r2, #0]
    b8f4:	ldr	r1, [r6, #4]
    b8f6:	str	r1, [r2, #4]
    b8f8:	ldr	r1, [r6, #8]
    b8fa:	str	r1, [r2, #8]
    b8fc:	mov	r6, r7
    b8fe:	mov	r4, r3
    b900:	mov	r8, sl
    b902:	subs	r3, r4, r5
    b904:	cmp	r3, #15
    b906:	bhi.n	b944 <_realloc_r+0x164>
    b908:	ldr.w	r3, [r8, #4]
    b90c:	and.w	r3, r3, #1
    b910:	orrs	r3, r4
    b912:	add	r4, r8
    b914:	str.w	r3, [r8, #4]
    b918:	ldr	r3, [r4, #4]
    b91a:	orr.w	r3, r3, #1
    b91e:	str	r3, [r4, #4]
    b920:	mov	r0, r9
    b922:	bl	b7dc <__malloc_unlock>
    b926:	mov	r0, r6
    b928:	add	sp, #12
    b92a:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b92e:	bic.w	r1, r1, #3
    b932:	add	r1, r4
    b934:	cmp	r1, r2
    b936:	blt.n	b97c <_realloc_r+0x19c>
    b938:	ldr	r3, [r0, #12]
    b93a:	ldr	r2, [r0, #8]
    b93c:	mov	r4, r1
    b93e:	str	r3, [r2, #12]
    b940:	str	r2, [r3, #8]
    b942:	b.n	b902 <_realloc_r+0x122>
    b944:	ldr.w	r2, [r8, #4]
    b948:	add.w	r1, r8, r5
    b94c:	and.w	r2, r2, #1
    b950:	orrs	r5, r2
    b952:	orr.w	r2, r3, #1
    b956:	add	r3, r1
    b958:	str.w	r5, [r8, #4]
    b95c:	str	r2, [r1, #4]
    b95e:	ldr	r2, [r3, #4]
    b960:	orr.w	r2, r2, #1
    b964:	adds	r1, #8
    b966:	str	r2, [r3, #4]
    b968:	mov	r0, r9
    b96a:	bl	e9e8 <_free_r>
    b96e:	b.n	b920 <_realloc_r+0x140>
    b970:	mov	r1, r2
    b972:	add	sp, #12
    b974:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b978:	b.w	b0d8 <_malloc_r>
    b97c:	tst.w	lr, #1
    b980:	bne.w	b838 <_realloc_r+0x58>
    b984:	ldr.w	r3, [r6, #-8]
    b988:	rsb	sl, r3, r8
    b98c:	ldr.w	r3, [sl, #4]
    b990:	bic.w	ip, r3, #3
    b994:	add.w	lr, r1, ip
    b998:	cmp	lr, r2
    b99a:	blt.n	b8b4 <_realloc_r+0xd4>
    b99c:	ldr	r3, [r0, #12]
    b99e:	ldr	r2, [r0, #8]
    b9a0:	mov	r7, sl
    b9a2:	str	r3, [r2, #12]
    b9a4:	str	r2, [r3, #8]
    b9a6:	ldr.w	r1, [r7, #8]!
    b9aa:	ldr.w	r3, [sl, #12]
    b9ae:	str	r3, [r1, #12]
    b9b0:	subs	r2, r4, #4
    b9b2:	cmp	r2, #36	; 0x24
    b9b4:	str	r1, [r3, #8]
    b9b6:	bhi.w	baec <_realloc_r+0x30c>
    b9ba:	cmp	r2, #19
    b9bc:	bls.n	ba84 <_realloc_r+0x2a4>
    b9be:	ldr	r3, [r6, #0]
    b9c0:	str.w	r3, [sl, #8]
    b9c4:	ldr	r3, [r6, #4]
    b9c6:	str.w	r3, [sl, #12]
    b9ca:	cmp	r2, #27
    b9cc:	bhi.w	bb10 <_realloc_r+0x330>
    b9d0:	adds	r6, #8
    b9d2:	add.w	r3, sl, #16
    b9d6:	b.n	ba86 <_realloc_r+0x2a6>
    b9d8:	bic.w	fp, r1, #3
    b9dc:	add	fp, r4
    b9de:	add.w	r0, r5, #16
    b9e2:	cmp	fp, r0
    b9e4:	bge.n	ba9a <_realloc_r+0x2ba>
    b9e6:	tst.w	lr, #1
    b9ea:	bne.w	b838 <_realloc_r+0x58>
    b9ee:	ldr.w	r1, [r6, #-8]
    b9f2:	rsb	sl, r1, r8
    b9f6:	ldr.w	r1, [sl, #4]
    b9fa:	bic.w	ip, r1, #3
    b9fe:	add	fp, ip
    ba00:	cmp	r0, fp
    ba02:	bgt.w	b8b4 <_realloc_r+0xd4>
    ba06:	mov	r7, sl
    ba08:	ldr.w	r1, [sl, #12]
    ba0c:	ldr.w	r0, [r7, #8]!
    ba10:	subs	r2, r4, #4
    ba12:	cmp	r2, #36	; 0x24
    ba14:	str	r1, [r0, #12]
    ba16:	str	r0, [r1, #8]
    ba18:	bhi.w	bb84 <_realloc_r+0x3a4>
    ba1c:	cmp	r2, #19
    ba1e:	bls.w	bb6c <_realloc_r+0x38c>
    ba22:	ldr	r1, [r6, #0]
    ba24:	str.w	r1, [sl, #8]
    ba28:	ldr	r1, [r6, #4]
    ba2a:	str.w	r1, [sl, #12]
    ba2e:	cmp	r2, #27
    ba30:	bhi.w	bb92 <_realloc_r+0x3b2>
    ba34:	adds	r6, #8
    ba36:	add.w	r2, sl, #16
    ba3a:	ldr	r1, [r6, #0]
    ba3c:	str	r1, [r2, #0]
    ba3e:	ldr	r1, [r6, #4]
    ba40:	str	r1, [r2, #4]
    ba42:	ldr	r1, [r6, #8]
    ba44:	str	r1, [r2, #8]
    ba46:	add.w	r1, sl, r5
    ba4a:	rsb	r2, r5, fp
    ba4e:	orr.w	r2, r2, #1
    ba52:	str	r1, [r3, #8]
    ba54:	str	r2, [r1, #4]
    ba56:	ldr.w	r3, [sl, #4]
    ba5a:	and.w	r3, r3, #1
    ba5e:	orrs	r5, r3
    ba60:	mov	r0, r9
    ba62:	str.w	r5, [sl, #4]
    ba66:	bl	b7dc <__malloc_unlock>
    ba6a:	mov	r0, r7
    ba6c:	b.n	b928 <_realloc_r+0x148>
    ba6e:	ldr	r3, [r6, #0]
    ba70:	str	r3, [r0, #0]
    ba72:	ldr	r3, [r6, #4]
    ba74:	str	r3, [r0, #4]
    ba76:	cmp	r2, #27
    ba78:	bhi.n	baca <_realloc_r+0x2ea>
    ba7a:	add.w	r3, r0, #8
    ba7e:	add.w	r2, r6, #8
    ba82:	b.n	b86a <_realloc_r+0x8a>
    ba84:	mov	r3, r7
    ba86:	ldr	r2, [r6, #0]
    ba88:	str	r2, [r3, #0]
    ba8a:	ldr	r2, [r6, #4]
    ba8c:	str	r2, [r3, #4]
    ba8e:	ldr	r2, [r6, #8]
    ba90:	str	r2, [r3, #8]
    ba92:	mov	r6, r7
    ba94:	mov	r4, lr
    ba96:	mov	r8, sl
    ba98:	b.n	b902 <_realloc_r+0x122>
    ba9a:	add.w	r1, r8, r5
    ba9e:	rsb	fp, r5, fp
    baa2:	orr.w	r2, fp, #1
    baa6:	str	r1, [r3, #8]
    baa8:	str	r2, [r1, #4]
    baaa:	ldr.w	r3, [r6, #-4]
    baae:	and.w	r3, r3, #1
    bab2:	orrs	r5, r3
    bab4:	mov	r0, r9
    bab6:	str.w	r5, [r6, #-4]
    baba:	bl	b7dc <__malloc_unlock>
    babe:	mov	r0, r6
    bac0:	b.n	b928 <_realloc_r+0x148>
    bac2:	mov	r1, r6
    bac4:	bl	b674 <memmove>
    bac8:	b.n	b876 <_realloc_r+0x96>
    baca:	ldr	r3, [r6, #8]
    bacc:	str	r3, [r0, #8]
    bace:	ldr	r3, [r6, #12]
    bad0:	str	r3, [r0, #12]
    bad2:	cmp	r2, #36	; 0x24
    bad4:	beq.n	bb28 <_realloc_r+0x348>
    bad6:	add.w	r3, r0, #16
    bada:	add.w	r2, r6, #16
    bade:	b.n	b86a <_realloc_r+0x8a>
    bae0:	ldr.w	r3, [r0, #-4]
    bae4:	bic.w	r3, r3, #3
    bae8:	add	r4, r3
    baea:	b.n	b902 <_realloc_r+0x122>
    baec:	mov	r1, r6
    baee:	mov	r0, r7
    baf0:	mov	r4, lr
    baf2:	mov	r8, sl
    baf4:	bl	b674 <memmove>
    baf8:	mov	r6, r7
    bafa:	b.n	b902 <_realloc_r+0x122>
    bafc:	mov	r2, r7
    bafe:	b.n	b8f0 <_realloc_r+0x110>
    bb00:	mov	r1, r6
    bb02:	mov	r0, r7
    bb04:	mov	r4, r3
    bb06:	mov	r8, sl
    bb08:	bl	b674 <memmove>
    bb0c:	mov	r6, r7
    bb0e:	b.n	b902 <_realloc_r+0x122>
    bb10:	ldr	r3, [r6, #8]
    bb12:	str.w	r3, [sl, #16]
    bb16:	ldr	r3, [r6, #12]
    bb18:	str.w	r3, [sl, #20]
    bb1c:	cmp	r2, #36	; 0x24
    bb1e:	beq.n	bb58 <_realloc_r+0x378>
    bb20:	adds	r6, #16
    bb22:	add.w	r3, sl, #24
    bb26:	b.n	ba86 <_realloc_r+0x2a6>
    bb28:	ldr	r3, [r6, #16]
    bb2a:	str	r3, [r0, #16]
    bb2c:	ldr	r3, [r6, #20]
    bb2e:	str	r3, [r0, #20]
    bb30:	add.w	r2, r6, #24
    bb34:	add.w	r3, r0, #24
    bb38:	b.n	b86a <_realloc_r+0x8a>
    bb3a:	nop
    bb3c:	.word	0x20001160
    bb40:	ldr	r1, [r6, #8]
    bb42:	str.w	r1, [sl, #16]
    bb46:	ldr	r1, [r6, #12]
    bb48:	str.w	r1, [sl, #20]
    bb4c:	cmp	r2, #36	; 0x24
    bb4e:	beq.n	bb70 <_realloc_r+0x390>
    bb50:	adds	r6, #16
    bb52:	add.w	r2, sl, #24
    bb56:	b.n	b8f0 <_realloc_r+0x110>
    bb58:	ldr	r3, [r6, #16]
    bb5a:	str.w	r3, [sl, #24]
    bb5e:	ldr	r3, [r6, #20]
    bb60:	str.w	r3, [sl, #28]
    bb64:	adds	r6, #24
    bb66:	add.w	r3, sl, #32
    bb6a:	b.n	ba86 <_realloc_r+0x2a6>
    bb6c:	mov	r2, r7
    bb6e:	b.n	ba3a <_realloc_r+0x25a>
    bb70:	ldr	r2, [r6, #16]
    bb72:	str.w	r2, [sl, #24]
    bb76:	ldr	r2, [r6, #20]
    bb78:	str.w	r2, [sl, #28]
    bb7c:	adds	r6, #24
    bb7e:	add.w	r2, sl, #32
    bb82:	b.n	b8f0 <_realloc_r+0x110>
    bb84:	mov	r1, r6
    bb86:	mov	r0, r7
    bb88:	str	r3, [sp, #4]
    bb8a:	bl	b674 <memmove>
    bb8e:	ldr	r3, [sp, #4]
    bb90:	b.n	ba46 <_realloc_r+0x266>
    bb92:	ldr	r1, [r6, #8]
    bb94:	str.w	r1, [sl, #16]
    bb98:	ldr	r1, [r6, #12]
    bb9a:	str.w	r1, [sl, #20]
    bb9e:	cmp	r2, #36	; 0x24
    bba0:	beq.n	bbaa <_realloc_r+0x3ca>
    bba2:	adds	r6, #16
    bba4:	add.w	r2, sl, #24
    bba8:	b.n	ba3a <_realloc_r+0x25a>
    bbaa:	ldr	r2, [r6, #16]
    bbac:	str.w	r2, [sl, #24]
    bbb0:	ldr	r2, [r6, #20]
    bbb2:	str.w	r2, [sl, #28]
    bbb6:	adds	r6, #24
    bbb8:	add.w	r2, sl, #32
    bbbc:	b.n	ba3a <_realloc_r+0x25a>
    bbbe:	nop

0000bbc0 <_sbrk_r>:
    bbc0:	push	{r3, r4, r5, lr}
    bbc2:	ldr	r4, [pc, #28]	; (bbe0 <_sbrk_r+0x20>)
    bbc4:	movs	r3, #0
    bbc6:	mov	r5, r0
    bbc8:	mov	r0, r1
    bbca:	str	r3, [r4, #0]
    bbcc:	bl	92d0 <_sbrk>
    bbd0:	adds	r3, r0, #1
    bbd2:	beq.n	bbd6 <_sbrk_r+0x16>
    bbd4:	pop	{r3, r4, r5, pc}
    bbd6:	ldr	r3, [r4, #0]
    bbd8:	cmp	r3, #0
    bbda:	beq.n	bbd4 <_sbrk_r+0x14>
    bbdc:	str	r3, [r5, #0]
    bbde:	pop	{r3, r4, r5, pc}
    bbe0:	.word	0x2000dac0

0000bbe4 <sprintf>:
    bbe4:	push	{r1, r2, r3}
    bbe6:	push	{r4, r5, r6, r7, lr}
    bbe8:	sub	sp, #112	; 0x70
    bbea:	add	r3, sp, #132	; 0x84
    bbec:	ldr	r1, [pc, #60]	; (bc2c <sprintf+0x48>)
    bbee:	ldr.w	r2, [r3], #4
    bbf2:	str	r3, [sp, #4]
    bbf4:	mov	r5, r0
    bbf6:	mvn.w	r4, #2147483648	; 0x80000000
    bbfa:	ldr	r0, [r1, #0]
    bbfc:	str	r5, [sp, #8]
    bbfe:	mov.w	r7, #520	; 0x208
    bc02:	movw	r6, #65535	; 0xffff
    bc06:	add	r1, sp, #8
    bc08:	str	r5, [sp, #24]
    bc0a:	strh.w	r7, [sp, #20]
    bc0e:	str	r4, [sp, #16]
    bc10:	str	r4, [sp, #28]
    bc12:	strh.w	r6, [sp, #22]
    bc16:	bl	c160 <_svfprintf_r>
    bc1a:	ldr	r3, [sp, #8]
    bc1c:	movs	r2, #0
    bc1e:	strb	r2, [r3, #0]
    bc20:	add	sp, #112	; 0x70
    bc22:	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    bc26:	add	sp, #12
    bc28:	bx	lr
    bc2a:	nop
    bc2c:	.word	0x20000ff0
	...
    bc40:	sub.w	r0, r2, r3
    bc44:	bx	lr
    bc46:	nop

0000bc48 <strcmp>:
    bc48:	ldrb	r2, [r0, #0]
    bc4a:	ldrb	r3, [r1, #0]
    bc4c:	cmp	r2, #1
    bc4e:	it	cs
    bc50:	cmpcs	r2, r3
    bc52:	bne.n	bc40 <sprintf+0x5c>
    bc54:	strd	r4, r5, [sp, #-16]!
    bc58:	orr.w	r4, r0, r1
    bc5c:	strd	r6, r7, [sp, #8]
    bc60:	mvn.w	ip, #0
    bc64:	mov.w	r2, r4, lsl #29
    bc68:	cbz	r2, bcb0 <strcmp+0x68>
    bc6a:	eor.w	r4, r0, r1
    bc6e:	tst.w	r4, #7
    bc72:	bne.n	bd4a <strcmp+0x102>
    bc74:	and.w	r4, r0, #7
    bc78:	bic.w	r0, r0, #7
    bc7c:	and.w	r5, r4, #3
    bc80:	bic.w	r1, r1, #7
    bc84:	mov.w	r5, r5, lsl #3
    bc88:	ldrd	r2, r3, [r0], #16
    bc8c:	tst.w	r4, #4
    bc90:	ldrd	r6, r7, [r1], #16
    bc94:	lsl.w	r4, ip, r5
    bc98:	orn	r2, r2, r4
    bc9c:	orn	r6, r6, r4
    bca0:	beq.n	bcb8 <strcmp+0x70>
    bca2:	orn	r3, r3, r4
    bca6:	mov	r2, ip
    bca8:	orn	r7, r7, r4
    bcac:	mov	r6, ip
    bcae:	b.n	bcb8 <strcmp+0x70>
    bcb0:	ldrd	r2, r3, [r0], #16
    bcb4:	ldrd	r6, r7, [r1], #16
    bcb8:	uadd8	r5, r2, ip
    bcbc:	eor.w	r4, r2, r6
    bcc0:	sel	r4, r4, ip
    bcc4:	cbnz	r4, bd22 <strcmp+0xda>
    bcc6:	uadd8	r5, r3, ip
    bcca:	eor.w	r5, r3, r7
    bcce:	sel	r5, r5, ip
    bcd2:	cbnz	r5, bcfa <strcmp+0xb2>
    bcd4:	ldrd	r2, r3, [r0, #-8]
    bcd8:	ldrd	r6, r7, [r1, #-8]
    bcdc:	uadd8	r5, r2, ip
    bce0:	eor.w	r4, r2, r6
    bce4:	sel	r4, r4, ip
    bce8:	uadd8	r5, r3, ip
    bcec:	eor.w	r5, r3, r7
    bcf0:	sel	r5, r5, ip
    bcf4:	orrs	r5, r4
    bcf6:	beq.n	bcb0 <strcmp+0x68>
    bcf8:	cbnz	r4, bd22 <strcmp+0xda>
    bcfa:	rev	r5, r5
    bcfc:	clz	r4, r5
    bd00:	bic.w	r4, r4, #7
    bd04:	lsr.w	r1, r7, r4
    bd08:	ldrd	r6, r7, [sp, #8]
    bd0c:	lsr.w	r3, r3, r4
    bd10:	and.w	r0, r3, #255	; 0xff
    bd14:	and.w	r1, r1, #255	; 0xff
    bd18:	ldrd	r4, r5, [sp], #16
    bd1c:	sub.w	r0, r0, r1
    bd20:	bx	lr
    bd22:	rev	r4, r4
    bd24:	clz	r4, r4
    bd28:	bic.w	r4, r4, #7
    bd2c:	lsr.w	r1, r6, r4
    bd30:	ldrd	r6, r7, [sp, #8]
    bd34:	lsr.w	r2, r2, r4
    bd38:	and.w	r0, r2, #255	; 0xff
    bd3c:	and.w	r1, r1, #255	; 0xff
    bd40:	ldrd	r4, r5, [sp], #16
    bd44:	sub.w	r0, r0, r1
    bd48:	bx	lr
    bd4a:	tst.w	r4, #3
    bd4e:	bne.n	bdca <strcmp+0x182>
    bd50:	ands.w	r4, r0, #3
    bd54:	bne.n	bda8 <strcmp+0x160>
    bd56:	ldr.w	r2, [r0], #8
    bd5a:	ldr.w	r3, [r1], #8
    bd5e:	uadd8	r5, r2, ip
    bd62:	eor.w	r5, r2, r3
    bd66:	sel	r5, r5, ip
    bd6a:	cbnz	r5, bd84 <strcmp+0x13c>
    bd6c:	ldr.w	r2, [r0, #-4]
    bd70:	ldr.w	r3, [r1, #-4]
    bd74:	uadd8	r5, r2, ip
    bd78:	eor.w	r5, r2, r3
    bd7c:	sel	r5, r5, ip
    bd80:	cmp	r5, #0
    bd82:	beq.n	bd56 <strcmp+0x10e>
    bd84:	rev	r5, r5
    bd86:	clz	r4, r5
    bd8a:	bic.w	r4, r4, #7
    bd8e:	lsr.w	r1, r3, r4
    bd92:	lsr.w	r2, r2, r4
    bd96:	and.w	r0, r2, #255	; 0xff
    bd9a:	and.w	r1, r1, #255	; 0xff
    bd9e:	ldrd	r4, r5, [sp], #16
    bda2:	sub.w	r0, r0, r1
    bda6:	bx	lr
    bda8:	mov.w	r4, r4, lsl #3
    bdac:	bic.w	r0, r0, #3
    bdb0:	ldr.w	r2, [r0], #8
    bdb4:	bic.w	r1, r1, #3
    bdb8:	ldr.w	r3, [r1], #8
    bdbc:	lsl.w	r4, ip, r4
    bdc0:	orn	r2, r2, r4
    bdc4:	orn	r3, r3, r4
    bdc8:	b.n	bd5e <strcmp+0x116>
    bdca:	ands.w	r4, r0, #3
    bdce:	beq.n	be06 <strcmp+0x1be>
    bdd0:	sub.w	r1, r1, r4
    bdd4:	bic.w	r0, r0, #3
    bdd8:	lsls	r4, r4, #31
    bdda:	ldr.w	r2, [r0], #4
    bdde:	beq.n	bdee <strcmp+0x1a6>
    bde0:	bcs.n	be02 <strcmp+0x1ba>
    bde2:	ldrb	r3, [r1, #2]
    bde4:	uxtb.w	r4, r2, ror #16
    bde8:	subs	r4, r4, r3
    bdea:	bne.n	bdfa <strcmp+0x1b2>
    bdec:	cbz	r3, bdfa <strcmp+0x1b2>
    bdee:	ldrb	r3, [r1, #3]
    bdf0:	uxtb.w	r4, r2, ror #24
    bdf4:	subs	r4, r4, r3
    bdf6:	bne.n	bdfa <strcmp+0x1b2>
    bdf8:	cbnz	r3, be02 <strcmp+0x1ba>
    bdfa:	mov	r0, r4
    bdfc:	ldr.w	r4, [sp], #16
    be00:	bx	lr
    be02:	add.w	r1, r1, #4
    be06:	ldr.w	r2, [r0], #4
    be0a:	lsls	r4, r1, #31
    be0c:	bic.w	r1, r1, #3
    be10:	ldr.w	r3, [r1], #4
    be14:	bhi.n	bea8 <strcmp+0x260>
    be16:	bcs.n	be62 <strcmp+0x21a>
    be18:	bic.w	r4, r2, #4278190080	; 0xff000000
    be1c:	uadd8	r5, r2, ip
    be20:	eors.w	r5, r4, r3, lsr #8
    be24:	sel	r5, r5, ip
    be28:	bne.n	be40 <strcmp+0x1f8>
    be2a:	cbnz	r5, be46 <strcmp+0x1fe>
    be2c:	ldr.w	r3, [r1], #4
    be30:	eor.w	r4, r4, r2
    be34:	cmp.w	r4, r3, lsl #24
    be38:	bne.n	be58 <strcmp+0x210>
    be3a:	ldr.w	r2, [r0], #4
    be3e:	b.n	be18 <strcmp+0x1d0>
    be40:	mov.w	r3, r3, lsr #8
    be44:	b.n	bef2 <strcmp+0x2aa>
    be46:	bics.w	r5, r5, #4278190080	; 0xff000000
    be4a:	bne.n	bee8 <strcmp+0x2a0>
    be4c:	ldrb	r0, [r1, #0]
    be4e:	ldrd	r4, r5, [sp], #16
    be52:	rsb	r0, r0, #0
    be56:	bx	lr
    be58:	mov.w	r2, r2, lsr #24
    be5c:	and.w	r3, r3, #255	; 0xff
    be60:	b.n	bef2 <strcmp+0x2aa>
    be62:	and.w	r4, r2, ip, lsr #16
    be66:	uadd8	r5, r2, ip
    be6a:	eors.w	r5, r4, r3, lsr #16
    be6e:	sel	r5, r5, ip
    be72:	bne.n	be8a <strcmp+0x242>
    be74:	cbnz	r5, be90 <strcmp+0x248>
    be76:	ldr.w	r3, [r1], #4
    be7a:	eor.w	r4, r4, r2
    be7e:	cmp.w	r4, r3, lsl #16
    be82:	bne.n	be9e <strcmp+0x256>
    be84:	ldr.w	r2, [r0], #4
    be88:	b.n	be62 <strcmp+0x21a>
    be8a:	mov.w	r3, r3, lsr #16
    be8e:	b.n	bef2 <strcmp+0x2aa>
    be90:	ands.w	r5, r5, ip, lsr #16
    be94:	bne.n	bee8 <strcmp+0x2a0>
    be96:	ldrh	r3, [r1, #0]
    be98:	mov.w	r2, r2, lsr #16
    be9c:	b.n	bef2 <strcmp+0x2aa>
    be9e:	mov.w	r2, r2, lsr #16
    bea2:	and.w	r3, r3, ip, lsr #16
    bea6:	b.n	bef2 <strcmp+0x2aa>
    bea8:	and.w	r4, r2, #255	; 0xff
    beac:	uadd8	r5, r2, ip
    beb0:	eors.w	r5, r4, r3, lsr #24
    beb4:	sel	r5, r5, ip
    beb8:	bne.n	bed0 <strcmp+0x288>
    beba:	cbnz	r5, bed6 <strcmp+0x28e>
    bebc:	ldr.w	r3, [r1], #4
    bec0:	eor.w	r4, r4, r2
    bec4:	cmp.w	r4, r3, lsl #8
    bec8:	bne.n	bede <strcmp+0x296>
    beca:	ldr.w	r2, [r0], #4
    bece:	b.n	bea8 <strcmp+0x260>
    bed0:	mov.w	r3, r3, lsr #24
    bed4:	b.n	bef2 <strcmp+0x2aa>
    bed6:	tst.w	r5, #255	; 0xff
    beda:	bne.n	bee8 <strcmp+0x2a0>
    bedc:	ldr	r3, [r1, #0]
    bede:	mov.w	r2, r2, lsr #8
    bee2:	bic.w	r3, r3, #4278190080	; 0xff000000
    bee6:	b.n	bef2 <strcmp+0x2aa>
    bee8:	mov.w	r0, #0
    beec:	ldrd	r4, r5, [sp], #16
    bef0:	bx	lr
    bef2:	rev	r2, r2
    bef4:	rev	r3, r3
    bef6:	uadd8	r4, r2, ip
    befa:	eor.w	r4, r2, r3
    befe:	sel	r5, r4, ip
    bf02:	clz	r4, r5
    bf06:	lsl.w	r2, r2, r4
    bf0a:	lsl.w	r3, r3, r4
    bf0e:	mov.w	r0, r2, lsr #24
    bf12:	ldrd	r4, r5, [sp], #16
    bf16:	sub.w	r0, r0, r3, lsr #24
    bf1a:	bx	lr

0000bf1c <strcpy>:
    bf1c:	eor.w	r2, r0, r1
    bf20:	mov	ip, r0
    bf22:	tst.w	r2, #3
    bf26:	bne.n	bfc8 <strcpy+0xac>
    bf28:	tst.w	r1, #3
    bf2c:	bne.n	bf94 <strcpy+0x78>
    bf2e:	str.w	r4, [sp, #-4]!
    bf32:	tst.w	r1, #4
    bf36:	ldr.w	r3, [r1], #4
    bf3a:	beq.n	bf54 <strcpy+0x38>
    bf3c:	sub.w	r2, r3, #16843009	; 0x1010101
    bf40:	bics	r2, r3
    bf42:	tst.w	r2, #2155905152	; 0x80808080
    bf46:	itt	eq
    bf48:	streq.w	r3, [ip], #4
    bf4c:	ldreq.w	r3, [r1], #4
    bf50:	bne.n	bf80 <strcpy+0x64>
    bf52:	nop
    bf54:	ldr.w	r4, [r1], #4
    bf58:	sub.w	r2, r3, #16843009	; 0x1010101
    bf5c:	bics	r2, r3
    bf5e:	tst.w	r2, #2155905152	; 0x80808080
    bf62:	sub.w	r2, r4, #16843009	; 0x1010101
    bf66:	bne.n	bf80 <strcpy+0x64>
    bf68:	str.w	r3, [ip], #4
    bf6c:	bics	r2, r4
    bf6e:	tst.w	r2, #2155905152	; 0x80808080
    bf72:	itt	eq
    bf74:	ldreq.w	r3, [r1], #4
    bf78:	streq.w	r4, [ip], #4
    bf7c:	beq.n	bf54 <strcpy+0x38>
    bf7e:	mov	r3, r4
    bf80:	strb.w	r3, [ip], #1
    bf84:	tst.w	r3, #255	; 0xff
    bf88:	mov.w	r3, r3, ror #8
    bf8c:	bne.n	bf80 <strcpy+0x64>
    bf8e:	ldr.w	r4, [sp], #4
    bf92:	bx	lr
    bf94:	tst.w	r1, #1
    bf98:	beq.n	bfa8 <strcpy+0x8c>
    bf9a:	ldrb.w	r2, [r1], #1
    bf9e:	strb.w	r2, [ip], #1
    bfa2:	cmp	r2, #0
    bfa4:	it	eq
    bfa6:	bxeq	lr
    bfa8:	tst.w	r1, #2
    bfac:	beq.n	bf2e <strcpy+0x12>
    bfae:	ldrh.w	r2, [r1], #2
    bfb2:	tst.w	r2, #255	; 0xff
    bfb6:	itet	ne
    bfb8:	strhne.w	r2, [ip], #2
    bfbc:	strbeq.w	r2, [ip]
    bfc0:	tstne.w	r2, #65280	; 0xff00
    bfc4:	bne.n	bf2e <strcpy+0x12>
    bfc6:	bx	lr
    bfc8:	ldrb.w	r2, [r1], #1
    bfcc:	strb.w	r2, [ip], #1
    bfd0:	cmp	r2, #0
    bfd2:	bne.n	bfc8 <strcpy+0xac>
    bfd4:	bx	lr
    bfd6:	nop

0000bfd8 <strlcat>:
    bfd8:	push	{r4, r5, r6, lr}
    bfda:	cbz	r2, c01a <strlcat+0x42>
    bfdc:	ldrb	r6, [r0, #0]
    bfde:	cbz	r6, c026 <strlcat+0x4e>
    bfe0:	adds	r3, r0, #1
    bfe2:	adds	r6, r0, r2
    bfe4:	b.n	bfec <strlcat+0x14>
    bfe6:	ldrb	r5, [r3, #0]
    bfe8:	adds	r3, #1
    bfea:	cbz	r5, bff2 <strlcat+0x1a>
    bfec:	cmp	r6, r3
    bfee:	mov	r4, r3
    bff0:	bne.n	bfe6 <strlcat+0xe>
    bff2:	subs	r6, r4, r0
    bff4:	subs	r2, r2, r6
    bff6:	beq.n	c01c <strlcat+0x44>
    bff8:	ldrb	r3, [r1, #0]
    bffa:	mov	r5, r1
    bffc:	cbz	r3, c012 <strlcat+0x3a>
    bffe:	cmp	r2, #1
    c000:	beq.n	c008 <strlcat+0x30>
    c002:	strb	r3, [r4, #0]
    c004:	subs	r2, #1
    c006:	adds	r4, #1
    c008:	ldrb.w	r3, [r5, #1]!
    c00c:	cmp	r3, #0
    c00e:	bne.n	bffe <strlcat+0x26>
    c010:	subs	r3, r5, r1
    c012:	movs	r2, #0
    c014:	strb	r2, [r4, #0]
    c016:	adds	r0, r6, r3
    c018:	pop	{r4, r5, r6, pc}
    c01a:	mov	r6, r2
    c01c:	mov	r0, r1
    c01e:	bl	c080 <strlen>
    c022:	add	r0, r6
    c024:	pop	{r4, r5, r6, pc}
    c026:	mov	r4, r0
    c028:	b.n	bff8 <strlcat+0x20>
    c02a:	nop

0000c02c <strlcpy>:
    c02c:	push	{r4}
    c02e:	mov	r3, r1
    c030:	cbz	r2, c046 <strlcpy+0x1a>
    c032:	b.n	c03e <strlcpy+0x12>
    c034:	ldrb.w	r4, [r3], #1
    c038:	strb.w	r4, [r0], #1
    c03c:	cbz	r4, c04e <strlcpy+0x22>
    c03e:	subs	r2, #1
    c040:	bne.n	c034 <strlcpy+0x8>
    c042:	movs	r2, #0
    c044:	strb	r2, [r0, #0]
    c046:	ldrb.w	r2, [r3], #1
    c04a:	cmp	r2, #0
    c04c:	bne.n	c046 <strlcpy+0x1a>
    c04e:	subs	r0, r3, r1
    c050:	subs	r0, #1
    c052:	ldr.w	r4, [sp], #4
    c056:	bx	lr
	...

0000c080 <strlen>:
    c080:	pld	[r0]
    c084:	strd	r4, r5, [sp, #-8]!
    c088:	bic.w	r1, r0, #7
    c08c:	mvn.w	ip, #0
    c090:	ands.w	r4, r0, #7
    c094:	pld	[r1, #32]
    c098:	bne.w	c12e <strlen+0xae>
    c09c:	mov.w	r4, #0
    c0a0:	mvn.w	r0, #7
    c0a4:	ldrd	r2, r3, [r1]
    c0a8:	pld	[r1, #64]	; 0x40
    c0ac:	add.w	r0, r0, #8
    c0b0:	uadd8	r2, r2, ip
    c0b4:	sel	r2, r4, ip
    c0b8:	uadd8	r3, r3, ip
    c0bc:	sel	r3, r2, ip
    c0c0:	cbnz	r3, c116 <strlen+0x96>
    c0c2:	ldrd	r2, r3, [r1, #8]
    c0c6:	uadd8	r2, r2, ip
    c0ca:	add.w	r0, r0, #8
    c0ce:	sel	r2, r4, ip
    c0d2:	uadd8	r3, r3, ip
    c0d6:	sel	r3, r2, ip
    c0da:	cbnz	r3, c116 <strlen+0x96>
    c0dc:	ldrd	r2, r3, [r1, #16]
    c0e0:	uadd8	r2, r2, ip
    c0e4:	add.w	r0, r0, #8
    c0e8:	sel	r2, r4, ip
    c0ec:	uadd8	r3, r3, ip
    c0f0:	sel	r3, r2, ip
    c0f4:	cbnz	r3, c116 <strlen+0x96>
    c0f6:	ldrd	r2, r3, [r1, #24]
    c0fa:	add.w	r1, r1, #32
    c0fe:	uadd8	r2, r2, ip
    c102:	add.w	r0, r0, #8
    c106:	sel	r2, r4, ip
    c10a:	uadd8	r3, r3, ip
    c10e:	sel	r3, r2, ip
    c112:	cmp	r3, #0
    c114:	beq.n	c0a4 <strlen+0x24>
    c116:	cmp	r2, #0
    c118:	itt	eq
    c11a:	addeq	r0, #4
    c11c:	moveq	r2, r3
    c11e:	rev	r2, r2
    c120:	clz	r2, r2
    c124:	ldrd	r4, r5, [sp], #8
    c128:	add.w	r0, r0, r2, lsr #3
    c12c:	bx	lr
    c12e:	ldrd	r2, r3, [r1]
    c132:	and.w	r5, r4, #3
    c136:	rsb	r0, r4, #0
    c13a:	mov.w	r5, r5, lsl #3
    c13e:	tst.w	r4, #4
    c142:	pld	[r1, #64]	; 0x40
    c146:	lsl.w	r5, ip, r5
    c14a:	orn	r2, r2, r5
    c14e:	itt	ne
    c150:	ornne	r3, r3, r5
    c154:	movne	r2, ip
    c156:	mov.w	r4, #0
    c15a:	b.n	c0b0 <strlen+0x30>
    c15c:	movs	r0, r0
	...

0000c160 <_svfprintf_r>:
    c160:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c164:	sub	sp, #260	; 0x104
    c166:	mov	r4, r1
    c168:	str	r1, [sp, #20]
    c16a:	mov	r5, r2
    c16c:	str	r3, [sp, #40]	; 0x28
    c16e:	str	r0, [sp, #24]
    c170:	bl	ebb8 <_localeconv_r>
    c174:	ldr	r3, [r0, #0]
    c176:	str	r3, [sp, #76]	; 0x4c
    c178:	mov	r0, r3
    c17a:	bl	c080 <strlen>
    c17e:	ldrh	r3, [r4, #12]
    c180:	str	r0, [sp, #72]	; 0x48
    c182:	lsls	r6, r3, #24
    c184:	bpl.n	c18e <_svfprintf_r+0x2e>
    c186:	ldr	r3, [r4, #16]
    c188:	cmp	r3, #0
    c18a:	beq.w	d3f0 <_svfprintf_r+0x1290>
    c18e:	vldr	d7, [pc, #664]	; c428 <_svfprintf_r+0x2c8>
    c192:	movs	r3, #0
    c194:	vstr	d7, [sp, #64]	; 0x40
    c198:	str	r3, [sp, #56]	; 0x38
    c19a:	str	r3, [sp, #148]	; 0x94
    c19c:	str	r3, [sp, #144]	; 0x90
    c19e:	str	r3, [sp, #84]	; 0x54
    c1a0:	str	r3, [sp, #28]
    c1a2:	ldr.w	sl, [pc, #656]	; c434 <_svfprintf_r+0x2d4>
    c1a6:	add	r3, sp, #192	; 0xc0
    c1a8:	str	r3, [sp, #140]	; 0x8c
    c1aa:	mov	r9, r3
    c1ac:	mov	r8, r5
    c1ae:	ldrb.w	r3, [r8]
    c1b2:	mov	r4, r8
    c1b4:	cbz	r3, c1f2 <_svfprintf_r+0x92>
    c1b6:	cmp	r3, #37	; 0x25
    c1b8:	bne.n	c1c0 <_svfprintf_r+0x60>
    c1ba:	b.n	c1f2 <_svfprintf_r+0x92>
    c1bc:	cmp	r3, #37	; 0x25
    c1be:	beq.n	c1c8 <_svfprintf_r+0x68>
    c1c0:	ldrb.w	r3, [r4, #1]!
    c1c4:	cmp	r3, #0
    c1c6:	bne.n	c1bc <_svfprintf_r+0x5c>
    c1c8:	rsb	r5, r8, r4
    c1cc:	cbz	r5, c1f2 <_svfprintf_r+0x92>
    c1ce:	ldr	r3, [sp, #144]	; 0x90
    c1d0:	ldr	r2, [sp, #148]	; 0x94
    c1d2:	str.w	r8, [r9]
    c1d6:	adds	r3, #1
    c1d8:	add	r2, r5
    c1da:	cmp	r3, #7
    c1dc:	str.w	r5, [r9, #4]
    c1e0:	str	r2, [sp, #148]	; 0x94
    c1e2:	str	r3, [sp, #144]	; 0x90
    c1e4:	bgt.w	c334 <_svfprintf_r+0x1d4>
    c1e8:	add.w	r9, r9, #8
    c1ec:	ldr	r3, [sp, #28]
    c1ee:	add	r3, r5
    c1f0:	str	r3, [sp, #28]
    c1f2:	ldrb	r3, [r4, #0]
    c1f4:	cmp	r3, #0
    c1f6:	beq.w	c346 <_svfprintf_r+0x1e6>
    c1fa:	movs	r3, #0
    c1fc:	mov	r2, r3
    c1fe:	strb.w	r3, [sp, #111]	; 0x6f
    c202:	mov	r1, r3
    c204:	str	r3, [sp, #32]
    c206:	str	r3, [sp, #12]
    c208:	mov.w	fp, #4294967295
    c20c:	ldrb	r3, [r4, #1]
    c20e:	add.w	r8, r4, #1
    c212:	mov	r5, fp
    c214:	add.w	r8, r8, #1
    c218:	sub.w	r0, r3, #32
    c21c:	cmp	r0, #88	; 0x58
    c21e:	bhi.w	ca8a <_svfprintf_r+0x92a>
    c222:	tbh	[pc, r0, lsl #1]
    c226:	.short	0x03a0
    c228:	.word	0x04320432
    c22c:	.word	0x043203a8
    c230:	.word	0x04320432
    c234:	.word	0x04320432
    c238:	.word	0x03af0432
    c23c:	.word	0x043203bd
    c240:	.word	0x00e2005d
    c244:	.word	0x01090432
    c248:	.word	0x01100110
    c24c:	.word	0x01100110
    c250:	.word	0x01100110
    c254:	.word	0x01100110
    c258:	.word	0x04320110
    c25c:	.word	0x04320432
    c260:	.word	0x04320432
    c264:	.word	0x04320432
    c268:	.word	0x04320432
    c26c:	.word	0x01200432
    c270:	.word	0x04320286
    c274:	.word	0x04320286
    c278:	.word	0x04320432
    c27c:	.word	0x02d40432
    c280:	.word	0x04320432
    c284:	.word	0x043202e5
    c288:	.word	0x04320432
    c28c:	.word	0x04320432
    c290:	.word	0x0432030f
    c294:	.word	0x033d0432
    c298:	.word	0x04320432
    c29c:	.word	0x04320432
    c2a0:	.word	0x04320432
    c2a4:	.word	0x04320432
    c2a8:	.word	0x04320432
    c2ac:	.word	0x0391037e
    c2b0:	.word	0x02860286
    c2b4:	.word	0x03990286
    c2b8:	.word	0x04320391
    c2bc:	.word	0x04070432
    c2c0:	.word	0x04120432
    c2c4:	.word	0x006400a3
    c2c8:	.word	0x043203c2
    c2cc:	.word	0x043203c9
    c2d0:	.word	0x043203ea
    c2d4:	.word	0x03f20432
    c2d8:	ldr	r0, [sp, #32]
    c2da:	str	r3, [sp, #40]	; 0x28
    c2dc:	negs	r0, r0
    c2de:	str	r0, [sp, #32]
    c2e0:	ldr	r3, [sp, #12]
    c2e2:	orr.w	r3, r3, #4
    c2e6:	str	r3, [sp, #12]
    c2e8:	ldrb.w	r3, [r8]
    c2ec:	b.n	c214 <_svfprintf_r+0xb4>
    c2ee:	ldr	r0, [sp, #40]	; 0x28
    c2f0:	mov	fp, r5
    c2f2:	movs	r1, #0
    c2f4:	ldr	r4, [r0, #0]
    c2f6:	strb.w	r1, [sp, #111]	; 0x6f
    c2fa:	adds	r7, r0, #4
    c2fc:	ldr	r0, [sp, #12]
    c2fe:	movs	r3, #48	; 0x30
    c300:	movs	r2, #120	; 0x78
    c302:	cmp	fp, r1
    c304:	strb.w	r3, [sp, #112]	; 0x70
    c308:	mov.w	r5, #0
    c30c:	strb.w	r2, [sp, #113]	; 0x71
    c310:	orr.w	r3, r0, #2
    c314:	blt.w	cac4 <_svfprintf_r+0x964>
    c318:	bic.w	r3, r0, #128	; 0x80
    c31c:	orr.w	r3, r3, #2
    c320:	str	r3, [sp, #12]
    c322:	orrs.w	r3, r4, r5
    c326:	str	r7, [sp, #40]	; 0x28
    c328:	beq.w	ca70 <_svfprintf_r+0x910>
    c32c:	mov	r7, r1
    c32e:	str	r2, [sp, #52]	; 0x34
    c330:	ldr	r0, [pc, #252]	; (c430 <_svfprintf_r+0x2d0>)
    c332:	b.n	c902 <_svfprintf_r+0x7a2>
    c334:	add	r2, sp, #140	; 0x8c
    c336:	ldr	r1, [sp, #20]
    c338:	ldr	r0, [sp, #24]
    c33a:	bl	f2a4 <__ssprint_r>
    c33e:	cbnz	r0, c354 <_svfprintf_r+0x1f4>
    c340:	add.w	r9, sp, #192	; 0xc0
    c344:	b.n	c1ec <_svfprintf_r+0x8c>
    c346:	ldr	r3, [sp, #148]	; 0x94
    c348:	cbz	r3, c354 <_svfprintf_r+0x1f4>
    c34a:	ldr	r0, [sp, #24]
    c34c:	ldr	r1, [sp, #20]
    c34e:	add	r2, sp, #140	; 0x8c
    c350:	bl	f2a4 <__ssprint_r>
    c354:	ldr	r3, [sp, #20]
    c356:	ldrh	r3, [r3, #12]
    c358:	tst.w	r3, #64	; 0x40
    c35c:	ldr	r3, [sp, #28]
    c35e:	it	ne
    c360:	movne.w	r3, #4294967295
    c364:	mov	r0, r3
    c366:	add	sp, #260	; 0x104
    c368:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c36c:	str	r3, [sp, #52]	; 0x34
    c36e:	mov	fp, r5
    c370:	cmp	r2, #0
    c372:	bne.w	d7dc <_svfprintf_r+0x167c>
    c376:	ldr	r2, [sp, #12]
    c378:	ands.w	r3, r2, #32
    c37c:	beq.w	c80c <_svfprintf_r+0x6ac>
    c380:	ldr	r7, [sp, #40]	; 0x28
    c382:	adds	r7, #7
    c384:	bic.w	r3, r7, #7
    c388:	movs	r7, #0
    c38a:	add.w	r1, r3, #8
    c38e:	cmp	fp, r7
    c390:	str	r1, [sp, #40]	; 0x28
    c392:	ldrd	r4, r5, [r3]
    c396:	strb.w	r7, [sp, #111]	; 0x6f
    c39a:	blt.w	d262 <_svfprintf_r+0x1102>
    c39e:	bic.w	r3, r2, #128	; 0x80
    c3a2:	str	r3, [sp, #12]
    c3a4:	orrs.w	r3, r4, r5
    c3a8:	beq.w	cab4 <_svfprintf_r+0x954>
    c3ac:	add	r6, sp, #192	; 0xc0
    c3ae:	lsrs	r2, r4, #3
    c3b0:	orr.w	r2, r2, r5, lsl #29
    c3b4:	lsrs	r1, r5, #3
    c3b6:	and.w	r3, r4, #7
    c3ba:	mov	r5, r1
    c3bc:	mov	r4, r2
    c3be:	adds	r3, #48	; 0x30
    c3c0:	orrs.w	r2, r4, r5
    c3c4:	strb.w	r3, [r6, #-1]!
    c3c8:	bne.n	c3ae <_svfprintf_r+0x24e>
    c3ca:	ldr	r2, [sp, #12]
    c3cc:	lsls	r1, r2, #31
    c3ce:	bpl.w	c4f0 <_svfprintf_r+0x390>
    c3d2:	cmp	r3, #48	; 0x30
    c3d4:	beq.w	c4f0 <_svfprintf_r+0x390>
    c3d8:	movs	r2, #48	; 0x30
    c3da:	subs	r3, r6, #1
    c3dc:	strb.w	r2, [r6, #-1]
    c3e0:	add	r2, sp, #192	; 0xc0
    c3e2:	subs	r2, r2, r3
    c3e4:	str	r2, [sp, #36]	; 0x24
    c3e6:	mov	r6, r3
    c3e8:	b.n	c4f6 <_svfprintf_r+0x396>
    c3ea:	ldrb.w	r3, [r8]
    c3ee:	cmp	r3, #42	; 0x2a
    c3f0:	add.w	r4, r8, #1
    c3f4:	beq.w	d7c0 <_svfprintf_r+0x1660>
    c3f8:	sub.w	r0, r3, #48	; 0x30
    c3fc:	cmp	r0, #9
    c3fe:	it	ls
    c400:	movls	r5, #0
    c402:	bhi.w	d712 <_svfprintf_r+0x15b2>
    c406:	ldrb.w	r3, [r4], #1
    c40a:	add.w	r5, r5, r5, lsl #2
    c40e:	add.w	r5, r0, r5, lsl #1
    c412:	sub.w	r0, r3, #48	; 0x30
    c416:	cmp	r0, #9
    c418:	bls.n	c406 <_svfprintf_r+0x2a6>
    c41a:	orr.w	r5, r5, r5, asr #31
    c41e:	mov	r8, r4
    c420:	b.n	c218 <_svfprintf_r+0xb8>
    c422:	nop
    c424:	nop.w
	...
    c430:	.word	0x20000934
    c434:	.word	0x20000900
    c438:	ldr	r3, [sp, #12]
    c43a:	orr.w	r3, r3, #128	; 0x80
    c43e:	str	r3, [sp, #12]
    c440:	ldrb.w	r3, [r8]
    c444:	b.n	c214 <_svfprintf_r+0xb4>
    c446:	sub.w	r0, r3, #48	; 0x30
    c44a:	movs	r3, #0
    c44c:	mov	r4, r3
    c44e:	ldrb.w	r3, [r8], #1
    c452:	add.w	r4, r4, r4, lsl #2
    c456:	add.w	r4, r0, r4, lsl #1
    c45a:	sub.w	r0, r3, #48	; 0x30
    c45e:	cmp	r0, #9
    c460:	bls.n	c44e <_svfprintf_r+0x2ee>
    c462:	str	r4, [sp, #32]
    c464:	b.n	c218 <_svfprintf_r+0xb8>
    c466:	str	r3, [sp, #52]	; 0x34
    c468:	mov	fp, r5
    c46a:	cmp	r2, #0
    c46c:	bne.w	d7f8 <_svfprintf_r+0x1698>
    c470:	ldr	r3, [sp, #12]
    c472:	orr.w	r3, r3, #16
    c476:	str	r3, [sp, #12]
    c478:	ldr	r3, [sp, #12]
    c47a:	lsls	r4, r3, #26
    c47c:	bpl.w	ceee <_svfprintf_r+0xd8e>
    c480:	ldr	r7, [sp, #40]	; 0x28
    c482:	adds	r7, #7
    c484:	bic.w	r7, r7, #7
    c488:	ldrd	r2, r3, [r7]
    c48c:	add.w	r1, r7, #8
    c490:	str	r1, [sp, #40]	; 0x28
    c492:	mov	r4, r2
    c494:	mov	r5, r3
    c496:	cmp	r2, #0
    c498:	sbcs.w	r3, r3, #0
    c49c:	blt.w	cf64 <_svfprintf_r+0xe04>
    c4a0:	cmp.w	fp, #0
    c4a4:	ldrb.w	r7, [sp, #111]	; 0x6f
    c4a8:	blt.w	cf2a <_svfprintf_r+0xdca>
    c4ac:	ldr	r3, [sp, #12]
    c4ae:	bic.w	r3, r3, #128	; 0x80
    c4b2:	str	r3, [sp, #12]
    c4b4:	orrs.w	r3, r4, r5
    c4b8:	beq.w	c88c <_svfprintf_r+0x72c>
    c4bc:	cmp	r5, #0
    c4be:	it	eq
    c4c0:	cmpeq	r4, #10
    c4c2:	bcc.w	c896 <_svfprintf_r+0x736>
    c4c6:	add	r6, sp, #192	; 0xc0
    c4c8:	mov	r0, r4
    c4ca:	mov	r1, r5
    c4cc:	movs	r2, #10
    c4ce:	movs	r3, #0
    c4d0:	bl	ad40 <__aeabi_uldivmod>
    c4d4:	adds	r2, #48	; 0x30
    c4d6:	strb.w	r2, [r6, #-1]!
    c4da:	mov	r0, r4
    c4dc:	mov	r1, r5
    c4de:	movs	r3, #0
    c4e0:	movs	r2, #10
    c4e2:	bl	ad40 <__aeabi_uldivmod>
    c4e6:	mov	r4, r0
    c4e8:	mov	r5, r1
    c4ea:	orrs.w	r3, r4, r5
    c4ee:	bne.n	c4c8 <_svfprintf_r+0x368>
    c4f0:	add	r3, sp, #192	; 0xc0
    c4f2:	subs	r3, r3, r6
    c4f4:	str	r3, [sp, #36]	; 0x24
    c4f6:	ldr	r3, [sp, #36]	; 0x24
    c4f8:	cmp	r3, fp
    c4fa:	it	lt
    c4fc:	movlt	r3, fp
    c4fe:	str	r3, [sp, #16]
    c500:	movs	r3, #0
    c502:	str	r3, [sp, #60]	; 0x3c
    c504:	cbz	r7, c50c <_svfprintf_r+0x3ac>
    c506:	ldr	r3, [sp, #16]
    c508:	adds	r3, #1
    c50a:	str	r3, [sp, #16]
    c50c:	ldr	r3, [sp, #12]
    c50e:	ands.w	r3, r3, #2
    c512:	str	r3, [sp, #44]	; 0x2c
    c514:	beq.n	c51c <_svfprintf_r+0x3bc>
    c516:	ldr	r3, [sp, #16]
    c518:	adds	r3, #2
    c51a:	str	r3, [sp, #16]
    c51c:	ldr	r3, [sp, #12]
    c51e:	ands.w	r3, r3, #132	; 0x84
    c522:	str	r3, [sp, #48]	; 0x30
    c524:	bne.w	cade <_svfprintf_r+0x97e>
    c528:	ldr	r3, [sp, #32]
    c52a:	ldr	r2, [sp, #16]
    c52c:	subs	r5, r3, r2
    c52e:	cmp	r5, #0
    c530:	ble.w	cade <_svfprintf_r+0x97e>
    c534:	cmp	r5, #16
    c536:	ldr	r1, [sp, #148]	; 0x94
    c538:	ldr	r2, [sp, #144]	; 0x90
    c53a:	ldr	r7, [pc, #672]	; (c7dc <_svfprintf_r+0x67c>)
    c53c:	ble.n	c58e <_svfprintf_r+0x42e>
    c53e:	str	r6, [sp, #80]	; 0x50
    c540:	mov	r0, r9
    c542:	movs	r4, #16
    c544:	mov	r9, r7
    c546:	ldr	r6, [sp, #20]
    c548:	mov	r7, r5
    c54a:	ldr	r5, [sp, #24]
    c54c:	b.n	c558 <_svfprintf_r+0x3f8>
    c54e:	subs	r7, #16
    c550:	cmp	r7, #16
    c552:	add.w	r0, r0, #8
    c556:	ble.n	c586 <_svfprintf_r+0x426>
    c558:	adds	r2, #1
    c55a:	ldr	r3, [pc, #640]	; (c7dc <_svfprintf_r+0x67c>)
    c55c:	str	r2, [sp, #144]	; 0x90
    c55e:	adds	r1, #16
    c560:	cmp	r2, #7
    c562:	str	r1, [sp, #148]	; 0x94
    c564:	stmia.w	r0, {r3, r4}
    c568:	ble.n	c54e <_svfprintf_r+0x3ee>
    c56a:	add	r2, sp, #140	; 0x8c
    c56c:	mov	r1, r6
    c56e:	mov	r0, r5
    c570:	bl	f2a4 <__ssprint_r>
    c574:	cmp	r0, #0
    c576:	bne.w	c354 <_svfprintf_r+0x1f4>
    c57a:	subs	r7, #16
    c57c:	cmp	r7, #16
    c57e:	ldr	r1, [sp, #148]	; 0x94
    c580:	ldr	r2, [sp, #144]	; 0x90
    c582:	add	r0, sp, #192	; 0xc0
    c584:	bgt.n	c558 <_svfprintf_r+0x3f8>
    c586:	ldr	r6, [sp, #80]	; 0x50
    c588:	mov	r5, r7
    c58a:	mov	r7, r9
    c58c:	mov	r9, r0
    c58e:	adds	r2, #1
    c590:	adds	r4, r5, r1
    c592:	cmp	r2, #7
    c594:	str	r4, [sp, #148]	; 0x94
    c596:	str	r2, [sp, #144]	; 0x90
    c598:	str.w	r7, [r9]
    c59c:	str.w	r5, [r9, #4]
    c5a0:	bgt.w	cdfe <_svfprintf_r+0xc9e>
    c5a4:	ldrb.w	r7, [sp, #111]	; 0x6f
    c5a8:	add.w	r9, r9, #8
    c5ac:	cbz	r7, c5cc <_svfprintf_r+0x46c>
    c5ae:	ldr	r3, [sp, #144]	; 0x90
    c5b0:	adds	r3, #1
    c5b2:	adds	r4, #1
    c5b4:	add.w	r1, sp, #111	; 0x6f
    c5b8:	movs	r2, #1
    c5ba:	cmp	r3, #7
    c5bc:	str	r4, [sp, #148]	; 0x94
    c5be:	str	r3, [sp, #144]	; 0x90
    c5c0:	stmia.w	r9, {r1, r2}
    c5c4:	bgt.w	cd12 <_svfprintf_r+0xbb2>
    c5c8:	add.w	r9, r9, #8
    c5cc:	ldr	r3, [sp, #44]	; 0x2c
    c5ce:	cbz	r3, c5ec <_svfprintf_r+0x48c>
    c5d0:	ldr	r3, [sp, #144]	; 0x90
    c5d2:	adds	r3, #1
    c5d4:	adds	r4, #2
    c5d6:	add	r1, sp, #112	; 0x70
    c5d8:	movs	r2, #2
    c5da:	cmp	r3, #7
    c5dc:	str	r4, [sp, #148]	; 0x94
    c5de:	str	r3, [sp, #144]	; 0x90
    c5e0:	stmia.w	r9, {r1, r2}
    c5e4:	bgt.w	cd2a <_svfprintf_r+0xbca>
    c5e8:	add.w	r9, r9, #8
    c5ec:	ldr	r3, [sp, #48]	; 0x30
    c5ee:	cmp	r3, #128	; 0x80
    c5f0:	beq.w	cbb6 <_svfprintf_r+0xa56>
    c5f4:	ldr	r3, [sp, #36]	; 0x24
    c5f6:	rsb	r7, r3, fp
    c5fa:	cmp	r7, #0
    c5fc:	ble.n	c666 <_svfprintf_r+0x506>
    c5fe:	ldr	r2, [pc, #480]	; (c7e0 <_svfprintf_r+0x680>)
    c600:	ldr	r3, [sp, #144]	; 0x90
    c602:	str	r2, [sp, #44]	; 0x2c
    c604:	cmp	r7, #16
    c606:	ble.n	c64e <_svfprintf_r+0x4ee>
    c608:	mov	r2, r4
    c60a:	mov.w	fp, #16
    c60e:	ldr	r5, [sp, #24]
    c610:	ldr	r4, [sp, #20]
    c612:	b.n	c61e <_svfprintf_r+0x4be>
    c614:	subs	r7, #16
    c616:	cmp	r7, #16
    c618:	add.w	r9, r9, #8
    c61c:	ble.n	c64c <_svfprintf_r+0x4ec>
    c61e:	adds	r3, #1
    c620:	adds	r2, #16
    c622:	cmp	r3, #7
    c624:	str	r2, [sp, #148]	; 0x94
    c626:	str	r3, [sp, #144]	; 0x90
    c628:	stmia.w	r9, {sl, fp}
    c62c:	ble.n	c614 <_svfprintf_r+0x4b4>
    c62e:	add	r2, sp, #140	; 0x8c
    c630:	mov	r1, r4
    c632:	mov	r0, r5
    c634:	bl	f2a4 <__ssprint_r>
    c638:	cmp	r0, #0
    c63a:	bne.w	c354 <_svfprintf_r+0x1f4>
    c63e:	subs	r7, #16
    c640:	cmp	r7, #16
    c642:	ldr	r2, [sp, #148]	; 0x94
    c644:	ldr	r3, [sp, #144]	; 0x90
    c646:	add.w	r9, sp, #192	; 0xc0
    c64a:	bgt.n	c61e <_svfprintf_r+0x4be>
    c64c:	mov	r4, r2
    c64e:	adds	r3, #1
    c650:	ldr	r2, [sp, #44]	; 0x2c
    c652:	str	r3, [sp, #144]	; 0x90
    c654:	add	r4, r7
    c656:	cmp	r3, #7
    c658:	str	r4, [sp, #148]	; 0x94
    c65a:	stmia.w	r9, {r2, r7}
    c65e:	bgt.w	ccfa <_svfprintf_r+0xb9a>
    c662:	add.w	r9, r9, #8
    c666:	ldr	r3, [sp, #12]
    c668:	lsls	r2, r3, #23
    c66a:	bmi.w	cae2 <_svfprintf_r+0x982>
    c66e:	ldr	r3, [sp, #144]	; 0x90
    c670:	ldr	r1, [sp, #36]	; 0x24
    c672:	str.w	r6, [r9]
    c676:	adds	r3, #1
    c678:	add	r4, r1
    c67a:	cmp	r3, #7
    c67c:	str	r4, [sp, #148]	; 0x94
    c67e:	str.w	r1, [r9, #4]
    c682:	str	r3, [sp, #144]	; 0x90
    c684:	bgt.w	ccce <_svfprintf_r+0xb6e>
    c688:	add.w	r9, r9, #8
    c68c:	ldr	r3, [sp, #12]
    c68e:	lsls	r1, r3, #29
    c690:	bpl.n	c712 <_svfprintf_r+0x5b2>
    c692:	ldr	r3, [sp, #32]
    c694:	ldr	r2, [sp, #16]
    c696:	subs	r5, r3, r2
    c698:	cmp	r5, #0
    c69a:	ble.n	c712 <_svfprintf_r+0x5b2>
    c69c:	cmp	r5, #16
    c69e:	ldr	r3, [sp, #144]	; 0x90
    c6a0:	ldr	r7, [pc, #312]	; (c7dc <_svfprintf_r+0x67c>)
    c6a2:	ble.n	c6ec <_svfprintf_r+0x58c>
    c6a4:	mov	r2, r4
    c6a6:	movs	r6, #16
    c6a8:	ldr.w	fp, [sp, #24]
    c6ac:	ldr	r4, [sp, #20]
    c6ae:	b.n	c6ba <_svfprintf_r+0x55a>
    c6b0:	subs	r5, #16
    c6b2:	cmp	r5, #16
    c6b4:	add.w	r9, r9, #8
    c6b8:	ble.n	c6ea <_svfprintf_r+0x58a>
    c6ba:	adds	r3, #1
    c6bc:	ldr	r1, [pc, #284]	; (c7dc <_svfprintf_r+0x67c>)
    c6be:	str	r3, [sp, #144]	; 0x90
    c6c0:	adds	r2, #16
    c6c2:	cmp	r3, #7
    c6c4:	str	r2, [sp, #148]	; 0x94
    c6c6:	stmia.w	r9, {r1, r6}
    c6ca:	ble.n	c6b0 <_svfprintf_r+0x550>
    c6cc:	add	r2, sp, #140	; 0x8c
    c6ce:	mov	r1, r4
    c6d0:	mov	r0, fp
    c6d2:	bl	f2a4 <__ssprint_r>
    c6d6:	cmp	r0, #0
    c6d8:	bne.w	c354 <_svfprintf_r+0x1f4>
    c6dc:	subs	r5, #16
    c6de:	cmp	r5, #16
    c6e0:	ldr	r2, [sp, #148]	; 0x94
    c6e2:	ldr	r3, [sp, #144]	; 0x90
    c6e4:	add.w	r9, sp, #192	; 0xc0
    c6e8:	bgt.n	c6ba <_svfprintf_r+0x55a>
    c6ea:	mov	r4, r2
    c6ec:	adds	r3, #1
    c6ee:	add	r4, r5
    c6f0:	cmp	r3, #7
    c6f2:	str	r4, [sp, #148]	; 0x94
    c6f4:	str	r3, [sp, #144]	; 0x90
    c6f6:	str.w	r7, [r9]
    c6fa:	str.w	r5, [r9, #4]
    c6fe:	ble.n	c712 <_svfprintf_r+0x5b2>
    c700:	add	r2, sp, #140	; 0x8c
    c702:	ldr	r1, [sp, #20]
    c704:	ldr	r0, [sp, #24]
    c706:	bl	f2a4 <__ssprint_r>
    c70a:	cmp	r0, #0
    c70c:	bne.w	c354 <_svfprintf_r+0x1f4>
    c710:	ldr	r4, [sp, #148]	; 0x94
    c712:	ldr	r3, [sp, #28]
    c714:	ldr	r2, [sp, #32]
    c716:	ldr	r1, [sp, #16]
    c718:	cmp	r2, r1
    c71a:	ite	ge
    c71c:	addge	r3, r3, r2
    c71e:	addlt	r3, r3, r1
    c720:	str	r3, [sp, #28]
    c722:	cmp	r4, #0
    c724:	bne.w	cce6 <_svfprintf_r+0xb86>
    c728:	movs	r3, #0
    c72a:	str	r3, [sp, #144]	; 0x90
    c72c:	add.w	r9, sp, #192	; 0xc0
    c730:	b.n	c1ae <_svfprintf_r+0x4e>
    c732:	str	r3, [sp, #52]	; 0x34
    c734:	mov	fp, r5
    c736:	cmp	r2, #0
    c738:	bne.w	d800 <_svfprintf_r+0x16a0>
    c73c:	ldr	r3, [sp, #12]
    c73e:	ldr	r7, [sp, #40]	; 0x28
    c740:	lsls	r2, r3, #28
    c742:	add.w	r7, r7, #7
    c746:	bpl.w	d232 <_svfprintf_r+0x10d2>
    c74a:	bic.w	r3, r7, #7
    c74e:	vldr	d7, [r3]
    c752:	vstr	d7, [sp, #64]	; 0x40
    c756:	add.w	r2, r3, #8
    c75a:	str	r2, [sp, #40]	; 0x28
    c75c:	ldrd	r1, r2, [sp, #64]	; 0x40
    c760:	bic.w	r3, r2, #2147483648	; 0x80000000
    c764:	str	r1, [sp, #88]	; 0x58
    c766:	str	r3, [sp, #92]	; 0x5c
    c768:	ldrd	r4, r5, [sp, #88]	; 0x58
    c76c:	mov.w	r2, #4294967295
    c770:	mov	r0, r4
    c772:	mov	r1, r5
    c774:	ldr	r3, [pc, #108]	; (c7e4 <_svfprintf_r+0x684>)
    c776:	bl	ad14 <__aeabi_dcmpun>
    c77a:	cmp	r0, #0
    c77c:	bne.w	d134 <_svfprintf_r+0xfd4>
    c780:	mov.w	r2, #4294967295
    c784:	ldr	r3, [pc, #92]	; (c7e4 <_svfprintf_r+0x684>)
    c786:	mov	r0, r4
    c788:	mov	r1, r5
    c78a:	bl	acd8 <__aeabi_dcmple>
    c78e:	cmp	r0, #0
    c790:	bne.w	d134 <_svfprintf_r+0xfd4>
    c794:	movs	r2, #0
    c796:	movs	r3, #0
    c798:	ldrd	r0, r1, [sp, #64]	; 0x40
    c79c:	bl	acc4 <__aeabi_dcmplt>
    c7a0:	cmp	r0, #0
    c7a2:	bne.w	d64a <_svfprintf_r+0x14ea>
    c7a6:	ldrb.w	r7, [sp, #111]	; 0x6f
    c7aa:	ldr	r6, [pc, #60]	; (c7e8 <_svfprintf_r+0x688>)
    c7ac:	ldr	r3, [pc, #60]	; (c7ec <_svfprintf_r+0x68c>)
    c7ae:	ldr	r1, [sp, #12]
    c7b0:	bic.w	r1, r1, #128	; 0x80
    c7b4:	str	r1, [sp, #12]
    c7b6:	ldr	r1, [sp, #52]	; 0x34
    c7b8:	movs	r2, #3
    c7ba:	mov.w	fp, #0
    c7be:	str	r2, [sp, #16]
    c7c0:	cmp	r1, #71	; 0x47
    c7c2:	it	le
    c7c4:	movle	r6, r3
    c7c6:	str	r2, [sp, #36]	; 0x24
    c7c8:	str.w	fp, [sp, #60]	; 0x3c
    c7cc:	b.n	c504 <_svfprintf_r+0x3a4>
    c7ce:	ldr	r3, [sp, #12]
    c7d0:	orr.w	r3, r3, #8
    c7d4:	str	r3, [sp, #12]
    c7d6:	ldrb.w	r3, [r8]
    c7da:	b.n	c214 <_svfprintf_r+0xb4>
    c7dc:	.word	0x20000950
    c7e0:	.word	0x20000900
    c7e4:	.word	0x7fefffff
    c7e8:	.word	0x20000914
    c7ec:	.word	0x20000910
    c7f0:	str	r3, [sp, #52]	; 0x34
    c7f2:	mov	fp, r5
    c7f4:	cmp	r2, #0
    c7f6:	bne.w	d818 <_svfprintf_r+0x16b8>
    c7fa:	ldr	r3, [sp, #12]
    c7fc:	orr.w	r3, r3, #16
    c800:	str	r3, [sp, #12]
    c802:	ldr	r2, [sp, #12]
    c804:	ands.w	r3, r2, #32
    c808:	bne.w	c380 <_svfprintf_r+0x220>
    c80c:	ldr	r1, [sp, #12]
    c80e:	ands.w	r2, r1, #16
    c812:	beq.w	d0cc <_svfprintf_r+0xf6c>
    c816:	ldr	r0, [sp, #40]	; 0x28
    c818:	strb.w	r3, [sp, #111]	; 0x6f
    c81c:	cmp.w	fp, #0
    c820:	ldr	r4, [r0, #0]
    c822:	add.w	r7, r0, #4
    c826:	mov.w	r5, #0
    c82a:	blt.w	d260 <_svfprintf_r+0x1100>
    c82e:	mov	r2, r1
    c830:	bic.w	r2, r2, #128	; 0x80
    c834:	str	r2, [sp, #12]
    c836:	orrs.w	r2, r4, r5
    c83a:	str	r7, [sp, #40]	; 0x28
    c83c:	beq.w	cab4 <_svfprintf_r+0x954>
    c840:	mov	r7, r3
    c842:	b.n	c3ac <_svfprintf_r+0x24c>
    c844:	str	r3, [sp, #52]	; 0x34
    c846:	mov	fp, r5
    c848:	cmp	r2, #0
    c84a:	bne.w	d810 <_svfprintf_r+0x16b0>
    c84e:	ldr	r3, [sp, #12]
    c850:	orr.w	r3, r3, #16
    c854:	str	r3, [sp, #12]
    c856:	ldr	r2, [sp, #12]
    c858:	ands.w	r3, r2, #32
    c85c:	beq.w	ceb8 <_svfprintf_r+0xd58>
    c860:	ldr	r7, [sp, #40]	; 0x28
    c862:	adds	r7, #7
    c864:	bic.w	r3, r7, #7
    c868:	movs	r7, #0
    c86a:	add.w	r1, r3, #8
    c86e:	cmp	fp, r7
    c870:	str	r1, [sp, #40]	; 0x28
    c872:	ldrd	r4, r5, [r3]
    c876:	strb.w	r7, [sp, #111]	; 0x6f
    c87a:	blt.w	cf2a <_svfprintf_r+0xdca>
    c87e:	bic.w	r3, r2, #128	; 0x80
    c882:	str	r3, [sp, #12]
    c884:	orrs.w	r3, r4, r5
    c888:	bne.w	c4bc <_svfprintf_r+0x35c>
    c88c:	cmp.w	fp, #0
    c890:	beq.w	ca7e <_svfprintf_r+0x91e>
    c894:	movs	r4, #0
    c896:	add	r6, sp, #256	; 0x100
    c898:	adds	r4, #48	; 0x30
    c89a:	strb.w	r4, [r6, #-65]!
    c89e:	b.n	c4f0 <_svfprintf_r+0x390>
    c8a0:	str	r3, [sp, #52]	; 0x34
    c8a2:	mov	fp, r5
    c8a4:	cmp	r2, #0
    c8a6:	bne.w	d808 <_svfprintf_r+0x16a8>
    c8aa:	ldr	r3, [sp, #12]
    c8ac:	ldr	r0, [pc, #700]	; (cb6c <_svfprintf_r+0xa0c>)
    c8ae:	lsls	r5, r3, #26
    c8b0:	bpl.w	ca1e <_svfprintf_r+0x8be>
    c8b4:	ldr	r7, [sp, #40]	; 0x28
    c8b6:	adds	r7, #7
    c8b8:	bic.w	r3, r7, #7
    c8bc:	ldrd	r4, r5, [r3]
    c8c0:	add.w	r2, r3, #8
    c8c4:	str	r2, [sp, #40]	; 0x28
    c8c6:	ldr	r2, [sp, #12]
    c8c8:	ands.w	r7, r2, #1
    c8cc:	beq.w	cd42 <_svfprintf_r+0xbe2>
    c8d0:	orrs.w	r3, r4, r5
    c8d4:	beq.w	d2dc <_svfprintf_r+0x117c>
    c8d8:	ldrb.w	r2, [sp, #52]	; 0x34
    c8dc:	strb.w	r2, [sp, #113]	; 0x71
    c8e0:	movs	r7, #0
    c8e2:	ldr	r2, [sp, #12]
    c8e4:	strb.w	r7, [sp, #111]	; 0x6f
    c8e8:	movs	r3, #48	; 0x30
    c8ea:	cmp	fp, r7
    c8ec:	strb.w	r3, [sp, #112]	; 0x70
    c8f0:	orr.w	r3, r2, #2
    c8f4:	blt.w	d654 <_svfprintf_r+0x14f4>
    c8f8:	bic.w	r3, r2, #128	; 0x80
    c8fc:	orr.w	r3, r3, #2
    c900:	str	r3, [sp, #12]
    c902:	add	r6, sp, #192	; 0xc0
    c904:	lsrs	r3, r4, #4
    c906:	and.w	r1, r4, #15
    c90a:	orr.w	r3, r3, r5, lsl #28
    c90e:	lsrs	r2, r5, #4
    c910:	mov	r4, r3
    c912:	mov	r5, r2
    c914:	ldrb	r3, [r0, r1]
    c916:	strb.w	r3, [r6, #-1]!
    c91a:	orrs.w	r3, r4, r5
    c91e:	bne.n	c904 <_svfprintf_r+0x7a4>
    c920:	b.n	c4f0 <_svfprintf_r+0x390>
    c922:	ldr	r1, [sp, #40]	; 0x28
    c924:	str	r3, [sp, #52]	; 0x34
    c926:	ldr	r2, [r1, #0]
    c928:	strb.w	r2, [sp, #152]	; 0x98
    c92c:	movs	r3, #0
    c92e:	mov	r2, r1
    c930:	mov	r7, r3
    c932:	strb.w	r3, [sp, #111]	; 0x6f
    c936:	adds	r2, #4
    c938:	movs	r3, #1
    c93a:	str	r3, [sp, #16]
    c93c:	mov	fp, r7
    c93e:	str	r7, [sp, #60]	; 0x3c
    c940:	str	r2, [sp, #40]	; 0x28
    c942:	str	r3, [sp, #36]	; 0x24
    c944:	add	r6, sp, #152	; 0x98
    c946:	b.n	c50c <_svfprintf_r+0x3ac>
    c948:	str	r3, [sp, #52]	; 0x34
    c94a:	mov	fp, r5
    c94c:	cmp	r2, #0
    c94e:	beq.w	c478 <_svfprintf_r+0x318>
    c952:	strb.w	r1, [sp, #111]	; 0x6f
    c956:	b.n	c478 <_svfprintf_r+0x318>
    c958:	ldr	r3, [sp, #12]
    c95a:	orr.w	r3, r3, #64	; 0x40
    c95e:	str	r3, [sp, #12]
    c960:	ldrb.w	r3, [r8]
    c964:	b.n	c214 <_svfprintf_r+0xb4>
    c966:	ldrb.w	r3, [r8]
    c96a:	cmp	r1, #0
    c96c:	bne.w	c214 <_svfprintf_r+0xb4>
    c970:	movs	r2, #1
    c972:	movs	r1, #32
    c974:	b.n	c214 <_svfprintf_r+0xb4>
    c976:	ldr	r3, [sp, #12]
    c978:	orr.w	r3, r3, #1
    c97c:	str	r3, [sp, #12]
    c97e:	ldrb.w	r3, [r8]
    c982:	b.n	c214 <_svfprintf_r+0xb4>
    c984:	ldr	r4, [sp, #40]	; 0x28
    c986:	ldr	r3, [r4, #0]
    c988:	str	r3, [sp, #32]
    c98a:	mov	r0, r3
    c98c:	cmp	r0, #0
    c98e:	mov	r3, r4
    c990:	add.w	r3, r3, #4
    c994:	blt.w	c2d8 <_svfprintf_r+0x178>
    c998:	str	r3, [sp, #40]	; 0x28
    c99a:	ldrb.w	r3, [r8]
    c99e:	b.n	c214 <_svfprintf_r+0xb4>
    c9a0:	ldrb.w	r3, [r8]
    c9a4:	movs	r2, #1
    c9a6:	movs	r1, #43	; 0x2b
    c9a8:	b.n	c214 <_svfprintf_r+0xb4>
    c9aa:	ldr	r3, [sp, #12]
    c9ac:	orr.w	r3, r3, #32
    c9b0:	str	r3, [sp, #12]
    c9b2:	ldrb.w	r3, [r8]
    c9b6:	b.n	c214 <_svfprintf_r+0xb4>
    c9b8:	ldr	r2, [sp, #40]	; 0x28
    c9ba:	str	r3, [sp, #52]	; 0x34
    c9bc:	ldr	r6, [r2, #0]
    c9be:	movs	r4, #0
    c9c0:	strb.w	r4, [sp, #111]	; 0x6f
    c9c4:	adds	r7, r2, #4
    c9c6:	cmp	r6, #0
    c9c8:	beq.w	d604 <_svfprintf_r+0x14a4>
    c9cc:	cmp	r5, #0
    c9ce:	blt.w	d494 <_svfprintf_r+0x1334>
    c9d2:	mov	r2, r5
    c9d4:	mov	r1, r4
    c9d6:	mov	r0, r6
    c9d8:	bl	ebe0 <memchr>
    c9dc:	cmp	r0, #0
    c9de:	beq.w	d6a8 <_svfprintf_r+0x1548>
    c9e2:	subs	r3, r0, r6
    c9e4:	str	r3, [sp, #36]	; 0x24
    c9e6:	mov	fp, r4
    c9e8:	bic.w	r3, r3, r3, asr #31
    c9ec:	str	r7, [sp, #40]	; 0x28
    c9ee:	str	r3, [sp, #16]
    c9f0:	str.w	fp, [sp, #60]	; 0x3c
    c9f4:	ldrb.w	r7, [sp, #111]	; 0x6f
    c9f8:	b.n	c504 <_svfprintf_r+0x3a4>
    c9fa:	str	r3, [sp, #52]	; 0x34
    c9fc:	mov	fp, r5
    c9fe:	cmp	r2, #0
    ca00:	beq.w	c856 <_svfprintf_r+0x6f6>
    ca04:	strb.w	r1, [sp, #111]	; 0x6f
    ca08:	b.n	c856 <_svfprintf_r+0x6f6>
    ca0a:	str	r3, [sp, #52]	; 0x34
    ca0c:	mov	fp, r5
    ca0e:	cmp	r2, #0
    ca10:	bne.w	d830 <_svfprintf_r+0x16d0>
    ca14:	ldr	r3, [sp, #12]
    ca16:	ldr	r0, [pc, #344]	; (cb70 <_svfprintf_r+0xa10>)
    ca18:	lsls	r5, r3, #26
    ca1a:	bmi.w	c8b4 <_svfprintf_r+0x754>
    ca1e:	ldr	r3, [sp, #12]
    ca20:	lsls	r4, r3, #27
    ca22:	bpl.w	d2a2 <_svfprintf_r+0x1142>
    ca26:	ldr	r2, [sp, #40]	; 0x28
    ca28:	mov	r3, r2
    ca2a:	adds	r3, #4
    ca2c:	ldr	r4, [r2, #0]
    ca2e:	str	r3, [sp, #40]	; 0x28
    ca30:	movs	r5, #0
    ca32:	b.n	c8c6 <_svfprintf_r+0x766>
    ca34:	ldrb.w	r3, [r8]
    ca38:	cmp	r3, #108	; 0x6c
    ca3a:	beq.w	d3c2 <_svfprintf_r+0x1262>
    ca3e:	ldr	r0, [sp, #12]
    ca40:	orr.w	r0, r0, #16
    ca44:	str	r0, [sp, #12]
    ca46:	b.w	c214 <_svfprintf_r+0xb4>
    ca4a:	cmp	r2, #0
    ca4c:	bne.w	d828 <_svfprintf_r+0x16c8>
    ca50:	ldr	r3, [sp, #12]
    ca52:	lsls	r3, r3, #26
    ca54:	bpl.w	d106 <_svfprintf_r+0xfa6>
    ca58:	ldr	r2, [sp, #40]	; 0x28
    ca5a:	ldr	r1, [sp, #28]
    ca5c:	ldr	r3, [r2, #0]
    ca5e:	asrs	r5, r1, #31
    ca60:	mov	r0, r1
    ca62:	adds	r2, #4
    ca64:	mov	r1, r5
    ca66:	str	r2, [sp, #40]	; 0x28
    ca68:	strd	r0, r1, [r3]
    ca6c:	b.w	c1ae <_svfprintf_r+0x4e>
    ca70:	ldr	r0, [pc, #252]	; (cb70 <_svfprintf_r+0xa10>)
    ca72:	str	r2, [sp, #52]	; 0x34
    ca74:	cmp.w	fp, #0
    ca78:	bne.w	cd64 <_svfprintf_r+0xc04>
    ca7c:	mov	r7, fp
    ca7e:	mov.w	fp, #0
    ca82:	str.w	fp, [sp, #36]	; 0x24
    ca86:	add	r6, sp, #192	; 0xc0
    ca88:	b.n	c4f6 <_svfprintf_r+0x396>
    ca8a:	str	r3, [sp, #52]	; 0x34
    ca8c:	cmp	r2, #0
    ca8e:	bne.w	d820 <_svfprintf_r+0x16c0>
    ca92:	ldr	r2, [sp, #52]	; 0x34
    ca94:	cmp	r2, #0
    ca96:	beq.w	c346 <_svfprintf_r+0x1e6>
    ca9a:	movs	r3, #0
    ca9c:	movs	r1, #1
    ca9e:	mov	r7, r3
    caa0:	str	r1, [sp, #16]
    caa2:	strb.w	r2, [sp, #152]	; 0x98
    caa6:	strb.w	r3, [sp, #111]	; 0x6f
    caaa:	mov	fp, r3
    caac:	str	r3, [sp, #60]	; 0x3c
    caae:	str	r1, [sp, #36]	; 0x24
    cab0:	add	r6, sp, #152	; 0x98
    cab2:	b.n	c50c <_svfprintf_r+0x3ac>
    cab4:	cmp.w	fp, #0
    cab8:	beq.w	d6d8 <_svfprintf_r+0x1578>
    cabc:	movs	r7, #0
    cabe:	movs	r4, #0
    cac0:	movs	r5, #0
    cac2:	b.n	c3ac <_svfprintf_r+0x24c>
    cac4:	ldr	r0, [pc, #168]	; (cb70 <_svfprintf_r+0xa10>)
    cac6:	str	r3, [sp, #12]
    cac8:	str	r2, [sp, #52]	; 0x34
    caca:	orrs.w	r3, r4, r5
    cace:	str	r7, [sp, #40]	; 0x28
    cad0:	mov.w	r7, #0
    cad4:	bne.w	c902 <_svfprintf_r+0x7a2>
    cad8:	movs	r4, #0
    cada:	movs	r5, #0
    cadc:	b.n	c902 <_svfprintf_r+0x7a2>
    cade:	ldr	r4, [sp, #148]	; 0x94
    cae0:	b.n	c5ac <_svfprintf_r+0x44c>
    cae2:	ldr	r3, [sp, #52]	; 0x34
    cae4:	cmp	r3, #101	; 0x65
    cae6:	ble.w	cc3e <_svfprintf_r+0xade>
    caea:	movs	r2, #0
    caec:	movs	r3, #0
    caee:	ldrd	r0, r1, [sp, #64]	; 0x40
    caf2:	bl	acb0 <__aeabi_dcmpeq>
    caf6:	cmp	r0, #0
    caf8:	beq.w	cd68 <_svfprintf_r+0xc08>
    cafc:	ldr	r3, [sp, #144]	; 0x90
    cafe:	ldr	r2, [pc, #116]	; (cb74 <_svfprintf_r+0xa14>)
    cb00:	str.w	r2, [r9]
    cb04:	adds	r3, #1
    cb06:	adds	r4, #1
    cb08:	movs	r2, #1
    cb0a:	cmp	r3, #7
    cb0c:	str	r4, [sp, #148]	; 0x94
    cb0e:	str	r3, [sp, #144]	; 0x90
    cb10:	str.w	r2, [r9, #4]
    cb14:	bgt.w	d2f4 <_svfprintf_r+0x1194>
    cb18:	add.w	r9, r9, #8
    cb1c:	ldr	r3, [sp, #116]	; 0x74
    cb1e:	ldr	r2, [sp, #56]	; 0x38
    cb20:	cmp	r3, r2
    cb22:	blt.n	cb2c <_svfprintf_r+0x9cc>
    cb24:	ldr	r3, [sp, #12]
    cb26:	lsls	r3, r3, #31
    cb28:	bpl.w	c68c <_svfprintf_r+0x52c>
    cb2c:	ldr	r3, [sp, #144]	; 0x90
    cb2e:	ldr	r1, [sp, #72]	; 0x48
    cb30:	ldr	r2, [sp, #76]	; 0x4c
    cb32:	str.w	r2, [r9]
    cb36:	adds	r3, #1
    cb38:	add	r4, r1
    cb3a:	cmp	r3, #7
    cb3c:	str	r4, [sp, #148]	; 0x94
    cb3e:	str.w	r1, [r9, #4]
    cb42:	str	r3, [sp, #144]	; 0x90
    cb44:	bgt.w	d3d6 <_svfprintf_r+0x1276>
    cb48:	add.w	r9, r9, #8
    cb4c:	ldr	r3, [sp, #56]	; 0x38
    cb4e:	subs	r5, r3, #1
    cb50:	cmp	r5, #0
    cb52:	ble.w	c68c <_svfprintf_r+0x52c>
    cb56:	ldr	r2, [pc, #32]	; (cb78 <_svfprintf_r+0xa18>)
    cb58:	ldr	r3, [sp, #144]	; 0x90
    cb5a:	str	r2, [sp, #44]	; 0x2c
    cb5c:	cmp	r5, #16
    cb5e:	ble.w	cf34 <_svfprintf_r+0xdd4>
    cb62:	movs	r6, #16
    cb64:	ldr	r7, [sp, #24]
    cb66:	ldr.w	fp, [sp, #20]
    cb6a:	b.n	cb88 <_svfprintf_r+0xa28>
    cb6c:	.word	0x20000920
    cb70:	.word	0x20000934
    cb74:	.word	0x200004d8
    cb78:	.word	0x20000900
    cb7c:	add.w	r9, r9, #8
    cb80:	subs	r5, #16
    cb82:	cmp	r5, #16
    cb84:	ble.w	cf34 <_svfprintf_r+0xdd4>
    cb88:	adds	r3, #1
    cb8a:	adds	r4, #16
    cb8c:	cmp	r3, #7
    cb8e:	str	r4, [sp, #148]	; 0x94
    cb90:	str	r3, [sp, #144]	; 0x90
    cb92:	str.w	sl, [r9]
    cb96:	str.w	r6, [r9, #4]
    cb9a:	ble.n	cb7c <_svfprintf_r+0xa1c>
    cb9c:	add	r2, sp, #140	; 0x8c
    cb9e:	mov	r1, fp
    cba0:	mov	r0, r7
    cba2:	bl	f2a4 <__ssprint_r>
    cba6:	cmp	r0, #0
    cba8:	bne.w	c354 <_svfprintf_r+0x1f4>
    cbac:	ldr	r4, [sp, #148]	; 0x94
    cbae:	ldr	r3, [sp, #144]	; 0x90
    cbb0:	add.w	r9, sp, #192	; 0xc0
    cbb4:	b.n	cb80 <_svfprintf_r+0xa20>
    cbb6:	ldr	r3, [sp, #32]
    cbb8:	ldr	r2, [sp, #16]
    cbba:	subs	r7, r3, r2
    cbbc:	cmp	r7, #0
    cbbe:	ble.w	c5f4 <_svfprintf_r+0x494>
    cbc2:	ldr	r2, [pc, #752]	; (ceb4 <_svfprintf_r+0xd54>)
    cbc4:	ldr	r3, [sp, #144]	; 0x90
    cbc6:	str	r2, [sp, #44]	; 0x2c
    cbc8:	cmp	r7, #16
    cbca:	ble.n	cc24 <_svfprintf_r+0xac4>
    cbcc:	mov	r2, r9
    cbce:	mov	r1, r4
    cbd0:	mov	r9, r7
    cbd2:	movs	r5, #16
    cbd4:	mov	r7, r6
    cbd6:	ldr	r4, [sp, #24]
    cbd8:	ldr	r6, [sp, #20]
    cbda:	b.n	cbea <_svfprintf_r+0xa8a>
    cbdc:	sub.w	r9, r9, #16
    cbe0:	cmp.w	r9, #16
    cbe4:	add.w	r2, r2, #8
    cbe8:	ble.n	cc1c <_svfprintf_r+0xabc>
    cbea:	adds	r3, #1
    cbec:	adds	r1, #16
    cbee:	cmp	r3, #7
    cbf0:	str	r1, [sp, #148]	; 0x94
    cbf2:	str	r3, [sp, #144]	; 0x90
    cbf4:	str.w	sl, [r2]
    cbf8:	str	r5, [r2, #4]
    cbfa:	ble.n	cbdc <_svfprintf_r+0xa7c>
    cbfc:	add	r2, sp, #140	; 0x8c
    cbfe:	mov	r1, r6
    cc00:	mov	r0, r4
    cc02:	bl	f2a4 <__ssprint_r>
    cc06:	cmp	r0, #0
    cc08:	bne.w	c354 <_svfprintf_r+0x1f4>
    cc0c:	sub.w	r9, r9, #16
    cc10:	cmp.w	r9, #16
    cc14:	ldr	r1, [sp, #148]	; 0x94
    cc16:	ldr	r3, [sp, #144]	; 0x90
    cc18:	add	r2, sp, #192	; 0xc0
    cc1a:	bgt.n	cbea <_svfprintf_r+0xa8a>
    cc1c:	mov	r6, r7
    cc1e:	mov	r4, r1
    cc20:	mov	r7, r9
    cc22:	mov	r9, r2
    cc24:	adds	r3, #1
    cc26:	ldr	r2, [sp, #44]	; 0x2c
    cc28:	str	r3, [sp, #144]	; 0x90
    cc2a:	add	r4, r7
    cc2c:	cmp	r3, #7
    cc2e:	str	r4, [sp, #148]	; 0x94
    cc30:	stmia.w	r9, {r2, r7}
    cc34:	bgt.w	d0b2 <_svfprintf_r+0xf52>
    cc38:	add.w	r9, r9, #8
    cc3c:	b.n	c5f4 <_svfprintf_r+0x494>
    cc3e:	ldr	r3, [sp, #56]	; 0x38
    cc40:	ldr	r5, [sp, #144]	; 0x90
    cc42:	cmp	r3, #1
    cc44:	ble.w	d05c <_svfprintf_r+0xefc>
    cc48:	adds	r5, #1
    cc4a:	adds	r4, #1
    cc4c:	movs	r3, #1
    cc4e:	cmp	r5, #7
    cc50:	str	r4, [sp, #148]	; 0x94
    cc52:	str	r5, [sp, #144]	; 0x90
    cc54:	str.w	r6, [r9]
    cc58:	str.w	r3, [r9, #4]
    cc5c:	bgt.w	d07e <_svfprintf_r+0xf1e>
    cc60:	add.w	r9, r9, #8
    cc64:	ldr	r2, [sp, #72]	; 0x48
    cc66:	ldr	r3, [sp, #76]	; 0x4c
    cc68:	str.w	r3, [r9]
    cc6c:	adds	r5, #1
    cc6e:	add	r4, r2
    cc70:	cmp	r5, #7
    cc72:	str	r4, [sp, #148]	; 0x94
    cc74:	str	r5, [sp, #144]	; 0x90
    cc76:	str.w	r2, [r9, #4]
    cc7a:	bgt.w	d098 <_svfprintf_r+0xf38>
    cc7e:	add.w	r9, r9, #8
    cc82:	movs	r3, #0
    cc84:	movs	r2, #0
    cc86:	ldrd	r0, r1, [sp, #64]	; 0x40
    cc8a:	bl	acb0 <__aeabi_dcmpeq>
    cc8e:	ldr	r3, [sp, #56]	; 0x38
    cc90:	cmp	r0, #0
    cc92:	bne.w	ce1c <_svfprintf_r+0xcbc>
    cc96:	subs	r3, #1
    cc98:	adds	r5, #1
    cc9a:	adds	r6, #1
    cc9c:	add	r4, r3
    cc9e:	cmp	r5, #7
    cca0:	str	r5, [sp, #144]	; 0x90
    cca2:	str	r4, [sp, #148]	; 0x94
    cca4:	str.w	r6, [r9]
    cca8:	str.w	r3, [r9, #4]
    ccac:	bgt.w	ce9a <_svfprintf_r+0xd3a>
    ccb0:	add.w	r9, r9, #8
    ccb4:	ldr	r2, [sp, #84]	; 0x54
    ccb6:	str.w	r2, [r9, #4]
    ccba:	adds	r5, #1
    ccbc:	add	r4, r2
    ccbe:	add	r3, sp, #124	; 0x7c
    ccc0:	cmp	r5, #7
    ccc2:	str	r4, [sp, #148]	; 0x94
    ccc4:	str	r5, [sp, #144]	; 0x90
    ccc6:	str.w	r3, [r9]
    ccca:	ble.w	c688 <_svfprintf_r+0x528>
    ccce:	add	r2, sp, #140	; 0x8c
    ccd0:	ldr	r1, [sp, #20]
    ccd2:	ldr	r0, [sp, #24]
    ccd4:	bl	f2a4 <__ssprint_r>
    ccd8:	cmp	r0, #0
    ccda:	bne.w	c354 <_svfprintf_r+0x1f4>
    ccde:	ldr	r4, [sp, #148]	; 0x94
    cce0:	add.w	r9, sp, #192	; 0xc0
    cce4:	b.n	c68c <_svfprintf_r+0x52c>
    cce6:	add	r2, sp, #140	; 0x8c
    cce8:	ldr	r1, [sp, #20]
    ccea:	ldr	r0, [sp, #24]
    ccec:	bl	f2a4 <__ssprint_r>
    ccf0:	cmp	r0, #0
    ccf2:	beq.w	c728 <_svfprintf_r+0x5c8>
    ccf6:	b.w	c354 <_svfprintf_r+0x1f4>
    ccfa:	add	r2, sp, #140	; 0x8c
    ccfc:	ldr	r1, [sp, #20]
    ccfe:	ldr	r0, [sp, #24]
    cd00:	bl	f2a4 <__ssprint_r>
    cd04:	cmp	r0, #0
    cd06:	bne.w	c354 <_svfprintf_r+0x1f4>
    cd0a:	ldr	r4, [sp, #148]	; 0x94
    cd0c:	add.w	r9, sp, #192	; 0xc0
    cd10:	b.n	c666 <_svfprintf_r+0x506>
    cd12:	add	r2, sp, #140	; 0x8c
    cd14:	ldr	r1, [sp, #20]
    cd16:	ldr	r0, [sp, #24]
    cd18:	bl	f2a4 <__ssprint_r>
    cd1c:	cmp	r0, #0
    cd1e:	bne.w	c354 <_svfprintf_r+0x1f4>
    cd22:	ldr	r4, [sp, #148]	; 0x94
    cd24:	add.w	r9, sp, #192	; 0xc0
    cd28:	b.n	c5cc <_svfprintf_r+0x46c>
    cd2a:	add	r2, sp, #140	; 0x8c
    cd2c:	ldr	r1, [sp, #20]
    cd2e:	ldr	r0, [sp, #24]
    cd30:	bl	f2a4 <__ssprint_r>
    cd34:	cmp	r0, #0
    cd36:	bne.w	c354 <_svfprintf_r+0x1f4>
    cd3a:	ldr	r4, [sp, #148]	; 0x94
    cd3c:	add.w	r9, sp, #192	; 0xc0
    cd40:	b.n	c5ec <_svfprintf_r+0x48c>
    cd42:	cmp.w	fp, #0
    cd46:	strb.w	r7, [sp, #111]	; 0x6f
    cd4a:	blt.w	d30c <_svfprintf_r+0x11ac>
    cd4e:	bic.w	r3, r2, #128	; 0x80
    cd52:	str	r3, [sp, #12]
    cd54:	orrs.w	r3, r4, r5
    cd58:	bne.w	c902 <_svfprintf_r+0x7a2>
    cd5c:	cmp.w	fp, #0
    cd60:	beq.w	ca7c <_svfprintf_r+0x91c>
    cd64:	movs	r7, #0
    cd66:	b.n	cad8 <_svfprintf_r+0x978>
    cd68:	ldr	r5, [sp, #116]	; 0x74
    cd6a:	cmp	r5, #0
    cd6c:	ble.w	d312 <_svfprintf_r+0x11b2>
    cd70:	ldr	r3, [sp, #60]	; 0x3c
    cd72:	ldr	r2, [sp, #56]	; 0x38
    cd74:	cmp	r3, r2
    cd76:	it	ge
    cd78:	movge	r3, r2
    cd7a:	cmp	r3, #0
    cd7c:	mov	r5, r3
    cd7e:	ble.n	cd9c <_svfprintf_r+0xc3c>
    cd80:	ldr	r3, [sp, #144]	; 0x90
    cd82:	str.w	r6, [r9]
    cd86:	adds	r3, #1
    cd88:	add	r4, r5
    cd8a:	cmp	r3, #7
    cd8c:	str	r4, [sp, #148]	; 0x94
    cd8e:	str.w	r5, [r9, #4]
    cd92:	str	r3, [sp, #144]	; 0x90
    cd94:	bgt.w	d4ea <_svfprintf_r+0x138a>
    cd98:	add.w	r9, r9, #8
    cd9c:	ldr	r3, [sp, #60]	; 0x3c
    cd9e:	cmp	r5, #0
    cda0:	it	ge
    cda2:	subge	r3, r3, r5
    cda4:	cmp	r3, #0
    cda6:	mov	r5, r3
    cda8:	ble.w	cf9c <_svfprintf_r+0xe3c>
    cdac:	ldr	r2, [pc, #260]	; (ceb4 <_svfprintf_r+0xd54>)
    cdae:	ldr	r3, [sp, #144]	; 0x90
    cdb0:	str	r2, [sp, #44]	; 0x2c
    cdb2:	cmp	r5, #16
    cdb4:	ble.w	d2be <_svfprintf_r+0x115e>
    cdb8:	mov	r2, r4
    cdba:	movs	r7, #16
    cdbc:	ldr.w	fp, [sp, #24]
    cdc0:	ldr	r4, [sp, #20]
    cdc2:	b.n	cdd0 <_svfprintf_r+0xc70>
    cdc4:	add.w	r9, r9, #8
    cdc8:	subs	r5, #16
    cdca:	cmp	r5, #16
    cdcc:	ble.w	d2bc <_svfprintf_r+0x115c>
    cdd0:	adds	r3, #1
    cdd2:	adds	r2, #16
    cdd4:	cmp	r3, #7
    cdd6:	str	r2, [sp, #148]	; 0x94
    cdd8:	str	r3, [sp, #144]	; 0x90
    cdda:	str.w	sl, [r9]
    cdde:	str.w	r7, [r9, #4]
    cde2:	ble.n	cdc4 <_svfprintf_r+0xc64>
    cde4:	add	r2, sp, #140	; 0x8c
    cde6:	mov	r1, r4
    cde8:	mov	r0, fp
    cdea:	bl	f2a4 <__ssprint_r>
    cdee:	cmp	r0, #0
    cdf0:	bne.w	c354 <_svfprintf_r+0x1f4>
    cdf4:	ldr	r2, [sp, #148]	; 0x94
    cdf6:	ldr	r3, [sp, #144]	; 0x90
    cdf8:	add.w	r9, sp, #192	; 0xc0
    cdfc:	b.n	cdc8 <_svfprintf_r+0xc68>
    cdfe:	add	r2, sp, #140	; 0x8c
    ce00:	ldr	r1, [sp, #20]
    ce02:	ldr	r0, [sp, #24]
    ce04:	bl	f2a4 <__ssprint_r>
    ce08:	cmp	r0, #0
    ce0a:	bne.w	c354 <_svfprintf_r+0x1f4>
    ce0e:	ldrb.w	r7, [sp, #111]	; 0x6f
    ce12:	ldr	r4, [sp, #148]	; 0x94
    ce14:	add.w	r9, sp, #192	; 0xc0
    ce18:	b.w	c5ac <_svfprintf_r+0x44c>
    ce1c:	subs	r6, r3, #1
    ce1e:	cmp	r6, #0
    ce20:	ble.w	ccb4 <_svfprintf_r+0xb54>
    ce24:	ldr	r3, [pc, #140]	; (ceb4 <_svfprintf_r+0xd54>)
    ce26:	str	r3, [sp, #44]	; 0x2c
    ce28:	cmp	r6, #16
    ce2a:	ble.n	ce86 <_svfprintf_r+0xd26>
    ce2c:	str.w	r8, [sp, #36]	; 0x24
    ce30:	movs	r7, #16
    ce32:	mov	r8, r6
    ce34:	ldr.w	fp, [sp, #24]
    ce38:	ldr	r6, [sp, #20]
    ce3a:	b.n	ce4a <_svfprintf_r+0xcea>
    ce3c:	sub.w	r8, r8, #16
    ce40:	cmp.w	r8, #16
    ce44:	add.w	r9, r9, #8
    ce48:	ble.n	ce80 <_svfprintf_r+0xd20>
    ce4a:	adds	r5, #1
    ce4c:	adds	r4, #16
    ce4e:	cmp	r5, #7
    ce50:	str	r4, [sp, #148]	; 0x94
    ce52:	str	r5, [sp, #144]	; 0x90
    ce54:	str.w	sl, [r9]
    ce58:	str.w	r7, [r9, #4]
    ce5c:	ble.n	ce3c <_svfprintf_r+0xcdc>
    ce5e:	add	r2, sp, #140	; 0x8c
    ce60:	mov	r1, r6
    ce62:	mov	r0, fp
    ce64:	bl	f2a4 <__ssprint_r>
    ce68:	cmp	r0, #0
    ce6a:	bne.w	c354 <_svfprintf_r+0x1f4>
    ce6e:	sub.w	r8, r8, #16
    ce72:	cmp.w	r8, #16
    ce76:	ldr	r4, [sp, #148]	; 0x94
    ce78:	ldr	r5, [sp, #144]	; 0x90
    ce7a:	add.w	r9, sp, #192	; 0xc0
    ce7e:	bgt.n	ce4a <_svfprintf_r+0xcea>
    ce80:	mov	r6, r8
    ce82:	ldr.w	r8, [sp, #36]	; 0x24
    ce86:	ldr	r3, [sp, #44]	; 0x2c
    ce88:	adds	r5, #1
    ce8a:	add	r4, r6
    ce8c:	cmp	r5, #7
    ce8e:	str	r4, [sp, #148]	; 0x94
    ce90:	str	r5, [sp, #144]	; 0x90
    ce92:	stmia.w	r9, {r3, r6}
    ce96:	ble.w	ccb0 <_svfprintf_r+0xb50>
    ce9a:	add	r2, sp, #140	; 0x8c
    ce9c:	ldr	r1, [sp, #20]
    ce9e:	ldr	r0, [sp, #24]
    cea0:	bl	f2a4 <__ssprint_r>
    cea4:	cmp	r0, #0
    cea6:	bne.w	c354 <_svfprintf_r+0x1f4>
    ceaa:	ldr	r4, [sp, #148]	; 0x94
    ceac:	ldr	r5, [sp, #144]	; 0x90
    ceae:	add.w	r9, sp, #192	; 0xc0
    ceb2:	b.n	ccb4 <_svfprintf_r+0xb54>
    ceb4:	.word	0x20000900
    ceb8:	ldr	r1, [sp, #12]
    ceba:	ands.w	r2, r1, #16
    cebe:	beq.w	d268 <_svfprintf_r+0x1108>
    cec2:	ldr	r0, [sp, #40]	; 0x28
    cec4:	strb.w	r3, [sp, #111]	; 0x6f
    cec8:	cmp.w	fp, #0
    cecc:	ldr	r4, [r0, #0]
    cece:	add.w	r7, r0, #4
    ced2:	mov.w	r5, #0
    ced6:	blt.n	cf26 <_svfprintf_r+0xdc6>
    ced8:	mov	r2, r1
    ceda:	bic.w	r2, r2, #128	; 0x80
    cede:	str	r2, [sp, #12]
    cee0:	orrs.w	r2, r4, r5
    cee4:	str	r7, [sp, #40]	; 0x28
    cee6:	mov	r7, r3
    cee8:	bne.w	c4bc <_svfprintf_r+0x35c>
    ceec:	b.n	c88c <_svfprintf_r+0x72c>
    ceee:	ldr	r3, [sp, #12]
    cef0:	lsls	r0, r3, #27
    cef2:	bmi.n	cf4a <_svfprintf_r+0xdea>
    cef4:	ldr	r3, [sp, #12]
    cef6:	lsls	r1, r3, #25
    cef8:	bpl.n	cf4a <_svfprintf_r+0xdea>
    cefa:	ldr	r1, [sp, #40]	; 0x28
    cefc:	ldrsh.w	r4, [r1]
    cf00:	adds	r1, #4
    cf02:	asrs	r5, r4, #31
    cf04:	mov	r2, r4
    cf06:	mov	r3, r5
    cf08:	str	r1, [sp, #40]	; 0x28
    cf0a:	b.w	c496 <_svfprintf_r+0x336>
    cf0e:	ldr	r1, [sp, #40]	; 0x28
    cf10:	strb.w	r3, [sp, #111]	; 0x6f
    cf14:	cmp.w	fp, #0
    cf18:	ldr	r4, [r1, #0]
    cf1a:	add.w	r7, r1, #4
    cf1e:	mov.w	r5, #0
    cf22:	bge.w	d3be <_svfprintf_r+0x125e>
    cf26:	str	r7, [sp, #40]	; 0x28
    cf28:	mov	r7, r3
    cf2a:	orrs.w	r3, r4, r5
    cf2e:	bne.w	c4bc <_svfprintf_r+0x35c>
    cf32:	b.n	c896 <_svfprintf_r+0x736>
    cf34:	adds	r3, #1
    cf36:	ldr	r2, [sp, #44]	; 0x2c
    cf38:	str	r3, [sp, #144]	; 0x90
    cf3a:	add	r4, r5
    cf3c:	cmp	r3, #7
    cf3e:	str	r4, [sp, #148]	; 0x94
    cf40:	stmia.w	r9, {r2, r5}
    cf44:	ble.w	c688 <_svfprintf_r+0x528>
    cf48:	b.n	ccce <_svfprintf_r+0xb6e>
    cf4a:	ldr	r2, [sp, #40]	; 0x28
    cf4c:	ldr	r4, [r2, #0]
    cf4e:	mov	r3, r2
    cf50:	adds	r3, #4
    cf52:	asrs	r5, r4, #31
    cf54:	mov	r2, r4
    cf56:	str	r3, [sp, #40]	; 0x28
    cf58:	cmp	r2, #0
    cf5a:	mov	r3, r5
    cf5c:	sbcs.w	r3, r3, #0
    cf60:	bge.w	c4a0 <_svfprintf_r+0x340>
    cf64:	negs	r4, r4
    cf66:	mov.w	r7, #45	; 0x2d
    cf6a:	sbc.w	r5, r5, r5, lsl #1
    cf6e:	cmp.w	fp, #0
    cf72:	strb.w	r7, [sp, #111]	; 0x6f
    cf76:	blt.w	c4bc <_svfprintf_r+0x35c>
    cf7a:	ldr	r3, [sp, #12]
    cf7c:	bic.w	r3, r3, #128	; 0x80
    cf80:	str	r3, [sp, #12]
    cf82:	b.w	c4bc <_svfprintf_r+0x35c>
    cf86:	add	r2, sp, #140	; 0x8c
    cf88:	ldr	r1, [sp, #20]
    cf8a:	ldr	r0, [sp, #24]
    cf8c:	bl	f2a4 <__ssprint_r>
    cf90:	cmp	r0, #0
    cf92:	bne.w	c354 <_svfprintf_r+0x1f4>
    cf96:	ldr	r4, [sp, #148]	; 0x94
    cf98:	add.w	r9, sp, #192	; 0xc0
    cf9c:	ldr	r2, [sp, #60]	; 0x3c
    cf9e:	ldr	r3, [sp, #116]	; 0x74
    cfa0:	add	r2, r6
    cfa2:	mov	r7, r2
    cfa4:	ldr	r2, [sp, #56]	; 0x38
    cfa6:	cmp	r3, r2
    cfa8:	blt.n	d03a <_svfprintf_r+0xeda>
    cfaa:	ldr	r2, [sp, #12]
    cfac:	lsls	r5, r2, #31
    cfae:	bmi.n	d03a <_svfprintf_r+0xeda>
    cfb0:	ldr	r1, [sp, #56]	; 0x38
    cfb2:	add	r6, r1
    cfb4:	subs	r5, r6, r7
    cfb6:	subs	r3, r1, r3
    cfb8:	cmp	r5, r3
    cfba:	it	ge
    cfbc:	movge	r5, r3
    cfbe:	cmp	r5, #0
    cfc0:	mov	r6, r5
    cfc2:	ble.n	cfe0 <_svfprintf_r+0xe80>
    cfc4:	ldr	r2, [sp, #144]	; 0x90
    cfc6:	str.w	r7, [r9]
    cfca:	adds	r2, #1
    cfcc:	add	r4, r5
    cfce:	cmp	r2, #7
    cfd0:	str	r4, [sp, #148]	; 0x94
    cfd2:	str.w	r5, [r9, #4]
    cfd6:	str	r2, [sp, #144]	; 0x90
    cfd8:	bgt.w	d5d8 <_svfprintf_r+0x1478>
    cfdc:	add.w	r9, r9, #8
    cfe0:	cmp	r6, #0
    cfe2:	ite	ge
    cfe4:	subge	r5, r3, r6
    cfe6:	movlt	r5, r3
    cfe8:	cmp	r5, #0
    cfea:	ble.w	c68c <_svfprintf_r+0x52c>
    cfee:	ldr	r2, [pc, #744]	; (d2d8 <_svfprintf_r+0x1178>)
    cff0:	ldr	r3, [sp, #144]	; 0x90
    cff2:	str	r2, [sp, #44]	; 0x2c
    cff4:	cmp	r5, #16
    cff6:	ble.n	cf34 <_svfprintf_r+0xdd4>
    cff8:	movs	r6, #16
    cffa:	ldr	r7, [sp, #24]
    cffc:	ldr.w	fp, [sp, #20]
    d000:	b.n	d00c <_svfprintf_r+0xeac>
    d002:	add.w	r9, r9, #8
    d006:	subs	r5, #16
    d008:	cmp	r5, #16
    d00a:	ble.n	cf34 <_svfprintf_r+0xdd4>
    d00c:	adds	r3, #1
    d00e:	adds	r4, #16
    d010:	cmp	r3, #7
    d012:	str	r4, [sp, #148]	; 0x94
    d014:	str	r3, [sp, #144]	; 0x90
    d016:	str.w	sl, [r9]
    d01a:	str.w	r6, [r9, #4]
    d01e:	ble.n	d002 <_svfprintf_r+0xea2>
    d020:	add	r2, sp, #140	; 0x8c
    d022:	mov	r1, fp
    d024:	mov	r0, r7
    d026:	bl	f2a4 <__ssprint_r>
    d02a:	cmp	r0, #0
    d02c:	bne.w	c354 <_svfprintf_r+0x1f4>
    d030:	ldr	r4, [sp, #148]	; 0x94
    d032:	ldr	r3, [sp, #144]	; 0x90
    d034:	add.w	r9, sp, #192	; 0xc0
    d038:	b.n	d006 <_svfprintf_r+0xea6>
    d03a:	ldr	r2, [sp, #144]	; 0x90
    d03c:	ldr	r0, [sp, #72]	; 0x48
    d03e:	ldr	r1, [sp, #76]	; 0x4c
    d040:	str.w	r1, [r9]
    d044:	adds	r2, #1
    d046:	add	r4, r0
    d048:	cmp	r2, #7
    d04a:	str	r4, [sp, #148]	; 0x94
    d04c:	str.w	r0, [r9, #4]
    d050:	str	r2, [sp, #144]	; 0x90
    d052:	bgt.w	d5be <_svfprintf_r+0x145e>
    d056:	add.w	r9, r9, #8
    d05a:	b.n	cfb0 <_svfprintf_r+0xe50>
    d05c:	ldr	r3, [sp, #12]
    d05e:	lsls	r0, r3, #31
    d060:	bmi.w	cc48 <_svfprintf_r+0xae8>
    d064:	adds	r5, #1
    d066:	adds	r4, #1
    d068:	movs	r3, #1
    d06a:	cmp	r5, #7
    d06c:	str	r4, [sp, #148]	; 0x94
    d06e:	str	r5, [sp, #144]	; 0x90
    d070:	str.w	r6, [r9]
    d074:	str.w	r3, [r9, #4]
    d078:	ble.w	ccb0 <_svfprintf_r+0xb50>
    d07c:	b.n	ce9a <_svfprintf_r+0xd3a>
    d07e:	add	r2, sp, #140	; 0x8c
    d080:	ldr	r1, [sp, #20]
    d082:	ldr	r0, [sp, #24]
    d084:	bl	f2a4 <__ssprint_r>
    d088:	cmp	r0, #0
    d08a:	bne.w	c354 <_svfprintf_r+0x1f4>
    d08e:	ldr	r4, [sp, #148]	; 0x94
    d090:	ldr	r5, [sp, #144]	; 0x90
    d092:	add.w	r9, sp, #192	; 0xc0
    d096:	b.n	cc64 <_svfprintf_r+0xb04>
    d098:	add	r2, sp, #140	; 0x8c
    d09a:	ldr	r1, [sp, #20]
    d09c:	ldr	r0, [sp, #24]
    d09e:	bl	f2a4 <__ssprint_r>
    d0a2:	cmp	r0, #0
    d0a4:	bne.w	c354 <_svfprintf_r+0x1f4>
    d0a8:	ldr	r4, [sp, #148]	; 0x94
    d0aa:	ldr	r5, [sp, #144]	; 0x90
    d0ac:	add.w	r9, sp, #192	; 0xc0
    d0b0:	b.n	cc82 <_svfprintf_r+0xb22>
    d0b2:	add	r2, sp, #140	; 0x8c
    d0b4:	ldr	r1, [sp, #20]
    d0b6:	ldr	r0, [sp, #24]
    d0b8:	bl	f2a4 <__ssprint_r>
    d0bc:	cmp	r0, #0
    d0be:	bne.w	c354 <_svfprintf_r+0x1f4>
    d0c2:	ldr	r4, [sp, #148]	; 0x94
    d0c4:	add.w	r9, sp, #192	; 0xc0
    d0c8:	b.w	c5f4 <_svfprintf_r+0x494>
    d0cc:	ldr	r1, [sp, #12]
    d0ce:	ands.w	r3, r1, #64	; 0x40
    d0d2:	beq.w	d248 <_svfprintf_r+0x10e8>
    d0d6:	ldr	r0, [sp, #40]	; 0x28
    d0d8:	strb.w	r2, [sp, #111]	; 0x6f
    d0dc:	mov	r3, r0
    d0de:	cmp.w	fp, #0
    d0e2:	add.w	r3, r3, #4
    d0e6:	ldrh	r4, [r0, #0]
    d0e8:	mov.w	r5, #0
    d0ec:	blt.w	d470 <_svfprintf_r+0x1310>
    d0f0:	bic.w	r1, r1, #128	; 0x80
    d0f4:	str	r1, [sp, #12]
    d0f6:	orrs.w	r1, r4, r5
    d0fa:	str	r3, [sp, #40]	; 0x28
    d0fc:	beq.w	cab4 <_svfprintf_r+0x954>
    d100:	mov	r7, r2
    d102:	b.w	c3ac <_svfprintf_r+0x24c>
    d106:	ldr	r3, [sp, #12]
    d108:	lsls	r7, r3, #27
    d10a:	bmi.n	d124 <_svfprintf_r+0xfc4>
    d10c:	ldr	r3, [sp, #12]
    d10e:	lsls	r6, r3, #25
    d110:	bpl.n	d124 <_svfprintf_r+0xfc4>
    d112:	ldr	r2, [sp, #40]	; 0x28
    d114:	ldr	r3, [r2, #0]
    d116:	adds	r2, #4
    d118:	str	r2, [sp, #40]	; 0x28
    d11a:	ldrh.w	r2, [sp, #28]
    d11e:	strh	r2, [r3, #0]
    d120:	b.w	c1ae <_svfprintf_r+0x4e>
    d124:	ldr	r2, [sp, #40]	; 0x28
    d126:	ldr	r3, [r2, #0]
    d128:	adds	r2, #4
    d12a:	str	r2, [sp, #40]	; 0x28
    d12c:	ldr	r2, [sp, #28]
    d12e:	str	r2, [r3, #0]
    d130:	b.w	c1ae <_svfprintf_r+0x4e>
    d134:	ldrd	r0, r1, [sp, #64]	; 0x40
    d138:	mov	r2, r0
    d13a:	mov	r3, r1
    d13c:	bl	ad14 <__aeabi_dcmpun>
    d140:	cmp	r0, #0
    d142:	bne.w	d740 <_svfprintf_r+0x15e0>
    d146:	ldr	r3, [sp, #52]	; 0x34
    d148:	cmp.w	fp, #4294967295
    d14c:	bic.w	r7, r3, #32
    d150:	beq.w	d622 <_svfprintf_r+0x14c2>
    d154:	cmp	r7, #71	; 0x47
    d156:	beq.w	d45e <_svfprintf_r+0x12fe>
    d15a:	ldr	r3, [sp, #68]	; 0x44
    d15c:	ldr	r2, [sp, #12]
    d15e:	cmp	r3, #0
    d160:	orr.w	r2, r2, #256	; 0x100
    d164:	str	r2, [sp, #44]	; 0x2c
    d166:	blt.w	d65a <_svfprintf_r+0x14fa>
    d16a:	vldr	d7, [sp, #64]	; 0x40
    d16e:	vstr	d7, [sp, #96]	; 0x60
    d172:	movs	r3, #0
    d174:	str	r3, [sp, #16]
    d176:	ldr	r3, [sp, #52]	; 0x34
    d178:	cmp	r3, #102	; 0x66
    d17a:	beq.w	d628 <_svfprintf_r+0x14c8>
    d17e:	cmp	r3, #70	; 0x46
    d180:	beq.w	d40e <_svfprintf_r+0x12ae>
    d184:	cmp	r7, #69	; 0x45
    d186:	ite	eq
    d188:	addeq.w	r5, fp, #1
    d18c:	movne	r5, fp
    d18e:	add	r2, sp, #132	; 0x84
    d190:	add	r3, sp, #120	; 0x78
    d192:	str	r2, [sp, #4]
    d194:	str	r3, [sp, #0]
    d196:	mov	r2, r5
    d198:	add	r3, sp, #116	; 0x74
    d19a:	movs	r1, #2
    d19c:	vldr	d0, [sp, #96]	; 0x60
    d1a0:	ldr	r0, [sp, #24]
    d1a2:	bl	da18 <_dtoa_r>
    d1a6:	ldr	r3, [sp, #52]	; 0x34
    d1a8:	cmp	r3, #103	; 0x67
    d1aa:	mov	r6, r0
    d1ac:	bne.w	d686 <_svfprintf_r+0x1526>
    d1b0:	ldr	r3, [sp, #12]
    d1b2:	lsls	r2, r3, #31
    d1b4:	bpl.w	d72a <_svfprintf_r+0x15ca>
    d1b8:	adds	r4, r6, r5
    d1ba:	movs	r2, #0
    d1bc:	movs	r3, #0
    d1be:	ldrd	r0, r1, [sp, #96]	; 0x60
    d1c2:	bl	acb0 <__aeabi_dcmpeq>
    d1c6:	cmp	r0, #0
    d1c8:	bne.w	d4e6 <_svfprintf_r+0x1386>
    d1cc:	ldr	r3, [sp, #132]	; 0x84
    d1ce:	cmp	r4, r3
    d1d0:	bls.n	d1e0 <_svfprintf_r+0x1080>
    d1d2:	movs	r1, #48	; 0x30
    d1d4:	adds	r2, r3, #1
    d1d6:	str	r2, [sp, #132]	; 0x84
    d1d8:	strb	r1, [r3, #0]
    d1da:	ldr	r3, [sp, #132]	; 0x84
    d1dc:	cmp	r4, r3
    d1de:	bhi.n	d1d4 <_svfprintf_r+0x1074>
    d1e0:	subs	r3, r3, r6
    d1e2:	cmp	r7, #71	; 0x47
    d1e4:	str	r3, [sp, #56]	; 0x38
    d1e6:	beq.w	d4d8 <_svfprintf_r+0x1378>
    d1ea:	ldr	r3, [sp, #52]	; 0x34
    d1ec:	cmp	r3, #101	; 0x65
    d1ee:	ble.w	d6a4 <_svfprintf_r+0x1544>
    d1f2:	ldr	r3, [sp, #52]	; 0x34
    d1f4:	cmp	r3, #102	; 0x66
    d1f6:	ldr	r3, [sp, #116]	; 0x74
    d1f8:	str	r3, [sp, #60]	; 0x3c
    d1fa:	beq.w	d6be <_svfprintf_r+0x155e>
    d1fe:	ldr	r2, [sp, #60]	; 0x3c
    d200:	ldr	r1, [sp, #56]	; 0x38
    d202:	cmp	r2, r1
    d204:	blt.w	d66c <_svfprintf_r+0x150c>
    d208:	ldr	r3, [sp, #12]
    d20a:	lsls	r1, r3, #31
    d20c:	bmi.w	d72e <_svfprintf_r+0x15ce>
    d210:	bic.w	r3, r2, r2, asr #31
    d214:	str	r2, [sp, #36]	; 0x24
    d216:	movs	r2, #103	; 0x67
    d218:	str	r2, [sp, #52]	; 0x34
    d21a:	ldr	r2, [sp, #16]
    d21c:	cmp	r2, #0
    d21e:	bne.w	d480 <_svfprintf_r+0x1320>
    d222:	str	r3, [sp, #16]
    d224:	ldr	r3, [sp, #44]	; 0x2c
    d226:	str	r3, [sp, #12]
    d228:	mov	fp, r2
    d22a:	ldrb.w	r7, [sp, #111]	; 0x6f
    d22e:	b.w	c504 <_svfprintf_r+0x3a4>
    d232:	bic.w	r7, r7, #7
    d236:	vldr	d7, [r7]
    d23a:	add.w	r3, r7, #8
    d23e:	vstr	d7, [sp, #64]	; 0x40
    d242:	str	r3, [sp, #40]	; 0x28
    d244:	b.w	c75c <_svfprintf_r+0x5fc>
    d248:	ldr	r1, [sp, #40]	; 0x28
    d24a:	strb.w	r3, [sp, #111]	; 0x6f
    d24e:	cmp.w	fp, #0
    d252:	ldr	r4, [r1, #0]
    d254:	add.w	r7, r1, #4
    d258:	mov.w	r5, #0
    d25c:	bge.w	d3b8 <_svfprintf_r+0x1258>
    d260:	str	r7, [sp, #40]	; 0x28
    d262:	movs	r7, #0
    d264:	b.w	c3ac <_svfprintf_r+0x24c>
    d268:	ldr	r1, [sp, #12]
    d26a:	ands.w	r3, r1, #64	; 0x40
    d26e:	beq.w	cf0e <_svfprintf_r+0xdae>
    d272:	ldr	r0, [sp, #40]	; 0x28
    d274:	strb.w	r2, [sp, #111]	; 0x6f
    d278:	mov	r3, r0
    d27a:	cmp.w	fp, #0
    d27e:	add.w	r3, r3, #4
    d282:	ldrh	r4, [r0, #0]
    d284:	mov.w	r5, #0
    d288:	blt.w	d46a <_svfprintf_r+0x130a>
    d28c:	bic.w	r1, r1, #128	; 0x80
    d290:	str	r1, [sp, #12]
    d292:	orrs.w	r1, r4, r5
    d296:	str	r3, [sp, #40]	; 0x28
    d298:	mov	r7, r2
    d29a:	bne.w	c4bc <_svfprintf_r+0x35c>
    d29e:	b.w	c88c <_svfprintf_r+0x72c>
    d2a2:	ldr	r3, [sp, #12]
    d2a4:	ldr	r2, [sp, #40]	; 0x28
    d2a6:	tst.w	r3, #64	; 0x40
    d2aa:	mov	r3, r2
    d2ac:	beq.w	d474 <_svfprintf_r+0x1314>
    d2b0:	adds	r3, #4
    d2b2:	ldrh	r4, [r2, #0]
    d2b4:	str	r3, [sp, #40]	; 0x28
    d2b6:	movs	r5, #0
    d2b8:	b.w	c8c6 <_svfprintf_r+0x766>
    d2bc:	mov	r4, r2
    d2be:	adds	r3, #1
    d2c0:	ldr	r2, [sp, #44]	; 0x2c
    d2c2:	str	r3, [sp, #144]	; 0x90
    d2c4:	add	r4, r5
    d2c6:	cmp	r3, #7
    d2c8:	str	r4, [sp, #148]	; 0x94
    d2ca:	stmia.w	r9, {r2, r5}
    d2ce:	bgt.w	cf86 <_svfprintf_r+0xe26>
    d2d2:	add.w	r9, r9, #8
    d2d6:	b.n	cf9c <_svfprintf_r+0xe3c>
    d2d8:	.word	0x20000900
    d2dc:	movs	r7, #0
    d2de:	cmp	fp, r7
    d2e0:	strb.w	r7, [sp, #111]	; 0x6f
    d2e4:	blt.w	cad8 <_svfprintf_r+0x978>
    d2e8:	ldr	r3, [sp, #12]
    d2ea:	bic.w	r3, r3, #128	; 0x80
    d2ee:	str	r3, [sp, #12]
    d2f0:	b.w	ca74 <_svfprintf_r+0x914>
    d2f4:	add	r2, sp, #140	; 0x8c
    d2f6:	ldr	r1, [sp, #20]
    d2f8:	ldr	r0, [sp, #24]
    d2fa:	bl	f2a4 <__ssprint_r>
    d2fe:	cmp	r0, #0
    d300:	bne.w	c354 <_svfprintf_r+0x1f4>
    d304:	ldr	r4, [sp, #148]	; 0x94
    d306:	add.w	r9, sp, #192	; 0xc0
    d30a:	b.n	cb1c <_svfprintf_r+0x9bc>
    d30c:	ldr	r7, [sp, #40]	; 0x28
    d30e:	b.w	caca <_svfprintf_r+0x96a>
    d312:	ldr	r3, [sp, #144]	; 0x90
    d314:	ldr	r2, [pc, #736]	; (d5f8 <_svfprintf_r+0x1498>)
    d316:	str.w	r2, [r9]
    d31a:	adds	r3, #1
    d31c:	adds	r4, #1
    d31e:	movs	r2, #1
    d320:	cmp	r3, #7
    d322:	str	r4, [sp, #148]	; 0x94
    d324:	str	r3, [sp, #144]	; 0x90
    d326:	str.w	r2, [r9, #4]
    d32a:	bgt.w	d444 <_svfprintf_r+0x12e4>
    d32e:	add.w	r9, r9, #8
    d332:	cbnz	r5, d340 <_svfprintf_r+0x11e0>
    d334:	ldr	r3, [sp, #56]	; 0x38
    d336:	cbnz	r3, d340 <_svfprintf_r+0x11e0>
    d338:	ldr	r3, [sp, #12]
    d33a:	lsls	r7, r3, #31
    d33c:	bpl.w	c68c <_svfprintf_r+0x52c>
    d340:	ldr	r3, [sp, #144]	; 0x90
    d342:	ldr	r1, [sp, #72]	; 0x48
    d344:	ldr	r2, [sp, #76]	; 0x4c
    d346:	str.w	r2, [r9]
    d34a:	adds	r3, #1
    d34c:	add	r4, r1
    d34e:	cmp	r3, #7
    d350:	str	r4, [sp, #148]	; 0x94
    d352:	str.w	r1, [r9, #4]
    d356:	str	r3, [sp, #144]	; 0x90
    d358:	bgt.w	d6f6 <_svfprintf_r+0x1596>
    d35c:	add.w	r9, r9, #8
    d360:	negs	r5, r5
    d362:	cmp	r5, #0
    d364:	ble.w	d4bc <_svfprintf_r+0x135c>
    d368:	ldr	r2, [pc, #656]	; (d5fc <_svfprintf_r+0x149c>)
    d36a:	str	r2, [sp, #44]	; 0x2c
    d36c:	cmp	r5, #16
    d36e:	ble.w	d504 <_svfprintf_r+0x13a4>
    d372:	mov	r2, r4
    d374:	movs	r7, #16
    d376:	ldr.w	fp, [sp, #24]
    d37a:	ldr	r4, [sp, #20]
    d37c:	b.n	d38a <_svfprintf_r+0x122a>
    d37e:	add.w	r9, r9, #8
    d382:	subs	r5, #16
    d384:	cmp	r5, #16
    d386:	ble.w	d502 <_svfprintf_r+0x13a2>
    d38a:	adds	r3, #1
    d38c:	adds	r2, #16
    d38e:	cmp	r3, #7
    d390:	str	r2, [sp, #148]	; 0x94
    d392:	str	r3, [sp, #144]	; 0x90
    d394:	str.w	sl, [r9]
    d398:	str.w	r7, [r9, #4]
    d39c:	ble.n	d37e <_svfprintf_r+0x121e>
    d39e:	add	r2, sp, #140	; 0x8c
    d3a0:	mov	r1, r4
    d3a2:	mov	r0, fp
    d3a4:	bl	f2a4 <__ssprint_r>
    d3a8:	cmp	r0, #0
    d3aa:	bne.w	c354 <_svfprintf_r+0x1f4>
    d3ae:	ldr	r2, [sp, #148]	; 0x94
    d3b0:	ldr	r3, [sp, #144]	; 0x90
    d3b2:	add.w	r9, sp, #192	; 0xc0
    d3b6:	b.n	d382 <_svfprintf_r+0x1222>
    d3b8:	ldr	r2, [sp, #12]
    d3ba:	b.w	c830 <_svfprintf_r+0x6d0>
    d3be:	ldr	r2, [sp, #12]
    d3c0:	b.n	ceda <_svfprintf_r+0xd7a>
    d3c2:	ldr	r3, [sp, #12]
    d3c4:	orr.w	r3, r3, #32
    d3c8:	str	r3, [sp, #12]
    d3ca:	add.w	r8, r8, #1
    d3ce:	ldrb.w	r3, [r8]
    d3d2:	b.w	c214 <_svfprintf_r+0xb4>
    d3d6:	add	r2, sp, #140	; 0x8c
    d3d8:	ldr	r1, [sp, #20]
    d3da:	ldr	r0, [sp, #24]
    d3dc:	bl	f2a4 <__ssprint_r>
    d3e0:	cmp	r0, #0
    d3e2:	bne.w	c354 <_svfprintf_r+0x1f4>
    d3e6:	ldr	r4, [sp, #148]	; 0x94
    d3e8:	add.w	r9, sp, #192	; 0xc0
    d3ec:	b.w	cb4c <_svfprintf_r+0x9ec>
    d3f0:	movs	r1, #64	; 0x40
    d3f2:	ldr	r0, [sp, #24]
    d3f4:	bl	b0d8 <_malloc_r>
    d3f8:	ldr	r2, [sp, #20]
    d3fa:	str	r0, [r2, #0]
    d3fc:	str	r0, [r2, #16]
    d3fe:	cmp	r0, #0
    d400:	beq.w	d7ea <_svfprintf_r+0x168a>
    d404:	ldr	r2, [sp, #20]
    d406:	movs	r3, #64	; 0x40
    d408:	str	r3, [r2, #20]
    d40a:	b.w	c18e <_svfprintf_r+0x2e>
    d40e:	add	r2, sp, #132	; 0x84
    d410:	add	r3, sp, #120	; 0x78
    d412:	str	r2, [sp, #4]
    d414:	str	r3, [sp, #0]
    d416:	mov	r2, fp
    d418:	add	r3, sp, #116	; 0x74
    d41a:	movs	r1, #3
    d41c:	vldr	d0, [sp, #96]	; 0x60
    d420:	ldr	r0, [sp, #24]
    d422:	bl	da18 <_dtoa_r>
    d426:	mov	r5, fp
    d428:	mov	r6, r0
    d42a:	ldr	r3, [sp, #52]	; 0x34
    d42c:	cmp	r3, #70	; 0x46
    d42e:	add.w	r4, r6, r5
    d432:	bne.w	d1ba <_svfprintf_r+0x105a>
    d436:	ldrb	r3, [r6, #0]
    d438:	cmp	r3, #48	; 0x30
    d43a:	beq.w	d74c <_svfprintf_r+0x15ec>
    d43e:	ldr	r5, [sp, #116]	; 0x74
    d440:	add	r4, r5
    d442:	b.n	d1ba <_svfprintf_r+0x105a>
    d444:	add	r2, sp, #140	; 0x8c
    d446:	ldr	r1, [sp, #20]
    d448:	ldr	r0, [sp, #24]
    d44a:	bl	f2a4 <__ssprint_r>
    d44e:	cmp	r0, #0
    d450:	bne.w	c354 <_svfprintf_r+0x1f4>
    d454:	ldr	r5, [sp, #116]	; 0x74
    d456:	ldr	r4, [sp, #148]	; 0x94
    d458:	add.w	r9, sp, #192	; 0xc0
    d45c:	b.n	d332 <_svfprintf_r+0x11d2>
    d45e:	cmp.w	fp, #0
    d462:	it	eq
    d464:	moveq.w	fp, #1
    d468:	b.n	d15a <_svfprintf_r+0xffa>
    d46a:	str	r3, [sp, #40]	; 0x28
    d46c:	mov	r7, r2
    d46e:	b.n	cf2a <_svfprintf_r+0xdca>
    d470:	str	r3, [sp, #40]	; 0x28
    d472:	b.n	d262 <_svfprintf_r+0x1102>
    d474:	adds	r3, #4
    d476:	ldr	r4, [r2, #0]
    d478:	str	r3, [sp, #40]	; 0x28
    d47a:	movs	r5, #0
    d47c:	b.w	c8c6 <_svfprintf_r+0x766>
    d480:	movs	r7, #45	; 0x2d
    d482:	str	r3, [sp, #16]
    d484:	ldr	r3, [sp, #44]	; 0x2c
    d486:	str	r3, [sp, #12]
    d488:	strb.w	r7, [sp, #111]	; 0x6f
    d48c:	mov.w	fp, #0
    d490:	b.w	c506 <_svfprintf_r+0x3a6>
    d494:	mov	r0, r6
    d496:	bl	c080 <strlen>
    d49a:	mov	fp, r4
    d49c:	mov	r3, r0
    d49e:	str	r0, [sp, #36]	; 0x24
    d4a0:	b.w	c9e8 <_svfprintf_r+0x888>
    d4a4:	add	r2, sp, #140	; 0x8c
    d4a6:	ldr	r1, [sp, #20]
    d4a8:	ldr	r0, [sp, #24]
    d4aa:	bl	f2a4 <__ssprint_r>
    d4ae:	cmp	r0, #0
    d4b0:	bne.w	c354 <_svfprintf_r+0x1f4>
    d4b4:	ldr	r4, [sp, #148]	; 0x94
    d4b6:	ldr	r3, [sp, #144]	; 0x90
    d4b8:	add.w	r9, sp, #192	; 0xc0
    d4bc:	ldr	r1, [sp, #56]	; 0x38
    d4be:	str.w	r6, [r9]
    d4c2:	adds	r3, #1
    d4c4:	add	r4, r1
    d4c6:	cmp	r3, #7
    d4c8:	str	r4, [sp, #148]	; 0x94
    d4ca:	str	r3, [sp, #144]	; 0x90
    d4cc:	str.w	r1, [r9, #4]
    d4d0:	ble.w	c688 <_svfprintf_r+0x528>
    d4d4:	b.w	ccce <_svfprintf_r+0xb6e>
    d4d8:	ldr	r3, [sp, #116]	; 0x74
    d4da:	adds	r5, r3, #3
    d4dc:	blt.n	d51c <_svfprintf_r+0x13bc>
    d4de:	cmp	fp, r3
    d4e0:	blt.n	d51c <_svfprintf_r+0x13bc>
    d4e2:	str	r3, [sp, #60]	; 0x3c
    d4e4:	b.n	d1fe <_svfprintf_r+0x109e>
    d4e6:	mov	r3, r4
    d4e8:	b.n	d1e0 <_svfprintf_r+0x1080>
    d4ea:	add	r2, sp, #140	; 0x8c
    d4ec:	ldr	r1, [sp, #20]
    d4ee:	ldr	r0, [sp, #24]
    d4f0:	bl	f2a4 <__ssprint_r>
    d4f4:	cmp	r0, #0
    d4f6:	bne.w	c354 <_svfprintf_r+0x1f4>
    d4fa:	ldr	r4, [sp, #148]	; 0x94
    d4fc:	add.w	r9, sp, #192	; 0xc0
    d500:	b.n	cd9c <_svfprintf_r+0xc3c>
    d502:	mov	r4, r2
    d504:	adds	r3, #1
    d506:	ldr	r2, [sp, #44]	; 0x2c
    d508:	str	r3, [sp, #144]	; 0x90
    d50a:	add	r4, r5
    d50c:	cmp	r3, #7
    d50e:	str	r4, [sp, #148]	; 0x94
    d510:	stmia.w	r9, {r2, r5}
    d514:	bgt.n	d4a4 <_svfprintf_r+0x1344>
    d516:	add.w	r9, r9, #8
    d51a:	b.n	d4bc <_svfprintf_r+0x135c>
    d51c:	ldr	r2, [sp, #52]	; 0x34
    d51e:	subs	r2, #2
    d520:	str	r2, [sp, #52]	; 0x34
    d522:	subs	r3, #1
    d524:	cmp	r3, #0
    d526:	ldrb.w	r2, [sp, #52]	; 0x34
    d52a:	str	r3, [sp, #116]	; 0x74
    d52c:	it	lt
    d52e:	neglt	r3, r3
    d530:	strb.w	r2, [sp, #124]	; 0x7c
    d534:	ite	lt
    d536:	movlt	r2, #45	; 0x2d
    d538:	movge	r2, #43	; 0x2b
    d53a:	cmp	r3, #9
    d53c:	strb.w	r2, [sp, #125]	; 0x7d
    d540:	ble.w	d71a <_svfprintf_r+0x15ba>
    d544:	add.w	r0, sp, #139	; 0x8b
    d548:	mov	r4, r0
    d54a:	ldr	r2, [pc, #180]	; (d600 <_svfprintf_r+0x14a0>)
    d54c:	smull	r2, r1, r2, r3
    d550:	asrs	r2, r3, #31
    d552:	rsb	r2, r2, r1, asr #2
    d556:	add.w	r1, r2, r2, lsl #2
    d55a:	sub.w	r3, r3, r1, lsl #1
    d55e:	add.w	r1, r3, #48	; 0x30
    d562:	cmp	r2, #9
    d564:	mov	r3, r2
    d566:	strb.w	r1, [r4, #-1]!
    d56a:	bgt.n	d54a <_svfprintf_r+0x13ea>
    d56c:	mov	r1, r4
    d56e:	adds	r3, #48	; 0x30
    d570:	uxtb	r2, r3
    d572:	strb.w	r2, [r1, #-1]!
    d576:	cmp	r0, r1
    d578:	bls.w	d7e4 <_svfprintf_r+0x1684>
    d57c:	add.w	r1, sp, #126	; 0x7e
    d580:	mov	r3, r4
    d582:	b.n	d588 <_svfprintf_r+0x1428>
    d584:	ldrb.w	r2, [r3], #1
    d588:	strb.w	r2, [r1], #1
    d58c:	cmp	r0, r3
    d58e:	bne.n	d584 <_svfprintf_r+0x1424>
    d590:	adds	r3, r0, #1
    d592:	subs	r3, r3, r4
    d594:	add.w	r2, sp, #126	; 0x7e
    d598:	add	r3, r2
    d59a:	add	r2, sp, #124	; 0x7c
    d59c:	subs	r3, r3, r2
    d59e:	ldr	r2, [sp, #56]	; 0x38
    d5a0:	str	r3, [sp, #84]	; 0x54
    d5a2:	cmp	r2, #1
    d5a4:	add	r3, r2
    d5a6:	str	r3, [sp, #36]	; 0x24
    d5a8:	ble.w	d77a <_svfprintf_r+0x161a>
    d5ac:	ldr	r3, [sp, #36]	; 0x24
    d5ae:	ldr	r2, [sp, #72]	; 0x48
    d5b0:	add	r3, r2
    d5b2:	movs	r2, #0
    d5b4:	str	r3, [sp, #36]	; 0x24
    d5b6:	str	r2, [sp, #60]	; 0x3c
    d5b8:	bic.w	r3, r3, r3, asr #31
    d5bc:	b.n	d21a <_svfprintf_r+0x10ba>
    d5be:	add	r2, sp, #140	; 0x8c
    d5c0:	ldr	r1, [sp, #20]
    d5c2:	ldr	r0, [sp, #24]
    d5c4:	bl	f2a4 <__ssprint_r>
    d5c8:	cmp	r0, #0
    d5ca:	bne.w	c354 <_svfprintf_r+0x1f4>
    d5ce:	ldr	r3, [sp, #116]	; 0x74
    d5d0:	ldr	r4, [sp, #148]	; 0x94
    d5d2:	add.w	r9, sp, #192	; 0xc0
    d5d6:	b.n	cfb0 <_svfprintf_r+0xe50>
    d5d8:	add	r2, sp, #140	; 0x8c
    d5da:	ldr	r1, [sp, #20]
    d5dc:	ldr	r0, [sp, #24]
    d5de:	bl	f2a4 <__ssprint_r>
    d5e2:	cmp	r0, #0
    d5e4:	bne.w	c354 <_svfprintf_r+0x1f4>
    d5e8:	ldr	r3, [sp, #116]	; 0x74
    d5ea:	ldr	r2, [sp, #56]	; 0x38
    d5ec:	ldr	r4, [sp, #148]	; 0x94
    d5ee:	subs	r3, r2, r3
    d5f0:	add.w	r9, sp, #192	; 0xc0
    d5f4:	b.n	cfe0 <_svfprintf_r+0xe80>
    d5f6:	nop
    d5f8:	.word	0x200004d8
    d5fc:	.word	0x20000900
    d600:	.word	0x66666667
    d604:	cmp	r5, #6
    d606:	mov	r3, r5
    d608:	it	cs
    d60a:	movcs	r3, #6
    d60c:	str	r3, [sp, #36]	; 0x24
    d60e:	bic.w	r3, r3, r3, asr #31
    d612:	mov	fp, r6
    d614:	str	r7, [sp, #40]	; 0x28
    d616:	str	r6, [sp, #60]	; 0x3c
    d618:	mov	r7, r6
    d61a:	str	r3, [sp, #16]
    d61c:	ldr	r6, [pc, #536]	; (d838 <_svfprintf_r+0x16d8>)
    d61e:	b.w	c504 <_svfprintf_r+0x3a4>
    d622:	mov.w	fp, #6
    d626:	b.n	d15a <_svfprintf_r+0xffa>
    d628:	add	r2, sp, #132	; 0x84
    d62a:	add	r3, sp, #120	; 0x78
    d62c:	str	r2, [sp, #4]
    d62e:	str	r3, [sp, #0]
    d630:	mov	r2, fp
    d632:	add	r3, sp, #116	; 0x74
    d634:	movs	r1, #3
    d636:	vldr	d0, [sp, #96]	; 0x60
    d63a:	ldr	r0, [sp, #24]
    d63c:	bl	da18 <_dtoa_r>
    d640:	mov	r5, fp
    d642:	mov	r6, r0
    d644:	add.w	r4, r0, fp
    d648:	b.n	d436 <_svfprintf_r+0x12d6>
    d64a:	movs	r7, #45	; 0x2d
    d64c:	strb.w	r7, [sp, #111]	; 0x6f
    d650:	b.w	c7aa <_svfprintf_r+0x64a>
    d654:	str	r3, [sp, #12]
    d656:	b.w	c902 <_svfprintf_r+0x7a2>
    d65a:	ldrd	r1, r2, [sp, #64]	; 0x40
    d65e:	add.w	r3, r2, #2147483648	; 0x80000000
    d662:	str	r3, [sp, #100]	; 0x64
    d664:	movs	r3, #45	; 0x2d
    d666:	str	r1, [sp, #96]	; 0x60
    d668:	str	r3, [sp, #16]
    d66a:	b.n	d176 <_svfprintf_r+0x1016>
    d66c:	ldr	r2, [sp, #72]	; 0x48
    d66e:	ldr	r3, [sp, #56]	; 0x38
    d670:	add	r3, r2
    d672:	ldr	r2, [sp, #60]	; 0x3c
    d674:	str	r3, [sp, #36]	; 0x24
    d676:	cmp	r2, #0
    d678:	ble.w	d78e <_svfprintf_r+0x162e>
    d67c:	movs	r2, #103	; 0x67
    d67e:	bic.w	r3, r3, r3, asr #31
    d682:	str	r2, [sp, #52]	; 0x34
    d684:	b.n	d21a <_svfprintf_r+0x10ba>
    d686:	ldr	r3, [sp, #52]	; 0x34
    d688:	cmp	r3, #71	; 0x47
    d68a:	bne.w	d1b8 <_svfprintf_r+0x1058>
    d68e:	ldr	r3, [sp, #12]
    d690:	lsls	r3, r3, #31
    d692:	bmi.w	d42a <_svfprintf_r+0x12ca>
    d696:	ldr	r3, [sp, #132]	; 0x84
    d698:	cmp	r7, #71	; 0x47
    d69a:	sub.w	r3, r3, r6
    d69e:	str	r3, [sp, #56]	; 0x38
    d6a0:	beq.w	d4d8 <_svfprintf_r+0x1378>
    d6a4:	ldr	r3, [sp, #116]	; 0x74
    d6a6:	b.n	d522 <_svfprintf_r+0x13c2>
    d6a8:	bic.w	r3, r5, r5, asr #31
    d6ac:	str	r7, [sp, #40]	; 0x28
    d6ae:	str	r3, [sp, #16]
    d6b0:	str	r5, [sp, #36]	; 0x24
    d6b2:	mov	fp, r0
    d6b4:	str	r0, [sp, #60]	; 0x3c
    d6b6:	ldrb.w	r7, [sp, #111]	; 0x6f
    d6ba:	b.w	c504 <_svfprintf_r+0x3a4>
    d6be:	cmp	r3, #0
    d6c0:	ble.n	d79e <_svfprintf_r+0x163e>
    d6c2:	cmp.w	fp, #0
    d6c6:	bne.n	d768 <_svfprintf_r+0x1608>
    d6c8:	ldr	r2, [sp, #12]
    d6ca:	lsls	r4, r2, #31
    d6cc:	bmi.n	d768 <_svfprintf_r+0x1608>
    d6ce:	mov	r2, r3
    d6d0:	str	r2, [sp, #36]	; 0x24
    d6d2:	bic.w	r3, r3, r3, asr #31
    d6d6:	b.n	d21a <_svfprintf_r+0x10ba>
    d6d8:	ldr	r3, [sp, #12]
    d6da:	lsls	r3, r3, #31
    d6dc:	mov	r7, fp
    d6de:	bpl.n	d6ec <_svfprintf_r+0x158c>
    d6e0:	add	r6, sp, #256	; 0x100
    d6e2:	movs	r3, #48	; 0x30
    d6e4:	strb.w	r3, [r6, #-65]!
    d6e8:	b.w	c4f0 <_svfprintf_r+0x390>
    d6ec:	str.w	fp, [sp, #36]	; 0x24
    d6f0:	add	r6, sp, #192	; 0xc0
    d6f2:	b.w	c4f6 <_svfprintf_r+0x396>
    d6f6:	add	r2, sp, #140	; 0x8c
    d6f8:	ldr	r1, [sp, #20]
    d6fa:	ldr	r0, [sp, #24]
    d6fc:	bl	f2a4 <__ssprint_r>
    d700:	cmp	r0, #0
    d702:	bne.w	c354 <_svfprintf_r+0x1f4>
    d706:	ldr	r5, [sp, #116]	; 0x74
    d708:	ldr	r4, [sp, #148]	; 0x94
    d70a:	ldr	r3, [sp, #144]	; 0x90
    d70c:	add.w	r9, sp, #192	; 0xc0
    d710:	b.n	d360 <_svfprintf_r+0x1200>
    d712:	mov	r8, r4
    d714:	movs	r5, #0
    d716:	b.w	c218 <_svfprintf_r+0xb8>
    d71a:	adds	r3, #48	; 0x30
    d71c:	movs	r2, #48	; 0x30
    d71e:	strb.w	r3, [sp, #127]	; 0x7f
    d722:	strb.w	r2, [sp, #126]	; 0x7e
    d726:	add	r3, sp, #128	; 0x80
    d728:	b.n	d59a <_svfprintf_r+0x143a>
    d72a:	ldr	r3, [sp, #132]	; 0x84
    d72c:	b.n	d1e0 <_svfprintf_r+0x1080>
    d72e:	ldr	r2, [sp, #72]	; 0x48
    d730:	ldr	r3, [sp, #60]	; 0x3c
    d732:	add	r3, r2
    d734:	movs	r2, #103	; 0x67
    d736:	str	r3, [sp, #36]	; 0x24
    d738:	str	r2, [sp, #52]	; 0x34
    d73a:	bic.w	r3, r3, r3, asr #31
    d73e:	b.n	d21a <_svfprintf_r+0x10ba>
    d740:	ldr	r6, [pc, #248]	; (d83c <_svfprintf_r+0x16dc>)
    d742:	ldr	r3, [pc, #252]	; (d840 <_svfprintf_r+0x16e0>)
    d744:	ldrb.w	r7, [sp, #111]	; 0x6f
    d748:	b.w	c7ae <_svfprintf_r+0x64e>
    d74c:	movs	r2, #0
    d74e:	movs	r3, #0
    d750:	ldrd	r0, r1, [sp, #96]	; 0x60
    d754:	bl	acb0 <__aeabi_dcmpeq>
    d758:	cmp	r0, #0
    d75a:	bne.w	d43e <_svfprintf_r+0x12de>
    d75e:	rsb	r5, r5, #1
    d762:	str	r5, [sp, #116]	; 0x74
    d764:	add	r4, r5
    d766:	b.n	d1ba <_svfprintf_r+0x105a>
    d768:	ldr	r3, [sp, #60]	; 0x3c
    d76a:	ldr	r2, [sp, #72]	; 0x48
    d76c:	adds	r5, r3, r2
    d76e:	add.w	r3, r5, fp
    d772:	str	r3, [sp, #36]	; 0x24
    d774:	bic.w	r3, r3, r3, asr #31
    d778:	b.n	d21a <_svfprintf_r+0x10ba>
    d77a:	ldr	r3, [sp, #12]
    d77c:	ands.w	r3, r3, #1
    d780:	bne.w	d5ac <_svfprintf_r+0x144c>
    d784:	str	r3, [sp, #60]	; 0x3c
    d786:	ldr	r3, [sp, #36]	; 0x24
    d788:	bic.w	r3, r3, r3, asr #31
    d78c:	b.n	d21a <_svfprintf_r+0x10ba>
    d78e:	ldr	r3, [sp, #60]	; 0x3c
    d790:	ldr	r2, [sp, #36]	; 0x24
    d792:	rsb	r3, r3, #1
    d796:	add	r2, r3
    d798:	mov	r3, r2
    d79a:	str	r2, [sp, #36]	; 0x24
    d79c:	b.n	d67c <_svfprintf_r+0x151c>
    d79e:	cmp.w	fp, #0
    d7a2:	bne.n	d7aa <_svfprintf_r+0x164a>
    d7a4:	ldr	r3, [sp, #12]
    d7a6:	lsls	r0, r3, #31
    d7a8:	bpl.n	d7ba <_svfprintf_r+0x165a>
    d7aa:	ldr	r3, [sp, #72]	; 0x48
    d7ac:	adds	r5, r3, #1
    d7ae:	add.w	r3, r5, fp
    d7b2:	str	r3, [sp, #36]	; 0x24
    d7b4:	bic.w	r3, r3, r3, asr #31
    d7b8:	b.n	d21a <_svfprintf_r+0x10ba>
    d7ba:	movs	r3, #1
    d7bc:	str	r3, [sp, #36]	; 0x24
    d7be:	b.n	d21a <_svfprintf_r+0x10ba>
    d7c0:	ldr	r0, [sp, #40]	; 0x28
    d7c2:	ldrb.w	r3, [r8, #1]
    d7c6:	ldr	r5, [r0, #0]
    d7c8:	adds	r0, #4
    d7ca:	cmp	r5, #0
    d7cc:	str	r0, [sp, #40]	; 0x28
    d7ce:	mov	r8, r4
    d7d0:	bge.w	c214 <_svfprintf_r+0xb4>
    d7d4:	mov.w	r5, #4294967295
    d7d8:	b.w	c214 <_svfprintf_r+0xb4>
    d7dc:	strb.w	r1, [sp, #111]	; 0x6f
    d7e0:	b.w	c376 <_svfprintf_r+0x216>
    d7e4:	add.w	r3, sp, #126	; 0x7e
    d7e8:	b.n	d59a <_svfprintf_r+0x143a>
    d7ea:	ldr	r2, [sp, #24]
    d7ec:	movs	r3, #12
    d7ee:	str	r3, [r2, #0]
    d7f0:	mov.w	r0, #4294967295
    d7f4:	b.w	c366 <_svfprintf_r+0x206>
    d7f8:	strb.w	r1, [sp, #111]	; 0x6f
    d7fc:	b.w	c470 <_svfprintf_r+0x310>
    d800:	strb.w	r1, [sp, #111]	; 0x6f
    d804:	b.w	c73c <_svfprintf_r+0x5dc>
    d808:	strb.w	r1, [sp, #111]	; 0x6f
    d80c:	b.w	c8aa <_svfprintf_r+0x74a>
    d810:	strb.w	r1, [sp, #111]	; 0x6f
    d814:	b.w	c84e <_svfprintf_r+0x6ee>
    d818:	strb.w	r1, [sp, #111]	; 0x6f
    d81c:	b.w	c7fa <_svfprintf_r+0x69a>
    d820:	strb.w	r1, [sp, #111]	; 0x6f
    d824:	b.w	ca92 <_svfprintf_r+0x932>
    d828:	strb.w	r1, [sp, #111]	; 0x6f
    d82c:	b.w	ca50 <_svfprintf_r+0x8f0>
    d830:	strb.w	r1, [sp, #111]	; 0x6f
    d834:	b.w	ca14 <_svfprintf_r+0x8b4>
    d838:	.word	0x20000948
    d83c:	.word	0x2000091c
    d840:	.word	0x20000918

0000d844 <_vdprintf_r>:
    d844:	push	{r4, r5, r6, r7, lr}
    d846:	sub.w	sp, sp, #532	; 0x214
    d84a:	add	r5, sp, #16
    d84c:	str	r3, [sp, #0]
    d84e:	mov	r7, r1
    d850:	mov	r3, r2
    d852:	mov.w	r4, #512	; 0x200
    d856:	add	r2, sp, #12
    d858:	mov	r1, r5
    d85a:	str	r4, [sp, #12]
    d85c:	mov	r6, r0
    d85e:	bl	f3a4 <_vasnprintf_r>
    d862:	cbz	r0, d888 <_vdprintf_r+0x44>
    d864:	mov	r4, r0
    d866:	mov	r2, r0
    d868:	mov	r1, r7
    d86a:	ldr	r3, [sp, #12]
    d86c:	mov	r0, r6
    d86e:	bl	d8c4 <_write_r>
    d872:	cmp	r4, r5
    d874:	str	r0, [sp, #12]
    d876:	beq.n	d882 <_vdprintf_r+0x3e>
    d878:	mov	r0, r6
    d87a:	mov	r1, r4
    d87c:	bl	e9e8 <_free_r>
    d880:	ldr	r0, [sp, #12]
    d882:	add.w	sp, sp, #532	; 0x214
    d886:	pop	{r4, r5, r6, r7, pc}
    d888:	mov.w	r0, #4294967295
    d88c:	b.n	d882 <_vdprintf_r+0x3e>
    d88e:	nop

0000d890 <vdprintf>:
    d890:	push	{r4}
    d892:	ldr	r4, [pc, #16]	; (d8a4 <vdprintf+0x14>)
    d894:	mov	r3, r2
    d896:	mov	r2, r1
    d898:	mov	r1, r0
    d89a:	ldr	r0, [r4, #0]
    d89c:	ldr.w	r4, [sp], #4
    d8a0:	b.w	d844 <_vdprintf_r>
    d8a4:	.word	0x20000ff0

0000d8a8 <__ascii_wctomb>:
    d8a8:	cbz	r1, d8b4 <__ascii_wctomb+0xc>
    d8aa:	cmp	r2, #255	; 0xff
    d8ac:	bhi.n	d8b8 <__ascii_wctomb+0x10>
    d8ae:	strb	r2, [r1, #0]
    d8b0:	movs	r0, #1
    d8b2:	bx	lr
    d8b4:	mov	r0, r1
    d8b6:	bx	lr
    d8b8:	movs	r3, #138	; 0x8a
    d8ba:	str	r3, [r0, #0]
    d8bc:	mov.w	r0, #4294967295
    d8c0:	bx	lr
    d8c2:	nop

0000d8c4 <_write_r>:
    d8c4:	push	{r4, r5, r6, lr}
    d8c6:	mov	r5, r1
    d8c8:	ldr	r4, [pc, #32]	; (d8ec <_write_r+0x28>)
    d8ca:	mov	r1, r2
    d8cc:	mov	r6, r0
    d8ce:	mov	r2, r3
    d8d0:	mov	r0, r5
    d8d2:	movs	r3, #0
    d8d4:	str	r3, [r4, #0]
    d8d6:	bl	a018 <_write>
    d8da:	adds	r3, r0, #1
    d8dc:	beq.n	d8e0 <_write_r+0x1c>
    d8de:	pop	{r4, r5, r6, pc}
    d8e0:	ldr	r3, [r4, #0]
    d8e2:	cmp	r3, #0
    d8e4:	beq.n	d8de <_write_r+0x1a>
    d8e6:	str	r3, [r6, #0]
    d8e8:	pop	{r4, r5, r6, pc}
    d8ea:	nop
    d8ec:	.word	0x2000dac0

0000d8f0 <quorem>:
    d8f0:	ldr	r2, [r0, #16]
    d8f2:	ldr	r3, [r1, #16]
    d8f4:	cmp	r3, r2
    d8f6:	bgt.w	da14 <quorem+0x124>
    d8fa:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d8fe:	add.w	r8, r3, #4294967295
    d902:	add.w	r7, r1, #20
    d906:	add.w	fp, r0, #20
    d90a:	ldr.w	r2, [r7, r8, lsl #2]
    d90e:	ldr.w	r3, [fp, r8, lsl #2]
    d912:	mov.w	r4, r8, lsl #2
    d916:	sub	sp, #12
    d918:	adds	r2, #1
    d91a:	udiv	r9, r3, r2
    d91e:	add.w	r3, fp, r4
    d922:	str	r4, [sp, #0]
    d924:	add.w	sl, r7, r4
    d928:	str	r3, [sp, #4]
    d92a:	cmp.w	r9, #0
    d92e:	beq.n	d9a4 <quorem+0xb4>
    d930:	movs	r5, #0
    d932:	mov	ip, r7
    d934:	mov	lr, fp
    d936:	mov	r3, r5
    d938:	ldr.w	r6, [ip], #4
    d93c:	ldr.w	r2, [lr]
    d940:	uxth	r4, r6
    d942:	mla	r5, r9, r4, r5
    d946:	lsrs	r6, r6, #16
    d948:	lsrs	r4, r5, #16
    d94a:	mla	r4, r9, r6, r4
    d94e:	uxth	r5, r5
    d950:	subs	r3, r3, r5
    d952:	uxth	r6, r4
    d954:	uxtah	r3, r3, r2
    d958:	rsb	r6, r6, r2, lsr #16
    d95c:	add.w	r6, r6, r3, asr #16
    d960:	uxth	r3, r3
    d962:	orr.w	r3, r3, r6, lsl #16
    d966:	cmp	sl, ip
    d968:	str.w	r3, [lr], #4
    d96c:	mov.w	r5, r4, lsr #16
    d970:	mov.w	r3, r6, asr #16
    d974:	bcs.n	d938 <quorem+0x48>
    d976:	ldr	r3, [sp, #0]
    d978:	ldr.w	r3, [fp, r3]
    d97c:	cbnz	r3, d9a4 <quorem+0xb4>
    d97e:	ldr	r4, [sp, #4]
    d980:	subs	r3, r4, #4
    d982:	cmp	fp, r3
    d984:	bcs.n	d9a0 <quorem+0xb0>
    d986:	ldr.w	r3, [r4, #-4]
    d98a:	cbnz	r3, d9a0 <quorem+0xb0>
    d98c:	sub.w	r3, r4, #8
    d990:	b.n	d998 <quorem+0xa8>
    d992:	ldr	r2, [r3, #0]
    d994:	subs	r3, #4
    d996:	cbnz	r2, d9a0 <quorem+0xb0>
    d998:	cmp	fp, r3
    d99a:	add.w	r8, r8, #4294967295
    d99e:	bcc.n	d992 <quorem+0xa2>
    d9a0:	str.w	r8, [r0, #16]
    d9a4:	mov	r4, r0
    d9a6:	bl	f090 <__mcmp>
    d9aa:	cmp	r0, #0
    d9ac:	blt.n	da0c <quorem+0x11c>
    d9ae:	add.w	r9, r9, #1
    d9b2:	mov	r5, fp
    d9b4:	movs	r3, #0
    d9b6:	ldr.w	r1, [r7], #4
    d9ba:	ldr	r0, [r5, #0]
    d9bc:	uxth	r2, r1
    d9be:	subs	r2, r3, r2
    d9c0:	lsrs	r1, r1, #16
    d9c2:	uxtah	r2, r2, r0
    d9c6:	rsb	r3, r1, r0, lsr #16
    d9ca:	add.w	r3, r3, r2, asr #16
    d9ce:	uxth	r1, r2
    d9d0:	orr.w	r1, r1, r3, lsl #16
    d9d4:	cmp	sl, r7
    d9d6:	str.w	r1, [r5], #4
    d9da:	mov.w	r3, r3, asr #16
    d9de:	bcs.n	d9b6 <quorem+0xc6>
    d9e0:	ldr.w	r2, [fp, r8, lsl #2]
    d9e4:	add.w	r3, fp, r8, lsl #2
    d9e8:	cbnz	r2, da0c <quorem+0x11c>
    d9ea:	subs	r2, r3, #4
    d9ec:	cmp	fp, r2
    d9ee:	bcs.n	da08 <quorem+0x118>
    d9f0:	ldr.w	r2, [r3, #-4]
    d9f4:	cbnz	r2, da08 <quorem+0x118>
    d9f6:	subs	r3, #8
    d9f8:	b.n	da00 <quorem+0x110>
    d9fa:	ldr	r2, [r3, #0]
    d9fc:	subs	r3, #4
    d9fe:	cbnz	r2, da08 <quorem+0x118>
    da00:	cmp	fp, r3
    da02:	add.w	r8, r8, #4294967295
    da06:	bcc.n	d9fa <quorem+0x10a>
    da08:	str.w	r8, [r4, #16]
    da0c:	mov	r0, r9
    da0e:	add	sp, #12
    da10:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    da14:	movs	r0, #0
    da16:	bx	lr

0000da18 <_dtoa_r>:
    da18:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    da1c:	vmov	r6, r7, d0
    da20:	sub	sp, #108	; 0x6c
    da22:	ldr	r4, [r0, #64]	; 0x40
    da24:	ldr	r5, [sp, #144]	; 0x90
    da26:	str	r1, [sp, #0]
    da28:	mov	r9, r0
    da2a:	str	r2, [sp, #20]
    da2c:	str	r3, [sp, #12]
    da2e:	vmov	sl, s0
    da32:	mov	fp, r7
    da34:	cbz	r4, da4c <_dtoa_r+0x34>
    da36:	ldr	r2, [r0, #68]	; 0x44
    da38:	str	r2, [r4, #4]
    da3a:	movs	r3, #1
    da3c:	lsls	r3, r2
    da3e:	str	r3, [r4, #8]
    da40:	mov	r1, r4
    da42:	bl	eccc <_Bfree>
    da46:	movs	r3, #0
    da48:	str.w	r3, [r9, #64]	; 0x40
    da4c:	cmp.w	fp, #0
    da50:	mov	r4, fp
    da52:	blt.n	dabe <_dtoa_r+0xa6>
    da54:	movs	r3, #0
    da56:	str	r3, [r5, #0]
    da58:	ldr	r3, [pc, #644]	; (dce0 <_dtoa_r+0x2c8>)
    da5a:	mov	r2, r3
    da5c:	ands	r3, r4
    da5e:	cmp	r3, r2
    da60:	beq.n	da90 <_dtoa_r+0x78>
    da62:	movs	r2, #0
    da64:	movs	r3, #0
    da66:	mov	r0, sl
    da68:	mov	r1, fp
    da6a:	bl	acb0 <__aeabi_dcmpeq>
    da6e:	mov	r6, sl
    da70:	mov	r7, fp
    da72:	mov	r8, r0
    da74:	cbz	r0, daca <_dtoa_r+0xb2>
    da76:	ldr	r2, [sp, #12]
    da78:	movs	r3, #1
    da7a:	str	r3, [r2, #0]
    da7c:	ldr	r3, [sp, #148]	; 0x94
    da7e:	cmp	r3, #0
    da80:	beq.w	dc00 <_dtoa_r+0x1e8>
    da84:	ldr	r0, [pc, #604]	; (dce4 <_dtoa_r+0x2cc>)
    da86:	str	r0, [r3, #0]
    da88:	subs	r0, #1
    da8a:	add	sp, #108	; 0x6c
    da8c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    da90:	ldr	r2, [sp, #12]
    da92:	movw	r3, #9999	; 0x270f
    da96:	str	r3, [r2, #0]
    da98:	cmp.w	sl, #0
    da9c:	beq.w	dbd4 <_dtoa_r+0x1bc>
    daa0:	ldr	r0, [pc, #580]	; (dce8 <_dtoa_r+0x2d0>)
    daa2:	ldr	r3, [sp, #148]	; 0x94
    daa4:	cmp	r3, #0
    daa6:	beq.n	da8a <_dtoa_r+0x72>
    daa8:	ldrb	r3, [r0, #3]
    daaa:	cmp	r3, #0
    daac:	beq.w	dc04 <_dtoa_r+0x1ec>
    dab0:	add.w	r3, r0, #8
    dab4:	ldr	r2, [sp, #148]	; 0x94
    dab6:	str	r3, [r2, #0]
    dab8:	add	sp, #108	; 0x6c
    daba:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    dabe:	movs	r3, #1
    dac0:	bic.w	r4, fp, #2147483648	; 0x80000000
    dac4:	str	r3, [r5, #0]
    dac6:	mov	fp, r4
    dac8:	b.n	da58 <_dtoa_r+0x40>
    daca:	add	r2, sp, #96	; 0x60
    dacc:	add	r1, sp, #100	; 0x64
    dace:	vmov	d0, r6, r7
    dad2:	mov	r0, r9
    dad4:	bl	f1e8 <__d2b>
    dad8:	lsrs	r5, r4, #20
    dada:	str	r0, [sp, #40]	; 0x28
    dadc:	bne.w	dbe6 <_dtoa_r+0x1ce>
    dae0:	ldr	r5, [sp, #96]	; 0x60
    dae2:	ldr	r6, [sp, #100]	; 0x64
    dae4:	add	r6, r5
    dae6:	addw	r3, r6, #1074	; 0x432
    daea:	cmp	r3, #32
    daec:	ble.w	e000 <_dtoa_r+0x5e8>
    daf0:	rsb	r3, r3, #64	; 0x40
    daf4:	addw	r0, r6, #1042	; 0x412
    daf8:	lsls	r4, r3
    dafa:	lsr.w	r0, sl, r0
    dafe:	orrs	r0, r4
    db00:	bl	a6f4 <__aeabi_ui2d>
    db04:	movs	r3, #1
    db06:	subs	r4, r6, #1
    db08:	sub.w	r1, r1, #32505856	; 0x1f00000
    db0c:	str	r3, [sp, #60]	; 0x3c
    db0e:	movs	r2, #0
    db10:	ldr	r3, [pc, #472]	; (dcec <_dtoa_r+0x2d4>)
    db12:	bl	a478 <__aeabi_dsub>
    db16:	add	r3, pc, #432	; (adr r3, dcc8 <_dtoa_r+0x2b0>)
    db18:	ldrd	r2, r3, [r3]
    db1c:	bl	a7e0 <__aeabi_dmul>
    db20:	add	r3, pc, #428	; (adr r3, dcd0 <_dtoa_r+0x2b8>)
    db22:	ldrd	r2, r3, [r3]
    db26:	bl	a47c <__adddf3>
    db2a:	mov	r6, r0
    db2c:	mov	r0, r4
    db2e:	mov	r7, r1
    db30:	bl	a714 <__aeabi_i2d>
    db34:	add	r3, pc, #416	; (adr r3, dcd8 <_dtoa_r+0x2c0>)
    db36:	ldrd	r2, r3, [r3]
    db3a:	bl	a7e0 <__aeabi_dmul>
    db3e:	mov	r2, r0
    db40:	mov	r3, r1
    db42:	mov	r0, r6
    db44:	mov	r1, r7
    db46:	bl	a47c <__adddf3>
    db4a:	mov	r6, r0
    db4c:	mov	r7, r1
    db4e:	bl	f464 <__aeabi_d2iz>
    db52:	movs	r2, #0
    db54:	str	r0, [sp, #16]
    db56:	movs	r3, #0
    db58:	mov	r0, r6
    db5a:	mov	r1, r7
    db5c:	bl	acc4 <__aeabi_dcmplt>
    db60:	cmp	r0, #0
    db62:	bne.w	dfb6 <_dtoa_r+0x59e>
    db66:	ldr	r6, [sp, #16]
    db68:	cmp	r6, #22
    db6a:	bhi.w	dfb0 <_dtoa_r+0x598>
    db6e:	ldr	r3, [pc, #384]	; (dcf0 <_dtoa_r+0x2d8>)
    db70:	add.w	r3, r3, r6, lsl #3
    db74:	ldrd	r0, r1, [r3]
    db78:	mov	r2, sl
    db7a:	mov	r3, fp
    db7c:	bl	ad00 <__aeabi_dcmpgt>
    db80:	cmp	r0, #0
    db82:	beq.w	e00a <_dtoa_r+0x5f2>
    db86:	subs	r3, r6, #1
    db88:	str	r3, [sp, #16]
    db8a:	movs	r3, #0
    db8c:	str	r3, [sp, #52]	; 0x34
    db8e:	subs	r5, r5, r4
    db90:	subs.w	r8, r5, #1
    db94:	bmi.w	dfec <_dtoa_r+0x5d4>
    db98:	movs	r3, #0
    db9a:	str	r3, [sp, #28]
    db9c:	ldr	r3, [sp, #16]
    db9e:	cmp	r3, #0
    dba0:	blt.w	dfda <_dtoa_r+0x5c2>
    dba4:	add	r8, r3
    dba6:	str	r3, [sp, #48]	; 0x30
    dba8:	movs	r3, #0
    dbaa:	str	r3, [sp, #24]
    dbac:	ldr	r3, [sp, #0]
    dbae:	cmp	r3, #9
    dbb0:	bhi.n	dc08 <_dtoa_r+0x1f0>
    dbb2:	cmp	r3, #5
    dbb4:	ble.w	e840 <_dtoa_r+0xe28>
    dbb8:	subs	r3, #4
    dbba:	str	r3, [sp, #0]
    dbbc:	movs	r6, #0
    dbbe:	ldr	r3, [sp, #0]
    dbc0:	subs	r3, #2
    dbc2:	cmp	r3, #3
    dbc4:	bhi.w	e80e <_dtoa_r+0xdf6>
    dbc8:	tbh	[pc, r3, lsl #1]
    dbcc:	.word	0x0224032b
    dbd0:	.word	0x04500336
    dbd4:	ldr	r3, [pc, #272]	; (dce8 <_dtoa_r+0x2d0>)
    dbd6:	ldr	r2, [pc, #284]	; (dcf4 <_dtoa_r+0x2dc>)
    dbd8:	ubfx	r0, r4, #0, #20
    dbdc:	cmp	r0, #0
    dbde:	ite	ne
    dbe0:	movne	r0, r3
    dbe2:	moveq	r0, r2
    dbe4:	b.n	daa2 <_dtoa_r+0x8a>
    dbe6:	ubfx	r3, fp, #0, #20
    dbea:	orr.w	r1, r3, #1069547520	; 0x3fc00000
    dbee:	subw	r4, r5, #1023	; 0x3ff
    dbf2:	mov	r0, sl
    dbf4:	str.w	r8, [sp, #60]	; 0x3c
    dbf8:	orr.w	r1, r1, #3145728	; 0x300000
    dbfc:	ldr	r5, [sp, #96]	; 0x60
    dbfe:	b.n	db0e <_dtoa_r+0xf6>
    dc00:	ldr	r0, [pc, #244]	; (dcf8 <_dtoa_r+0x2e0>)
    dc02:	b.n	da8a <_dtoa_r+0x72>
    dc04:	adds	r3, r0, #3
    dc06:	b.n	dab4 <_dtoa_r+0x9c>
    dc08:	movs	r1, #0
    dc0a:	str.w	r1, [r9, #68]	; 0x44
    dc0e:	mov	r0, r9
    dc10:	mov	r4, r1
    dc12:	str	r1, [sp, #0]
    dc14:	bl	ec80 <_Balloc>
    dc18:	mov.w	r3, #4294967295
    dc1c:	str	r3, [sp, #32]
    dc1e:	str	r3, [sp, #56]	; 0x38
    dc20:	movs	r3, #1
    dc22:	str	r0, [sp, #36]	; 0x24
    dc24:	str.w	r0, [r9, #64]	; 0x40
    dc28:	str	r4, [sp, #20]
    dc2a:	str	r3, [sp, #44]	; 0x2c
    dc2c:	ldr	r3, [sp, #100]	; 0x64
    dc2e:	cmp	r3, #0
    dc30:	blt.w	ddd4 <_dtoa_r+0x3bc>
    dc34:	ldr	r2, [sp, #16]
    dc36:	cmp	r2, #14
    dc38:	bgt.w	ddd4 <_dtoa_r+0x3bc>
    dc3c:	ldr	r3, [pc, #176]	; (dcf0 <_dtoa_r+0x2d8>)
    dc3e:	add.w	r3, r3, r2, lsl #3
    dc42:	vldr	d7, [r3]
    dc46:	ldr	r3, [sp, #20]
    dc48:	cmp	r3, #0
    dc4a:	vstr	d7, [sp]
    dc4e:	blt.w	e24e <_dtoa_r+0x836>
    dc52:	mov	r6, sl
    dc54:	mov	r7, fp
    dc56:	ldrd	sl, fp, [sp]
    dc5a:	mov	r0, r6
    dc5c:	mov	r2, sl
    dc5e:	mov	r3, fp
    dc60:	mov	r1, r7
    dc62:	bl	aa34 <__aeabi_ddiv>
    dc66:	bl	f464 <__aeabi_d2iz>
    dc6a:	mov	r4, r0
    dc6c:	bl	a714 <__aeabi_i2d>
    dc70:	mov	r2, sl
    dc72:	mov	r3, fp
    dc74:	bl	a7e0 <__aeabi_dmul>
    dc78:	mov	r3, r1
    dc7a:	mov	r2, r0
    dc7c:	mov	r1, r7
    dc7e:	mov	r0, r6
    dc80:	bl	a478 <__aeabi_dsub>
    dc84:	ldr	r5, [sp, #36]	; 0x24
    dc86:	add.w	r3, r4, #48	; 0x30
    dc8a:	strb	r3, [r5, #0]
    dc8c:	ldr	r3, [sp, #32]
    dc8e:	cmp	r3, #1
    dc90:	mov	r6, r0
    dc92:	mov	r7, r1
    dc94:	add.w	r5, r5, #1
    dc98:	beq.n	dd5e <_dtoa_r+0x346>
    dc9a:	movs	r2, #0
    dc9c:	ldr	r3, [pc, #92]	; (dcfc <_dtoa_r+0x2e4>)
    dc9e:	bl	a7e0 <__aeabi_dmul>
    dca2:	movs	r2, #0
    dca4:	movs	r3, #0
    dca6:	mov	r6, r0
    dca8:	mov	r7, r1
    dcaa:	bl	acb0 <__aeabi_dcmpeq>
    dcae:	cmp	r0, #0
    dcb0:	bne.n	ddae <_dtoa_r+0x396>
    dcb2:	str.w	r9, [sp, #20]
    dcb6:	ldr.w	sl, [sp, #32]
    dcba:	ldr.w	fp, [sp, #36]	; 0x24
    dcbe:	ldrd	r8, r9, [sp]
    dcc2:	b.n	dd16 <_dtoa_r+0x2fe>
    dcc4:	nop.w
    dcc8:	.word	0x636f4361
    dccc:	.word	0x3fd287a7
    dcd0:	.word	0x8b60c8b3
    dcd4:	.word	0x3fc68a28
    dcd8:	.word	0x509f79fb
    dcdc:	.word	0x3fd34413
    dce0:	.word	0x7ff00000
    dce4:	.word	0x200004d9
    dce8:	.word	0x20000a70
    dcec:	.word	0x3ff80000
    dcf0:	.word	0x20000a78
    dcf4:	.word	0x20000a64
    dcf8:	.word	0x200004d8
    dcfc:	.word	0x40240000
    dd00:	bl	a7e0 <__aeabi_dmul>
    dd04:	movs	r2, #0
    dd06:	movs	r3, #0
    dd08:	mov	r6, r0
    dd0a:	mov	r7, r1
    dd0c:	bl	acb0 <__aeabi_dcmpeq>
    dd10:	cmp	r0, #0
    dd12:	bne.w	e472 <_dtoa_r+0xa5a>
    dd16:	mov	r2, r8
    dd18:	mov	r3, r9
    dd1a:	mov	r0, r6
    dd1c:	mov	r1, r7
    dd1e:	bl	aa34 <__aeabi_ddiv>
    dd22:	bl	f464 <__aeabi_d2iz>
    dd26:	mov	r4, r0
    dd28:	bl	a714 <__aeabi_i2d>
    dd2c:	mov	r2, r8
    dd2e:	mov	r3, r9
    dd30:	bl	a7e0 <__aeabi_dmul>
    dd34:	mov	r2, r0
    dd36:	mov	r3, r1
    dd38:	mov	r0, r6
    dd3a:	mov	r1, r7
    dd3c:	bl	a478 <__aeabi_dsub>
    dd40:	add.w	lr, r4, #48	; 0x30
    dd44:	strb.w	lr, [r5], #1
    dd48:	rsb	lr, fp, r5
    dd4c:	cmp	lr, sl
    dd4e:	mov	r6, r0
    dd50:	mov	r7, r1
    dd52:	mov.w	r2, #0
    dd56:	ldr	r3, [pc, #696]	; (e010 <_dtoa_r+0x5f8>)
    dd58:	bne.n	dd00 <_dtoa_r+0x2e8>
    dd5a:	ldr.w	r9, [sp, #20]
    dd5e:	mov	r2, r6
    dd60:	mov	r3, r7
    dd62:	mov	r0, r6
    dd64:	mov	r1, r7
    dd66:	bl	a47c <__adddf3>
    dd6a:	mov	r6, r0
    dd6c:	mov	r7, r1
    dd6e:	mov	r2, r0
    dd70:	mov	r3, r1
    dd72:	ldrd	r0, r1, [sp]
    dd76:	bl	acc4 <__aeabi_dcmplt>
    dd7a:	cbnz	r0, dd8e <_dtoa_r+0x376>
    dd7c:	mov	r2, r6
    dd7e:	mov	r3, r7
    dd80:	ldrd	r0, r1, [sp]
    dd84:	bl	acb0 <__aeabi_dcmpeq>
    dd88:	cbz	r0, ddae <_dtoa_r+0x396>
    dd8a:	lsls	r3, r4, #31
    dd8c:	bpl.n	ddae <_dtoa_r+0x396>
    dd8e:	ldrb.w	r4, [r5, #-1]
    dd92:	ldr	r2, [sp, #36]	; 0x24
    dd94:	subs	r3, r5, #1
    dd96:	b.n	dda2 <_dtoa_r+0x38a>
    dd98:	cmp	r2, r3
    dd9a:	beq.w	e596 <_dtoa_r+0xb7e>
    dd9e:	ldrb.w	r4, [r3, #-1]!
    dda2:	cmp	r4, #57	; 0x39
    dda4:	add.w	r5, r3, #1
    dda8:	beq.n	dd98 <_dtoa_r+0x380>
    ddaa:	adds	r4, #1
    ddac:	strb	r4, [r3, #0]
    ddae:	ldr	r1, [sp, #40]	; 0x28
    ddb0:	mov	r0, r9
    ddb2:	bl	eccc <_Bfree>
    ddb6:	movs	r2, #0
    ddb8:	ldr	r3, [sp, #16]
    ddba:	strb	r2, [r5, #0]
    ddbc:	ldr	r2, [sp, #12]
    ddbe:	adds	r3, #1
    ddc0:	str	r3, [r2, #0]
    ddc2:	ldr	r3, [sp, #148]	; 0x94
    ddc4:	cmp	r3, #0
    ddc6:	beq.w	e500 <_dtoa_r+0xae8>
    ddca:	ldr	r0, [sp, #36]	; 0x24
    ddcc:	str	r5, [r3, #0]
    ddce:	add	sp, #108	; 0x6c
    ddd0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ddd4:	ldr	r2, [sp, #44]	; 0x2c
    ddd6:	cmp	r2, #0
    ddd8:	beq.w	dff8 <_dtoa_r+0x5e0>
    dddc:	ldr	r2, [sp, #0]
    ddde:	cmp	r2, #1
    dde0:	ble.w	e292 <_dtoa_r+0x87a>
    dde4:	ldr	r3, [sp, #32]
    dde6:	ldr	r2, [sp, #24]
    dde8:	subs	r7, r3, #1
    ddea:	cmp	r2, r7
    ddec:	blt.w	e506 <_dtoa_r+0xaee>
    ddf0:	subs	r7, r2, r7
    ddf2:	ldr	r3, [sp, #32]
    ddf4:	cmp	r3, #0
    ddf6:	blt.w	e6fa <_dtoa_r+0xce2>
    ddfa:	ldr	r5, [sp, #28]
    ddfc:	ldr	r3, [sp, #32]
    ddfe:	ldr	r2, [sp, #28]
    de00:	movs	r1, #1
    de02:	add	r2, r3
    de04:	mov	r0, r9
    de06:	str	r2, [sp, #28]
    de08:	add	r8, r3
    de0a:	bl	edfc <__i2b>
    de0e:	mov	r6, r0
    de10:	cbz	r5, de2c <_dtoa_r+0x414>
    de12:	cmp.w	r8, #0
    de16:	ble.n	de2c <_dtoa_r+0x414>
    de18:	cmp	r5, r8
    de1a:	ldr	r2, [sp, #28]
    de1c:	mov	r3, r5
    de1e:	it	ge
    de20:	movge	r3, r8
    de22:	subs	r2, r2, r3
    de24:	str	r2, [sp, #28]
    de26:	subs	r5, r5, r3
    de28:	rsb	r8, r3, r8
    de2c:	ldr	r3, [sp, #24]
    de2e:	cmp	r3, #0
    de30:	ble.w	e41e <_dtoa_r+0xa06>
    de34:	ldr	r2, [sp, #44]	; 0x2c
    de36:	cmp	r2, #0
    de38:	beq.w	e240 <_dtoa_r+0x828>
    de3c:	cmp	r7, #0
    de3e:	beq.w	e240 <_dtoa_r+0x828>
    de42:	mov	r1, r6
    de44:	mov	r2, r7
    de46:	mov	r0, r9
    de48:	bl	ef40 <__pow5mult>
    de4c:	ldr	r2, [sp, #40]	; 0x28
    de4e:	mov	r1, r0
    de50:	mov	r6, r0
    de52:	mov	r0, r9
    de54:	bl	ee10 <__multiply>
    de58:	ldr	r1, [sp, #40]	; 0x28
    de5a:	mov	r4, r0
    de5c:	mov	r0, r9
    de5e:	bl	eccc <_Bfree>
    de62:	ldr	r3, [sp, #24]
    de64:	subs	r3, r3, r7
    de66:	str	r3, [sp, #24]
    de68:	bne.w	e23e <_dtoa_r+0x826>
    de6c:	movs	r1, #1
    de6e:	mov	r0, r9
    de70:	bl	edfc <__i2b>
    de74:	ldr	r3, [sp, #48]	; 0x30
    de76:	str	r0, [sp, #24]
    de78:	cmp	r3, #0
    de7a:	beq.w	e2a8 <_dtoa_r+0x890>
    de7e:	mov	r1, r0
    de80:	mov	r2, r3
    de82:	mov	r0, r9
    de84:	bl	ef40 <__pow5mult>
    de88:	ldr	r3, [sp, #0]
    de8a:	str	r0, [sp, #24]
    de8c:	cmp	r3, #1
    de8e:	ble.w	e478 <_dtoa_r+0xa60>
    de92:	movs	r7, #0
    de94:	ldr	r2, [sp, #24]
    de96:	ldr	r3, [r2, #16]
    de98:	add.w	r3, r2, r3, lsl #2
    de9c:	ldr	r0, [r3, #16]
    de9e:	bl	ed60 <__hi0bits>
    dea2:	rsb	r0, r0, #32
    dea6:	add	r0, r8
    dea8:	ands.w	r0, r0, #31
    deac:	beq.w	e2a4 <_dtoa_r+0x88c>
    deb0:	rsb	r3, r0, #32
    deb4:	cmp	r3, #4
    deb6:	ble.w	e834 <_dtoa_r+0xe1c>
    deba:	rsb	r0, r0, #28
    debe:	ldr	r3, [sp, #28]
    dec0:	add	r3, r0
    dec2:	str	r3, [sp, #28]
    dec4:	add	r5, r0
    dec6:	add	r8, r0
    dec8:	ldr	r3, [sp, #28]
    deca:	cmp	r3, #0
    decc:	ble.n	deda <_dtoa_r+0x4c2>
    dece:	mov	r1, r4
    ded0:	mov	r2, r3
    ded2:	mov	r0, r9
    ded4:	bl	efe0 <__lshift>
    ded8:	mov	r4, r0
    deda:	cmp.w	r8, #0
    dede:	ble.n	deec <_dtoa_r+0x4d4>
    dee0:	mov	r2, r8
    dee2:	ldr	r1, [sp, #24]
    dee4:	mov	r0, r9
    dee6:	bl	efe0 <__lshift>
    deea:	str	r0, [sp, #24]
    deec:	ldr	r3, [sp, #52]	; 0x34
    deee:	cmp	r3, #0
    def0:	bne.w	e3e8 <_dtoa_r+0x9d0>
    def4:	ldr	r3, [sp, #32]
    def6:	cmp	r3, #0
    def8:	ble.w	e422 <_dtoa_r+0xa0a>
    defc:	ldr	r3, [sp, #44]	; 0x2c
    defe:	cmp	r3, #0
    df00:	bne.w	e2ec <_dtoa_r+0x8d4>
    df04:	ldr.w	fp, [sp, #36]	; 0x24
    df08:	ldr	r7, [sp, #32]
    df0a:	ldr.w	r8, [sp, #24]
    df0e:	mov	r5, fp
    df10:	b.n	df18 <_dtoa_r+0x500>
    df12:	bl	ece0 <__multadd>
    df16:	mov	r4, r0
    df18:	mov	r1, r8
    df1a:	mov	r0, r4
    df1c:	bl	d8f0 <quorem>
    df20:	add.w	sl, r0, #48	; 0x30
    df24:	strb.w	sl, [r5], #1
    df28:	rsb	r3, fp, r5
    df2c:	cmp	r3, r7
    df2e:	mov.w	r2, #10
    df32:	mov.w	r3, #0
    df36:	mov	r1, r4
    df38:	mov	r0, r9
    df3a:	blt.n	df12 <_dtoa_r+0x4fa>
    df3c:	ldr	r3, [sp, #36]	; 0x24
    df3e:	ldr	r2, [sp, #32]
    df40:	cmp	r2, #1
    df42:	ite	ge
    df44:	addge	r3, r3, r2
    df46:	addlt	r3, #1
    df48:	mov	r5, r3
    df4a:	mov.w	fp, #0
    df4e:	mov	r1, r4
    df50:	movs	r2, #1
    df52:	mov	r0, r9
    df54:	bl	efe0 <__lshift>
    df58:	ldr	r1, [sp, #24]
    df5a:	str	r0, [sp, #40]	; 0x28
    df5c:	bl	f090 <__mcmp>
    df60:	cmp	r0, #0
    df62:	ble.w	e570 <_dtoa_r+0xb58>
    df66:	ldrb.w	r2, [r5, #-1]
    df6a:	ldr	r1, [sp, #36]	; 0x24
    df6c:	subs	r3, r5, #1
    df6e:	b.n	df7a <_dtoa_r+0x562>
    df70:	cmp	r3, r1
    df72:	beq.w	e45e <_dtoa_r+0xa46>
    df76:	ldrb.w	r2, [r3, #-1]!
    df7a:	cmp	r2, #57	; 0x39
    df7c:	add.w	r5, r3, #1
    df80:	beq.n	df70 <_dtoa_r+0x558>
    df82:	adds	r2, #1
    df84:	strb	r2, [r3, #0]
    df86:	ldr	r1, [sp, #24]
    df88:	mov	r0, r9
    df8a:	bl	eccc <_Bfree>
    df8e:	cmp	r6, #0
    df90:	beq.w	ddae <_dtoa_r+0x396>
    df94:	cmp.w	fp, #0
    df98:	beq.n	dfa6 <_dtoa_r+0x58e>
    df9a:	cmp	fp, r6
    df9c:	beq.n	dfa6 <_dtoa_r+0x58e>
    df9e:	mov	r1, fp
    dfa0:	mov	r0, r9
    dfa2:	bl	eccc <_Bfree>
    dfa6:	mov	r1, r6
    dfa8:	mov	r0, r9
    dfaa:	bl	eccc <_Bfree>
    dfae:	b.n	ddae <_dtoa_r+0x396>
    dfb0:	movs	r3, #1
    dfb2:	str	r3, [sp, #52]	; 0x34
    dfb4:	b.n	db8e <_dtoa_r+0x176>
    dfb6:	ldr.w	r8, [sp, #16]
    dfba:	mov	r0, r8
    dfbc:	bl	a714 <__aeabi_i2d>
    dfc0:	mov	r2, r0
    dfc2:	mov	r3, r1
    dfc4:	mov	r0, r6
    dfc6:	mov	r1, r7
    dfc8:	bl	acb0 <__aeabi_dcmpeq>
    dfcc:	cmp	r0, #0
    dfce:	bne.w	db66 <_dtoa_r+0x14e>
    dfd2:	add.w	r3, r8, #4294967295
    dfd6:	str	r3, [sp, #16]
    dfd8:	b.n	db66 <_dtoa_r+0x14e>
    dfda:	ldr	r2, [sp, #28]
    dfdc:	ldr	r3, [sp, #16]
    dfde:	subs	r2, r2, r3
    dfe0:	negs	r3, r3
    dfe2:	str	r3, [sp, #24]
    dfe4:	movs	r3, #0
    dfe6:	str	r2, [sp, #28]
    dfe8:	str	r3, [sp, #48]	; 0x30
    dfea:	b.n	dbac <_dtoa_r+0x194>
    dfec:	rsb	r3, r8, #0
    dff0:	str	r3, [sp, #28]
    dff2:	mov.w	r8, #0
    dff6:	b.n	db9c <_dtoa_r+0x184>
    dff8:	ldr	r7, [sp, #24]
    dffa:	ldr	r5, [sp, #28]
    dffc:	ldr	r6, [sp, #44]	; 0x2c
    dffe:	b.n	de10 <_dtoa_r+0x3f8>
    e000:	rsb	r4, r3, #32
    e004:	lsl.w	r0, sl, r4
    e008:	b.n	db00 <_dtoa_r+0xe8>
    e00a:	str	r0, [sp, #52]	; 0x34
    e00c:	b.n	db8e <_dtoa_r+0x176>
    e00e:	nop
    e010:	.word	0x40240000
    e014:	movs	r3, #0
    e016:	str	r3, [sp, #44]	; 0x2c
    e018:	ldr	r3, [sp, #16]
    e01a:	ldr	r2, [sp, #20]
    e01c:	add	r3, r2
    e01e:	str	r3, [sp, #56]	; 0x38
    e020:	adds	r3, #1
    e022:	cmp	r3, #0
    e024:	str	r3, [sp, #32]
    e026:	ble.w	e524 <_dtoa_r+0xb0c>
    e02a:	ldr	r4, [sp, #32]
    e02c:	mov	r5, r4
    e02e:	movs	r1, #0
    e030:	cmp	r5, #23
    e032:	str.w	r1, [r9, #68]	; 0x44
    e036:	bls.n	e050 <_dtoa_r+0x638>
    e038:	movs	r2, #1
    e03a:	movs	r3, #4
    e03c:	lsls	r3, r3, #1
    e03e:	add.w	r0, r3, #20
    e042:	cmp	r0, r5
    e044:	mov	r1, r2
    e046:	add.w	r2, r2, #1
    e04a:	bls.n	e03c <_dtoa_r+0x624>
    e04c:	str.w	r1, [r9, #68]	; 0x44
    e050:	mov	r0, r9
    e052:	bl	ec80 <_Balloc>
    e056:	cmp	r4, #14
    e058:	str	r0, [sp, #36]	; 0x24
    e05a:	str.w	r0, [r9, #64]	; 0x40
    e05e:	bhi.w	dc2c <_dtoa_r+0x214>
    e062:	cmp	r6, #0
    e064:	beq.w	dc2c <_dtoa_r+0x214>
    e068:	ldr	r1, [sp, #16]
    e06a:	cmp	r1, #0
    e06c:	strd	sl, fp, [sp, #64]	; 0x40
    e070:	ble.w	e5a8 <_dtoa_r+0xb90>
    e074:	ldr	r3, [pc, #576]	; (e2b8 <_dtoa_r+0x8a0>)
    e076:	and.w	r2, r1, #15
    e07a:	asrs	r6, r1, #4
    e07c:	add.w	r3, r3, r2, lsl #3
    e080:	lsls	r0, r6, #27
    e082:	ldrd	r4, r5, [r3]
    e086:	bpl.w	e516 <_dtoa_r+0xafe>
    e08a:	ldr	r3, [pc, #560]	; (e2bc <_dtoa_r+0x8a4>)
    e08c:	mov	r0, sl
    e08e:	mov	r1, fp
    e090:	ldrd	r2, r3, [r3, #32]
    e094:	bl	aa34 <__aeabi_ddiv>
    e098:	strd	r0, r1, [sp, #72]	; 0x48
    e09c:	and.w	r6, r6, #15
    e0a0:	mov.w	sl, #3
    e0a4:	cbz	r6, e0c8 <_dtoa_r+0x6b0>
    e0a6:	ldr	r7, [pc, #532]	; (e2bc <_dtoa_r+0x8a4>)
    e0a8:	lsls	r1, r6, #31
    e0aa:	bpl.n	e0c0 <_dtoa_r+0x6a8>
    e0ac:	mov	r0, r4
    e0ae:	mov	r1, r5
    e0b0:	ldrd	r2, r3, [r7]
    e0b4:	bl	a7e0 <__aeabi_dmul>
    e0b8:	add.w	sl, sl, #1
    e0bc:	mov	r4, r0
    e0be:	mov	r5, r1
    e0c0:	asrs	r6, r6, #1
    e0c2:	add.w	r7, r7, #8
    e0c6:	bne.n	e0a8 <_dtoa_r+0x690>
    e0c8:	mov	r2, r4
    e0ca:	mov	r3, r5
    e0cc:	ldrd	r0, r1, [sp, #72]	; 0x48
    e0d0:	bl	aa34 <__aeabi_ddiv>
    e0d4:	mov	r6, r0
    e0d6:	mov	r7, r1
    e0d8:	ldr	r3, [sp, #52]	; 0x34
    e0da:	cbz	r3, e0ee <_dtoa_r+0x6d6>
    e0dc:	movs	r2, #0
    e0de:	ldr	r3, [pc, #480]	; (e2c0 <_dtoa_r+0x8a8>)
    e0e0:	mov	r0, r6
    e0e2:	mov	r1, r7
    e0e4:	bl	acc4 <__aeabi_dcmplt>
    e0e8:	cmp	r0, #0
    e0ea:	bne.w	e722 <_dtoa_r+0xd0a>
    e0ee:	mov	r0, sl
    e0f0:	bl	a714 <__aeabi_i2d>
    e0f4:	mov	r2, r6
    e0f6:	mov	r3, r7
    e0f8:	bl	a7e0 <__aeabi_dmul>
    e0fc:	ldr	r3, [pc, #452]	; (e2c4 <_dtoa_r+0x8ac>)
    e0fe:	movs	r2, #0
    e100:	bl	a47c <__adddf3>
    e104:	ldr	r3, [sp, #32]
    e106:	mov	r4, r0
    e108:	sub.w	r5, r1, #54525952	; 0x3400000
    e10c:	cmp	r3, #0
    e10e:	beq.w	e4c8 <_dtoa_r+0xab0>
    e112:	ldr	r3, [sp, #16]
    e114:	str	r3, [sp, #88]	; 0x58
    e116:	ldr	r3, [sp, #32]
    e118:	str	r3, [sp, #72]	; 0x48
    e11a:	ldr	r3, [sp, #44]	; 0x2c
    e11c:	cmp	r3, #0
    e11e:	beq.w	e64a <_dtoa_r+0xc32>
    e122:	ldr	r2, [sp, #72]	; 0x48
    e124:	ldr	r3, [pc, #400]	; (e2b8 <_dtoa_r+0x8a0>)
    e126:	ldr	r1, [pc, #416]	; (e2c8 <_dtoa_r+0x8b0>)
    e128:	add.w	r3, r3, r2, lsl #3
    e12c:	ldrd	r2, r3, [r3, #-8]
    e130:	movs	r0, #0
    e132:	bl	aa34 <__aeabi_ddiv>
    e136:	mov	r2, r4
    e138:	mov	r3, r5
    e13a:	bl	a478 <__aeabi_dsub>
    e13e:	mov	sl, r0
    e140:	mov	fp, r1
    e142:	mov	r0, r6
    e144:	mov	r1, r7
    e146:	bl	f464 <__aeabi_d2iz>
    e14a:	mov	r4, r0
    e14c:	bl	a714 <__aeabi_i2d>
    e150:	mov	r2, r0
    e152:	mov	r3, r1
    e154:	mov	r0, r6
    e156:	mov	r1, r7
    e158:	bl	a478 <__aeabi_dsub>
    e15c:	adds	r4, #48	; 0x30
    e15e:	ldr	r5, [sp, #36]	; 0x24
    e160:	uxtb	r4, r4
    e162:	mov	r6, r0
    e164:	mov	r7, r1
    e166:	strb	r4, [r5, #0]
    e168:	mov	r2, r0
    e16a:	mov	r3, r1
    e16c:	mov	r0, sl
    e16e:	mov	r1, fp
    e170:	adds	r5, #1
    e172:	bl	ad00 <__aeabi_dcmpgt>
    e176:	cmp	r0, #0
    e178:	bne.n	e21c <_dtoa_r+0x804>
    e17a:	mov	r2, r6
    e17c:	mov	r3, r7
    e17e:	movs	r0, #0
    e180:	ldr	r1, [pc, #316]	; (e2c0 <_dtoa_r+0x8a8>)
    e182:	bl	a478 <__aeabi_dsub>
    e186:	mov	r2, r0
    e188:	mov	r3, r1
    e18a:	mov	r0, sl
    e18c:	mov	r1, fp
    e18e:	bl	ad00 <__aeabi_dcmpgt>
    e192:	cmp	r0, #0
    e194:	bne.w	e7a8 <_dtoa_r+0xd90>
    e198:	ldr	r2, [sp, #72]	; 0x48
    e19a:	cmp	r2, #1
    e19c:	ble.w	e58e <_dtoa_r+0xb76>
    e1a0:	ldr	r3, [sp, #72]	; 0x48
    e1a2:	ldr	r2, [sp, #36]	; 0x24
    e1a4:	str.w	r8, [sp, #72]	; 0x48
    e1a8:	add	r3, r2
    e1aa:	mov	r8, r3
    e1ac:	b.n	e1ca <_dtoa_r+0x7b2>
    e1ae:	movs	r0, #0
    e1b0:	ldr	r1, [pc, #268]	; (e2c0 <_dtoa_r+0x8a8>)
    e1b2:	bl	a478 <__aeabi_dsub>
    e1b6:	mov	r2, sl
    e1b8:	mov	r3, fp
    e1ba:	bl	acc4 <__aeabi_dcmplt>
    e1be:	cmp	r0, #0
    e1c0:	bne.w	e7a8 <_dtoa_r+0xd90>
    e1c4:	cmp	r5, r8
    e1c6:	beq.w	e58a <_dtoa_r+0xb72>
    e1ca:	mov	r0, sl
    e1cc:	mov	r1, fp
    e1ce:	movs	r2, #0
    e1d0:	ldr	r3, [pc, #248]	; (e2cc <_dtoa_r+0x8b4>)
    e1d2:	bl	a7e0 <__aeabi_dmul>
    e1d6:	movs	r2, #0
    e1d8:	ldr	r3, [pc, #240]	; (e2cc <_dtoa_r+0x8b4>)
    e1da:	mov	sl, r0
    e1dc:	mov	fp, r1
    e1de:	mov	r0, r6
    e1e0:	mov	r1, r7
    e1e2:	bl	a7e0 <__aeabi_dmul>
    e1e6:	mov	r7, r1
    e1e8:	mov	r6, r0
    e1ea:	bl	f464 <__aeabi_d2iz>
    e1ee:	mov	r4, r0
    e1f0:	bl	a714 <__aeabi_i2d>
    e1f4:	mov	r2, r0
    e1f6:	mov	r3, r1
    e1f8:	mov	r0, r6
    e1fa:	mov	r1, r7
    e1fc:	bl	a478 <__aeabi_dsub>
    e200:	adds	r4, #48	; 0x30
    e202:	uxtb	r4, r4
    e204:	mov	r2, sl
    e206:	mov	r3, fp
    e208:	strb.w	r4, [r5], #1
    e20c:	mov	r6, r0
    e20e:	mov	r7, r1
    e210:	bl	acc4 <__aeabi_dcmplt>
    e214:	mov	r2, r6
    e216:	mov	r3, r7
    e218:	cmp	r0, #0
    e21a:	beq.n	e1ae <_dtoa_r+0x796>
    e21c:	ldr	r3, [sp, #88]	; 0x58
    e21e:	str	r3, [sp, #16]
    e220:	b.n	ddae <_dtoa_r+0x396>
    e222:	movs	r3, #0
    e224:	str	r3, [sp, #44]	; 0x2c
    e226:	ldr	r3, [sp, #20]
    e228:	cmp	r3, #0
    e22a:	ble.w	e52e <_dtoa_r+0xb16>
    e22e:	mov	r5, r3
    e230:	mov	r4, r3
    e232:	str	r3, [sp, #56]	; 0x38
    e234:	str	r3, [sp, #32]
    e236:	b.n	e02e <_dtoa_r+0x616>
    e238:	movs	r3, #1
    e23a:	str	r3, [sp, #44]	; 0x2c
    e23c:	b.n	e226 <_dtoa_r+0x80e>
    e23e:	str	r4, [sp, #40]	; 0x28
    e240:	ldr	r2, [sp, #24]
    e242:	ldr	r1, [sp, #40]	; 0x28
    e244:	mov	r0, r9
    e246:	bl	ef40 <__pow5mult>
    e24a:	mov	r4, r0
    e24c:	b.n	de6c <_dtoa_r+0x454>
    e24e:	ldr	r3, [sp, #32]
    e250:	cmp	r3, #0
    e252:	bgt.w	dc52 <_dtoa_r+0x23a>
    e256:	bne.w	e4f8 <_dtoa_r+0xae0>
    e25a:	movs	r2, #0
    e25c:	ldr	r3, [pc, #112]	; (e2d0 <_dtoa_r+0x8b8>)
    e25e:	ldrd	r0, r1, [sp]
    e262:	bl	a7e0 <__aeabi_dmul>
    e266:	mov	r3, fp
    e268:	mov	r2, sl
    e26a:	bl	acec <__aeabi_dcmpge>
    e26e:	ldr	r3, [sp, #32]
    e270:	str	r3, [sp, #24]
    e272:	mov	r6, r3
    e274:	cmp	r0, #0
    e276:	beq.w	e44e <_dtoa_r+0xa36>
    e27a:	ldr	r3, [sp, #20]
    e27c:	ldr	r5, [sp, #36]	; 0x24
    e27e:	mvns	r3, r3
    e280:	str	r3, [sp, #16]
    e282:	ldr	r1, [sp, #24]
    e284:	mov	r0, r9
    e286:	bl	eccc <_Bfree>
    e28a:	cmp	r6, #0
    e28c:	beq.w	ddae <_dtoa_r+0x396>
    e290:	b.n	dfa6 <_dtoa_r+0x58e>
    e292:	ldr	r2, [sp, #60]	; 0x3c
    e294:	cmp	r2, #0
    e296:	beq.w	e70a <_dtoa_r+0xcf2>
    e29a:	addw	r3, r3, #1075	; 0x433
    e29e:	ldr	r7, [sp, #24]
    e2a0:	ldr	r5, [sp, #28]
    e2a2:	b.n	ddfe <_dtoa_r+0x3e6>
    e2a4:	movs	r0, #28
    e2a6:	b.n	debe <_dtoa_r+0x4a6>
    e2a8:	ldr	r3, [sp, #0]
    e2aa:	cmp	r3, #1
    e2ac:	ble.w	e7b0 <_dtoa_r+0xd98>
    e2b0:	ldr	r7, [sp, #48]	; 0x30
    e2b2:	movs	r0, #1
    e2b4:	b.n	dea6 <_dtoa_r+0x48e>
    e2b6:	nop
    e2b8:	.word	0x20000a78
    e2bc:	.word	0x20000b40
    e2c0:	.word	0x3ff00000
    e2c4:	.word	0x401c0000
    e2c8:	.word	0x3fe00000
    e2cc:	.word	0x40240000
    e2d0:	.word	0x40140000
    e2d4:	mov	r1, r6
    e2d6:	movs	r3, #0
    e2d8:	movs	r2, #10
    e2da:	mov	r0, r9
    e2dc:	bl	ece0 <__multadd>
    e2e0:	ldr	r3, [sp, #56]	; 0x38
    e2e2:	cmp	r3, #0
    e2e4:	mov	r6, r0
    e2e6:	ble.w	e804 <_dtoa_r+0xdec>
    e2ea:	str	r3, [sp, #32]
    e2ec:	cmp	r5, #0
    e2ee:	ble.n	e2fc <_dtoa_r+0x8e4>
    e2f0:	mov	r1, r6
    e2f2:	mov	r2, r5
    e2f4:	mov	r0, r9
    e2f6:	bl	efe0 <__lshift>
    e2fa:	mov	r6, r0
    e2fc:	cmp	r7, #0
    e2fe:	bne.w	e5fa <_dtoa_r+0xbe2>
    e302:	mov	r8, r6
    e304:	ldr	r3, [sp, #32]
    e306:	ldr	r2, [sp, #36]	; 0x24
    e308:	subs	r3, #1
    e30a:	adds	r3, r2, r3
    e30c:	str	r3, [sp, #32]
    e30e:	and.w	r3, sl, #1
    e312:	str	r3, [sp, #40]	; 0x28
    e314:	mov	r7, r2
    e316:	ldr.w	fp, [sp, #24]
    e31a:	mov	r0, r4
    e31c:	mov	r1, fp
    e31e:	bl	d8f0 <quorem>
    e322:	mov	r1, r6
    e324:	mov	r5, r0
    e326:	mov	r0, r4
    e328:	bl	f090 <__mcmp>
    e32c:	mov	r2, r8
    e32e:	mov	r1, fp
    e330:	mov	sl, r0
    e332:	mov	r0, r9
    e334:	bl	f0d4 <__mdiff>
    e338:	ldr	r2, [r0, #12]
    e33a:	mov	fp, r0
    e33c:	add.w	r3, r5, #48	; 0x30
    e340:	cmp	r2, #0
    e342:	bne.n	e3d8 <_dtoa_r+0x9c0>
    e344:	mov	r1, r0
    e346:	mov	r0, r4
    e348:	str	r3, [sp, #28]
    e34a:	bl	f090 <__mcmp>
    e34e:	mov	r1, fp
    e350:	str	r0, [sp, #20]
    e352:	mov	r0, r9
    e354:	bl	eccc <_Bfree>
    e358:	ldr	r2, [sp, #20]
    e35a:	ldr	r3, [sp, #28]
    e35c:	cbnz	r2, e36a <_dtoa_r+0x952>
    e35e:	ldr	r1, [sp, #0]
    e360:	cbnz	r1, e36a <_dtoa_r+0x952>
    e362:	ldr	r1, [sp, #40]	; 0x28
    e364:	cmp	r1, #0
    e366:	beq.w	e7d4 <_dtoa_r+0xdbc>
    e36a:	cmp.w	sl, #0
    e36e:	blt.w	e538 <_dtoa_r+0xb20>
    e372:	bne.n	e380 <_dtoa_r+0x968>
    e374:	ldr	r1, [sp, #0]
    e376:	cbnz	r1, e380 <_dtoa_r+0x968>
    e378:	ldr	r1, [sp, #40]	; 0x28
    e37a:	cmp	r1, #0
    e37c:	beq.w	e538 <_dtoa_r+0xb20>
    e380:	cmp	r2, #0
    e382:	bgt.w	e622 <_dtoa_r+0xc0a>
    e386:	ldr	r2, [sp, #32]
    e388:	strb	r3, [r7, #0]
    e38a:	add.w	sl, r7, #1
    e38e:	cmp	r7, r2
    e390:	mov	r5, sl
    e392:	beq.w	e63a <_dtoa_r+0xc22>
    e396:	mov	r1, r4
    e398:	movs	r3, #0
    e39a:	movs	r2, #10
    e39c:	mov	r0, r9
    e39e:	bl	ece0 <__multadd>
    e3a2:	cmp	r6, r8
    e3a4:	mov	r4, r0
    e3a6:	mov	r1, r6
    e3a8:	mov.w	r3, #0
    e3ac:	mov.w	r2, #10
    e3b0:	mov	r0, r9
    e3b2:	beq.n	e3cc <_dtoa_r+0x9b4>
    e3b4:	bl	ece0 <__multadd>
    e3b8:	mov	r1, r8
    e3ba:	mov	r6, r0
    e3bc:	movs	r3, #0
    e3be:	movs	r2, #10
    e3c0:	mov	r0, r9
    e3c2:	bl	ece0 <__multadd>
    e3c6:	mov	r7, sl
    e3c8:	mov	r8, r0
    e3ca:	b.n	e316 <_dtoa_r+0x8fe>
    e3cc:	bl	ece0 <__multadd>
    e3d0:	mov	r7, sl
    e3d2:	mov	r6, r0
    e3d4:	mov	r8, r0
    e3d6:	b.n	e316 <_dtoa_r+0x8fe>
    e3d8:	mov	r1, r0
    e3da:	mov	r0, r9
    e3dc:	str	r3, [sp, #20]
    e3de:	bl	eccc <_Bfree>
    e3e2:	movs	r2, #1
    e3e4:	ldr	r3, [sp, #20]
    e3e6:	b.n	e36a <_dtoa_r+0x952>
    e3e8:	ldr	r1, [sp, #24]
    e3ea:	mov	r0, r4
    e3ec:	bl	f090 <__mcmp>
    e3f0:	cmp	r0, #0
    e3f2:	bge.w	def4 <_dtoa_r+0x4dc>
    e3f6:	mov	r1, r4
    e3f8:	ldr	r4, [sp, #16]
    e3fa:	movs	r3, #0
    e3fc:	subs	r4, #1
    e3fe:	movs	r2, #10
    e400:	mov	r0, r9
    e402:	str	r4, [sp, #16]
    e404:	bl	ece0 <__multadd>
    e408:	ldr	r3, [sp, #44]	; 0x2c
    e40a:	mov	r4, r0
    e40c:	cmp	r3, #0
    e40e:	bne.w	e2d4 <_dtoa_r+0x8bc>
    e412:	ldr	r3, [sp, #56]	; 0x38
    e414:	cmp	r3, #0
    e416:	ble.w	e7f4 <_dtoa_r+0xddc>
    e41a:	str	r3, [sp, #32]
    e41c:	b.n	df04 <_dtoa_r+0x4ec>
    e41e:	ldr	r4, [sp, #40]	; 0x28
    e420:	b.n	de6c <_dtoa_r+0x454>
    e422:	ldr	r3, [sp, #0]
    e424:	cmp	r3, #2
    e426:	ble.w	defc <_dtoa_r+0x4e4>
    e42a:	ldr	r3, [sp, #32]
    e42c:	cmp	r3, #0
    e42e:	bne.w	e76c <_dtoa_r+0xd54>
    e432:	ldr	r1, [sp, #24]
    e434:	movs	r2, #5
    e436:	mov	r0, r9
    e438:	bl	ece0 <__multadd>
    e43c:	mov	r1, r0
    e43e:	str	r0, [sp, #24]
    e440:	mov	r0, r4
    e442:	bl	f090 <__mcmp>
    e446:	cmp	r0, #0
    e448:	str	r4, [sp, #40]	; 0x28
    e44a:	ble.w	e27a <_dtoa_r+0x862>
    e44e:	ldr	r2, [sp, #16]
    e450:	ldr	r1, [sp, #36]	; 0x24
    e452:	movs	r3, #49	; 0x31
    e454:	adds	r2, #1
    e456:	str	r2, [sp, #16]
    e458:	strb	r3, [r1, #0]
    e45a:	adds	r5, r1, #1
    e45c:	b.n	e282 <_dtoa_r+0x86a>
    e45e:	ldr	r2, [sp, #16]
    e460:	adds	r2, #1
    e462:	str	r2, [sp, #16]
    e464:	ldr	r2, [sp, #36]	; 0x24
    e466:	movs	r3, #49	; 0x31
    e468:	strb	r3, [r2, #0]
    e46a:	b.n	df86 <_dtoa_r+0x56e>
    e46c:	movs	r3, #1
    e46e:	str	r3, [sp, #44]	; 0x2c
    e470:	b.n	e018 <_dtoa_r+0x600>
    e472:	ldr.w	r9, [sp, #20]
    e476:	b.n	ddae <_dtoa_r+0x396>
    e478:	cmp.w	sl, #0
    e47c:	bne.w	de92 <_dtoa_r+0x47a>
    e480:	ubfx	r3, fp, #0, #20
    e484:	cmp	r3, #0
    e486:	bne.w	e706 <_dtoa_r+0xcee>
    e48a:	bic.w	r7, fp, #2147483648	; 0x80000000
    e48e:	lsrs	r7, r7, #20
    e490:	lsls	r7, r7, #20
    e492:	cbz	r7, e4a0 <_dtoa_r+0xa88>
    e494:	ldr	r3, [sp, #28]
    e496:	adds	r3, #1
    e498:	str	r3, [sp, #28]
    e49a:	add.w	r8, r8, #1
    e49e:	movs	r7, #1
    e4a0:	ldr	r3, [sp, #48]	; 0x30
    e4a2:	movs	r0, #1
    e4a4:	cmp	r3, #0
    e4a6:	beq.w	dea6 <_dtoa_r+0x48e>
    e4aa:	b.n	de94 <_dtoa_r+0x47c>
    e4ac:	mov	r0, sl
    e4ae:	bl	a714 <__aeabi_i2d>
    e4b2:	mov	r2, r6
    e4b4:	mov	r3, r7
    e4b6:	bl	a7e0 <__aeabi_dmul>
    e4ba:	movs	r2, #0
    e4bc:	ldr	r3, [pc, #764]	; (e7bc <_dtoa_r+0xda4>)
    e4be:	bl	a47c <__adddf3>
    e4c2:	mov	r4, r0
    e4c4:	sub.w	r5, r1, #54525952	; 0x3400000
    e4c8:	mov	r0, r6
    e4ca:	mov	r1, r7
    e4cc:	movs	r2, #0
    e4ce:	ldr	r3, [pc, #752]	; (e7c0 <_dtoa_r+0xda8>)
    e4d0:	bl	a478 <__aeabi_dsub>
    e4d4:	mov	r2, r4
    e4d6:	mov	r3, r5
    e4d8:	mov	r6, r0
    e4da:	mov	r7, r1
    e4dc:	bl	ad00 <__aeabi_dcmpgt>
    e4e0:	cmp	r0, #0
    e4e2:	bne.w	e642 <_dtoa_r+0xc2a>
    e4e6:	mov	r2, r4
    e4e8:	add.w	r3, r5, #2147483648	; 0x80000000
    e4ec:	mov	r0, r6
    e4ee:	mov	r1, r7
    e4f0:	bl	acc4 <__aeabi_dcmplt>
    e4f4:	cmp	r0, #0
    e4f6:	beq.n	e58e <_dtoa_r+0xb76>
    e4f8:	movs	r3, #0
    e4fa:	str	r3, [sp, #24]
    e4fc:	mov	r6, r3
    e4fe:	b.n	e27a <_dtoa_r+0x862>
    e500:	ldr	r0, [sp, #36]	; 0x24
    e502:	b.w	da8a <_dtoa_r+0x72>
    e506:	ldr	r3, [sp, #24]
    e508:	ldr	r2, [sp, #48]	; 0x30
    e50a:	str	r7, [sp, #24]
    e50c:	subs	r3, r7, r3
    e50e:	add	r2, r3
    e510:	str	r2, [sp, #48]	; 0x30
    e512:	movs	r7, #0
    e514:	b.n	ddf2 <_dtoa_r+0x3da>
    e516:	vldr	d7, [sp, #64]	; 0x40
    e51a:	mov.w	sl, #2
    e51e:	vstr	d7, [sp, #72]	; 0x48
    e522:	b.n	e0a4 <_dtoa_r+0x68c>
    e524:	mov	r4, r3
    e526:	movs	r1, #0
    e528:	str.w	r1, [r9, #68]	; 0x44
    e52c:	b.n	e050 <_dtoa_r+0x638>
    e52e:	movs	r4, #1
    e530:	str	r4, [sp, #56]	; 0x38
    e532:	str	r4, [sp, #32]
    e534:	str	r4, [sp, #20]
    e536:	b.n	e526 <_dtoa_r+0xb0e>
    e538:	cmp	r2, #0
    e53a:	mov	sl, r3
    e53c:	ble.n	e562 <_dtoa_r+0xb4a>
    e53e:	mov	r1, r4
    e540:	movs	r2, #1
    e542:	mov	r0, r9
    e544:	bl	efe0 <__lshift>
    e548:	ldr	r1, [sp, #24]
    e54a:	mov	r4, r0
    e54c:	bl	f090 <__mcmp>
    e550:	cmp	r0, #0
    e552:	ble.w	e7e6 <_dtoa_r+0xdce>
    e556:	cmp.w	sl, #57	; 0x39
    e55a:	beq.w	e770 <_dtoa_r+0xd58>
    e55e:	add.w	sl, r5, #49	; 0x31
    e562:	mov	fp, r6
    e564:	strb.w	sl, [r7]
    e568:	adds	r5, r7, #1
    e56a:	mov	r6, r8
    e56c:	str	r4, [sp, #40]	; 0x28
    e56e:	b.n	df86 <_dtoa_r+0x56e>
    e570:	bne.n	e57c <_dtoa_r+0xb64>
    e572:	tst.w	sl, #1
    e576:	beq.n	e57c <_dtoa_r+0xb64>
    e578:	b.n	df66 <_dtoa_r+0x54e>
    e57a:	mov	r5, r2
    e57c:	ldrb.w	r3, [r5, #-1]
    e580:	cmp	r3, #48	; 0x30
    e582:	add.w	r2, r5, #4294967295
    e586:	beq.n	e57a <_dtoa_r+0xb62>
    e588:	b.n	df86 <_dtoa_r+0x56e>
    e58a:	ldr.w	r8, [sp, #72]	; 0x48
    e58e:	ldrd	sl, fp, [sp, #64]	; 0x40
    e592:	b.w	dc2c <_dtoa_r+0x214>
    e596:	ldr	r1, [sp, #36]	; 0x24
    e598:	movs	r2, #48	; 0x30
    e59a:	strb	r2, [r1, #0]
    e59c:	ldr	r2, [sp, #16]
    e59e:	ldrb.w	r4, [r5, #-1]
    e5a2:	adds	r2, #1
    e5a4:	str	r2, [sp, #16]
    e5a6:	b.n	ddaa <_dtoa_r+0x392>
    e5a8:	ldr	r3, [sp, #16]
    e5aa:	negs	r4, r3
    e5ac:	cmp	r4, #0
    e5ae:	beq.w	e718 <_dtoa_r+0xd00>
    e5b2:	ldr	r3, [pc, #528]	; (e7c4 <_dtoa_r+0xdac>)
    e5b4:	and.w	r2, r4, #15
    e5b8:	add.w	r3, r3, r2, lsl #3
    e5bc:	ldrd	r2, r3, [r3]
    e5c0:	ldrd	r0, r1, [sp, #64]	; 0x40
    e5c4:	bl	a7e0 <__aeabi_dmul>
    e5c8:	asrs	r4, r4, #4
    e5ca:	mov	r6, r0
    e5cc:	mov	r7, r1
    e5ce:	beq.w	e7fe <_dtoa_r+0xde6>
    e5d2:	ldr	r5, [pc, #500]	; (e7c8 <_dtoa_r+0xdb0>)
    e5d4:	mov.w	sl, #2
    e5d8:	lsls	r2, r4, #31
    e5da:	bpl.n	e5f0 <_dtoa_r+0xbd8>
    e5dc:	mov	r0, r6
    e5de:	mov	r1, r7
    e5e0:	ldrd	r2, r3, [r5]
    e5e4:	bl	a7e0 <__aeabi_dmul>
    e5e8:	add.w	sl, sl, #1
    e5ec:	mov	r6, r0
    e5ee:	mov	r7, r1
    e5f0:	asrs	r4, r4, #1
    e5f2:	add.w	r5, r5, #8
    e5f6:	bne.n	e5d8 <_dtoa_r+0xbc0>
    e5f8:	b.n	e0d8 <_dtoa_r+0x6c0>
    e5fa:	ldr	r1, [r6, #4]
    e5fc:	mov	r0, r9
    e5fe:	bl	ec80 <_Balloc>
    e602:	ldr	r3, [r6, #16]
    e604:	adds	r2, r3, #2
    e606:	mov	r5, r0
    e608:	lsls	r2, r2, #2
    e60a:	add.w	r1, r6, #12
    e60e:	adds	r0, #12
    e610:	bl	7f58 <memcpy>
    e614:	mov	r1, r5
    e616:	movs	r2, #1
    e618:	mov	r0, r9
    e61a:	bl	efe0 <__lshift>
    e61e:	mov	r8, r0
    e620:	b.n	e304 <_dtoa_r+0x8ec>
    e622:	cmp	r3, #57	; 0x39
    e624:	beq.w	e770 <_dtoa_r+0xd58>
    e628:	add.w	sl, r3, #1
    e62c:	mov	fp, r6
    e62e:	strb.w	sl, [r7]
    e632:	adds	r5, r7, #1
    e634:	mov	r6, r8
    e636:	str	r4, [sp, #40]	; 0x28
    e638:	b.n	df86 <_dtoa_r+0x56e>
    e63a:	mov	fp, r6
    e63c:	mov	sl, r3
    e63e:	mov	r6, r8
    e640:	b.n	df4e <_dtoa_r+0x536>
    e642:	movs	r3, #0
    e644:	str	r3, [sp, #24]
    e646:	mov	r6, r3
    e648:	b.n	e44e <_dtoa_r+0xa36>
    e64a:	ldr	r3, [sp, #72]	; 0x48
    e64c:	ldr	r1, [pc, #372]	; (e7c4 <_dtoa_r+0xdac>)
    e64e:	subs	r2, r3, #1
    e650:	add.w	r1, r1, r2, lsl #3
    e654:	mov	r3, r5
    e656:	str	r2, [sp, #92]	; 0x5c
    e658:	ldrd	r0, r1, [r1]
    e65c:	mov	r2, r4
    e65e:	bl	a7e0 <__aeabi_dmul>
    e662:	strd	r0, r1, [sp, #80]	; 0x50
    e666:	mov	r1, r7
    e668:	mov	r0, r6
    e66a:	bl	f464 <__aeabi_d2iz>
    e66e:	mov	r4, r0
    e670:	bl	a714 <__aeabi_i2d>
    e674:	mov	r3, r1
    e676:	mov	r2, r0
    e678:	mov	r1, r7
    e67a:	mov	r0, r6
    e67c:	bl	a478 <__aeabi_dsub>
    e680:	ldr	r3, [sp, #72]	; 0x48
    e682:	mov	r7, r1
    e684:	ldr	r1, [sp, #36]	; 0x24
    e686:	adds	r4, #48	; 0x30
    e688:	cmp	r3, #1
    e68a:	mov	r6, r0
    e68c:	strb	r4, [r1, #0]
    e68e:	add.w	r5, r1, #1
    e692:	beq.n	e6d6 <_dtoa_r+0xcbe>
    e694:	ldr	r3, [sp, #72]	; 0x48
    e696:	ldr	r2, [sp, #36]	; 0x24
    e698:	add	r3, r2
    e69a:	mov	sl, r3
    e69c:	mov	fp, r5
    e69e:	movs	r2, #0
    e6a0:	ldr	r3, [pc, #296]	; (e7cc <_dtoa_r+0xdb4>)
    e6a2:	mov	r0, r6
    e6a4:	mov	r1, r7
    e6a6:	bl	a7e0 <__aeabi_dmul>
    e6aa:	mov	r7, r1
    e6ac:	mov	r6, r0
    e6ae:	bl	f464 <__aeabi_d2iz>
    e6b2:	mov	r4, r0
    e6b4:	bl	a714 <__aeabi_i2d>
    e6b8:	adds	r4, #48	; 0x30
    e6ba:	mov	r2, r0
    e6bc:	mov	r3, r1
    e6be:	mov	r0, r6
    e6c0:	mov	r1, r7
    e6c2:	bl	a478 <__aeabi_dsub>
    e6c6:	strb.w	r4, [fp], #1
    e6ca:	cmp	sl, fp
    e6cc:	mov	r6, r0
    e6ce:	mov	r7, r1
    e6d0:	bne.n	e69e <_dtoa_r+0xc86>
    e6d2:	ldr	r3, [sp, #92]	; 0x5c
    e6d4:	add	r5, r3
    e6d6:	movs	r2, #0
    e6d8:	ldr	r3, [pc, #244]	; (e7d0 <_dtoa_r+0xdb8>)
    e6da:	ldrd	r0, r1, [sp, #80]	; 0x50
    e6de:	bl	a47c <__adddf3>
    e6e2:	mov	r2, r6
    e6e4:	mov	r3, r7
    e6e6:	bl	acc4 <__aeabi_dcmplt>
    e6ea:	cmp	r0, #0
    e6ec:	beq.n	e780 <_dtoa_r+0xd68>
    e6ee:	ldr	r3, [sp, #88]	; 0x58
    e6f0:	str	r3, [sp, #16]
    e6f2:	ldrb.w	r4, [r5, #-1]
    e6f6:	b.w	dd92 <_dtoa_r+0x37a>
    e6fa:	ldr	r3, [sp, #28]
    e6fc:	ldr	r2, [sp, #32]
    e6fe:	subs	r5, r3, r2
    e700:	movs	r3, #0
    e702:	b.w	ddfe <_dtoa_r+0x3e6>
    e706:	movs	r7, #0
    e708:	b.n	e4a0 <_dtoa_r+0xa88>
    e70a:	ldr	r3, [sp, #96]	; 0x60
    e70c:	ldr	r7, [sp, #24]
    e70e:	ldr	r5, [sp, #28]
    e710:	rsb	r3, r3, #54	; 0x36
    e714:	b.w	ddfe <_dtoa_r+0x3e6>
    e718:	ldrd	r6, r7, [sp, #64]	; 0x40
    e71c:	mov.w	sl, #2
    e720:	b.n	e0d8 <_dtoa_r+0x6c0>
    e722:	ldr	r3, [sp, #32]
    e724:	cmp	r3, #0
    e726:	beq.w	e4ac <_dtoa_r+0xa94>
    e72a:	ldr	r3, [sp, #56]	; 0x38
    e72c:	cmp	r3, #0
    e72e:	ble.w	e58e <_dtoa_r+0xb76>
    e732:	movs	r2, #0
    e734:	ldr	r3, [pc, #148]	; (e7cc <_dtoa_r+0xdb4>)
    e736:	mov	r0, r6
    e738:	mov	r1, r7
    e73a:	bl	a7e0 <__aeabi_dmul>
    e73e:	mov	r6, r0
    e740:	mov	r7, r1
    e742:	add.w	r0, sl, #1
    e746:	bl	a714 <__aeabi_i2d>
    e74a:	mov	r2, r6
    e74c:	mov	r3, r7
    e74e:	bl	a7e0 <__aeabi_dmul>
    e752:	movs	r2, #0
    e754:	ldr	r3, [pc, #100]	; (e7bc <_dtoa_r+0xda4>)
    e756:	bl	a47c <__adddf3>
    e75a:	ldr	r2, [sp, #16]
    e75c:	ldr	r3, [sp, #56]	; 0x38
    e75e:	str	r3, [sp, #72]	; 0x48
    e760:	subs	r2, #1
    e762:	mov	r4, r0
    e764:	sub.w	r5, r1, #54525952	; 0x3400000
    e768:	str	r2, [sp, #88]	; 0x58
    e76a:	b.n	e11a <_dtoa_r+0x702>
    e76c:	str	r4, [sp, #40]	; 0x28
    e76e:	b.n	e27a <_dtoa_r+0x862>
    e770:	movs	r2, #57	; 0x39
    e772:	mov	fp, r6
    e774:	str	r4, [sp, #40]	; 0x28
    e776:	mov	r6, r8
    e778:	strb	r2, [r7, #0]
    e77a:	adds	r5, r7, #1
    e77c:	b.w	df6a <_dtoa_r+0x552>
    e780:	ldrd	r2, r3, [sp, #80]	; 0x50
    e784:	movs	r0, #0
    e786:	ldr	r1, [pc, #72]	; (e7d0 <_dtoa_r+0xdb8>)
    e788:	bl	a478 <__aeabi_dsub>
    e78c:	mov	r2, r6
    e78e:	mov	r3, r7
    e790:	bl	ad00 <__aeabi_dcmpgt>
    e794:	cbnz	r0, e79a <_dtoa_r+0xd82>
    e796:	b.n	e58e <_dtoa_r+0xb76>
    e798:	mov	r5, r2
    e79a:	ldrb.w	r3, [r5, #-1]
    e79e:	cmp	r3, #48	; 0x30
    e7a0:	add.w	r2, r5, #4294967295
    e7a4:	beq.n	e798 <_dtoa_r+0xd80>
    e7a6:	b.n	e21c <_dtoa_r+0x804>
    e7a8:	ldr	r3, [sp, #88]	; 0x58
    e7aa:	str	r3, [sp, #16]
    e7ac:	b.w	dd92 <_dtoa_r+0x37a>
    e7b0:	cmp.w	sl, #0
    e7b4:	bne.w	e2b0 <_dtoa_r+0x898>
    e7b8:	b.n	e480 <_dtoa_r+0xa68>
    e7ba:	nop
    e7bc:	.word	0x401c0000
    e7c0:	.word	0x40140000
    e7c4:	.word	0x20000a78
    e7c8:	.word	0x20000b40
    e7cc:	.word	0x40240000
    e7d0:	.word	0x3fe00000
    e7d4:	cmp	r3, #57	; 0x39
    e7d6:	mov	fp, sl
    e7d8:	mov	sl, r3
    e7da:	beq.n	e770 <_dtoa_r+0xd58>
    e7dc:	cmp.w	fp, #0
    e7e0:	bgt.w	e55e <_dtoa_r+0xb46>
    e7e4:	b.n	e562 <_dtoa_r+0xb4a>
    e7e6:	bne.w	e562 <_dtoa_r+0xb4a>
    e7ea:	tst.w	sl, #1
    e7ee:	beq.w	e562 <_dtoa_r+0xb4a>
    e7f2:	b.n	e556 <_dtoa_r+0xb3e>
    e7f4:	ldr	r3, [sp, #0]
    e7f6:	cmp	r3, #2
    e7f8:	bgt.n	e846 <_dtoa_r+0xe2e>
    e7fa:	ldr	r3, [sp, #56]	; 0x38
    e7fc:	b.n	e41a <_dtoa_r+0xa02>
    e7fe:	mov.w	sl, #2
    e802:	b.n	e0d8 <_dtoa_r+0x6c0>
    e804:	ldr	r3, [sp, #0]
    e806:	cmp	r3, #2
    e808:	bgt.n	e846 <_dtoa_r+0xe2e>
    e80a:	ldr	r3, [sp, #56]	; 0x38
    e80c:	b.n	e2ea <_dtoa_r+0x8d2>
    e80e:	movs	r4, #0
    e810:	str.w	r4, [r9, #68]	; 0x44
    e814:	mov	r1, r4
    e816:	mov	r0, r9
    e818:	bl	ec80 <_Balloc>
    e81c:	mov.w	r3, #4294967295
    e820:	str	r3, [sp, #32]
    e822:	str	r3, [sp, #56]	; 0x38
    e824:	movs	r3, #1
    e826:	str	r0, [sp, #36]	; 0x24
    e828:	str	r4, [sp, #20]
    e82a:	str.w	r0, [r9, #64]	; 0x40
    e82e:	str	r3, [sp, #44]	; 0x2c
    e830:	b.w	dc2c <_dtoa_r+0x214>
    e834:	beq.w	dec8 <_dtoa_r+0x4b0>
    e838:	rsb	r0, r0, #60	; 0x3c
    e83c:	b.w	debe <_dtoa_r+0x4a6>
    e840:	movs	r6, #1
    e842:	b.w	dbbe <_dtoa_r+0x1a6>
    e846:	ldr	r3, [sp, #56]	; 0x38
    e848:	str	r3, [sp, #32]
    e84a:	b.n	e42a <_dtoa_r+0xa12>

0000e84c <fcvtbuf>:
    e84c:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    e850:	vpush	{d8}
    e854:	vmov.f32	s16, s0
    e858:	vmov.f32	s17, s1
    e85c:	ldr	r5, [pc, #224]	; (e940 <fcvtbuf+0xf4>)
    e85e:	sub	sp, #20
    e860:	ldr	r7, [r5, #0]
    e862:	mov	r4, r0
    e864:	mov	r6, r1
    e866:	mov	r8, r2
    e868:	mov	r5, r3
    e86a:	cmp	r3, #0
    e86c:	beq.n	e90a <fcvtbuf+0xbe>
    e86e:	movs	r2, #0
    e870:	ldr	r3, [pc, #208]	; (e944 <fcvtbuf+0xf8>)
    e872:	vmov	r0, r1, d8
    e876:	bl	acc4 <__aeabi_dcmplt>
    e87a:	cbnz	r0, e8dc <fcvtbuf+0x90>
    e87c:	vmov.f32	s0, s16
    e880:	vmov.f32	s1, s17
    e884:	add	r3, sp, #12
    e886:	str	r3, [sp, #4]
    e888:	str.w	r8, [sp]
    e88c:	mov	r0, r7
    e88e:	mov	r3, r6
    e890:	mov	r2, r4
    e892:	movs	r1, #3
    e894:	bl	da18 <_dtoa_r>
    e898:	ldr	r3, [sp, #12]
    e89a:	ldr	r1, [r6, #0]
    e89c:	cmp	r0, r3
    e89e:	rsb	r1, r1, #0
    e8a2:	bcs.n	e918 <fcvtbuf+0xcc>
    e8a4:	subs	r1, r1, r5
    e8a6:	mov	r3, r5
    e8a8:	ldrb.w	r2, [r0], #1
    e8ac:	strb.w	r2, [r3], #1
    e8b0:	ldr	r2, [sp, #12]
    e8b2:	cmp	r2, r0
    e8b4:	add.w	r6, r3, r1
    e8b8:	bhi.n	e8a8 <fcvtbuf+0x5c>
    e8ba:	cmp	r4, r6
    e8bc:	ble.n	e91e <fcvtbuf+0xd2>
    e8be:	subs	r2, r4, r6
    e8c0:	add	r2, r3
    e8c2:	movs	r1, #48	; 0x30
    e8c4:	strb.w	r1, [r3], #1
    e8c8:	cmp	r2, r3
    e8ca:	bne.n	e8c4 <fcvtbuf+0x78>
    e8cc:	movs	r3, #0
    e8ce:	strb	r3, [r2, #0]
    e8d0:	mov	r0, r5
    e8d2:	add	sp, #20
    e8d4:	vpop	{d8}
    e8d8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    e8dc:	movs	r2, #0
    e8de:	ldr	r3, [pc, #104]	; (e948 <fcvtbuf+0xfc>)
    e8e0:	vmov	r0, r1, d8
    e8e4:	bl	ad00 <__aeabi_dcmpgt>
    e8e8:	cmp	r0, #0
    e8ea:	beq.n	e87c <fcvtbuf+0x30>
    e8ec:	vmov.f32	s0, s16
    e8f0:	vmov.f32	s1, s17
    e8f4:	add	r3, sp, #12
    e8f6:	str	r3, [sp, #4]
    e8f8:	str.w	r8, [sp]
    e8fc:	mov	r0, r7
    e8fe:	mov	r3, r6
    e900:	mov	r2, r4
    e902:	movs	r1, #2
    e904:	bl	da18 <_dtoa_r>
    e908:	b.n	e898 <fcvtbuf+0x4c>
    e90a:	ldr	r2, [r7, #80]	; 0x50
    e90c:	add.w	r3, r0, #35	; 0x23
    e910:	cmp	r2, r3
    e912:	ble.n	e922 <fcvtbuf+0xd6>
    e914:	ldr	r5, [r7, #84]	; 0x54
    e916:	b.n	e86e <fcvtbuf+0x22>
    e918:	mov	r6, r1
    e91a:	mov	r3, r5
    e91c:	b.n	e8ba <fcvtbuf+0x6e>
    e91e:	mov	r2, r3
    e920:	b.n	e8cc <fcvtbuf+0x80>
    e922:	add.w	r9, r0, #36	; 0x24
    e926:	mov	r2, r9
    e928:	ldr	r1, [r7, #84]	; 0x54
    e92a:	mov	r0, r7
    e92c:	bl	b7e0 <_realloc_r>
    e930:	mov	r5, r0
    e932:	cmp	r0, #0
    e934:	beq.n	e8d0 <fcvtbuf+0x84>
    e936:	str.w	r9, [r7, #80]	; 0x50
    e93a:	str	r0, [r7, #84]	; 0x54
    e93c:	b.n	e86e <fcvtbuf+0x22>
    e93e:	nop
    e940:	.word	0x20000ff0
    e944:	.word	0x3ff00000
    e948:	.word	0xbff00000

0000e94c <_malloc_trim_r>:
    e94c:	push	{r3, r4, r5, r6, r7, lr}
    e94e:	ldr	r7, [pc, #140]	; (e9dc <_malloc_trim_r+0x90>)
    e950:	mov	r4, r1
    e952:	mov	r6, r0
    e954:	bl	b7d8 <__malloc_lock>
    e958:	ldr	r3, [r7, #8]
    e95a:	ldr	r5, [r3, #4]
    e95c:	bic.w	r5, r5, #3
    e960:	subs	r1, r5, r4
    e962:	addw	r1, r1, #4079	; 0xfef
    e966:	bic.w	r1, r1, #4080	; 0xff0
    e96a:	bic.w	r1, r1, #15
    e96e:	sub.w	r4, r1, #4096	; 0x1000
    e972:	cmp.w	r4, #4096	; 0x1000
    e976:	blt.n	e988 <_malloc_trim_r+0x3c>
    e978:	movs	r1, #0
    e97a:	mov	r0, r6
    e97c:	bl	bbc0 <_sbrk_r>
    e980:	ldr	r3, [r7, #8]
    e982:	add	r3, r5
    e984:	cmp	r0, r3
    e986:	beq.n	e992 <_malloc_trim_r+0x46>
    e988:	mov	r0, r6
    e98a:	bl	b7dc <__malloc_unlock>
    e98e:	movs	r0, #0
    e990:	pop	{r3, r4, r5, r6, r7, pc}
    e992:	negs	r1, r4
    e994:	mov	r0, r6
    e996:	bl	bbc0 <_sbrk_r>
    e99a:	adds	r0, #1
    e99c:	beq.n	e9ba <_malloc_trim_r+0x6e>
    e99e:	ldr	r3, [pc, #64]	; (e9e0 <_malloc_trim_r+0x94>)
    e9a0:	ldr	r2, [r7, #8]
    e9a2:	ldr	r1, [r3, #0]
    e9a4:	subs	r5, r5, r4
    e9a6:	orr.w	r5, r5, #1
    e9aa:	mov	r0, r6
    e9ac:	subs	r1, r1, r4
    e9ae:	str	r5, [r2, #4]
    e9b0:	str	r1, [r3, #0]
    e9b2:	bl	b7dc <__malloc_unlock>
    e9b6:	movs	r0, #1
    e9b8:	pop	{r3, r4, r5, r6, r7, pc}
    e9ba:	movs	r1, #0
    e9bc:	mov	r0, r6
    e9be:	bl	bbc0 <_sbrk_r>
    e9c2:	ldr	r2, [r7, #8]
    e9c4:	subs	r3, r0, r2
    e9c6:	cmp	r3, #15
    e9c8:	ble.n	e988 <_malloc_trim_r+0x3c>
    e9ca:	ldr	r4, [pc, #24]	; (e9e4 <_malloc_trim_r+0x98>)
    e9cc:	ldr	r1, [pc, #16]	; (e9e0 <_malloc_trim_r+0x94>)
    e9ce:	ldr	r4, [r4, #0]
    e9d0:	orr.w	r3, r3, #1
    e9d4:	subs	r0, r0, r4
    e9d6:	str	r3, [r2, #4]
    e9d8:	str	r0, [r1, #0]
    e9da:	b.n	e988 <_malloc_trim_r+0x3c>
    e9dc:	.word	0x20001160
    e9e0:	.word	0x2000b2c8
    e9e4:	.word	0x2000156c

0000e9e8 <_free_r>:
    e9e8:	cmp	r1, #0
    e9ea:	beq.n	ea78 <_free_r+0x90>
    e9ec:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e9f0:	mov	r5, r1
    e9f2:	mov	r8, r0
    e9f4:	bl	b7d8 <__malloc_lock>
    e9f8:	ldr.w	r7, [r5, #-4]
    e9fc:	ldr	r1, [pc, #424]	; (eba8 <_free_r+0x1c0>)
    e9fe:	bic.w	r3, r7, #1
    ea02:	sub.w	r4, r5, #8
    ea06:	adds	r2, r4, r3
    ea08:	ldr	r6, [r1, #8]
    ea0a:	ldr	r0, [r2, #4]
    ea0c:	cmp	r2, r6
    ea0e:	bic.w	r0, r0, #3
    ea12:	beq.n	eada <_free_r+0xf2>
    ea14:	lsls	r6, r7, #31
    ea16:	str	r0, [r2, #4]
    ea18:	bmi.n	ea32 <_free_r+0x4a>
    ea1a:	ldr.w	r7, [r5, #-8]
    ea1e:	subs	r4, r4, r7
    ea20:	add.w	lr, r1, #8
    ea24:	ldr	r5, [r4, #8]
    ea26:	cmp	r5, lr
    ea28:	add	r3, r7
    ea2a:	beq.n	eb0c <_free_r+0x124>
    ea2c:	ldr	r7, [r4, #12]
    ea2e:	str	r7, [r5, #12]
    ea30:	str	r5, [r7, #8]
    ea32:	adds	r5, r2, r0
    ea34:	ldr	r5, [r5, #4]
    ea36:	lsls	r5, r5, #31
    ea38:	bpl.n	eac0 <_free_r+0xd8>
    ea3a:	orr.w	r2, r3, #1
    ea3e:	str	r2, [r4, #4]
    ea40:	str	r3, [r4, r3]
    ea42:	cmp.w	r3, #512	; 0x200
    ea46:	bcs.n	ea7a <_free_r+0x92>
    ea48:	lsrs	r3, r3, #3
    ea4a:	adds	r2, r3, #1
    ea4c:	ldr	r5, [r1, #4]
    ea4e:	ldr.w	r7, [r1, r2, lsl #3]
    ea52:	str	r7, [r4, #8]
    ea54:	movs	r0, #1
    ea56:	asrs	r3, r3, #2
    ea58:	lsl.w	r3, r0, r3
    ea5c:	add.w	r0, r1, r2, lsl #3
    ea60:	orrs	r5, r3
    ea62:	subs	r0, #8
    ea64:	str	r0, [r4, #12]
    ea66:	str	r5, [r1, #4]
    ea68:	str.w	r4, [r1, r2, lsl #3]
    ea6c:	str	r4, [r7, #12]
    ea6e:	mov	r0, r8
    ea70:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    ea74:	b.w	b7dc <__malloc_unlock>
    ea78:	bx	lr
    ea7a:	lsrs	r2, r3, #9
    ea7c:	cmp	r2, #4
    ea7e:	bhi.n	eb28 <_free_r+0x140>
    ea80:	lsrs	r2, r3, #6
    ea82:	add.w	r7, r2, #57	; 0x39
    ea86:	lsls	r7, r7, #1
    ea88:	add.w	r5, r2, #56	; 0x38
    ea8c:	add.w	r0, r1, r7, lsl #2
    ea90:	ldr.w	r2, [r1, r7, lsl #2]
    ea94:	ldr	r1, [pc, #272]	; (eba8 <_free_r+0x1c0>)
    ea96:	subs	r0, #8
    ea98:	cmp	r0, r2
    ea9a:	beq.n	eb38 <_free_r+0x150>
    ea9c:	ldr	r1, [r2, #4]
    ea9e:	bic.w	r1, r1, #3
    eaa2:	cmp	r3, r1
    eaa4:	bcs.n	eaac <_free_r+0xc4>
    eaa6:	ldr	r2, [r2, #8]
    eaa8:	cmp	r0, r2
    eaaa:	bne.n	ea9c <_free_r+0xb4>
    eaac:	ldr	r0, [r2, #12]
    eaae:	str	r0, [r4, #12]
    eab0:	str	r2, [r4, #8]
    eab2:	str	r4, [r0, #8]
    eab4:	str	r4, [r2, #12]
    eab6:	mov	r0, r8
    eab8:	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    eabc:	b.w	b7dc <__malloc_unlock>
    eac0:	ldr	r5, [r2, #8]
    eac2:	ldr	r7, [pc, #232]	; (ebac <_free_r+0x1c4>)
    eac4:	cmp	r5, r7
    eac6:	add	r3, r0
    eac8:	beq.n	eb4a <_free_r+0x162>
    eaca:	ldr	r0, [r2, #12]
    eacc:	str	r0, [r5, #12]
    eace:	orr.w	r2, r3, #1
    ead2:	str	r5, [r0, #8]
    ead4:	str	r2, [r4, #4]
    ead6:	str	r3, [r4, r3]
    ead8:	b.n	ea42 <_free_r+0x5a>
    eada:	lsls	r7, r7, #31
    eadc:	add	r3, r0
    eade:	bmi.n	eaf0 <_free_r+0x108>
    eae0:	ldr.w	r2, [r5, #-8]
    eae4:	subs	r4, r4, r2
    eae6:	add	r3, r2
    eae8:	ldr	r0, [r4, #8]
    eaea:	ldr	r2, [r4, #12]
    eaec:	str	r2, [r0, #12]
    eaee:	str	r0, [r2, #8]
    eaf0:	ldr	r2, [pc, #188]	; (ebb0 <_free_r+0x1c8>)
    eaf2:	ldr	r2, [r2, #0]
    eaf4:	orr.w	r0, r3, #1
    eaf8:	cmp	r3, r2
    eafa:	str	r0, [r4, #4]
    eafc:	str	r4, [r1, #8]
    eafe:	bcc.n	ea6e <_free_r+0x86>
    eb00:	ldr	r3, [pc, #176]	; (ebb4 <_free_r+0x1cc>)
    eb02:	mov	r0, r8
    eb04:	ldr	r1, [r3, #0]
    eb06:	bl	e94c <_malloc_trim_r>
    eb0a:	b.n	ea6e <_free_r+0x86>
    eb0c:	adds	r1, r2, r0
    eb0e:	ldr	r1, [r1, #4]
    eb10:	lsls	r1, r1, #31
    eb12:	bmi.n	eb9e <_free_r+0x1b6>
    eb14:	ldr	r1, [r2, #8]
    eb16:	ldr	r2, [r2, #12]
    eb18:	str	r2, [r1, #12]
    eb1a:	add	r3, r0
    eb1c:	orr.w	r0, r3, #1
    eb20:	str	r1, [r2, #8]
    eb22:	str	r0, [r4, #4]
    eb24:	str	r3, [r4, r3]
    eb26:	b.n	ea6e <_free_r+0x86>
    eb28:	cmp	r2, #20
    eb2a:	bhi.n	eb5c <_free_r+0x174>
    eb2c:	add.w	r7, r2, #92	; 0x5c
    eb30:	lsls	r7, r7, #1
    eb32:	add.w	r5, r2, #91	; 0x5b
    eb36:	b.n	ea8c <_free_r+0xa4>
    eb38:	asrs	r2, r5, #2
    eb3a:	ldr	r3, [r1, #4]
    eb3c:	movs	r5, #1
    eb3e:	lsl.w	r2, r5, r2
    eb42:	orrs	r3, r2
    eb44:	str	r3, [r1, #4]
    eb46:	mov	r2, r0
    eb48:	b.n	eaae <_free_r+0xc6>
    eb4a:	orr.w	r2, r3, #1
    eb4e:	str	r4, [r1, #20]
    eb50:	str	r4, [r1, #16]
    eb52:	str	r5, [r4, #12]
    eb54:	str	r5, [r4, #8]
    eb56:	str	r2, [r4, #4]
    eb58:	str	r3, [r4, r3]
    eb5a:	b.n	ea6e <_free_r+0x86>
    eb5c:	cmp	r2, #84	; 0x54
    eb5e:	bhi.n	eb6e <_free_r+0x186>
    eb60:	lsrs	r2, r3, #12
    eb62:	add.w	r7, r2, #111	; 0x6f
    eb66:	lsls	r7, r7, #1
    eb68:	add.w	r5, r2, #110	; 0x6e
    eb6c:	b.n	ea8c <_free_r+0xa4>
    eb6e:	cmp.w	r2, #340	; 0x154
    eb72:	bhi.n	eb82 <_free_r+0x19a>
    eb74:	lsrs	r2, r3, #15
    eb76:	add.w	r7, r2, #120	; 0x78
    eb7a:	lsls	r7, r7, #1
    eb7c:	add.w	r5, r2, #119	; 0x77
    eb80:	b.n	ea8c <_free_r+0xa4>
    eb82:	movw	r0, #1364	; 0x554
    eb86:	cmp	r2, r0
    eb88:	bhi.n	eb98 <_free_r+0x1b0>
    eb8a:	lsrs	r2, r3, #18
    eb8c:	add.w	r7, r2, #125	; 0x7d
    eb90:	lsls	r7, r7, #1
    eb92:	add.w	r5, r2, #124	; 0x7c
    eb96:	b.n	ea8c <_free_r+0xa4>
    eb98:	movs	r7, #254	; 0xfe
    eb9a:	movs	r5, #126	; 0x7e
    eb9c:	b.n	ea8c <_free_r+0xa4>
    eb9e:	orr.w	r2, r3, #1
    eba2:	str	r2, [r4, #4]
    eba4:	str	r3, [r4, r3]
    eba6:	b.n	ea6e <_free_r+0x86>
    eba8:	.word	0x20001160
    ebac:	.word	0x20001168
    ebb0:	.word	0x20001568
    ebb4:	.word	0x2000b2c4

0000ebb8 <_localeconv_r>:
    ebb8:	ldr	r2, [pc, #16]	; (ebcc <_localeconv_r+0x14>)
    ebba:	ldr	r3, [pc, #20]	; (ebd0 <_localeconv_r+0x18>)
    ebbc:	ldr	r2, [r2, #0]
    ebbe:	ldr	r0, [r2, #52]	; 0x34
    ebc0:	cmp	r0, #0
    ebc2:	it	eq
    ebc4:	moveq	r0, r3
    ebc6:	adds	r0, #240	; 0xf0
    ebc8:	bx	lr
    ebca:	nop
    ebcc:	.word	0x20000ff0
    ebd0:	.word	0x20000ff4
	...

0000ebe0 <memchr>:
    ebe0:	and.w	r1, r1, #255	; 0xff
    ebe4:	cmp	r2, #16
    ebe6:	blt.n	ec40 <memchr+0x60>
    ebe8:	tst.w	r0, #7
    ebec:	beq.n	ec00 <memchr+0x20>
    ebee:	ldrb.w	r3, [r0], #1
    ebf2:	subs	r2, #1
    ebf4:	cmp	r3, r1
    ebf6:	beq.n	ec54 <memchr+0x74>
    ebf8:	tst.w	r0, #7
    ebfc:	cbz	r2, ec50 <memchr+0x70>
    ebfe:	bne.n	ebee <memchr+0xe>
    ec00:	push	{r4, r5, r6, r7}
    ec02:	orr.w	r1, r1, r1, lsl #8
    ec06:	orr.w	r1, r1, r1, lsl #16
    ec0a:	bic.w	r4, r2, #7
    ec0e:	mvns.w	r7, #0
    ec12:	movs	r3, #0
    ec14:	ldrd	r5, r6, [r0], #8
    ec18:	subs	r4, #8
    ec1a:	eor.w	r5, r5, r1
    ec1e:	eor.w	r6, r6, r1
    ec22:	uadd8	r5, r5, r7
    ec26:	sel	r5, r3, r7
    ec2a:	uadd8	r6, r6, r7
    ec2e:	sel	r6, r5, r7
    ec32:	cbnz	r6, ec58 <memchr+0x78>
    ec34:	bne.n	ec14 <memchr+0x34>
    ec36:	pop	{r4, r5, r6, r7}
    ec38:	and.w	r1, r1, #255	; 0xff
    ec3c:	and.w	r2, r2, #7
    ec40:	cbz	r2, ec50 <memchr+0x70>
    ec42:	ldrb.w	r3, [r0], #1
    ec46:	subs	r2, #1
    ec48:	eor.w	r3, r3, r1
    ec4c:	cbz	r3, ec54 <memchr+0x74>
    ec4e:	bne.n	ec42 <memchr+0x62>
    ec50:	movs	r0, #0
    ec52:	bx	lr
    ec54:	subs	r0, #1
    ec56:	bx	lr
    ec58:	cmp	r5, #0
    ec5a:	itte	eq
    ec5c:	moveq	r5, r6
    ec5e:	subeq	r0, #3
    ec60:	subne	r0, #7
    ec62:	tst.w	r5, #1
    ec66:	bne.n	ec78 <memchr+0x98>
    ec68:	adds	r0, #1
    ec6a:	tst.w	r5, #256	; 0x100
    ec6e:	ittt	eq
    ec70:	addeq	r0, #1
    ec72:	tsteq.w	r5, #98304	; 0x18000
    ec76:	addeq	r0, #1
    ec78:	pop	{r4, r5, r6, r7}
    ec7a:	subs	r0, #1
    ec7c:	bx	lr
    ec7e:	nop

0000ec80 <_Balloc>:
    ec80:	ldr	r3, [r0, #76]	; 0x4c
    ec82:	push	{r4, r5, r6, lr}
    ec84:	mov	r5, r0
    ec86:	mov	r4, r1
    ec88:	cbz	r3, ec9e <_Balloc+0x1e>
    ec8a:	ldr.w	r0, [r3, r4, lsl #2]
    ec8e:	cbz	r0, ecb2 <_Balloc+0x32>
    ec90:	ldr	r2, [r0, #0]
    ec92:	str.w	r2, [r3, r4, lsl #2]
    ec96:	movs	r3, #0
    ec98:	str	r3, [r0, #16]
    ec9a:	str	r3, [r0, #12]
    ec9c:	pop	{r4, r5, r6, pc}
    ec9e:	movs	r2, #33	; 0x21
    eca0:	movs	r1, #4
    eca2:	bl	f404 <_calloc_r>
    eca6:	str	r0, [r5, #76]	; 0x4c
    eca8:	mov	r3, r0
    ecaa:	cmp	r0, #0
    ecac:	bne.n	ec8a <_Balloc+0xa>
    ecae:	movs	r0, #0
    ecb0:	pop	{r4, r5, r6, pc}
    ecb2:	movs	r1, #1
    ecb4:	lsl.w	r6, r1, r4
    ecb8:	adds	r2, r6, #5
    ecba:	mov	r0, r5
    ecbc:	lsls	r2, r2, #2
    ecbe:	bl	f404 <_calloc_r>
    ecc2:	cmp	r0, #0
    ecc4:	beq.n	ecae <_Balloc+0x2e>
    ecc6:	str	r4, [r0, #4]
    ecc8:	str	r6, [r0, #8]
    ecca:	b.n	ec96 <_Balloc+0x16>

0000eccc <_Bfree>:
    eccc:	cbz	r1, ecdc <_Bfree+0x10>
    ecce:	ldr	r3, [r0, #76]	; 0x4c
    ecd0:	ldr	r2, [r1, #4]
    ecd2:	ldr.w	r0, [r3, r2, lsl #2]
    ecd6:	str	r0, [r1, #0]
    ecd8:	str.w	r1, [r3, r2, lsl #2]
    ecdc:	bx	lr
    ecde:	nop

0000ece0 <__multadd>:
    ece0:	push	{r4, r5, r6, r7, lr}
    ece2:	ldr	r4, [r1, #16]
    ece4:	sub	sp, #12
    ece6:	mov	r5, r1
    ece8:	mov	r6, r0
    ecea:	add.w	lr, r1, #20
    ecee:	movs	r7, #0
    ecf0:	ldr.w	r0, [lr]
    ecf4:	uxth	r1, r0
    ecf6:	mla	r1, r2, r1, r3
    ecfa:	lsrs	r3, r1, #16
    ecfc:	lsrs	r0, r0, #16
    ecfe:	mla	r3, r2, r0, r3
    ed02:	uxth	r1, r1
    ed04:	adds	r7, #1
    ed06:	add.w	r1, r1, r3, lsl #16
    ed0a:	cmp	r4, r7
    ed0c:	str.w	r1, [lr], #4
    ed10:	mov.w	r3, r3, lsr #16
    ed14:	bgt.n	ecf0 <__multadd+0x10>
    ed16:	cbz	r3, ed28 <__multadd+0x48>
    ed18:	ldr	r2, [r5, #8]
    ed1a:	cmp	r4, r2
    ed1c:	bge.n	ed2e <__multadd+0x4e>
    ed1e:	add.w	r2, r5, r4, lsl #2
    ed22:	adds	r4, #1
    ed24:	str	r3, [r2, #20]
    ed26:	str	r4, [r5, #16]
    ed28:	mov	r0, r5
    ed2a:	add	sp, #12
    ed2c:	pop	{r4, r5, r6, r7, pc}
    ed2e:	ldr	r1, [r5, #4]
    ed30:	str	r3, [sp, #4]
    ed32:	adds	r1, #1
    ed34:	mov	r0, r6
    ed36:	bl	ec80 <_Balloc>
    ed3a:	ldr	r2, [r5, #16]
    ed3c:	adds	r2, #2
    ed3e:	add.w	r1, r5, #12
    ed42:	mov	r7, r0
    ed44:	lsls	r2, r2, #2
    ed46:	adds	r0, #12
    ed48:	bl	7f58 <memcpy>
    ed4c:	ldr	r2, [r6, #76]	; 0x4c
    ed4e:	ldr	r1, [r5, #4]
    ed50:	ldr	r3, [sp, #4]
    ed52:	ldr.w	r0, [r2, r1, lsl #2]
    ed56:	str	r0, [r5, #0]
    ed58:	str.w	r5, [r2, r1, lsl #2]
    ed5c:	mov	r5, r7
    ed5e:	b.n	ed1e <__multadd+0x3e>

0000ed60 <__hi0bits>:
    ed60:	lsrs	r3, r0, #16
    ed62:	lsls	r3, r3, #16
    ed64:	cbnz	r3, ed94 <__hi0bits+0x34>
    ed66:	lsls	r0, r0, #16
    ed68:	movs	r3, #16
    ed6a:	tst.w	r0, #4278190080	; 0xff000000
    ed6e:	itt	eq
    ed70:	lsleq	r0, r0, #8
    ed72:	addeq	r3, #8
    ed74:	tst.w	r0, #4026531840	; 0xf0000000
    ed78:	itt	eq
    ed7a:	lsleq	r0, r0, #4
    ed7c:	addeq	r3, #4
    ed7e:	tst.w	r0, #3221225472	; 0xc0000000
    ed82:	itt	eq
    ed84:	lsleq	r0, r0, #2
    ed86:	addeq	r3, #2
    ed88:	cmp	r0, #0
    ed8a:	blt.n	ed9c <__hi0bits+0x3c>
    ed8c:	lsls	r2, r0, #1
    ed8e:	bmi.n	ed98 <__hi0bits+0x38>
    ed90:	movs	r0, #32
    ed92:	bx	lr
    ed94:	movs	r3, #0
    ed96:	b.n	ed6a <__hi0bits+0xa>
    ed98:	adds	r0, r3, #1
    ed9a:	bx	lr
    ed9c:	mov	r0, r3
    ed9e:	bx	lr

0000eda0 <__lo0bits>:
    eda0:	ldr	r3, [r0, #0]
    eda2:	ands.w	r2, r3, #7
    eda6:	beq.n	edb8 <__lo0bits+0x18>
    eda8:	lsls	r1, r3, #31
    edaa:	bmi.n	edee <__lo0bits+0x4e>
    edac:	lsls	r2, r3, #30
    edae:	bmi.n	edf2 <__lo0bits+0x52>
    edb0:	lsrs	r3, r3, #2
    edb2:	str	r3, [r0, #0]
    edb4:	movs	r0, #2
    edb6:	bx	lr
    edb8:	uxth	r1, r3
    edba:	cbnz	r1, edc0 <__lo0bits+0x20>
    edbc:	lsrs	r3, r3, #16
    edbe:	movs	r2, #16
    edc0:	tst.w	r3, #255	; 0xff
    edc4:	itt	eq
    edc6:	lsreq	r3, r3, #8
    edc8:	addeq	r2, #8
    edca:	lsls	r1, r3, #28
    edcc:	itt	eq
    edce:	lsreq	r3, r3, #4
    edd0:	addeq	r2, #4
    edd2:	lsls	r1, r3, #30
    edd4:	itt	eq
    edd6:	lsreq	r3, r3, #2
    edd8:	addeq	r2, #2
    edda:	lsls	r1, r3, #31
    eddc:	bmi.n	ede8 <__lo0bits+0x48>
    edde:	lsrs	r3, r3, #1
    ede0:	bne.n	ede6 <__lo0bits+0x46>
    ede2:	movs	r0, #32
    ede4:	bx	lr
    ede6:	adds	r2, #1
    ede8:	str	r3, [r0, #0]
    edea:	mov	r0, r2
    edec:	bx	lr
    edee:	movs	r0, #0
    edf0:	bx	lr
    edf2:	lsrs	r3, r3, #1
    edf4:	str	r3, [r0, #0]
    edf6:	movs	r0, #1
    edf8:	bx	lr
    edfa:	nop

0000edfc <__i2b>:
    edfc:	push	{r4, lr}
    edfe:	mov	r4, r1
    ee00:	movs	r1, #1
    ee02:	bl	ec80 <_Balloc>
    ee06:	movs	r2, #1
    ee08:	str	r4, [r0, #20]
    ee0a:	str	r2, [r0, #16]
    ee0c:	pop	{r4, pc}
    ee0e:	nop

0000ee10 <__multiply>:
    ee10:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ee14:	ldr	r5, [r1, #16]
    ee16:	ldr	r7, [r2, #16]
    ee18:	cmp	r5, r7
    ee1a:	sub	sp, #12
    ee1c:	mov	r4, r1
    ee1e:	mov	r6, r2
    ee20:	bge.n	ee2c <__multiply+0x1c>
    ee22:	mov	r2, r5
    ee24:	mov	r4, r6
    ee26:	mov	r5, r7
    ee28:	mov	r6, r1
    ee2a:	mov	r7, r2
    ee2c:	ldr	r3, [r4, #8]
    ee2e:	ldr	r1, [r4, #4]
    ee30:	add.w	r8, r5, r7
    ee34:	cmp	r8, r3
    ee36:	it	gt
    ee38:	addgt	r1, #1
    ee3a:	bl	ec80 <_Balloc>
    ee3e:	add.w	ip, r0, #20
    ee42:	add.w	r9, ip, r8, lsl #2
    ee46:	cmp	ip, r9
    ee48:	str	r0, [sp, #0]
    ee4a:	bcs.n	ee58 <__multiply+0x48>
    ee4c:	mov	r3, ip
    ee4e:	movs	r1, #0
    ee50:	str.w	r1, [r3], #4
    ee54:	cmp	r9, r3
    ee56:	bhi.n	ee50 <__multiply+0x40>
    ee58:	add.w	r2, r6, #20
    ee5c:	add.w	sl, r2, r7, lsl #2
    ee60:	add.w	r3, r4, #20
    ee64:	cmp	r2, sl
    ee66:	add.w	lr, r3, r5, lsl #2
    ee6a:	bcs.n	ef16 <__multiply+0x106>
    ee6c:	str.w	r9, [sp, #4]
    ee70:	mov	r9, r3
    ee72:	ldr.w	r3, [r2], #4
    ee76:	uxth.w	fp, r3
    ee7a:	cmp.w	fp, #0
    ee7e:	beq.n	eec2 <__multiply+0xb2>
    ee80:	movs	r0, #0
    ee82:	mov	r7, r9
    ee84:	mov	r6, ip
    ee86:	mov	r5, r0
    ee88:	b.n	ee8c <__multiply+0x7c>
    ee8a:	mov	r6, r3
    ee8c:	ldr.w	r4, [r7], #4
    ee90:	ldr	r0, [r6, #0]
    ee92:	uxth	r1, r4
    ee94:	uxth	r3, r0
    ee96:	mla	r1, fp, r1, r3
    ee9a:	lsrs	r4, r4, #16
    ee9c:	lsrs	r0, r0, #16
    ee9e:	adds	r3, r1, r5
    eea0:	mla	r0, fp, r4, r0
    eea4:	add.w	r0, r0, r3, lsr #16
    eea8:	uxth	r1, r3
    eeaa:	mov	r3, r6
    eeac:	orr.w	r1, r1, r0, lsl #16
    eeb0:	cmp	lr, r7
    eeb2:	mov.w	r5, r0, lsr #16
    eeb6:	str.w	r1, [r3], #4
    eeba:	bhi.n	ee8a <__multiply+0x7a>
    eebc:	str	r5, [r6, #4]
    eebe:	ldr.w	r3, [r2, #-4]
    eec2:	movs.w	fp, r3, lsr #16
    eec6:	beq.n	ef0a <__multiply+0xfa>
    eec8:	ldr.w	r3, [ip]
    eecc:	mov	r7, ip
    eece:	mov	r0, r3
    eed0:	mov	r5, r9
    eed2:	movs	r1, #0
    eed4:	b.n	eed8 <__multiply+0xc8>
    eed6:	mov	r7, r6
    eed8:	ldrh	r4, [r5, #0]
    eeda:	lsrs	r0, r0, #16
    eedc:	mla	r0, fp, r4, r0
    eee0:	add	r1, r0
    eee2:	uxth	r4, r3
    eee4:	mov	r6, r7
    eee6:	orr.w	r3, r4, r1, lsl #16
    eeea:	str.w	r3, [r6], #4
    eeee:	ldr	r0, [r7, #4]
    eef0:	ldr.w	r4, [r5], #4
    eef4:	uxth	r3, r0
    eef6:	lsrs	r4, r4, #16
    eef8:	mla	r4, fp, r4, r3
    eefc:	add.w	r3, r4, r1, lsr #16
    ef00:	cmp	lr, r5
    ef02:	mov.w	r1, r3, lsr #16
    ef06:	bhi.n	eed6 <__multiply+0xc6>
    ef08:	str	r3, [r7, #4]
    ef0a:	cmp	sl, r2
    ef0c:	add.w	ip, ip, #4
    ef10:	bhi.n	ee72 <__multiply+0x62>
    ef12:	ldr.w	r9, [sp, #4]
    ef16:	cmp.w	r8, #0
    ef1a:	ble.n	ef34 <__multiply+0x124>
    ef1c:	ldr.w	r3, [r9, #-4]
    ef20:	sub.w	r9, r9, #4
    ef24:	cbz	r3, ef2e <__multiply+0x11e>
    ef26:	b.n	ef34 <__multiply+0x124>
    ef28:	ldr.w	r3, [r9, #-4]!
    ef2c:	cbnz	r3, ef34 <__multiply+0x124>
    ef2e:	subs.w	r8, r8, #1
    ef32:	bne.n	ef28 <__multiply+0x118>
    ef34:	ldr	r0, [sp, #0]
    ef36:	str.w	r8, [r0, #16]
    ef3a:	add	sp, #12
    ef3c:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000ef40 <__pow5mult>:
    ef40:	ands.w	r3, r2, #3
    ef44:	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ef48:	mov	r4, r2
    ef4a:	mov	r7, r0
    ef4c:	bne.n	efac <__pow5mult+0x6c>
    ef4e:	mov	r6, r1
    ef50:	asrs	r4, r4, #2
    ef52:	beq.n	ef8e <__pow5mult+0x4e>
    ef54:	ldr	r5, [r7, #72]	; 0x48
    ef56:	cbz	r5, efbe <__pow5mult+0x7e>
    ef58:	lsls	r3, r4, #31
    ef5a:	mov.w	r8, #0
    ef5e:	bmi.n	ef6e <__pow5mult+0x2e>
    ef60:	asrs	r4, r4, #1
    ef62:	beq.n	ef8e <__pow5mult+0x4e>
    ef64:	ldr	r0, [r5, #0]
    ef66:	cbz	r0, ef94 <__pow5mult+0x54>
    ef68:	mov	r5, r0
    ef6a:	lsls	r3, r4, #31
    ef6c:	bpl.n	ef60 <__pow5mult+0x20>
    ef6e:	mov	r2, r5
    ef70:	mov	r1, r6
    ef72:	mov	r0, r7
    ef74:	bl	ee10 <__multiply>
    ef78:	cbz	r6, efa8 <__pow5mult+0x68>
    ef7a:	ldr	r2, [r6, #4]
    ef7c:	ldr	r3, [r7, #76]	; 0x4c
    ef7e:	asrs	r4, r4, #1
    ef80:	ldr.w	r1, [r3, r2, lsl #2]
    ef84:	str	r1, [r6, #0]
    ef86:	str.w	r6, [r3, r2, lsl #2]
    ef8a:	mov	r6, r0
    ef8c:	bne.n	ef64 <__pow5mult+0x24>
    ef8e:	mov	r0, r6
    ef90:	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ef94:	mov	r2, r5
    ef96:	mov	r1, r5
    ef98:	mov	r0, r7
    ef9a:	bl	ee10 <__multiply>
    ef9e:	str	r0, [r5, #0]
    efa0:	str.w	r8, [r0]
    efa4:	mov	r5, r0
    efa6:	b.n	ef6a <__pow5mult+0x2a>
    efa8:	mov	r6, r0
    efaa:	b.n	ef60 <__pow5mult+0x20>
    efac:	subs	r2, r3, #1
    efae:	ldr	r5, [pc, #44]	; (efdc <__pow5mult+0x9c>)
    efb0:	movs	r3, #0
    efb2:	ldr.w	r2, [r5, r2, lsl #2]
    efb6:	bl	ece0 <__multadd>
    efba:	mov	r6, r0
    efbc:	b.n	ef50 <__pow5mult+0x10>
    efbe:	movs	r1, #1
    efc0:	mov	r0, r7
    efc2:	bl	ec80 <_Balloc>
    efc6:	movw	r1, #625	; 0x271
    efca:	movs	r2, #1
    efcc:	movs	r3, #0
    efce:	str	r1, [r0, #20]
    efd0:	str	r2, [r0, #16]
    efd2:	mov	r5, r0
    efd4:	str	r0, [r7, #72]	; 0x48
    efd6:	str	r3, [r0, #0]
    efd8:	b.n	ef58 <__pow5mult+0x18>
    efda:	nop
    efdc:	.word	0x20000b68

0000efe0 <__lshift>:
    efe0:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    efe4:	mov	r9, r2
    efe6:	ldr	r2, [r1, #16]
    efe8:	ldr	r3, [r1, #8]
    efea:	mov.w	r4, r9, asr #5
    efee:	add.w	r8, r4, r2
    eff2:	add.w	r5, r8, #1
    eff6:	cmp	r5, r3
    eff8:	mov	r6, r1
    effa:	mov	sl, r0
    effc:	ldr	r1, [r1, #4]
    effe:	ble.n	f00a <__lshift+0x2a>
    f000:	lsls	r3, r3, #1
    f002:	cmp	r5, r3
    f004:	add.w	r1, r1, #1
    f008:	bgt.n	f000 <__lshift+0x20>
    f00a:	mov	r0, sl
    f00c:	bl	ec80 <_Balloc>
    f010:	cmp	r4, #0
    f012:	add.w	r2, r0, #20
    f016:	ble.n	f08a <__lshift+0xaa>
    f018:	add.w	r3, r2, r4, lsl #2
    f01c:	movs	r1, #0
    f01e:	str.w	r1, [r2], #4
    f022:	cmp	r3, r2
    f024:	bne.n	f01e <__lshift+0x3e>
    f026:	ldr	r4, [r6, #16]
    f028:	add.w	r1, r6, #20
    f02c:	ands.w	r9, r9, #31
    f030:	add.w	lr, r1, r4, lsl #2
    f034:	beq.n	f07a <__lshift+0x9a>
    f036:	rsb	r2, r9, #32
    f03a:	movs	r4, #0
    f03c:	ldr	r7, [r1, #0]
    f03e:	lsl.w	ip, r7, r9
    f042:	orr.w	r4, ip, r4
    f046:	mov	ip, r3
    f048:	str.w	r4, [r3], #4
    f04c:	ldr.w	r4, [r1], #4
    f050:	cmp	lr, r1
    f052:	lsr.w	r4, r4, r2
    f056:	bhi.n	f03c <__lshift+0x5c>
    f058:	str.w	r4, [ip, #4]
    f05c:	cbz	r4, f062 <__lshift+0x82>
    f05e:	add.w	r5, r8, #2
    f062:	ldr.w	r3, [sl, #76]	; 0x4c
    f066:	ldr	r2, [r6, #4]
    f068:	subs	r5, #1
    f06a:	ldr.w	r1, [r3, r2, lsl #2]
    f06e:	str	r5, [r0, #16]
    f070:	str	r1, [r6, #0]
    f072:	str.w	r6, [r3, r2, lsl #2]
    f076:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f07a:	subs	r3, #4
    f07c:	ldr.w	r2, [r1], #4
    f080:	str.w	r2, [r3, #4]!
    f084:	cmp	lr, r1
    f086:	bhi.n	f07c <__lshift+0x9c>
    f088:	b.n	f062 <__lshift+0x82>
    f08a:	mov	r3, r2
    f08c:	b.n	f026 <__lshift+0x46>
    f08e:	nop

0000f090 <__mcmp>:
    f090:	ldr	r2, [r0, #16]
    f092:	ldr	r3, [r1, #16]
    f094:	subs	r2, r2, r3
    f096:	bne.n	f0c0 <__mcmp+0x30>
    f098:	lsls	r3, r3, #2
    f09a:	adds	r0, #20
    f09c:	adds	r1, #20
    f09e:	add	r1, r3
    f0a0:	push	{r4}
    f0a2:	add	r3, r0
    f0a4:	b.n	f0aa <__mcmp+0x1a>
    f0a6:	cmp	r0, r3
    f0a8:	bcs.n	f0c4 <__mcmp+0x34>
    f0aa:	ldr.w	r4, [r3, #-4]!
    f0ae:	ldr.w	r2, [r1, #-4]!
    f0b2:	cmp	r4, r2
    f0b4:	beq.n	f0a6 <__mcmp+0x16>
    f0b6:	bcc.n	f0cc <__mcmp+0x3c>
    f0b8:	movs	r0, #1
    f0ba:	ldr.w	r4, [sp], #4
    f0be:	bx	lr
    f0c0:	mov	r0, r2
    f0c2:	bx	lr
    f0c4:	movs	r0, #0
    f0c6:	ldr.w	r4, [sp], #4
    f0ca:	bx	lr
    f0cc:	mov.w	r0, #4294967295
    f0d0:	b.n	f0ba <__mcmp+0x2a>
    f0d2:	nop

0000f0d4 <__mdiff>:
    f0d4:	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f0d8:	ldr	r3, [r1, #16]
    f0da:	mov	r7, r1
    f0dc:	ldr	r1, [r2, #16]
    f0de:	subs	r3, r3, r1
    f0e0:	cmp	r3, #0
    f0e2:	mov	r8, r2
    f0e4:	bne.n	f116 <__mdiff+0x42>
    f0e6:	lsls	r1, r1, #2
    f0e8:	add.w	r2, r7, #20
    f0ec:	add.w	r5, r8, #20
    f0f0:	adds	r3, r2, r1
    f0f2:	add	r1, r5
    f0f4:	b.n	f0fa <__mdiff+0x26>
    f0f6:	cmp	r2, r3
    f0f8:	bcs.n	f1b8 <__mdiff+0xe4>
    f0fa:	ldr.w	r6, [r3, #-4]!
    f0fe:	ldr.w	r4, [r1, #-4]!
    f102:	cmp	r6, r4
    f104:	beq.n	f0f6 <__mdiff+0x22>
    f106:	bcs.n	f1ca <__mdiff+0xf6>
    f108:	mov	r3, r7
    f10a:	mov	r4, r2
    f10c:	mov	r7, r8
    f10e:	mov.w	r9, #1
    f112:	mov	r8, r3
    f114:	b.n	f124 <__mdiff+0x50>
    f116:	blt.n	f1d4 <__mdiff+0x100>
    f118:	add.w	r5, r7, #20
    f11c:	add.w	r4, r2, #20
    f120:	mov.w	r9, #0
    f124:	ldr	r1, [r7, #4]
    f126:	bl	ec80 <_Balloc>
    f12a:	ldr.w	r3, [r8, #16]
    f12e:	ldr	r6, [r7, #16]
    f130:	str.w	r9, [r0, #12]
    f134:	add.w	ip, r4, r3, lsl #2
    f138:	mov	lr, r4
    f13a:	add.w	r7, r5, r6, lsl #2
    f13e:	add.w	r4, r0, #20
    f142:	movs	r3, #0
    f144:	ldr.w	r1, [lr], #4
    f148:	ldr.w	r8, [r5], #4
    f14c:	uxth	r2, r1
    f14e:	uxtah	r3, r3, r8
    f152:	lsrs	r1, r1, #16
    f154:	subs	r2, r3, r2
    f156:	rsb	r3, r1, r8, lsr #16
    f15a:	add.w	r3, r3, r2, asr #16
    f15e:	uxth	r2, r2
    f160:	orr.w	r2, r2, r3, lsl #16
    f164:	cmp	ip, lr
    f166:	str.w	r2, [r4], #4
    f16a:	mov.w	r3, r3, asr #16
    f16e:	bhi.n	f144 <__mdiff+0x70>
    f170:	cmp	r7, r5
    f172:	bls.n	f1a4 <__mdiff+0xd0>
    f174:	mov	ip, r4
    f176:	mov	r1, r5
    f178:	ldr.w	lr, [r1], #4
    f17c:	uxtah	r2, r3, lr
    f180:	asrs	r3, r2, #16
    f182:	add.w	r3, r3, lr, lsr #16
    f186:	uxth	r2, r2
    f188:	orr.w	r2, r2, r3, lsl #16
    f18c:	cmp	r7, r1
    f18e:	str.w	r2, [ip], #4
    f192:	mov.w	r3, r3, asr #16
    f196:	bhi.n	f178 <__mdiff+0xa4>
    f198:	mvns	r5, r5
    f19a:	add	r5, r7
    f19c:	bic.w	r5, r5, #3
    f1a0:	adds	r5, #4
    f1a2:	add	r4, r5
    f1a4:	subs	r4, #4
    f1a6:	cbnz	r2, f1b2 <__mdiff+0xde>
    f1a8:	ldr.w	r3, [r4, #-4]!
    f1ac:	subs	r6, #1
    f1ae:	cmp	r3, #0
    f1b0:	beq.n	f1a8 <__mdiff+0xd4>
    f1b2:	str	r6, [r0, #16]
    f1b4:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    f1b8:	movs	r1, #0
    f1ba:	bl	ec80 <_Balloc>
    f1be:	movs	r2, #1
    f1c0:	movs	r3, #0
    f1c2:	str	r2, [r0, #16]
    f1c4:	str	r3, [r0, #20]
    f1c6:	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    f1ca:	mov	r4, r5
    f1cc:	mov.w	r9, #0
    f1d0:	mov	r5, r2
    f1d2:	b.n	f124 <__mdiff+0x50>
    f1d4:	mov	r3, r7
    f1d6:	add.w	r4, r7, #20
    f1da:	add.w	r5, r8, #20
    f1de:	mov	r7, r8
    f1e0:	mov.w	r9, #1
    f1e4:	mov	r8, r3
    f1e6:	b.n	f124 <__mdiff+0x50>

0000f1e8 <__d2b>:
    f1e8:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    f1ec:	vmov	r6, r7, d0
    f1f0:	sub	sp, #12
    f1f2:	mov	r8, r1
    f1f4:	movs	r1, #1
    f1f6:	mov	r4, r7
    f1f8:	ubfx	r5, r7, #20, #11
    f1fc:	mov	r7, r2
    f1fe:	bl	ec80 <_Balloc>
    f202:	ubfx	r4, r4, #0, #20
    f206:	mov	r9, r0
    f208:	cbz	r5, f20e <__d2b+0x26>
    f20a:	orr.w	r4, r4, #1048576	; 0x100000
    f20e:	str	r4, [sp, #4]
    f210:	cbz	r6, f25a <__d2b+0x72>
    f212:	add	r0, sp, #8
    f214:	str.w	r6, [r0, #-8]!
    f218:	bl	eda0 <__lo0bits>
    f21c:	cmp	r0, #0
    f21e:	bne.n	f28a <__d2b+0xa2>
    f220:	ldmia.w	sp, {r2, r3}
    f224:	str.w	r2, [r9, #20]
    f228:	cmp	r3, #0
    f22a:	ite	eq
    f22c:	moveq	r1, #1
    f22e:	movne	r1, #2
    f230:	str.w	r3, [r9, #24]
    f234:	str.w	r1, [r9, #16]
    f238:	cbnz	r5, f272 <__d2b+0x8a>
    f23a:	add.w	r3, r9, r1, lsl #2
    f23e:	subw	r0, r0, #1074	; 0x432
    f242:	str.w	r0, [r8]
    f246:	ldr	r0, [r3, #16]
    f248:	bl	ed60 <__hi0bits>
    f24c:	rsb	r0, r0, r1, lsl #5
    f250:	str	r0, [r7, #0]
    f252:	mov	r0, r9
    f254:	add	sp, #12
    f256:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    f25a:	add	r0, sp, #4
    f25c:	bl	eda0 <__lo0bits>
    f260:	ldr	r3, [sp, #4]
    f262:	str.w	r3, [r9, #20]
    f266:	movs	r1, #1
    f268:	adds	r0, #32
    f26a:	str.w	r1, [r9, #16]
    f26e:	cmp	r5, #0
    f270:	beq.n	f23a <__d2b+0x52>
    f272:	subw	r5, r5, #1075	; 0x433
    f276:	add	r5, r0
    f278:	rsb	r0, r0, #53	; 0x35
    f27c:	str.w	r5, [r8]
    f280:	str	r0, [r7, #0]
    f282:	mov	r0, r9
    f284:	add	sp, #12
    f286:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    f28a:	ldmia.w	sp, {r2, r3}
    f28e:	rsb	r1, r0, #32
    f292:	lsl.w	r1, r3, r1
    f296:	orrs	r2, r1
    f298:	lsrs	r3, r0
    f29a:	str	r3, [sp, #4]
    f29c:	str.w	r2, [r9, #20]
    f2a0:	b.n	f228 <__d2b+0x40>
    f2a2:	nop

0000f2a4 <__ssprint_r>:
    f2a4:	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f2a8:	ldr	r3, [r2, #8]
    f2aa:	sub	sp, #12
    f2ac:	mov	r8, r2
    f2ae:	cmp	r3, #0
    f2b0:	beq.n	f398 <__ssprint_r+0xf4>
    f2b2:	mov	fp, r0
    f2b4:	mov.w	r9, #0
    f2b8:	ldr	r6, [r2, #0]
    f2ba:	ldr	r0, [r1, #0]
    f2bc:	ldr	r3, [r1, #8]
    f2be:	mov	r5, r1
    f2c0:	mov	r4, r9
    f2c2:	cmp	r4, #0
    f2c4:	beq.n	f352 <__ssprint_r+0xae>
    f2c6:	cmp	r4, r3
    f2c8:	mov	r7, r3
    f2ca:	mov	sl, r3
    f2cc:	bcc.n	f35c <__ssprint_r+0xb8>
    f2ce:	ldrh	r3, [r5, #12]
    f2d0:	tst.w	r3, #1152	; 0x480
    f2d4:	beq.n	f332 <__ssprint_r+0x8e>
    f2d6:	ldr	r7, [r5, #20]
    f2d8:	ldr	r1, [r5, #16]
    f2da:	add.w	r7, r7, r7, lsl #1
    f2de:	rsb	sl, r1, r0
    f2e2:	add.w	r7, r7, r7, lsr #31
    f2e6:	adds	r0, r4, #1
    f2e8:	asrs	r7, r7, #1
    f2ea:	add	r0, sl
    f2ec:	cmp	r0, r7
    f2ee:	mov	r2, r7
    f2f0:	itt	hi
    f2f2:	movhi	r7, r0
    f2f4:	movhi	r2, r7
    f2f6:	lsls	r3, r3, #21
    f2f8:	bpl.n	f362 <__ssprint_r+0xbe>
    f2fa:	mov	r1, r2
    f2fc:	mov	r0, fp
    f2fe:	bl	b0d8 <_malloc_r>
    f302:	cmp	r0, #0
    f304:	beq.n	f376 <__ssprint_r+0xd2>
    f306:	mov	r2, sl
    f308:	ldr	r1, [r5, #16]
    f30a:	str	r0, [sp, #4]
    f30c:	bl	7f58 <memcpy>
    f310:	ldrh	r2, [r5, #12]
    f312:	ldr	r3, [sp, #4]
    f314:	bic.w	r2, r2, #1152	; 0x480
    f318:	orr.w	r2, r2, #128	; 0x80
    f31c:	strh	r2, [r5, #12]
    f31e:	rsb	r2, sl, r7
    f322:	add.w	r0, r3, sl
    f326:	str	r7, [r5, #20]
    f328:	str	r3, [r5, #16]
    f32a:	str	r0, [r5, #0]
    f32c:	str	r2, [r5, #8]
    f32e:	mov	r7, r4
    f330:	mov	sl, r4
    f332:	mov	r2, sl
    f334:	mov	r1, r9
    f336:	bl	b674 <memmove>
    f33a:	ldr.w	r2, [r8, #8]
    f33e:	ldr	r3, [r5, #8]
    f340:	ldr	r0, [r5, #0]
    f342:	subs	r3, r3, r7
    f344:	add	r0, sl
    f346:	subs	r4, r2, r4
    f348:	str	r3, [r5, #8]
    f34a:	str	r0, [r5, #0]
    f34c:	str.w	r4, [r8, #8]
    f350:	cbz	r4, f398 <__ssprint_r+0xf4>
    f352:	ldr.w	r9, [r6]
    f356:	ldr	r4, [r6, #4]
    f358:	adds	r6, #8
    f35a:	b.n	f2c2 <__ssprint_r+0x1e>
    f35c:	mov	r7, r4
    f35e:	mov	sl, r4
    f360:	b.n	f332 <__ssprint_r+0x8e>
    f362:	mov	r0, fp
    f364:	bl	b7e0 <_realloc_r>
    f368:	mov	r3, r0
    f36a:	cmp	r0, #0
    f36c:	bne.n	f31e <__ssprint_r+0x7a>
    f36e:	ldr	r1, [r5, #16]
    f370:	mov	r0, fp
    f372:	bl	e9e8 <_free_r>
    f376:	movs	r3, #12
    f378:	str.w	r3, [fp]
    f37c:	ldrh	r3, [r5, #12]
    f37e:	movs	r2, #0
    f380:	orr.w	r3, r3, #64	; 0x40
    f384:	mov.w	r0, #4294967295
    f388:	strh	r3, [r5, #12]
    f38a:	str.w	r2, [r8, #8]
    f38e:	str.w	r2, [r8, #4]
    f392:	add	sp, #12
    f394:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    f398:	movs	r0, #0
    f39a:	str.w	r0, [r8, #4]
    f39e:	add	sp, #12
    f3a0:	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000f3a4 <_vasnprintf_r>:
    f3a4:	push	{r4, r5, r6, lr}
    f3a6:	mov	r5, r2
    f3a8:	sub	sp, #104	; 0x68
    f3aa:	ldr	r4, [r2, #0]
    f3ac:	cbz	r1, f3b2 <_vasnprintf_r+0xe>
    f3ae:	cmp	r4, #0
    f3b0:	bne.n	f3e8 <_vasnprintf_r+0x44>
    f3b2:	movs	r4, #0
    f3b4:	mov.w	r2, #648	; 0x288
    f3b8:	strh.w	r2, [sp, #12]
    f3bc:	str	r4, [sp, #0]
    f3be:	str	r4, [sp, #16]
    f3c0:	mov	r2, r3
    f3c2:	movw	r6, #65535	; 0xffff
    f3c6:	ldr	r3, [sp, #120]	; 0x78
    f3c8:	str	r4, [sp, #8]
    f3ca:	mov	r1, sp
    f3cc:	str	r4, [sp, #20]
    f3ce:	strh.w	r6, [sp, #14]
    f3d2:	bl	c160 <_svfprintf_r>
    f3d6:	cmp	r0, #0
    f3d8:	blt.n	f3fe <_vasnprintf_r+0x5a>
    f3da:	ldr	r3, [sp, #0]
    f3dc:	str	r0, [r5, #0]
    f3de:	movs	r2, #0
    f3e0:	strb	r2, [r3, #0]
    f3e2:	ldr	r0, [sp, #16]
    f3e4:	add	sp, #104	; 0x68
    f3e6:	pop	{r4, r5, r6, pc}
    f3e8:	mov.w	r2, #1544	; 0x608
    f3ec:	str	r1, [sp, #0]
    f3ee:	str	r1, [sp, #16]
    f3f0:	strh.w	r2, [sp, #12]
    f3f4:	bge.n	f3c0 <_vasnprintf_r+0x1c>
    f3f6:	movs	r3, #139	; 0x8b
    f3f8:	str	r3, [r0, #0]
    f3fa:	movs	r0, #0
    f3fc:	b.n	f3e4 <_vasnprintf_r+0x40>
    f3fe:	movs	r0, #0
    f400:	b.n	f3e4 <_vasnprintf_r+0x40>
    f402:	nop

0000f404 <_calloc_r>:
    f404:	push	{r4, lr}
    f406:	mul.w	r1, r2, r1
    f40a:	bl	b0d8 <_malloc_r>
    f40e:	mov	r4, r0
    f410:	cbz	r0, f44a <_calloc_r+0x46>
    f412:	ldr.w	r2, [r0, #-4]
    f416:	bic.w	r2, r2, #3
    f41a:	subs	r2, #4
    f41c:	cmp	r2, #36	; 0x24
    f41e:	bhi.n	f452 <_calloc_r+0x4e>
    f420:	cmp	r2, #19
    f422:	bls.n	f44e <_calloc_r+0x4a>
    f424:	movs	r3, #0
    f426:	cmp	r2, #27
    f428:	str	r3, [r0, #0]
    f42a:	str	r3, [r0, #4]
    f42c:	bls.n	f45c <_calloc_r+0x58>
    f42e:	cmp	r2, #36	; 0x24
    f430:	str	r3, [r0, #8]
    f432:	str	r3, [r0, #12]
    f434:	iteee	ne
    f436:	addne.w	r2, r0, #16
    f43a:	streq	r3, [r0, #16]
    f43c:	streq	r3, [r0, #20]
    f43e:	addeq.w	r2, r0, #24
    f442:	movs	r3, #0
    f444:	str	r3, [r2, #0]
    f446:	str	r3, [r2, #4]
    f448:	str	r3, [r2, #8]
    f44a:	mov	r0, r4
    f44c:	pop	{r4, pc}
    f44e:	mov	r2, r0
    f450:	b.n	f442 <_calloc_r+0x3e>
    f452:	movs	r1, #0
    f454:	bl	b73c <memset>
    f458:	mov	r0, r4
    f45a:	pop	{r4, pc}
    f45c:	add.w	r2, r0, #8
    f460:	b.n	f442 <_calloc_r+0x3e>
    f462:	nop

0000f464 <__aeabi_d2iz>:
    f464:	mov.w	r2, r1, lsl #1
    f468:	adds.w	r2, r2, #2097152	; 0x200000
    f46c:	bcs.n	f49a <__aeabi_d2iz+0x36>
    f46e:	bpl.n	f494 <__aeabi_d2iz+0x30>
    f470:	mvn.w	r3, #992	; 0x3e0
    f474:	subs.w	r2, r3, r2, asr #21
    f478:	bls.n	f4a0 <__aeabi_d2iz+0x3c>
    f47a:	mov.w	r3, r1, lsl #11
    f47e:	orr.w	r3, r3, #2147483648	; 0x80000000
    f482:	orr.w	r3, r3, r0, lsr #21
    f486:	tst.w	r1, #2147483648	; 0x80000000
    f48a:	lsr.w	r0, r3, r2
    f48e:	it	ne
    f490:	negne	r0, r0
    f492:	bx	lr
    f494:	mov.w	r0, #0
    f498:	bx	lr
    f49a:	orrs.w	r0, r0, r1, lsl #12
    f49e:	bne.n	f4ac <__aeabi_d2iz+0x48>
    f4a0:	ands.w	r0, r1, #2147483648	; 0x80000000
    f4a4:	it	eq
    f4a6:	mvneq.w	r0, #2147483648	; 0x80000000
    f4aa:	bx	lr
    f4ac:	mov.w	r0, #0
    f4b0:	bx	lr
    f4b2:	nop
    f4b4:	movs	r0, r0
	...

0000f4b8 <___init_veneer>:
    f4b8:	ldr.w	pc, [pc]	; f4bc <___init_veneer+0x4>
    f4bc:	.word	0x60001b4d

Disassembly of section .fini:

0000f4c0 <_fini>:
    f4c0:	push	{r3, r4, r5, r6, r7, lr}
    f4c2:	nop

Disassembly of section .text.csf:

600125ec <hab_csf>:
	...
